{
  "number": 10184,
  "title": "[BuildCheck] Implement double writes analyzer",
  "body": "Fixes #9881\r\n\r\n### Context\r\n\r\nWe believe there is value in flagging cases where the same file is written by more than one task during a build. https://github.com/dotnet/source-build/issues/4390 is an example of a recent hard-to-diagnose build issue that could have been prevented by this analyzer.\r\n\r\n### Changes Made\r\n\r\nThis PR adds a new built-in analyzer and makes a few supporting changes.\r\n\r\n### Testing\r\n\r\n- Existing and new unit tests.\r\n- Built a few larger repos with the analyzer enabled.\r\n\r\n### Notes\r\n\r\nThe changes contain a fix/workaround for #10176.",
  "state": "MERGED",
  "createdAt": "2024-05-28T20:56:44Z",
  "updatedAt": "2024-06-10T07:13:09Z",
  "closedAt": "2024-06-10T07:13:04Z",
  "mergedAt": "2024-06-10T07:13:04Z",
  "additions": 373,
  "deletions": 30,
  "changedFiles": 9,
  "headRefName": "9881-double-writes",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d3db0968305096292c505a0e91bc9e49069a9073",
          "message": "Add task parameter enumeration helpers",
          "committedDate": "2024-05-28T11:51:23Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3be6cbf73e93c4f7c3ab9cc4768acca93e0159c3",
          "message": "Use correct IDs as task key",
          "committedDate": "2024-05-28T11:55:38Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bff8a4ea049f8c2c1ac7a84a9cb1e1c8a902c87d",
          "message": "Work around BuildEventContext issue",
          "committedDate": "2024-05-28T11:56:02Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b3619d723dbf48f9e3a00b2d34d8572633f3d15",
          "message": "Implement DoubleWritesAnalyzer",
          "committedDate": "2024-05-29T07:31:49Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9f1bf11462a06a3bfc934cdb7434370c9eb24db1",
          "message": "Update EndToEndTests",
          "committedDate": "2024-05-29T07:31:56Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce3b9ada092245afc9fd25c6c48843d6627f3610",
          "message": "Add DoubleWritesAnalyzer_Tests",
          "committedDate": "2024-05-29T07:31:56Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bd77da339133832cfcf66669ea29d15a32131f4e",
          "message": "Extend TaskInvocationAnalysisDataTests",
          "committedDate": "2024-05-29T07:31:56Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63c336e30b1f565ad384f1d2de192b6879511919",
          "message": "Add AnalysisData.ProjectFileDirectory",
          "committedDate": "2024-06-05T16:27:51Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5b64f2abdc5a045ae76cbbe59dc656247e6053d1",
          "message": "Use task invocation location for results",
          "committedDate": "2024-06-05T16:31:14Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm wondering how to properly absolutize the paths during the replay analysis",
              "createdAt": "2024-05-31T13:10:52Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Can actually relative paths appear here? If yes - should they actually be absolutized by appending to the dir location of the project being analyzed (which should be part of the data context)?",
              "createdAt": "2024-06-04T18:36:40Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Relative paths can appear here. And because the build runs with Current Working Directory == the-directory-of-the-project-being-built, effectively they are relative to the entry point project file. So I think this was _almost_ correct, it was just mistakenly using the path of the project file instead of just the directory.",
              "createdAt": "2024-06-05T16:35:26Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "The test I'm using for this looks like this:\r\n\r\nentry.proj:\r\n```xml\r\n<Project>\r\n  <Import Project=\"subdir\\proj.proj\" />\r\n</Project>\r\n```\r\n\r\nsubdir\\proj.proj:\r\n```xml\r\n<Project>\r\n  <Target Name=\"Build\">\r\n    <Copy SourceFiles=\"src.file\" DestinationFiles=\"dst.file\" />\r\n    <Copy SourceFiles=\"src.file\" DestinationFiles=\"dst.file\" />\r\n    <Message Text=\"Hello world\" />\r\n  </Target>\r\n</Project>\r\n```\r\n\r\nEven though `src.file` and `dst.file` appear in a project file imported from a subdirectory, they refer to files alongside `entry.proj` when `entry.proj` is built.",
              "createdAt": "2024-06-05T16:41:50Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Oh - you are right - I was misunderstanding your code - it was perfectly correct. And now it is even more correct :-))\r\nThank you!",
              "createdAt": "2024-06-05T18:15:04Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should ideally have some real location so that the error points to a meaningfull location.",
              "createdAt": "2024-05-31T13:14:53Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);\n+\n+            if (_filesWritten.TryGetValue(fileBeingWritten, out (string projectFilePath, string taskName) existingEntry))\n+            {\n+                context.ReportResult(BuildCheckResult.Create(\n+                    SupportedRule,\n+                    ElementLocation.EmptyLocation,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Ah, absolutely, passing one of the task invocation's location now.",
              "createdAt": "2024-06-05T16:32:06Z",
              "path": "src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;\n+\n+internal sealed class DoubleWritesAnalyzer : BuildAnalyzer\n+{\n+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(\"BC0102\", \"DoubleWrites\",\n+        \"Two tasks should not write the same file\",\n+        \"Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.\",\n+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });\n+\n+    public override string FriendlyName => \"MSBuild.DoubleWritesAnalyzer\";\n+\n+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);\n+    }\n+\n+    /// <summary>\n+    /// Contains the first project file + task that wrote the given file during the build.\n+    /// </summary>\n+    private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);\n+\n+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        // This analyzer uses a hard-coded list of tasks known to write files.\n+        switch (context.Data.TaskName)\n+        {\n+            case \"Csc\":\n+            case \"Vbc\":\n+            case \"Fsc\": AnalyzeCompilerTask(context); break;\n+            case \"Copy\": AnalyzeCopyTask(context); break;\n+        }\n+    }\n+\n+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // Compiler tasks have several parameters representing files being written.\n+        AnalyzeParameter(\"OutputAssembly\");\n+        AnalyzeParameter(\"OutputRefAssembly\");\n+        AnalyzeParameter(\"DocumentationFile\");\n+        AnalyzeParameter(\"PdbFile\");\n+\n+        void AnalyzeParameter(string parameterName)\n+        {\n+            if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))\n+            {\n+                string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+                AnalyzeWrite(context, outputPath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)\n+    {\n+        var taskParameters = context.Data.Parameters;\n+\n+        // The destination is specified as either DestinationFolder or DestinationFiles.\n+        if (taskParameters.TryGetValue(\"SourceFiles\", out TaskParameter? sourceFiles) &&\n+            taskParameters.TryGetValue(\"DestinationFolder\", out TaskParameter? destinationFolder))\n+        {\n+            string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? \"\";\n+            foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));\n+            }\n+        }\n+        else if (taskParameters.TryGetValue(\"DestinationFiles\", out TaskParameter? destinationFiles))\n+        {\n+            foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())\n+            {\n+                AnalyzeWrite(context, destinationFilePath);\n+            }\n+        }\n+    }\n+\n+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)\n+    {\n+        if (!string.IsNullOrEmpty(fileBeingWritten))\n+        {\n+            // Absolutize the path.\n+            fileBeingWritten = Path.GetFullPath(fileBeingWritten, context.Data.ProjectFilePath);\n+\n+            if (_filesWritten.TryGetValue(fileBeingWritten, out (string projectFilePath, string taskName) existingEntry))\n+            {\n+                context.ReportResult(BuildCheckResult.Create(\n+                    SupportedRule,\n+                    ElementLocation.EmptyLocation,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If we really wanted to get fancy and avoid most of these allocations, we could run `GetDirectoryName` only once and reuse for all instances but I think this is good enough. Too bad that `Path.GetFullPath(..., Path.GetDirectoryName(...))` cannot be done with Span.",
              "createdAt": "2024-06-05T16:38:47Z",
              "path": "src/Build/BuildCheck/OM/BuildCheckDataContext.cs",
              "diffHunk": "@@ -19,10 +20,18 @@ namespace Microsoft.Build.Experimental.BuildCheck;\n /// <param name=\"projectFilePath\">Currently built project.</param>\n public abstract class AnalysisData(string projectFilePath)\n {\n+    private string? _projectFileDirectory;\n+\n     /// <summary>\n     /// Full path to the project file being built.\n     /// </summary>\n     public string ProjectFilePath { get; } = projectFilePath;\n+\n+    /// <summary>\n+    /// Directory path of the file being built (the containing directory of <see cref=\"ProjectFilePath\"/>).\n+    /// </summary>\n+    public string ProjectFileDirectory =>\n+        _projectFileDirectory ??= Path.GetDirectoryName(ProjectFilePath)!;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "this is great as is",
              "createdAt": "2024-06-05T18:15:37Z",
              "path": "src/Build/BuildCheck/OM/BuildCheckDataContext.cs",
              "diffHunk": "@@ -19,10 +20,18 @@ namespace Microsoft.Build.Experimental.BuildCheck;\n /// <param name=\"projectFilePath\">Currently built project.</param>\n public abstract class AnalysisData(string projectFilePath)\n {\n+    private string? _projectFileDirectory;\n+\n     /// <summary>\n     /// Full path to the project file being built.\n     /// </summary>\n     public string ProjectFilePath { get; } = projectFilePath;\n+\n+    /// <summary>\n+    /// Directory path of the file being built (the containing directory of <see cref=\"ProjectFilePath\"/>).\n+    /// </summary>\n+    public string ProjectFileDirectory =>\n+        _projectFileDirectory ??= Path.GetDirectoryName(ProjectFilePath)!;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}