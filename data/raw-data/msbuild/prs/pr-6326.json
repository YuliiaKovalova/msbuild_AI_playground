{
  "number": 6326,
  "title": "Miscellaneous logging improvements",
  "body": "We're almost at the finish line. This PR contains most remaining low-hanging fruit fixes to logging efficiency. There are more fruit of course, but it's no longer clear what else to do to meaningfully reduce binlog size and overhead even further.\r\n\r\nThe primary insights are:\r\n * don't log BuildEventArgs.Message where it can be recovered (less strings)\r\n * log Message separately from Arguments, instead of concatenating into formatted message and logging that (smaller strings, more deduplication)\r\n * cache string resources instead of retrieving them every time, log resource string and arguments separately\r\n * add more test coverage for Serial and Parallel console loggers (which is currently sorely lacking, since we mostly use MockLogger in tests)\r\n\r\nI tried to separate independent changes into separate commits, so reviewing commit-by-commit is better. For some changes, turn on Ignore Whitespace will help.\r\n\r\nFinal binlog size and perf numbers are very favorable.\r\n\r\nBinlog size:\r\n\r\n16.9.2 | main | This PR\r\n-- | -- | --\r\n20 MB | 3.5 MB | 2.7 MB\r\n120 MB | 15 MB | 10 MB\r\n\r\nIncremental build duration on a smaller project:\r\n\r\n\u00a0 | 16.9.2 | This PR\r\n-- | -- | --\r\n/m /bl | 18.6 s | 14.1 s\r\n/bl | 32 s | 18 s\r\n/m | 9 s | 9 s\r\nno /m no /bl | 15 s | 15 s\r\n\r\nIncremental build for Roslyn.sln:\r\n\r\n\u00a0 | 16.9.2 | This PR\r\n-- | -- | --\r\n/m /bl | 1:11 s | 37 s\r\n/bl | 2:23 s | 1:03 s\r\n\r\n\r\n\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2021-04-05T02:02:37Z",
  "updatedAt": "2021-04-20T20:47:53Z",
  "closedAt": "2021-04-20T20:47:51Z",
  "mergedAt": "2021-04-20T20:47:51Z",
  "additions": 1388,
  "deletions": 516,
  "changedFiles": 44,
  "headRefName": "dev/kirillo/logless",
  "isDraft": false,
  "author": {
    "login": "KirillOsenkov"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "KirillOsenkov"
      }
    ]
  },
  "labels": [
    "Area: Performance",
    "Area: Task: Resolve Assembly References (RAR)",
    "Area: Logging",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c09a5377388631ca55730b0b15b0d3da2ab8d380",
          "message": "Don't log BuildEventArgs.Message where it can be reconstructed.\n\nFor most BuildEventArgs we can completely reconstruct the message text from the other fields. Do not allocate and log the Message string in this case, and override Message implementation to recover the message lazily on demand. This way the message never needs to be allocated to travel across nodes or written/read into binlog. It is only materialized when a console/file logger requests it.\n\nFor cases where LazyFormattedBuildEventArgs has Arguments, don't flatten and materialize the Message during node packet translation or binlog write/read.\n\nThe two improvements above help significantly reduce string allocations, the number of strings logged and the string size. Smaller strings means that deduplication can do a better job reusing strings, and as such most large strings simply dissolve.\n\nStrings before: Total size: 7,770,723, Count: 33,648, Largest: 55,401\nStrings after: Total size: 1,382,154, Count: 18,701, Largest: 10,197\n\nIncrement the binlog file format version to 13. Write LazyFormattedBuildEventArgs.Arguments array into the binlog if present.\n\nDo not persist Importance for BuildEventArgs that ignore it or where it defaults to low.\nDo not write ThreadId into the binlog as it's never used.\nIntroduce the internal field BuildEventArgs.RawMessage to expose the underlying message field and avoid the side effects of calling Message (which formats using the Arguments).\n\nAdd Condition, EvaluatedCondition and OriginallySucceeded on TargetSkippedEventArgs so we can recover the message.\n\nDo not sort item metadata when writing a binlog. We want binlogs to be fully roundtrippable and not lose any information. This is useful for unit-tests that compare against text logs and verify that played back logs are fully identical.\n\nAdd a new ILoggingService.LogCommentFromText overload that accepts a string and arguments. This allows us to cache resource strings instead of retrieving them every time.\n\nDo not allocate or set Message when creating ProjectStarted, ProjectFinished, TargetStarted, TargetFinished, TaskStarted or TaskFinished.\n\nFollowing the pattern set for TaskParameterEventArgs, inject the logic to format resource strings into BuildEventArgs using a static delegate. Later we can refactor and find a better pattern for this, but this works for now.\n\nFor TargetSkipped, log either OriginallySucceeded or Condition/EvaluatedCondition, and don't log the Message.\n\nWhen logging input files and output files for skipped targets, do not concatenate them into huge semicolon-separated strings, but log a TaskParameterEventArgs instead. Introduce two new kinds of TaskParameter: TargetSkippedInputs and TargetSkippedOutputs. However as this is a flat list of files with no itemType, log itemType as null. Adjust the GetParameterText() logic to not write an extra indent or itemType if it is null.\n\nImplement manual node packet translation for ProjectImported, TargetSkipped and Telemetry event args to avoid TranslateDotNet and binary formatter.",
          "committedDate": "2021-04-05T00:25:10Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9b5e2e067f082980eff014bfbdca0b701233755",
          "message": "Log TaskParameterEventArgs for inputs/outputs of TargetSkipped\n\nWhen logging input files and output files for skipped targets, do not concatenate them into huge semicolon-separated strings, but log a TaskParameterEventArgs instead. Introduce two new kinds of TaskParameter: TargetSkippedInputs and TargetSkippedOutputs. This way the smaller strings are deduplicated better.",
          "committedDate": "2021-04-05T00:26:59Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ace9956fe7be5cf06a8c9568fb406009c3327597",
          "message": "Do not allocate a single string for Task Parameter\n\nFor scalar task parameters, log a string with arguments instead of concatenating it into a single string such as \"TaskParameter:a=b\".",
          "committedDate": "2021-04-05T00:28:01Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "66acffdd8bff96e247d33e7cba372ad14098d097",
          "message": "Do not log property reassignment for MSBuildAllProjects\n\nThese concatenated strings are huge and are almost never useful.\n\nCache resource strings during evaluation instead of retrieving them every time.",
          "committedDate": "2021-04-05T00:30:35Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b6540bcbcff5a656035dca4a67b088dad269f586",
          "message": "Cache resource strings in RAR logging.\n\nInstead of retrieving resource strings every time, cache them, reduce allocations and concatenations. No need to use a resource string to just add 4/8/10/12 spaces.\n\nPrimarily this avoids concatenating the final string into a single string, but instead keeps the message separate from the arguments until the final string is requested.\n\nDon't log the image runtime version if it's v4.0.30319 as it's the overwhelming default and carries no useful information.\n\nUse better terminology for inclusion and exclusion lists.\n\nThis change looks extensive, but is pretty mechanical. Hard to review, but a significant improvement to allocations and RAR logging overhead.",
          "committedDate": "2021-04-05T00:52:10Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95021b14a940c4168c605c9776c859fe3762c759",
          "message": "Cache resource strings in the Copy task.",
          "committedDate": "2021-04-05T00:52:57Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c191e15806c0842fd1e76610e68a97f9ea684045",
          "message": "Use named arguments.",
          "committedDate": "2021-04-05T00:53:45Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "da331c9780fb262626a4b003df6697cfd531d1fc",
          "message": "Add NOPERFORMANCESUMMARY switch for console loggers.\n\nAllows to turn off perf summary even in diagnostic mode.\n\nUseful for diffing logs (as the perf numbers will be different when playing back a binlog).",
          "committedDate": "2021-04-05T01:11:18Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e270fea3f9f2b442faa563d1408cc591e6de9e09",
          "message": "Add TestLoggingForSkippedTargetInputsAndOutputs",
          "committedDate": "2021-04-05T01:12:15Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6fea5650ee1598f3e45a85751c8741b3e3fe868f",
          "message": "Compare console logs after binary logging roundtrip.\n\nTurns out we didn't have good coverage for Serial and Parallel console loggers. Include them in the binary logger roundtrip so we verify that logs from playing back a binlog are exactly identical to the logs from the real build.",
          "committedDate": "2021-04-05T01:13:23Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1de22cdd815fa1ca7361ca884206caade5bbb8fc",
          "message": "Add more coverage for console logs from binlog playback.\n\nRecord a binlog every time we build using TestEnvironment, as well as parallel and serial console logs. After the build, playback the binlog into a new serial and console logs and diff the results.\n\nThis ensures that all events that happen during our test can be correctly played back from a binlog and result in the exact same output.\n\nI leave a switch to turn it off for individual tests, but if these prove noisy we can turn this validation off entirely by default (and only turn it back on locally when working on logging related changes).\n\nI did have to turn it off for TreatWarningsAsErrorsWhenBuildingSameProjectMultipleTimes because the binlog contained an extra property MSBuildLastTaskResult=true. I'm not exactly sure what is happening there, but one theory is the console log sees the state where that property is not set, then it's being mutated, then the binary log observes the state. Since two logs capture live data from ProjectEvaluationFinished, and access at different times, it may be that this is a case where the evaluation mutates in between. We need to be on the lookout for more cases like this and maybe turn this validation off by default. But it does give us a ton of free coverage for Serial and Parallel loggers. Most of the tests actually only exercise the MockLogger, so it's nice to test the real text loggers too.\n\nI measured the overall duration of \"build.cmd -test\" and got inconclusive numbers. I think there's no obvious evidence that this change slows down the test run by any significant amount. The durations I got are:\n\n07:34.6 07:38.8\n06:45.4 06:52.5\n08:09.7 07:28.4\n06:49.7 07:32.5\n\nand I'm intentionally not telling which one is which to illustrate that there is no obvious slowdown.",
          "committedDate": "2021-04-05T01:48:13Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "785ffa172a295249d05f4f7d7de96890e49538e2",
          "message": "Fix test to work on unix.",
          "committedDate": "2021-04-05T02:56:56Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2410c417066c4f51d93652552221b97009ada612",
          "message": "Fix typo: HelpHeyword -> HelpKeyword.\n\nThis is safe because the enum is internal and the current name isn't used anywhere.",
          "committedDate": "2021-04-08T20:45:29Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ca456adfda8e5bc7fe26dfcad7e963ff3cb63cb8",
          "message": "Add GetResourceEightSpaces\n\nAlso make a separate bool field initialized.",
          "committedDate": "2021-04-08T20:54:09Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Fixes https://github.com/dotnet/msbuild/issues/6199",
        "createdAt": "2021-04-05T02:23:08Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> cache string resources instead of retrieving them every time\n\nThis is not directly related to /bl right? Is it worth it? You are only saving a hashtable lookup.",
        "createdAt": "2021-04-05T02:44:58Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "Some nice savings in bytes across the pipe, I assume this gives measurable improvements for /m /flp:d or similar.",
        "createdAt": "2021-04-05T02:47:45Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@danmoseley I have to confess I didn't know how `GetResourceString` is implemented, so I just assumed there'll be some non-zero amount of overhead there. Now that you're mentioning it, you're right of course, it will likely be negligible even if called thousands of times. I just benchmarked it and even though it's about 5x overhead compared to a simple hashtable lookup, it's still nanoseconds:\r\n\r\nhttps://github.com/KirillOsenkov/Benchmarks/blob/c77e8587477e38a9c7347efa6bb3d08b79f33a02/Benchmarks/Tests/ResourceManager.cs#L13-L15\r\n\r\nI was also driven by the fact that messages logged by RAR are among the most numerous and expensive:\r\n![image](https://user-images.githubusercontent.com/679326/113534082-871d5400-9584-11eb-9a22-b416167cea04.png)\r\n\r\nSo it's likely not worth going after GetResourceString() just for the sake of it, but here it also helps with reducing duplication and preparing indented strings once instead of allocating every time. Allocations are most certainly a problem.",
        "createdAt": "2021-04-05T03:32:11Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Oh, and file loggers are not even worth measuring right now because we know there are too many low hanging fruit there, primarily because of allocations. To give you a rough example:\r\n\r\nBuild | Duration\r\n-- | --\r\nSingle-core no logging: | 15 s\r\n/bl with no TaskParameterEventArgs | 15 s\r\n/bl | 18 s\r\n/flp1:v=diag | 59 s\r\n\r\nThere's just so much we can fix there. I hope I'll have time this year to do a pass like I did with `/bl`.",
        "createdAt": "2021-04-05T03:40:09Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I just checked the ratio of binlog to diag text log and this is pretty neat:\r\n![image](https://user-images.githubusercontent.com/679326/113541795-c903c580-9597-11eb-9a05-119d7a373d72.png)\r\n",
        "createdAt": "2021-04-05T05:48:12Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "It would be great to improve /flp1:v=diag but nobody does that normally of course. v=d and v=n would likely be worth more attention..",
        "createdAt": "2021-04-05T15:43:58Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "Absolutely, when we look at text logging we'll look at those verbosities first of course.",
        "createdAt": "2021-04-05T16:13:38Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I think I asked this but got distracted\u2014why do you have to pass null here as opposed to just not passing anything?",
              "createdAt": "2021-04-05T23:59:18Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -820,8 +777,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte\n                 {\n                     TaskStartedEventArgs buildEvent = new TaskStartedEventArgs\n                         (\n-                            ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"TaskStarted\", taskName),\n-                            null, // no help keyword\n+                            message: null,",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "to call the proper base constructor I think",
              "createdAt": "2021-04-08T19:50:58Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -820,8 +777,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte\n                 {\n                     TaskStartedEventArgs buildEvent = new TaskStartedEventArgs\n                         (\n-                            ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"TaskStarted\", taskName),\n-                            null, // no help keyword\n+                            message: null,",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Yes, this is to call the right constructor overload, which calls the right base constructor.",
              "createdAt": "2021-04-08T20:47:43Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -820,8 +777,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte\n                 {\n                     TaskStartedEventArgs buildEvent = new TaskStartedEventArgs\n                         (\n-                            ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"TaskStarted\", taskName),\n-                            null, // no help keyword\n+                            message: null,",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nstring indent = parameterName == null ? ...",
              "createdAt": "2021-04-06T00:01:36Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -71,17 +74,43 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n                 // If it's just one entry in the list, and it's not a task item with metadata, keep it on one line like a scalar\n                 bool specialTreatmentForSingle = (parameterValue.Count == 1 && !firstEntryIsTaskItemWithSomeCustomMetadata);\n \n-                if (!specialTreatmentForSingle)\n+                // If the parameterName is not specified, no need to have an extra indent.\n+                // Without parameterName:\n+                //\n+                // Input files: \n+                //     a.txt\n+                //     b.txt\n+                //\n+                // With parameterName:\n+                //\n+                // Input files:\n+                //     ParamName=\n+                //         a.txt\n+                //         b.txt\n+                string indent = \"        \";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "nah, that\u2019s too smart",
              "createdAt": "2021-04-08T19:51:22Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -71,17 +74,43 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n                 // If it's just one entry in the list, and it's not a task item with metadata, keep it on one line like a scalar\n                 bool specialTreatmentForSingle = (parameterValue.Count == 1 && !firstEntryIsTaskItemWithSomeCustomMetadata);\n \n-                if (!specialTreatmentForSingle)\n+                // If the parameterName is not specified, no need to have an extra indent.\n+                // Without parameterName:\n+                //\n+                // Input files: \n+                //     a.txt\n+                //     b.txt\n+                //\n+                // With parameterName:\n+                //\n+                // Input files:\n+                //     ParamName=\n+                //         a.txt\n+                //         b.txt\n+                string indent = \"        \";",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I know it wasn't your typo, but \ud83d\ude12HelpHeyword\r\n\r\nIs there some limit to this based on the maximum size of an int?",
              "createdAt": "2021-04-06T00:05:56Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs",
              "diffHunk": "@@ -22,6 +22,8 @@ internal enum BuildEventArgsFieldFlags\n         LineNumber = 1 << 10,\n         ColumnNumber = 1 << 11,\n         EndLineNumber = 1 << 12,\n-        EndColumnNumber = 1 << 13",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "OUCH! That is totally my typo, from 2017. Well spotted, and how embarrassing. Can't believe I never noticed. Will fix.",
              "createdAt": "2021-04-08T20:42:55Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs",
              "diffHunk": "@@ -22,6 +22,8 @@ internal enum BuildEventArgsFieldFlags\n         LineNumber = 1 << 10,\n         ColumnNumber = 1 << 11,\n         EndLineNumber = 1 << 12,\n-        EndColumnNumber = 1 << 13",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "And yes, we can only have 32. One tweak we can do when we run out is change the enum base type to long, this will buy us 32 more. But I don't think we'll be adding much more to this.",
              "createdAt": "2021-04-08T20:43:46Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs",
              "diffHunk": "@@ -22,6 +22,8 @@ internal enum BuildEventArgsFieldFlags\n         LineNumber = 1 << 10,\n         ColumnNumber = 1 << 11,\n         EndLineNumber = 1 << 12,\n-        EndColumnNumber = 1 << 13",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\u2764",
              "createdAt": "2021-04-06T00:10:16Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -374,62 +411,22 @@ private void Write(BuildWarningEventArgs e)\n \n         private void Write(BuildMessageEventArgs e)\n         {\n-            if (e is TaskParameterEventArgs taskParameter)\n-            {\n-                Write(taskParameter);\n-                return;\n-            }\n-\n-            if (e is CriticalBuildMessageEventArgs criticalBuildMessage)\n-            {\n-                Write(criticalBuildMessage);\n-                return;\n-            }\n-\n-            if (e is TaskCommandLineEventArgs taskCommandLine)\n-            {\n-                Write(taskCommandLine);\n-                return;\n-            }\n-\n-            if (e is ProjectImportedEventArgs projectImported)\n-            {\n-                Write(projectImported);\n-                return;\n-            }\n-\n-            if (e is TargetSkippedEventArgs targetSkipped)\n-            {\n-                Write(targetSkipped);\n-                return;\n-            }\n-\n-            if (e is PropertyReassignmentEventArgs propertyReassignment)\n-            {\n-                Write(propertyReassignment);\n-                return;\n-            }\n-\n-            if (e is UninitializedPropertyReadEventArgs uninitializedPropertyRead)\n-            {\n-                Write(uninitializedPropertyRead);\n-                return;\n-            }\n-\n-            if (e is EnvironmentVariableReadEventArgs environmentVariableRead)\n-            {\n-                Write(environmentVariableRead);\n-                return;\n-            }\n-\n-            if (e is PropertyInitialValueSetEventArgs propertyInitialValueSet)\n+            switch (e)\n             {\n-                Write(propertyInitialValueSet);\n-                return;\n+                case TaskParameterEventArgs taskParameter: Write(taskParameter); break;\n+                case ProjectImportedEventArgs projectImported: Write(projectImported); break;\n+                case TargetSkippedEventArgs targetSkipped: Write(targetSkipped); break;\n+                case PropertyReassignmentEventArgs propertyReassignment: Write(propertyReassignment); break;\n+                case TaskCommandLineEventArgs taskCommandLine: Write(taskCommandLine); break;\n+                case UninitializedPropertyReadEventArgs uninitializedPropertyRead: Write(uninitializedPropertyRead); break;\n+                case EnvironmentVariableReadEventArgs environmentVariableRead: Write(environmentVariableRead); break;\n+                case PropertyInitialValueSetEventArgs propertyInitialValueSet: Write(propertyInitialValueSet); break;\n+                case CriticalBuildMessageEventArgs criticalBuildMessage: Write(criticalBuildMessage); break;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you just delete these sorts of changes instead of commenting them out? Otherwise they'll last forever.",
              "createdAt": "2021-04-06T00:15:26Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -668,10 +691,11 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr\n                 flags |= BuildEventArgsFieldFlags.SenderName;\n             }\n \n-            if (e.ThreadId > 0)\n-            {\n-                flags |= BuildEventArgsFieldFlags.ThreadId;\n-            }\n+            // ThreadId never seems to be used or useful for anything.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "no, I want to keep them at least for a while as an indication of what was here in the old formats. We may decide to bring this back. I\u2019ll revisit in a year or so.",
              "createdAt": "2021-04-08T19:53:11Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -668,10 +691,11 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr\n                 flags |= BuildEventArgsFieldFlags.SenderName;\n             }\n \n-            if (e.ThreadId > 0)\n-            {\n-                flags |= BuildEventArgsFieldFlags.ThreadId;\n-            }\n+            // ThreadId never seems to be used or useful for anything.",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Please make sure you do. I don't like commented out code.",
              "createdAt": "2021-04-09T18:51:28Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -668,10 +691,11 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr\n                 flags |= BuildEventArgsFieldFlags.SenderName;\n             }\n \n-            if (e.ThreadId > 0)\n-            {\n-                flags |= BuildEventArgsFieldFlags.ThreadId;\n-            }\n+            // ThreadId never seems to be used or useful for anything.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we change this to:\r\ninternal static string ResourceStringFormatter(string resourceName, string[] arguments)\r\n?\r\n\r\n(Not sure why it isn't letting me write suggestions.)",
              "createdAt": "2021-04-06T00:20:04Z",
              "path": "src/Framework/BuildEventArgs.cs",
              "diffHunk": "@@ -246,7 +258,48 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)\n                 buildEventContext = BuildEventContext.Invalid;\n             }\n         }\n-#endregion\n+        #endregion\n \n+        /// <summary>\n+        /// This is the default stub implementation, only here as a safeguard.\n+        /// Actual logic is injected from Microsoft.Build.dll to replace this.\n+        /// This is used by the Message property overrides to reconstruct the\n+        /// message lazily on demand.\n+        /// </summary>\n+        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "no because this delegate is being replaced wholesale, and you can\u2019t replace a regular method",
              "createdAt": "2021-04-08T19:54:13Z",
              "path": "src/Framework/BuildEventArgs.cs",
              "diffHunk": "@@ -246,7 +258,48 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)\n                 buildEventContext = BuildEventContext.Invalid;\n             }\n         }\n-#endregion\n+        #endregion\n \n+        /// <summary>\n+        /// This is the default stub implementation, only here as a safeguard.\n+        /// Actual logic is injected from Microsoft.Build.dll to replace this.\n+        /// This is used by the Message property overrides to reconstruct the\n+        /// message lazily on demand.\n+        /// </summary>\n+        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "StringBuilderCache?",
              "createdAt": "2021-04-06T00:20:48Z",
              "path": "src/Framework/BuildEventArgs.cs",
              "diffHunk": "@@ -246,7 +258,48 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)\n                 buildEventContext = BuildEventContext.Invalid;\n             }\n         }\n-#endregion\n+        #endregion\n \n+        /// <summary>\n+        /// This is the default stub implementation, only here as a safeguard.\n+        /// Actual logic is injected from Microsoft.Build.dll to replace this.\n+        /// This is used by the Message property overrides to reconstruct the\n+        /// message lazily on demand.\n+        /// </summary>\n+        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>\n+        {\n+            var sb = new StringBuilder();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "StringBuilderCache is not available in MS.B.Framework, but that's OK because this code never runs anyway. It's just there as a stub in case we forget to reassign ResourceStringFormatter or something else breaks.",
              "createdAt": "2021-04-08T20:38:20Z",
              "path": "src/Framework/BuildEventArgs.cs",
              "diffHunk": "@@ -246,7 +258,48 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)\n                 buildEventContext = BuildEventContext.Invalid;\n             }\n         }\n-#endregion\n+        #endregion\n \n+        /// <summary>\n+        /// This is the default stub implementation, only here as a safeguard.\n+        /// Actual logic is injected from Microsoft.Build.dll to replace this.\n+        /// This is used by the Message property overrides to reconstruct the\n+        /// message lazily on demand.\n+        /// </summary>\n+        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>\n+        {\n+            var sb = new StringBuilder();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just to simplify this slightly, I might just always append argument and ',' and have sb.Length--; after the loop.",
              "createdAt": "2021-04-06T00:21:25Z",
              "path": "src/Framework/BuildEventArgs.cs",
              "diffHunk": "@@ -246,7 +258,48 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)\n                 buildEventContext = BuildEventContext.Invalid;\n             }\n         }\n-#endregion\n+        #endregion\n \n+        /// <summary>\n+        /// This is the default stub implementation, only here as a safeguard.\n+        /// Actual logic is injected from Microsoft.Build.dll to replace this.\n+        /// This is used by the Message property overrides to reconstruct the\n+        /// message lazily on demand.\n+        /// </summary>\n+        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>\n+        {\n+            var sb = new StringBuilder();\n+            sb.Append(resourceName);\n+            sb.Append(\"(\");\n+\n+            bool notFirst = false;\n+            foreach (var argument in arguments)\n+            {\n+                if (notFirst)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "ah, interesting. But then you'd have to mess with the case where there were no arguments. This is that classical Dijkstra's loop-and-a-half situation where you just can't win",
              "createdAt": "2021-04-08T20:40:36Z",
              "path": "src/Framework/BuildEventArgs.cs",
              "diffHunk": "@@ -246,7 +258,48 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)\n                 buildEventContext = BuildEventContext.Invalid;\n             }\n         }\n-#endregion\n+        #endregion\n \n+        /// <summary>\n+        /// This is the default stub implementation, only here as a safeguard.\n+        /// Actual logic is injected from Microsoft.Build.dll to replace this.\n+        /// This is used by the Message property overrides to reconstruct the\n+        /// message lazily on demand.\n+        /// </summary>\n+        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>\n+        {\n+            var sb = new StringBuilder();\n+            sb.Append(resourceName);\n+            sb.Append(\"(\");\n+\n+            bool notFirst = false;\n+            foreach (var argument in arguments)\n+            {\n+                if (notFirst)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like it removes the MSBuildALlProjects property altogether, is that the case?",
              "createdAt": "2021-04-07T22:19:32Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1315,6 +1315,13 @@ private void LogPropertyReassignment(P predecessor, P property, string location)\n             string newValue = property.EvaluatedValue;\n             string oldValue = predecessor?.EvaluatedValue;\n \n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "It doesn't log any property reassignment messages for MSBuildAllProjects, yes.",
              "createdAt": "2021-04-08T00:38:20Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1315,6 +1315,13 @@ private void LogPropertyReassignment(P predecessor, P property, string location)\n             string newValue = property.EvaluatedValue;\n             string oldValue = predecessor?.EvaluatedValue;\n \n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Just for clarity, MSBuildAllProjects isn't gone, and its final state is still logged; this only suppresses property reassignment.",
              "createdAt": "2021-04-08T15:12:48Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1315,6 +1315,13 @@ private void LogPropertyReassignment(P predecessor, P property, string location)\n             string newValue = property.EvaluatedValue;\n             string oldValue = predecessor?.EvaluatedValue;\n \n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "While we're here, I took a look at a binlog to see what other properties stand out. `DefineConstants` gets about as long as `MSBuildAllProjects` and is reassigned quite a bit. Any way to log these once at the end of evaluation?",
              "createdAt": "2021-04-07T22:24:31Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "`DefaultItemExcludes` doesn't get nearly as long or reassigned as many times but it seems worth mentioning.",
              "createdAt": "2021-04-07T22:25:39Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes, I've noticed DefaultItemExcludes too, but decided to not go too crazy. DefineConstants is certainly useful, so let's still log that.",
              "createdAt": "2021-04-08T00:29:34Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I was already familiar with MSBuildAllProjects. How is DefineConstants used?",
              "createdAt": "2021-04-08T15:15:24Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Also, is it that valuable to remove the initial value logging? That should only happen once, and it should be pretty small at that point, right?",
              "createdAt": "2021-04-08T15:16:22Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "DefineConstants is very useful, this is that thing that is passed to Csc that tells the compiler what `#ifdef` values are considered true.",
              "createdAt": "2021-04-08T20:56:26Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Yeah, not removing the initial logging, just the reassignment. There's a separate bug that the logging of initial values, environment variable reads is not working: https://github.com/dotnet/msbuild/issues/5015",
              "createdAt": "2021-04-08T20:58:35Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -259,18 +259,31 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)\n         /// <param name=\"location\">The location of this property's reassignment.</param>\n         private void TrackPropertyReassignment(P predecessor, P property, string location)\n         {\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;\n+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)\n+            {\n+                return;\n+            }\n+\n+            if (string.Equals(property.Name, \"MSBuildAllProjects\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: For consistency, `GetResourceEightSpaces` and so on. Or `GetResourceXSpaces(\"Resource\", SomeFancyEnumEnum.Four)` (the former seems like the better option).",
              "createdAt": "2021-04-07T22:37:00Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");\n+                ConsideredAndRejectedBecauseNoFile = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNoFile\");\n+                ConsideredAndRejectedBecauseNotAFileNameOnDisk = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNotAFileNameOnDisk\");\n+                ConsideredAndRejectedBecauseNotInGac = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNotInGac\");\n+                ConsideredAndRejectedBecauseTargetDidntHaveFusionName = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName\");\n+                Dependency = GetResource(\"ResolveAssemblyReference.Dependency\");\n+                FormattedAssemblyInfo = GetResourceFourSpaces(\"ResolveAssemblyReference.FormattedAssemblyInfo\");\n+                FoundRelatedFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundRelatedFile\");\n+                FoundSatelliteFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundSatelliteFile\");\n+                FoundScatterFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundScatterFile\");\n+                ImageRuntimeVersion = GetResourceFourSpaces(\"ResolveAssemblyReference.ImageRuntimeVersion\");\n+                IsAWinMdFile = GetResourceFourSpaces(\"ResolveAssemblyReference.IsAWinMdFile\");\n+                LogAttributeFormat = EightSpaces + GetResource(\"ResolveAssemblyReference.LogAttributeFormat\");\n+                LogTaskPropertyFormat = GetResource(\"ResolveAssemblyReference.LogTaskPropertyFormat\");\n+                NoBecauseParentReferencesFoundInGac = GetResourceFourSpaces(\"ResolveAssemblyReference.NoBecauseParentReferencesFoundInGac\");\n+                NotCopyLocalBecauseConflictVictim = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseConflictVictim\");\n+                NotCopyLocalBecauseEmbedded = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseEmbedded\");\n+                NotCopyLocalBecauseFrameworksFiles = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseFrameworksFiles\");\n+                NotCopyLocalBecauseIncomingItemAttributeOverrode = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseIncomingItemAttributeOverrode\");\n+                NotCopyLocalBecausePrerequisite = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecausePrerequisite\");\n+                NotCopyLocalBecauseReferenceFoundInGAC = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseReferenceFoundInGAC\");\n+                PrimaryReference = GetResource(\"ResolveAssemblyReference.PrimaryReference\");\n+                RemappedReference = GetResourceFourSpaces(\"ResolveAssemblyReference.RemappedReference\");\n+                RequiredBy = GetResourceFourSpaces(\"ResolveAssemblyReference.RequiredBy\");\n+                Resolved = GetResourceFourSpaces(\"ResolveAssemblyReference.Resolved\");\n+                ResolvedFrom = GetResourceFourSpaces(\"ResolveAssemblyReference.ResolvedFrom\");\n+                SearchedAssemblyFoldersEx = EightSpaces + GetResource(\"ResolveAssemblyReference.SearchedAssemblyFoldersEx\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I like this better than the second option, but I like the first option more.",
              "createdAt": "2021-04-08T15:26:25Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");\n+                ConsideredAndRejectedBecauseNoFile = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNoFile\");\n+                ConsideredAndRejectedBecauseNotAFileNameOnDisk = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNotAFileNameOnDisk\");\n+                ConsideredAndRejectedBecauseNotInGac = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNotInGac\");\n+                ConsideredAndRejectedBecauseTargetDidntHaveFusionName = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName\");\n+                Dependency = GetResource(\"ResolveAssemblyReference.Dependency\");\n+                FormattedAssemblyInfo = GetResourceFourSpaces(\"ResolveAssemblyReference.FormattedAssemblyInfo\");\n+                FoundRelatedFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundRelatedFile\");\n+                FoundSatelliteFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundSatelliteFile\");\n+                FoundScatterFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundScatterFile\");\n+                ImageRuntimeVersion = GetResourceFourSpaces(\"ResolveAssemblyReference.ImageRuntimeVersion\");\n+                IsAWinMdFile = GetResourceFourSpaces(\"ResolveAssemblyReference.IsAWinMdFile\");\n+                LogAttributeFormat = EightSpaces + GetResource(\"ResolveAssemblyReference.LogAttributeFormat\");\n+                LogTaskPropertyFormat = GetResource(\"ResolveAssemblyReference.LogTaskPropertyFormat\");\n+                NoBecauseParentReferencesFoundInGac = GetResourceFourSpaces(\"ResolveAssemblyReference.NoBecauseParentReferencesFoundInGac\");\n+                NotCopyLocalBecauseConflictVictim = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseConflictVictim\");\n+                NotCopyLocalBecauseEmbedded = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseEmbedded\");\n+                NotCopyLocalBecauseFrameworksFiles = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseFrameworksFiles\");\n+                NotCopyLocalBecauseIncomingItemAttributeOverrode = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseIncomingItemAttributeOverrode\");\n+                NotCopyLocalBecausePrerequisite = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecausePrerequisite\");\n+                NotCopyLocalBecauseReferenceFoundInGAC = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseReferenceFoundInGAC\");\n+                PrimaryReference = GetResource(\"ResolveAssemblyReference.PrimaryReference\");\n+                RemappedReference = GetResourceFourSpaces(\"ResolveAssemblyReference.RemappedReference\");\n+                RequiredBy = GetResourceFourSpaces(\"ResolveAssemblyReference.RequiredBy\");\n+                Resolved = GetResourceFourSpaces(\"ResolveAssemblyReference.Resolved\");\n+                ResolvedFrom = GetResourceFourSpaces(\"ResolveAssemblyReference.ResolvedFrom\");\n+                SearchedAssemblyFoldersEx = EightSpaces + GetResource(\"ResolveAssemblyReference.SearchedAssemblyFoldersEx\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "OK by popular demand I've introduced `GetResourceEightSpaces`. It does make sense.\r\nAlso added a separate bool `initialized` field.",
              "createdAt": "2021-04-08T20:54:50Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");\n+                ConsideredAndRejectedBecauseNoFile = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNoFile\");\n+                ConsideredAndRejectedBecauseNotAFileNameOnDisk = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNotAFileNameOnDisk\");\n+                ConsideredAndRejectedBecauseNotInGac = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseNotInGac\");\n+                ConsideredAndRejectedBecauseTargetDidntHaveFusionName = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName\");\n+                Dependency = GetResource(\"ResolveAssemblyReference.Dependency\");\n+                FormattedAssemblyInfo = GetResourceFourSpaces(\"ResolveAssemblyReference.FormattedAssemblyInfo\");\n+                FoundRelatedFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundRelatedFile\");\n+                FoundSatelliteFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundSatelliteFile\");\n+                FoundScatterFile = GetResourceFourSpaces(\"ResolveAssemblyReference.FoundScatterFile\");\n+                ImageRuntimeVersion = GetResourceFourSpaces(\"ResolveAssemblyReference.ImageRuntimeVersion\");\n+                IsAWinMdFile = GetResourceFourSpaces(\"ResolveAssemblyReference.IsAWinMdFile\");\n+                LogAttributeFormat = EightSpaces + GetResource(\"ResolveAssemblyReference.LogAttributeFormat\");\n+                LogTaskPropertyFormat = GetResource(\"ResolveAssemblyReference.LogTaskPropertyFormat\");\n+                NoBecauseParentReferencesFoundInGac = GetResourceFourSpaces(\"ResolveAssemblyReference.NoBecauseParentReferencesFoundInGac\");\n+                NotCopyLocalBecauseConflictVictim = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseConflictVictim\");\n+                NotCopyLocalBecauseEmbedded = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseEmbedded\");\n+                NotCopyLocalBecauseFrameworksFiles = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseFrameworksFiles\");\n+                NotCopyLocalBecauseIncomingItemAttributeOverrode = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseIncomingItemAttributeOverrode\");\n+                NotCopyLocalBecausePrerequisite = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecausePrerequisite\");\n+                NotCopyLocalBecauseReferenceFoundInGAC = GetResourceFourSpaces(\"ResolveAssemblyReference.NotCopyLocalBecauseReferenceFoundInGAC\");\n+                PrimaryReference = GetResource(\"ResolveAssemblyReference.PrimaryReference\");\n+                RemappedReference = GetResourceFourSpaces(\"ResolveAssemblyReference.RemappedReference\");\n+                RequiredBy = GetResourceFourSpaces(\"ResolveAssemblyReference.RequiredBy\");\n+                Resolved = GetResourceFourSpaces(\"ResolveAssemblyReference.Resolved\");\n+                ResolvedFrom = GetResourceFourSpaces(\"ResolveAssemblyReference.ResolvedFrom\");\n+                SearchedAssemblyFoldersEx = EightSpaces + GetResource(\"ResolveAssemblyReference.SearchedAssemblyFoldersEx\");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In an earlier commit you had a string for `Indent` that was four or eight spaces. Does it make sense to create a more global strings class that has things like fourspaces, eightspaces, resource formatters, etc?",
              "createdAt": "2021-04-07T22:38:17Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Probably not worth it honestly. But let's think about it some more.",
              "createdAt": "2021-04-08T00:31:27Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Checking `Resolved` here seems a bit arbitrary. Some sort of `HasBeenInitialized` bool sounds more intuitive.\r\n\r\nI was going to suggest checking `if (this != null)`, but this is essentially a _static_ singleton, so I see how this came about.",
              "createdAt": "2021-04-07T22:45:56Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "No big deal honestly. I agree WasInitialized is marginally better.",
              "createdAt": "2021-04-08T00:36:53Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "OK I added a `static bool initialized` field.",
              "createdAt": "2021-04-08T21:00:45Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "General question: I tried chasing when the string eventually gets formatted and stopped my search at `LoggingService.RouteBuildEvent`, the args get passed into a buildeventsink.Consume. Where do they get picked up and eventually formatted?",
              "createdAt": "2021-04-07T23:04:32Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1314,151 +1408,152 @@ private MessageImportance ChooseReferenceLoggingImportance(Reference reference)\n         /// </summary>\n         private void LogInputs()\n         {\n-            if (Traits.Instance.EscapeHatches.LogTaskInputs)\n+            if (Traits.Instance.EscapeHatches.LogTaskInputs || Silent)\n             {\n                 // the inputs will be logged automatically anyway, avoid duplication in the logs\n                 return;\n             }\n \n-            if (!Silent)\n-            {\n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.LogTaskPropertyFormat\", \"TargetFrameworkMoniker\");\n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.FourSpaceIndent\", _targetedFrameworkMoniker);\n+            string indent = Strings.FourSpaces;\n+            string property = Strings.LogTaskPropertyFormat;\n+            MessageImportance importance = MessageImportance.Low;\n \n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.LogTaskPropertyFormat\", \"TargetFrameworkMonikerDisplayName\");\n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.FourSpaceIndent\", TargetFrameworkMonikerDisplayName);\n+            Log.LogMessage(importance, property, \"TargetFrameworkMoniker\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "When either SerialConsoleLogger or ParallelConsoleLogger actually wants to print it. If there are no text loggers, the string is never concatenated together. Well maybe in the binlog viewer after reading the binlog.\r\n\r\nThe beauty of LazyFormattedBuildEventArgs is that arguments travel separately from the string through the entire system. We haven't been leveraging this until now. Node packet translator already did the right thing, and now the binlog reader and writer do too.",
              "createdAt": "2021-04-08T00:34:52Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1314,151 +1408,152 @@ private MessageImportance ChooseReferenceLoggingImportance(Reference reference)\n         /// </summary>\n         private void LogInputs()\n         {\n-            if (Traits.Instance.EscapeHatches.LogTaskInputs)\n+            if (Traits.Instance.EscapeHatches.LogTaskInputs || Silent)\n             {\n                 // the inputs will be logged automatically anyway, avoid duplication in the logs\n                 return;\n             }\n \n-            if (!Silent)\n-            {\n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.LogTaskPropertyFormat\", \"TargetFrameworkMoniker\");\n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.FourSpaceIndent\", _targetedFrameworkMoniker);\n+            string indent = Strings.FourSpaces;\n+            string property = Strings.LogTaskPropertyFormat;\n+            MessageImportance importance = MessageImportance.Low;\n \n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.LogTaskPropertyFormat\", \"TargetFrameworkMonikerDisplayName\");\n-                Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.FourSpaceIndent\", TargetFrameworkMonikerDisplayName);\n+            Log.LogMessage(importance, property, \"TargetFrameworkMoniker\");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would we generally benefit from avoiding just-in-time resource retrieving? I seem to recall you saying it was as fast as a dictionary lookup.",
              "createdAt": "2021-04-07T23:11:01Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2696,60 +2809,63 @@ private bool VerifyInputConditions()\n         /// <summary>\n         /// Log the target framework subset information.\n         /// </summary>\n-        private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[] whiteListSubsetTableInfo, ReferenceTable referenceTable)\n+        private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[] inclusionListSubsetTableInfo, ReferenceTable referenceTable)\n         {\n-            if (installedAssemblyTableInfo != null)\n+            if (installedAssemblyTableInfo == null)\n             {\n-                string dumpFrameworkSubsetList = Environment.GetEnvironmentVariable(\"MSBUILDDUMPFRAMEWORKSUBSETLIST\");\n+                return;\n+            }\n \n-                if (dumpFrameworkSubsetList != null)\n-                {\n-                    Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.TargetFrameworkSubsetLogHeader\");\n+            string dumpFrameworkSubsetList = Environment.GetEnvironmentVariable(\"MSBUILDDUMPFRAMEWORKSUBSETLIST\");\n+            if (dumpFrameworkSubsetList == null)\n+            {\n+                return;\n+            }\n \n-                    Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.TargetFrameworkRedistLogHeader\");\n-                    foreach (AssemblyTableInfo redistInfo in installedAssemblyTableInfo)\n-                    {\n-                        if (redistInfo != null)\n-                        {\n-                            Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.FourSpaceIndent\", Log.FormatResourceString(\"ResolveAssemblyReference.FormattedAssemblyInfo\", redistInfo.Path));\n-                        }\n-                    }\n+            Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.TargetFrameworkSubsetLogHeader\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Resource lookup seems to be fast, but the downside of LogMessageFromResources is that it formats the string and inlines the arguments, which we want to avoid. This is why I had to introduce a Log.LogMessage overload that takes a string with arguments and preserves the arguments separately.",
              "createdAt": "2021-04-08T00:36:06Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2696,60 +2809,63 @@ private bool VerifyInputConditions()\n         /// <summary>\n         /// Log the target framework subset information.\n         /// </summary>\n-        private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[] whiteListSubsetTableInfo, ReferenceTable referenceTable)\n+        private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[] inclusionListSubsetTableInfo, ReferenceTable referenceTable)\n         {\n-            if (installedAssemblyTableInfo != null)\n+            if (installedAssemblyTableInfo == null)\n             {\n-                string dumpFrameworkSubsetList = Environment.GetEnvironmentVariable(\"MSBUILDDUMPFRAMEWORKSUBSETLIST\");\n+                return;\n+            }\n \n-                if (dumpFrameworkSubsetList != null)\n-                {\n-                    Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.TargetFrameworkSubsetLogHeader\");\n+            string dumpFrameworkSubsetList = Environment.GetEnvironmentVariable(\"MSBUILDDUMPFRAMEWORKSUBSETLIST\");\n+            if (dumpFrameworkSubsetList == null)\n+            {\n+                return;\n+            }\n \n-                    Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.TargetFrameworkRedistLogHeader\");\n-                    foreach (AssemblyTableInfo redistInfo in installedAssemblyTableInfo)\n-                    {\n-                        if (redistInfo != null)\n-                        {\n-                            Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.FourSpaceIndent\", Log.FormatResourceString(\"ResolveAssemblyReference.FormattedAssemblyInfo\", redistInfo.Path));\n-                        }\n-                    }\n+            Log.LogMessageFromResources(MessageImportance.Low, \"ResolveAssemblyReference.TargetFrameworkSubsetLogHeader\");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since you reuse this pattern every time you define Message, maybe make a helper method that takes the message and args and assigns to RawMessage appropriately, then returns it?",
              "createdAt": "2021-04-08T15:06:35Z",
              "path": "src/Framework/TargetFinishedEventArgs.cs",
              "diffHunk": "@@ -176,5 +176,24 @@ public IEnumerable TargetOutputs\n             get => targetOutputs;\n             set => targetOutputs = value;\n         }\n+\n+        public override string Message\n+        {\n+            get\n+            {\n+                if (RawMessage == null)\n+                {\n+                    lock (locker)\n+                    {\n+                        if (RawMessage == null)\n+                        {\n+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? \"TargetFinishedSuccess\" : \"TargetFinishedFailure\", targetName, Path.GetFileName(projectFile));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I wanted to keep the code looking the same as it was originally where I took it from, this is why I also named the function the same way. We may refactor later.",
              "createdAt": "2021-04-08T21:03:04Z",
              "path": "src/Framework/TargetFinishedEventArgs.cs",
              "diffHunk": "@@ -176,5 +176,24 @@ public IEnumerable TargetOutputs\n             get => targetOutputs;\n             set => targetOutputs = value;\n         }\n+\n+        public override string Message\n+        {\n+            get\n+            {\n+                if (RawMessage == null)\n+                {\n+                    lock (locker)\n+                    {\n+                        if (RawMessage == null)\n+                        {\n+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? \"TargetFinishedSuccess\" : \"TargetFinishedFailure\", targetName, Path.GetFileName(projectFile));",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The check-lock-check pattern is very cautious. No need to check if you don't know, but do you have any idea how much it would cost to just check if it's null and reset it if it is, even if another process might be concurrently setting it? You would presumably allocate slightly more strings, but I don't think it would impact correctness, and it might save a little time.",
              "createdAt": "2021-04-08T15:10:03Z",
              "path": "src/Framework/TaskStartedEventArgs.cs",
              "diffHunk": "@@ -122,5 +122,24 @@ internal override void CreateFromStream(BinaryReader reader, int version)\n         /// MSBuild file where this task was defined.   \n         /// </summary>\n         public string TaskFile => taskFile;\n+\n+        public override string Message\n+        {\n+            get\n+            {\n+                if (RawMessage == null)\n+                {\n+                    lock (locker)\n+                    {\n+                        if (RawMessage == null)\n+                        {\n+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(\"TaskStarted\", TaskName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, I agree the worst thing that can happen is a string getting allocated twice, and chances of that are practically zero given all the consumers of calling the Message getter are really the two console loggers, and they are single-threaded. Perhaps we should just remove the lock entirely.\r\n\r\nBut for now it's not a perf problem, lock is incredibly fast and usually only shows up where there's insane amounts of contention.\r\n\r\nI'll investigate all this separately as part of https://github.com/dotnet/msbuild/issues/6002",
              "createdAt": "2021-04-08T21:07:52Z",
              "path": "src/Framework/TaskStartedEventArgs.cs",
              "diffHunk": "@@ -122,5 +122,24 @@ internal override void CreateFromStream(BinaryReader reader, int version)\n         /// MSBuild file where this task was defined.   \n         /// </summary>\n         public string TaskFile => taskFile;\n+\n+        public override string Message\n+        {\n+            get\n+            {\n+                if (RawMessage == null)\n+                {\n+                    lock (locker)\n+                    {\n+                        if (RawMessage == null)\n+                        {\n+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(\"TaskStarted\", TaskName);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Some of these (particularly looking at this one) sound like they wouldn't be logged more than ~once per project at most and often wouldn't be logged at all. For those cases, lazier sounds slightly more efficient.",
              "createdAt": "2021-04-08T15:14:15Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1659,6 +1666,15 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n             return allProjects;\n         }\n \n+        private static readonly string CouldNotResolveSdk = ResourceUtilities.GetResourceString(\"CouldNotResolveSdk\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "At this scale it really doesn't matter. I didn't want to think too hard about which strings are rare.",
              "createdAt": "2021-04-08T21:11:34Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1659,6 +1666,15 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n             return allProjects;\n         }\n \n+        private static readonly string CouldNotResolveSdk = ResourceUtilities.GetResourceString(\"CouldNotResolveSdk\");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm curious if we can just remove some of this logging or if customers actually want it. RAR logs a lot, and I have at least a vague understanding of what a lot of these are, but I've seen several cases in which people unfamiliar with RAR report an error and show me a portion of the logs that, to me, pretty clearly states what they should do to resolve the problem, but to them means nothing.\r\n\r\nI'm particularly thinking of things like scatter files because I have no idea what they're for, and I asked rainersigwald at one point, and he had no idea what they were for. If no one knows what they're for, why are we logging about them? Are they even helpful, or can we remove them (and calculating them) entirely?\r\n\r\nThat would clearly make this a potential breaking change, so although I'd be in favor of getting rid of the less understandable log messages, it would have to be under a change wave at minimum and probably shouldn't happen at all. Even figuring out which are the unclear log messages would be difficult, and getting it wrong could really annoy people.",
              "createdAt": "2021-04-08T15:25:14Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> I'm particularly thinking of things like scatter files because I have no idea what they're for, and I asked rainersigwald at one point, and he had no idea what they were for. If no one knows what they're for, why are we logging about them? Are they even helpful, or can we remove them (and calculating them) entirely?\r\n\r\nThis sounds worth talking about when Rainer gets back. Maybe a changewave to log \"less useful\" messages at the lowest verbosity rather than not at all. Unless they're already logged at the lowest. Then I don't think we can avoid someone somewhere getting annoyed.",
              "createdAt": "2021-04-08T18:56:47Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes, it's tempting to reduce RAR logging. RAR logging is the thing that bloats the binlog size the most. We should hopefully have an effort to increase more useful logging and reduce useless logging. I couldn't resist and removed the \"Image runtime is v4.0.30319\" in this PR which is absolutely useless (\"gee whiz, this .dll is a managed assembly\").\r\n\r\nBut removing more should be a separate effort.",
              "createdAt": "2021-04-08T21:15:19Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "In general, we should fight \"Captain Obvious logging\" everywhere and ensure that the signal-to-noise ratio is high. NuGet RestoreTask is especially high noise unfortunately: https://github.com/NuGet/Home/issues/10383",
              "createdAt": "2021-04-08T21:16:20Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -56,6 +56,96 @@ public class ResolveAssemblyReference : TaskExtension\n         /// </summary>\n         public ResolveAssemblyReference()\n         {\n+            Strings.Initialize(Log);\n+        }\n+\n+        private static class Strings\n+        {\n+            public const string FourSpaces = \"    \";\n+            public const string EightSpaces = \"        \";\n+            public const string TenSpaces = \"          \";\n+            public const string TwelveSpaces = \"            \";\n+\n+            public static string ConsideredAndRejectedBecauseFusionNamesDidntMatch;\n+            public static string ConsideredAndRejectedBecauseNoFile;\n+            public static string ConsideredAndRejectedBecauseNotAFileNameOnDisk;\n+            public static string ConsideredAndRejectedBecauseNotInGac;\n+            public static string ConsideredAndRejectedBecauseTargetDidntHaveFusionName;\n+            public static string Dependency;\n+            public static string FormattedAssemblyInfo;\n+            public static string FoundRelatedFile;\n+            public static string FoundSatelliteFile;\n+            public static string FoundScatterFile;\n+            public static string ImageRuntimeVersion;\n+            public static string IsAWinMdFile;\n+            public static string LogAttributeFormat;\n+            public static string LogTaskPropertyFormat;\n+            public static string NoBecauseParentReferencesFoundInGac;\n+            public static string NotCopyLocalBecauseConflictVictim;\n+            public static string NotCopyLocalBecauseEmbedded;\n+            public static string NotCopyLocalBecauseFrameworksFiles;\n+            public static string NotCopyLocalBecauseIncomingItemAttributeOverrode;\n+            public static string NotCopyLocalBecausePrerequisite;\n+            public static string NotCopyLocalBecauseReferenceFoundInGAC;\n+            public static string PrimaryReference;\n+            public static string RemappedReference;\n+            public static string RequiredBy;\n+            public static string Resolved;\n+            public static string ResolvedFrom;\n+            public static string SearchedAssemblyFoldersEx;\n+            public static string SearchPath;\n+            public static string TargetedProcessorArchitectureDoesNotMatch;\n+            public static string UnificationByAppConfig;\n+            public static string UnificationByAutoUnify;\n+            public static string UnificationByFrameworkRetarget;\n+            public static string UnifiedDependency;\n+            public static string UnifiedPrimaryReference;\n+\n+            internal static void Initialize(TaskLoggingHelper log)\n+            {\n+                if (Resolved != null)\n+                {\n+                    return;\n+                }\n+\n+                string GetResource(string name) => log.GetResourceMessage(name);\n+                string GetResourceFourSpaces(string name) => FourSpaces + log.GetResourceMessage(name);\n+\n+                ConsideredAndRejectedBecauseFusionNamesDidntMatch = EightSpaces + GetResource(\"ResolveAssemblyReference.ConsideredAndRejectedBecauseFusionNamesDidntMatch\");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would these sorts of changes wreak havoc with our other documentation?",
              "createdAt": "2021-04-08T15:53:27Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2774,7 +2890,7 @@ private bool ShouldUseSubsetBlackList()\n             }\n \n             // No subset names were passed in to search for in the targetframework directories and no installed subset tables were provided, we have nothing to use to \n-            // generate the black list with, so do not continue.\n+            // generate the exclusion list with, so do not continue.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "IMO it's a good start",
              "createdAt": "2021-04-08T18:57:47Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2774,7 +2890,7 @@ private bool ShouldUseSubsetBlackList()\n             }\n \n             // No subset names were passed in to search for in the targetframework directories and no installed subset tables were provided, we have nothing to use to \n-            // generate the black list with, so do not continue.\n+            // generate the exclusion list with, so do not continue.",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes, we should make these changes everywhere, including the public API eventually. As a first pass I limited this to comments and internal stuff like parameter names and local names, but we'll need a separate pass with an API change when Rainer gets back.",
              "createdAt": "2021-04-08T20:34:08Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2774,7 +2890,7 @@ private bool ShouldUseSubsetBlackList()\n             }\n \n             // No subset names were passed in to search for in the targetframework directories and no installed subset tables were provided, we have nothing to use to \n-            // generate the black list with, so do not continue.\n+            // generate the exclusion list with, so do not continue.",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d",
              "createdAt": "2021-04-08T15:57:03Z",
              "path": "src/Build/Logging/BaseConsoleLogger.cs",
              "diffHunk": "@@ -975,6 +975,9 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue\n                 case \"PERFORMANCESUMMARY\":\n                     showPerfSummary = true;\n                     return true;\n+                case \"NOPERFORMANCESUMMARY\":",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we really not already have a test for this? Seems so fundamental...",
              "createdAt": "2021-04-08T15:58:52Z",
              "path": "src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs",
              "diffHunk": "@@ -198,6 +198,43 @@ public void TestDependencyBuildWithError()\n             Assert.Equal(TargetResultCode.Success, resultsCache.GetResultForRequest(entry.Request)[\"Baz\"].ResultCode);\n         }\n \n+        [Fact]\n+        public void TestLoggingForSkippedTargetInputsAndOutputs()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, surprisingly I didn't find anything.",
              "createdAt": "2021-04-08T20:32:58Z",
              "path": "src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs",
              "diffHunk": "@@ -198,6 +198,43 @@ public void TestDependencyBuildWithError()\n             Assert.Equal(TargetResultCode.Success, resultsCache.GetResultForRequest(entry.Request)[\"Baz\"].ResultCode);\n         }\n \n+        [Fact]\n+        public void TestLoggingForSkippedTargetInputsAndOutputs()",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Rather than hardcoding all of these throughout various places, wouldn't it be better to just cache all resources in ResouceUitlities as they're asked for?",
              "createdAt": "2021-04-08T22:10:38Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1659,6 +1666,15 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n             return allProjects;\n         }\n \n+        private static readonly string CouldNotResolveSdk = ResourceUtilities.GetResourceString(\"CouldNotResolveSdk\");\n+        private static readonly string ProjectImported = ResourceUtilities.GetResourceString(\"ProjectImported\");",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Turns out they're already cached in the BCL so calling ResourceUtilities.GetResourceString is cheap enough (not as cheap as a static field access though).",
              "createdAt": "2021-04-08T22:57:34Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1659,6 +1666,15 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n             return allProjects;\n         }\n \n+        private static readonly string CouldNotResolveSdk = ResourceUtilities.GetResourceString(\"CouldNotResolveSdk\");\n+        private static readonly string ProjectImported = ResourceUtilities.GetResourceString(\"ProjectImported\");",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "@cdmihai another aspect of this just occurred to me. Evaluator.cs is a huge perf bottleneck and a hot path. This is why we should strive to microoptimize here no matter big or small, when it is reasonable of course. Get all the background noise out of the way as much as possible.",
              "createdAt": "2021-04-09T00:20:22Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1659,6 +1666,15 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n             return allProjects;\n         }\n \n+        private static readonly string CouldNotResolveSdk = ResourceUtilities.GetResourceString(\"CouldNotResolveSdk\");\n+        private static readonly string ProjectImported = ResourceUtilities.GetResourceString(\"ProjectImported\");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I wonder what the gains of offering a few overloads for it would be:\r\n\r\n\r\n```csharp\r\npublic void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object[] messageArgs)\r\npublic void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, object arg1)\r\npublic void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, object arg1, object arg2)\r\n```\r\n\r\nThat would avoid most of the allocations for the string.Format calls, I guess.",
              "createdAt": "2021-04-14T09:08:28Z",
              "path": "src/Build.UnitTests/BackEnd/MockLoggingService.cs",
              "diffHunk": "@@ -300,6 +300,17 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor\n             _writer(message);\n         }\n \n+        /// <inheritdoc />\n+        public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object[] messageArgs)",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "We\u2019ll need an array later on anyway, to store the arguments on LazyFormattedBuildEventArgs",
              "createdAt": "2021-04-14T16:00:26Z",
              "path": "src/Build.UnitTests/BackEnd/MockLoggingService.cs",
              "diffHunk": "@@ -300,6 +300,17 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor\n             _writer(message);\n         }\n \n+        /// <inheritdoc />\n+        public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object[] messageArgs)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}