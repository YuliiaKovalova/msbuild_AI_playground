{
  "number": 7055,
  "title": "Avoid temporary list allocations and specify list capacities in TaskItem",
  "body": "### Context\r\n\r\nNoticed while browsing code.\r\n\r\n### Changes Made\r\n\r\n- Avoid creating temporary `List<>` objects in several cases\r\n- Specify `List<>` capacities to avoid temporaries during construction and wasted space in result\r\n- (minor) Use a named argument to resolve ambiguity\r\n- (minor) Replace `as` type checks with direct type conversion\r\n\r\n### Testing\r\n\r\nUnit tests.\r\n\r\n### Notes\r\n\r\nMay be easier to review each commit separately.",
  "state": "MERGED",
  "createdAt": "2021-11-22T06:01:57Z",
  "updatedAt": "2021-12-09T22:26:52Z",
  "closedAt": "2021-12-07T14:57:38Z",
  "mergedAt": "2021-12-07T14:57:38Z",
  "additions": 151,
  "deletions": 68,
  "changedFiles": 4,
  "headRefName": "dev/drnoakes/task-item-list-allocations",
  "isDraft": false,
  "author": {
    "login": "drewnoakes"
  },
  "milestone": {
    "title": "VS 17.1"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "4801e5e7a0aa4ba4b610f4defc7afde28af7a1a4",
          "message": "Fix bidirectional equality tests\n\nThese duplicated statements were probably intended to validate that the equality implementation is commutative.",
          "committedDate": "2021-12-01T04:08:35Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3633c1d67b201e25149b9c90097385d798e536b6",
          "message": "Validate build success",
          "committedDate": "2021-12-01T04:08:35Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "095a62f97f220e98cde69877a36ed75028d4e4f5",
          "message": "Add a unit test for TaskItem metadata presentation",
          "committedDate": "2021-12-01T04:08:35Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9f4538bc9588c2fdc6c51f09e985ab024c2d15f9",
          "message": "Use named argument\n\nThe previous code confused me. I thought the comment was the variable name, which would suggest the instance would be immutable. In fact, the opposite is true. Using a named argument avoids that confusion.",
          "committedDate": "2021-12-01T04:09:05Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c05e0a154031efe9061ad76dbfb15992e8311a4",
          "message": "Remove type casts\n\nThe use of `as` suggests some kind of runtime type checking is involved, and that it may fail. In fact, the type is statically known to implement the interface, so direct assignment is sufficient.\n\nThere should be no runtime change here as the compiler appears to optimise the check away. I just find this form of the code clearer.",
          "committedDate": "2021-12-01T04:09:06Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2677de3f4692ecfdfb329923003cbd4421c714a3",
          "message": "Update github.com URL\n\nThe repo was moved from the 'microsoft' org to the 'dotnet' org.",
          "committedDate": "2021-12-01T04:10:52Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba55978a809a2823a6f8ea20684076f291783b33",
          "message": "Strengthen TaskItem metadata test",
          "committedDate": "2021-12-02T03:12:52Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d75c1d6ab83002d06f6f3fab3949bb8e2a196e64",
          "message": "Reserve correct List<> capacity",
          "committedDate": "2021-12-02T03:13:44Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cd744601ed428f7440b1186e62c2bc1f26d665bb",
          "message": "Remove CustomMetadataCount property\n\nRequired rewriting some of ProjectItemInstance.TaskItem.Equals.",
          "committedDate": "2021-12-02T03:28:32Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f26fb9695c89eb1f6ed7e4643e5fabfa1c0c8404",
          "message": "Inline CustomMetadataNames\n\nThere was only one usage. As the property is not cheap to call, inline it for further optimisation opportunities.",
          "committedDate": "2021-12-02T03:35:49Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21fe445eb89c4a9df75b25dafd8af3baa0e59bbb",
          "message": "Reserve correct list capacity",
          "committedDate": "2021-12-02T03:36:30Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3aea062462e9dd548b65d182e29c0293221d394b",
          "message": "Use List<>.AddRange\n\nInternally it optimises for ICollection<>, reserving enough capacity in one hit, then using CopyTo to copy data.",
          "committedDate": "2021-12-02T03:38:49Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eab716ded77ca31d612275fdcfdee86405f86660",
          "message": "Remove unused constructor",
          "committedDate": "2021-12-02T03:39:50Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ef21b3a0e4b9652451e8430f7d5acc6fa7f2fea0",
          "message": "Fix typo",
          "committedDate": "2021-12-07T01:44:27Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c9d8ccca05911f916910eb81c9b866041fc5c54",
          "message": "Return early if counts don't match",
          "committedDate": "2021-12-07T01:44:45Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "609a7b35d426b9e4718bbac85498b8b1089aaf88",
          "message": "Add explanatory comment for equality algorithm",
          "committedDate": "2021-12-07T01:45:15Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f7cdd1a38cba1a1e2fd00e4e5881a563295c3a9b",
          "message": "Merge branch 'main' into dev/drnoakes/task-item-list-allocations",
          "committedDate": "2021-12-07T02:28:40Z",
          "author": {
            "name": "Drew Noakes",
            "email": "git@drewnoakes.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> I noticed a couple instances of github.com/microsoft/msbuild later in this file. Clean-up of that optional.\r\n\r\nFixed in e9eb4f6b3e7a266ae620161b23fedc5c35cac301. There are 267 other such URLs though.",
        "createdAt": "2021-11-24T11:19:13Z",
        "author": {
          "login": "drewnoakes"
        }
      },
      {
        "body": "I've force-pushed an update that's rebased on main, drops those commits which did not consider overriding metadata, added test coverage for metadata on the task item, and have optimised what seems safe and worth doing, based on API usage.\r\n\r\nThe next step will be to reduce churn of temporary values in immutable collections when copying sets of metadata around by adding new batch operations. I'll hold off until this and #7085 to land in whatever form they may.",
        "createdAt": "2021-12-02T08:46:36Z",
        "author": {
          "login": "drewnoakes"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "If this is on a hot path do you think it's worth optimizing further by introducing a counting-only version of the `MetadataCollection` prop?",
              "createdAt": "2021-11-22T09:04:57Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +972,10 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get { return MetadataCollection.Count; }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "MetadataCollection seems to know fairly fast how many items there are going to be but then actually puts those items into a COW dictionary. Could we recreate the logic here? Not sure if that's what you were thinking, ladipro.",
              "createdAt": "2021-11-22T15:19:55Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +972,10 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get { return MetadataCollection.Count; }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, that's what I was thinking - count the number of items but don't actually create the COW dictionary.",
              "createdAt": "2021-11-23T09:36:30Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +972,10 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get { return MetadataCollection.Count; }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Nice! I've pushed an update that does this. Looking at other uses of the `MetadataCollection` property shows that almost none of them require a materialised collection. Most just enumerate. I've got some updates following that, but will save them for a separate PR.",
              "createdAt": "2021-11-24T11:16:28Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +972,10 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get { return MetadataCollection.Count; }",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is the advantage of this code compared to calling `AddRange`? `AddRange` appears to detect `ICollection<T>` and use its `CopyTo` to bulk-add all items so it may be even faster than the array-optimized foreach.\r\nhttps://github.com/dotnet/runtime/blob/77165a096318b30bb380d8c47b00a1c02a541dba/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L738-L766",
              "createdAt": "2021-11-22T10:20:36Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -194,8 +194,20 @@ public ICollection MetadataNames\n         {\n             get\n             {\n-                var metadataNames = new List<string>(_metadata?.Keys ?? Array.Empty<string>());\n-                metadataNames.AddRange(FileUtilities.ItemSpecModifiers.All);\n+                var metadataNames = new List<string>(capacity: MetadataCount);\n+\n+                if (_metadata is not null)\n+                {\n+                    foreach (string key in _metadata.Keys)\n+                    {\n+                        metadataNames.Add(key);\n+                    }\n+                }\n+\n+                foreach (string name in FileUtilities.ItemSpecModifiers.All)\n+                {\n+                    metadataNames.Add(name);\n+                }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thanks, that's a great observation. 4e0ea49e5d5e7fe7c12a4fc01c0323715e678d0e introduces three usages of `AddRange`.",
              "createdAt": "2021-11-24T11:17:48Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -194,8 +194,20 @@ public ICollection MetadataNames\n         {\n             get\n             {\n-                var metadataNames = new List<string>(_metadata?.Keys ?? Array.Empty<string>());\n-                metadataNames.AddRange(FileUtilities.ItemSpecModifiers.All);\n+                var metadataNames = new List<string>(capacity: MetadataCount);\n+\n+                if (_metadata is not null)\n+                {\n+                    foreach (string key in _metadata.Keys)\n+                    {\n+                        metadataNames.Add(key);\n+                    }\n+                }\n+\n+                foreach (string name in FileUtilities.ItemSpecModifiers.All)\n+                {\n+                    metadataNames.Add(name);\n+                }",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Note: this is only really an improvement if MetadataCount is very fast\u2014which it currently might not be.\r\n\r\nAlso, is there some convenient method like:\r\nreturn MetadataCollection.Count.Union(FileUtilities.ItemSpecModifiers.All);\r\n?\r\n\r\n`All` is an array, so I don't think so, but thought I'd check.",
              "createdAt": "2021-11-22T15:21:11Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -929,7 +929,12 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    List<string> names = new List<string>(capacity: MetadataCount);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`MetadataCount` has been updated to be much faster. Please take another look and see if you feel this needs further work.",
              "createdAt": "2021-11-24T11:21:25Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -929,7 +929,12 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    List<string> names = new List<string>(capacity: MetadataCount);",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I said Count but meant Keys.\r\n\r\nreturn MetadataCollection.Keys.Concat(FileUtilities.ItemSpecModifiers.All);\r\n?",
              "createdAt": "2021-11-24T18:10:49Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -929,7 +929,12 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    List<string> names = new List<string>(capacity: MetadataCount);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's possible, though we'd need to convert the `IEnumerable<>` to an `ICollection` . Calling `ToList` or `ToArray` is going to result in potentially multiple redundant allocations, as the resulting collection size is not known from the enumerator produced by `Concat`.\r\n\r\nBy allocating a list up-front with the needed capacity, that overhead is avoided and no waste occurs in the backing arrays.\r\n\r\nIt would be possible to make this allocate one fewer object by using `string[]` directly, rather than `List<string>`.",
              "createdAt": "2021-11-25T01:42:57Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -929,7 +929,12 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    List<string> names = new List<string>(capacity: MetadataCount);",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why bother making these at all?",
              "createdAt": "2021-11-22T15:28:32Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1576,9 +1579,8 @@ public bool Equals(TaskItem other)\n                     return true;\n                 }\n \n-                // Since both sides are this class, we know both sides support ITaskItem2.\n-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;\n-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;\n+                ITaskItem2 thisAsITaskItem2 = this;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The class implements `ITaskItem2` explicitly and explicit interface members can only be accessed via the interface type, even if you're \"in\" the implementing class.",
              "createdAt": "2021-11-23T09:32:43Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1576,9 +1579,8 @@ public bool Equals(TaskItem other)\n                     return true;\n                 }\n \n-                // Since both sides are this class, we know both sides support ITaskItem2.\n-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;\n-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;\n+                ITaskItem2 thisAsITaskItem2 = this;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm looking at this again and wondering if this is right. So it looks like the metadata should never be null\u2014although there is a check like this in MetadataCollection, the `else` condition is just Debug.Fail, which suggests to me that's just an error condition. On the other hand, it uses allMetadata.Set to \"add\" the metadata because \"Front of the list is highest priority,\" which to me suggests there might be duplicate metadata that should not be used. The same applies for the _directMetadata computation below.\r\n\r\nI'm wondering if it might make sense to store the \"current known\" state of metadata separately from any recent changes. That way you could skip most of the work. What do you think?",
              "createdAt": "2021-11-24T18:04:45Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I would have liked to avoid these null checks here, and the enumeration, and just added `Count`, but that would have been a breaking behaviour change. If you are sure there's no negative consequence from breaking that behaviour and overreporting the count when nulls exist, we can change this. I'm not confident that it's safe to do, however.",
              "createdAt": "2021-11-25T01:37:36Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I traced it back _itemDefinitions back for a while and haven't found any way to add a null to it yet, though I didn't go all the way. The other comments about Set potentially _not_ increasing the count was the more pertinent one in my mind\u2014that means this could create incorrect behavior in what seems to be an expected case.",
              "createdAt": "2021-11-25T02:50:09Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Discussion in https://github.com/dotnet/msbuild/issues/5267 suggests that the presence of null values may be due to concurrency issues with a prior implementation that predated the use of immutable collections.",
              "createdAt": "2021-11-25T10:06:07Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "The important problem here is that in the old way for computing CustomMetadataNames, we looped through _itemDefinitions _and_, under that, we looped through individual metadata. Further, there can be duplicates between ProjectItemDefinitionInstances, so just counting how many there are might get you the wrong answer. I can't think of a way to avoid creating at least a set in calculating CustomMetadataCount unless it was already created, which gets back to:\r\n> I'm wondering if it might make sense to store the \"current known\" state of metadata separately from any recent changes. That way you could skip most of the work.\r\n\r\nThe current way this is written will give incorrect metadata counts. We should also add a unit test to verify we don't hit this in the future.",
              "createdAt": "2021-11-29T19:09:37Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's an awesome observation! I'll also note that grepping for `CustomMetadataCount` yields no hits in any relevant .NET or VS related repo and there's only one internal use in `TaskItem.Equals`. So one possible way of addressing may be leaving `CustomMetadataCount` as is and coming up with a better implementation of `Equals`.",
              "createdAt": "2021-11-29T20:48:07Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thank you, that's a good point and invalidates the approach here as it is.\r\n\r\nI've rolled back much of this PR locally, added a test for the previous behaviour, and am taking another look at this.",
              "createdAt": "2021-12-01T21:28:00Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -973,11 +974,41 @@ public ICollection CustomMetadataNames\n             /// <summary>\n             /// Gets the number of custom metadata set on the item.\n             /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n+            /// This is the count of <see cref=\"MetadataCollection\"/>.\n             /// </summary>\n             public int CustomMetadataCount\n             {\n-                get { return CustomMetadataNames.Count; }\n+                get\n+                {\n+                    int count = 0;\n+\n+                    // NOTE we walk collections here and exclude null values from counts to maintain parity\n+                    // with the implementation of CustomMetadata.\n+\n+                    if (_itemDefinitions is not null)\n+                    {\n+                        foreach (ProjectItemDefinitionInstance item in _itemDefinitions)\n+                        {\n+                            if (item.Metadata is not null)",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83e\udd26\ud83c\udffb",
              "createdAt": "2021-12-02T15:10:52Z",
              "path": "src/Build.UnitTests/Instance/TaskItem_Tests.cs",
              "diffHunk": "@@ -59,7 +83,7 @@ public void TestEquivalence()\n             TaskItem right = new TaskItem(\"foo\", \"bar.proj\");\n \n             Assert.Equal(left, right);\n-            Assert.Equal(left, right);\n+            Assert.Equal(right, left);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        /// Validate the presentation of metadata on a TaskItem, both of direct values and those inherited from\r\n```",
              "createdAt": "2021-12-02T15:11:42Z",
              "path": "src/Build.UnitTests/Instance/TaskItem_Tests.cs",
              "diffHunk": "@@ -149,9 +173,66 @@ public void TestDeepClone()\n \n             TaskItem clone = parent.DeepClone();\n             Assert.True(parent.Equals(clone)); // \"The parent and the clone should be equal\"\n+            Assert.True(clone.Equals(parent)); // \"The parent and the clone should be equal\"\n             Assert.False(object.ReferenceEquals(parent, clone)); // \"The parent and the child should not be the same object\"\n         }\n \n+        /// <summary>\n+        /// Validate the presentation of metadata on a TaskItem, but of direct values and those inherited from",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it help to return false here before the loop if the sizes of `thisNames` and `other.MetadataCollection` don't match?",
              "createdAt": "2021-12-03T12:54:28Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1575,23 +1541,42 @@ public bool Equals(TaskItem other)\n                     return true;\n                 }\n \n-                // Since both sides are this class, we know both sides support ITaskItem2.\n-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;\n-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;\n+                ITaskItem2 thisAsITaskItem2 = this;\n+                ITaskItem2 otherAsITaskItem2 = other;\n \n                 // This is case-insensitive. See GetHashCode().\n                 if (!MSBuildNameIgnoreCaseComparer.Default.Equals(thisAsITaskItem2.EvaluatedIncludeEscaped, otherAsITaskItem2.EvaluatedIncludeEscaped))\n                 {\n                     return false;\n                 }\n \n-                if (this.CustomMetadataCount != other.CustomMetadataCount)\n+                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);\n+\n+                if (_itemDefinitions is not null)\n                 {\n-                    return false;\n+                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)\n+                    {\n+                        thisNames.UnionWith(itemDefinition.MetadataNames);\n+                    }\n+                }\n+\n+                if (_directMetadata is not null)\n+                {\n+                    foreach (ProjectMetadataInstance metadatum in _directMetadata)\n+                    {\n+                        thisNames.Add(metadatum.Name);\n+                    }\n                 }\n \n-                foreach (string name in this.CustomMetadataNames)\n+                foreach (ProjectMetadataInstance metadatum in other.MetadataCollection)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Nice! Added.",
              "createdAt": "2021-12-07T01:31:50Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1575,23 +1541,42 @@ public bool Equals(TaskItem other)\n                     return true;\n                 }\n \n-                // Since both sides are this class, we know both sides support ITaskItem2.\n-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;\n-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;\n+                ITaskItem2 thisAsITaskItem2 = this;\n+                ITaskItem2 otherAsITaskItem2 = other;\n \n                 // This is case-insensitive. See GetHashCode().\n                 if (!MSBuildNameIgnoreCaseComparer.Default.Equals(thisAsITaskItem2.EvaluatedIncludeEscaped, otherAsITaskItem2.EvaluatedIncludeEscaped))\n                 {\n                     return false;\n                 }\n \n-                if (this.CustomMetadataCount != other.CustomMetadataCount)\n+                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);\n+\n+                if (_itemDefinitions is not null)\n                 {\n-                    return false;\n+                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)\n+                    {\n+                        thisNames.UnionWith(itemDefinition.MetadataNames);\n+                    }\n+                }\n+\n+                if (_directMetadata is not null)\n+                {\n+                    foreach (ProjectMetadataInstance metadatum in _directMetadata)\n+                    {\n+                        thisNames.Add(metadatum.Name);\n+                    }\n                 }\n \n-                foreach (string name in this.CustomMetadataNames)\n+                foreach (ProjectMetadataInstance metadatum in other.MetadataCollection)",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    names.AddRange(metadataCollection.Keys);\r\n```\r\n\r\n?",
              "createdAt": "2021-12-03T15:47:27Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -928,13 +921,17 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;\n+\n+                    List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);\n \n-                    foreach (string name in FileUtilities.ItemSpecModifiers.All)\n+                    foreach (ProjectMetadataInstance metadatum in metadataCollection)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "(If the Keys method doesn't create a new object.)",
              "createdAt": "2021-12-06T16:31:39Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -928,13 +921,17 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;\n+\n+                    List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);\n \n-                    foreach (string name in FileUtilities.ItemSpecModifiers.All)\n+                    foreach (ProjectMetadataInstance metadatum in metadataCollection)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`Keys` is an `ICollection` so it must allocate linear storage. The underlying structure is an immutable dictionary, which is a tree. Enumerating it will be more efficient.",
              "createdAt": "2021-12-07T01:34:58Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -928,13 +921,17 @@ public ICollection MetadataNames\n             {\n                 get\n                 {\n-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);\n+                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;\n+\n+                    List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);\n \n-                    foreach (string name in FileUtilities.ItemSpecModifiers.All)\n+                    foreach (ProjectMetadataInstance metadatum in metadataCollection)",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't this public API surface?",
              "createdAt": "2021-12-03T15:48:55Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -948,37 +945,6 @@ public int MetadataCount\n                 get { return MetadataNames.Count; }\n             }\n \n-            /// <summary>\n-            /// Gets the names of custom metadata on the item.\n-            /// If there is none, returns an empty collection.\n-            /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n-            /// </summary>\n-            public ICollection CustomMetadataNames",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "(I was wrong)",
              "createdAt": "2021-12-06T16:28:24Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -948,37 +945,6 @@ public int MetadataCount\n                 get { return MetadataNames.Count; }\n             }\n \n-            /// <summary>\n-            /// Gets the names of custom metadata on the item.\n-            /// If there is none, returns an empty collection.\n-            /// Does not include built-in metadata.\n-            /// Computed, not necessarily fast.\n-            /// </summary>\n-            public ICollection CustomMetadataNames",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe add a comment that if this were values and not just names, you should be overwriting?\r\n\r\nThe only case I can think of when that would be relevant is if we had a bug where we used the case-sensitive string as a key into some dictionary instead of the case-insensitive string, in which case we might not find the right metadatum. (To be clear, I don't think we should be overly worried about that, but I think it may be worth a comment.)",
              "createdAt": "2021-12-03T15:55:52Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1575,23 +1541,42 @@ public bool Equals(TaskItem other)\n                     return true;\n                 }\n \n-                // Since both sides are this class, we know both sides support ITaskItem2.\n-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;\n-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;\n+                ITaskItem2 thisAsITaskItem2 = this;\n+                ITaskItem2 otherAsITaskItem2 = other;\n \n                 // This is case-insensitive. See GetHashCode().\n                 if (!MSBuildNameIgnoreCaseComparer.Default.Equals(thisAsITaskItem2.EvaluatedIncludeEscaped, otherAsITaskItem2.EvaluatedIncludeEscaped))\n                 {\n                     return false;\n                 }\n \n-                if (this.CustomMetadataCount != other.CustomMetadataCount)\n+                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);\n+\n+                if (_itemDefinitions is not null)\n                 {\n-                    return false;\n+                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)\n+                    {\n+                        thisNames.UnionWith(itemDefinition.MetadataNames);\n+                    }\n+                }\n+\n+                if (_directMetadata is not null)\n+                {\n+                    foreach (ProjectMetadataInstance metadatum in _directMetadata)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}