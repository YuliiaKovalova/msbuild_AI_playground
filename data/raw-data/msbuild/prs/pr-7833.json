{
  "number": 7833,
  "title": "Refactor ProjectCacheService and fix various issues",
  "body": "This is a substantial refactor in the ProjectCacheService.\r\n\r\nThe primary motivation is to be more permissive with the plugins which are configured. Each project configures its plugins via an item, however today it's enforced that every project has exactly the same single plugin. This refactor relaxes that requirement such that each project may configure 0 to N plugins, and there is no requirement for any projects' configuration to match.\r\n\r\nTo accomplish this, many parts had to be rewritten (and honestly, simplified).\r\n\r\nThe biggest change is to how plugins are initialized and disposed of. Previously, the initialization would happen up front for graph builds and on-demand as a \"VS Workaround\" in the VS scenario. The disposal would also happen as part of the build itself once the core part of the build was done. With these changes, because we may not know all plugins which will be used in a build session, each plugin is initialized on demand as soon as it's discovered. Initialization is mostly the same, however each plugin is initialized in the background concurrently. The `ProjectCacheService` keeps track of all plugins used and disposes of them when the `BuildManager` is torn down. This means exceptions during plugin shutdown don't get seen in the build result but instead raised as an exception from the `BuildManager`.\r\n\r\nIn general I've also tried to reduce the \"VS Workaround\" code as much as possible, although there is still a pretty big hack in `Evaluator` which makes me die a little inside.",
  "state": "MERGED",
  "createdAt": "2022-07-16T05:01:44Z",
  "updatedAt": "2022-08-12T18:17:41Z",
  "closedAt": "2022-08-12T07:52:35Z",
  "mergedAt": "2022-08-12T07:52:35Z",
  "additions": 653,
  "deletions": 1226,
  "changedFiles": 25,
  "headRefName": "projectcacheservice-refactor",
  "isDraft": false,
  "author": {
    "login": "dfederm"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "97e5f80ce0dcc61386903452c1204f4609ad376a",
          "message": "Refactor ProjectCacheService",
          "committedDate": "2022-07-16T04:47:26Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "585b43ff342dbf99748a95ffcde377c082bc3750",
          "message": "Avoid unnecessary evaluations in the VS scenario",
          "committedDate": "2022-07-16T06:23:44Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92f2a35d3ca4019887d8c1d5545393ad177333ed",
          "message": "PR comments",
          "committedDate": "2022-07-21T15:59:42Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb5e75373208c78bc13a8eddcbadc914ec71a6ff",
          "message": "Update src/Build/Evaluation/Evaluator.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2022-08-09T15:09:55Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "285b27933fb6035e0ba4b7fd70ca3371cbdeba26",
          "message": "Update src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2022-08-09T15:10:18Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "751dc60a27b08a348739356ad1ec9a7c3776095c",
          "message": "PR comments",
          "committedDate": "2022-08-09T15:18:23Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88763de20ca9dac455a01e277381d8e0c3db98a6",
          "message": "Update src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2022-08-09T17:01:36Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "If this only builds on .NET Core it can use https://docs.microsoft.com/en-us/dotnet/api/system.hashcode.combine?view=net-6.0\n",
              "createdAt": "2022-07-16T05:29:21Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>\n+    {\n+        private ProjectCacheDescriptorEqualityComparer()\n+        {\n+        }\n+\n+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();\n+\n+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)\n+        {\n+            if (ReferenceEquals(x, y))\n+            {\n+                return true;\n+            }\n+\n+            if (x is null || y is null)\n+            {\n+                return false;\n+            }\n+\n+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)\n+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)\n+                && CollectionHelpers.DictionaryEquals(x.PluginSettings, y.PluginSettings);\n+        }\n+\n+        public int GetHashCode(ProjectCacheDescriptor obj)\n+        {\n+            int hashCode = -1043047289;\n+\n+            if (obj.PluginAssemblyPath != null)\n+            {\n+                hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(obj.PluginAssemblyPath);\n+            }\n+\n+            if (obj.PluginInstance != null)\n+            {\n+                hashCode = (hashCode * -1521134295) + obj.PluginInstance.GetHashCode();\n+            }\n+\n+            if (obj.PluginSettings.Count > 0)\n+            {\n+                foreach (var pluginSetting in obj.PluginSettings.OrderBy(_ => _.Key))\n+                {\n+                    hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "It does not unfortunately",
              "createdAt": "2022-07-16T05:30:21Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>\n+    {\n+        private ProjectCacheDescriptorEqualityComparer()\n+        {\n+        }\n+\n+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();\n+\n+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)\n+        {\n+            if (ReferenceEquals(x, y))\n+            {\n+                return true;\n+            }\n+\n+            if (x is null || y is null)\n+            {\n+                return false;\n+            }\n+\n+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)\n+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)\n+                && CollectionHelpers.DictionaryEquals(x.PluginSettings, y.PluginSettings);\n+        }\n+\n+        public int GetHashCode(ProjectCacheDescriptor obj)\n+        {\n+            int hashCode = -1043047289;\n+\n+            if (obj.PluginAssemblyPath != null)\n+            {\n+                hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(obj.PluginAssemblyPath);\n+            }\n+\n+            if (obj.PluginInstance != null)\n+            {\n+                hashCode = (hashCode * -1521134295) + obj.PluginInstance.GetHashCode();\n+            }\n+\n+            if (obj.PluginSettings.Count > 0)\n+            {\n+                foreach (var pluginSetting in obj.PluginSettings.OrderBy(_ => _.Key))\n+                {\n+                    hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Curious about the relative performance of `new Dictionary<string, string>(0)` and ImmutableDictionary.Empty<string, string>();",
              "createdAt": "2022-07-19T18:29:18Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs",
              "diffHunk": "@@ -2,130 +2,34 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using System.Collections.Generic;\n-using System.Linq;\n-using Microsoft.Build.Graph;\n-using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     public class ProjectCacheDescriptor\n     {\n-        /// <summary>\n-        ///     The path to the assembly containing the project cache plugin.\n-        /// </summary>\n-        public string? PluginAssemblyPath { get; }\n-\n-        /// <summary>\n-        ///     The entry points with which the plugin will be initialized.\n-        /// </summary>\n-        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }\n-\n-        /// <summary>\n-        ///     The graph with which the plugin will be initialized.\n-        /// </summary>\n-        public ProjectGraph? ProjectGraph { get; }\n-\n-        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n-\n-        public ProjectCachePluginBase? PluginInstance { get; }\n-\n-        internal bool VsWorkaround { get; }\n-\n         private ProjectCacheDescriptor(\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings)\n-        {\n-            ErrorUtilities.VerifyThrowArgument(\n-                (entryPoints == null) ^ (projectGraph == null),\n-                \"EitherEntryPointsOrTheProjectGraphIsSet\");\n-\n-            EntryPoints = entryPoints;\n-            ProjectGraph = projectGraph;\n-            PluginSettings = pluginSettings ?? new Dictionary<string, string>();\n-        }\n-\n-        private ProjectCacheDescriptor(\n-            string pluginAssemblyPath,\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)\n+            string? pluginAssemblyPath,\n+            IReadOnlyDictionary<string, string>? pluginSettings,\n+            ProjectCachePluginBase? pluginInstance)\n         {\n             PluginAssemblyPath = pluginAssemblyPath;\n-        }\n-\n-        private ProjectCacheDescriptor(\n-            ProjectCachePluginBase pluginInstance,\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)\n-        {\n+            PluginSettings = pluginSettings ?? new Dictionary<string, string>(0);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`ImmutableDictionary.Empty<string, string>()` doesn't seem to exist.\r\n\r\nI could try to stash a static empty dictionary to use here, but all callers within MSBuild provide the value anyway so it'd only be external callers who would provide `null`, so I'm not sure it's worth it.",
              "createdAt": "2022-07-21T15:41:00Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs",
              "diffHunk": "@@ -2,130 +2,34 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using System.Collections.Generic;\n-using System.Linq;\n-using Microsoft.Build.Graph;\n-using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     public class ProjectCacheDescriptor\n     {\n-        /// <summary>\n-        ///     The path to the assembly containing the project cache plugin.\n-        /// </summary>\n-        public string? PluginAssemblyPath { get; }\n-\n-        /// <summary>\n-        ///     The entry points with which the plugin will be initialized.\n-        /// </summary>\n-        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }\n-\n-        /// <summary>\n-        ///     The graph with which the plugin will be initialized.\n-        /// </summary>\n-        public ProjectGraph? ProjectGraph { get; }\n-\n-        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n-\n-        public ProjectCachePluginBase? PluginInstance { get; }\n-\n-        internal bool VsWorkaround { get; }\n-\n         private ProjectCacheDescriptor(\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings)\n-        {\n-            ErrorUtilities.VerifyThrowArgument(\n-                (entryPoints == null) ^ (projectGraph == null),\n-                \"EitherEntryPointsOrTheProjectGraphIsSet\");\n-\n-            EntryPoints = entryPoints;\n-            ProjectGraph = projectGraph;\n-            PluginSettings = pluginSettings ?? new Dictionary<string, string>();\n-        }\n-\n-        private ProjectCacheDescriptor(\n-            string pluginAssemblyPath,\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)\n+            string? pluginAssemblyPath,\n+            IReadOnlyDictionary<string, string>? pluginSettings,\n+            ProjectCachePluginBase? pluginInstance)\n         {\n             PluginAssemblyPath = pluginAssemblyPath;\n-        }\n-\n-        private ProjectCacheDescriptor(\n-            ProjectCachePluginBase pluginInstance,\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)\n-        {\n+            PluginSettings = pluginSettings ?? new Dictionary<string, string>(0);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Looks like it's a net60 concept:\r\nhttps://docs.microsoft.com/dotnet/api/system.collections.immutable.immutabledictionary-2.empty?view=net-6.0&viewFallbackFrom=netframework-4.7.2\r\n\r\nYeah; wouldn't worry about it.",
              "createdAt": "2022-08-08T23:31:52Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs",
              "diffHunk": "@@ -2,130 +2,34 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using System.Collections.Generic;\n-using System.Linq;\n-using Microsoft.Build.Graph;\n-using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     public class ProjectCacheDescriptor\n     {\n-        /// <summary>\n-        ///     The path to the assembly containing the project cache plugin.\n-        /// </summary>\n-        public string? PluginAssemblyPath { get; }\n-\n-        /// <summary>\n-        ///     The entry points with which the plugin will be initialized.\n-        /// </summary>\n-        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }\n-\n-        /// <summary>\n-        ///     The graph with which the plugin will be initialized.\n-        /// </summary>\n-        public ProjectGraph? ProjectGraph { get; }\n-\n-        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n-\n-        public ProjectCachePluginBase? PluginInstance { get; }\n-\n-        internal bool VsWorkaround { get; }\n-\n         private ProjectCacheDescriptor(\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings)\n-        {\n-            ErrorUtilities.VerifyThrowArgument(\n-                (entryPoints == null) ^ (projectGraph == null),\n-                \"EitherEntryPointsOrTheProjectGraphIsSet\");\n-\n-            EntryPoints = entryPoints;\n-            ProjectGraph = projectGraph;\n-            PluginSettings = pluginSettings ?? new Dictionary<string, string>();\n-        }\n-\n-        private ProjectCacheDescriptor(\n-            string pluginAssemblyPath,\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)\n+            string? pluginAssemblyPath,\n+            IReadOnlyDictionary<string, string>? pluginSettings,\n+            ProjectCachePluginBase? pluginInstance)\n         {\n             PluginAssemblyPath = pluginAssemblyPath;\n-        }\n-\n-        private ProjectCacheDescriptor(\n-            ProjectCachePluginBase pluginInstance,\n-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n-            ProjectGraph? projectGraph,\n-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)\n-        {\n+            PluginSettings = pluginSettings ?? new Dictionary<string, string>(0);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are these both necessary? They sound to me like they're checking the same thing.",
              "createdAt": "2022-07-19T21:53:03Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>\n+    {\n+        private ProjectCacheDescriptorEqualityComparer()\n+        {\n+        }\n+\n+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();\n+\n+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)\n+        {\n+            if (ReferenceEquals(x, y))\n+            {\n+                return true;\n+            }\n+\n+            if (x is null || y is null)\n+            {\n+                return false;\n+            }\n+\n+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)\n+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, as they're mutually exclusive. A `ProjectCacheDescriptor` is created with either an assembly path or an instance.",
              "createdAt": "2022-07-21T15:38:08Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>\n+    {\n+        private ProjectCacheDescriptorEqualityComparer()\n+        {\n+        }\n+\n+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();\n+\n+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)\n+        {\n+            if (ReferenceEquals(x, y))\n+            {\n+                return true;\n+            }\n+\n+            if (x is null || y is null)\n+            {\n+                return false;\n+            }\n+\n+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)\n+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this more efficient than the ToDictionary method? I would've imagined that's easier to optimize.",
              "createdAt": "2022-07-19T21:55:53Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -822,13 +822,17 @@ private void CollectProjectCachePlugins()\n         {\n             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))\n             {\n-                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);\n+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(_data.Directory, item.EvaluatedInclude));\n \n-                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);\n+                var pluginSettings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'll use `ToDIctionary`. In general I try to avoid Linq though since it's pretty inefficient. In this case I was attempting to avoid resizing by providing a capacity, but `Metadata` ended up being an `IEnumerable` anyway, so no `Count` to use :(",
              "createdAt": "2022-07-21T15:31:40Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -822,13 +822,17 @@ private void CollectProjectCachePlugins()\n         {\n             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))\n             {\n-                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);\n+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(_data.Directory, item.EvaluatedInclude));\n \n-                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);\n+                var pluginSettings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wondering if we should move these changed things back to Unshipped? Not sure.",
              "createdAt": "2022-07-19T21:56:31Z",
              "path": "src/Build/PublicAPI/net/PublicAPI.Shipped.txt",
              "diffHunk": "@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I defer to you on this. I don't really know what the distinction is :)",
              "createdAt": "2022-07-21T15:34:58Z",
              "path": "src/Build/PublicAPI/net/PublicAPI.Shipped.txt",
              "diffHunk": "@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "\"Unshipped\" means we first introduced it in this version (i.e., 17.4p1), and we haven't hit a final version yet. Shipped means it won't change in the future. This is special, though, because it's \"Experimental\", which means we can change it even though it shipped, so I don't know which is more appropriate.",
              "createdAt": "2022-08-08T23:33:21Z",
              "path": "src/Build/PublicAPI/net/PublicAPI.Shipped.txt",
              "diffHunk": "@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I agree and landed on \"meh, it's already done this way so let's leave it.\"",
              "createdAt": "2022-08-09T13:38:36Z",
              "path": "src/Build/PublicAPI/net/PublicAPI.Shipped.txt",
              "diffHunk": "@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor\n+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why white space changes?",
              "createdAt": "2022-07-19T21:56:52Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1,17 +1,17 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <root>\n-  <!--\n-    Microsoft ResX Schema\n-\n+  <!-- \n+    Microsoft ResX Schema \n+    ",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "VS probably did it. I'll hand-edit it back",
              "createdAt": "2022-07-21T15:35:23Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1,17 +1,17 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <root>\n-  <!--\n-    Microsoft ResX Schema\n-\n+  <!-- \n+    Microsoft ResX Schema \n+    ",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this better not async?",
              "createdAt": "2022-07-19T21:58:26Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -2059,20 +2059,25 @@ internal class BuildManagerSession : IDisposable\n                 return buildTask.Result;\n             }\n \n-            public async Task<BuildResult> BuildProjectFileAsync(\n+            public Task<BuildResult> BuildProjectFileAsync(",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It returns the task directly. However, it is generally best practice to `async`/`await` anyway as it's a very minimal perf improvement and this is a UT anyway.",
              "createdAt": "2022-07-21T15:42:41Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -2059,20 +2059,25 @@ internal class BuildManagerSession : IDisposable\n                 return buildTask.Result;\n             }\n \n-            public async Task<BuildResult> BuildProjectFileAsync(\n+            public Task<BuildResult> BuildProjectFileAsync(",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The `OrderBy` could maybe be avoided here by computing a hash per setting, XORing them (which is commutative/order-independent), then combining that into the outer hash. That'd avoid some allocations and time complexity.",
              "createdAt": "2022-07-21T00:12:25Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>\n+    {\n+        private ProjectCacheDescriptorEqualityComparer()\n+        {\n+        }\n+\n+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();\n+\n+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)\n+        {\n+            if (ReferenceEquals(x, y))\n+            {\n+                return true;\n+            }\n+\n+            if (x is null || y is null)\n+            {\n+                return false;\n+            }\n+\n+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)\n+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)\n+                && CollectionHelpers.DictionaryEquals(x.PluginSettings, y.PluginSettings);\n+        }\n+\n+        public int GetHashCode(ProjectCacheDescriptor obj)\n+        {\n+            int hashCode = -1043047289;\n+\n+            if (obj.PluginAssemblyPath != null)\n+            {\n+                hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(obj.PluginAssemblyPath);\n+            }\n+\n+            if (obj.PluginInstance != null)\n+            {\n+                hashCode = (hashCode * -1521134295) + obj.PluginInstance.GetHashCode();\n+            }\n+\n+            if (obj.PluginSettings.Count > 0)\n+            {\n+                foreach (var pluginSetting in obj.PluginSettings.OrderBy(_ => _.Key))",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n\r\n```suggestion\r\n                string pluginPath = FileUtilities.NormalizePath(_data.Directory, item.EvaluatedInclude);\r\n```",
              "createdAt": "2022-08-09T13:40:48Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -822,13 +822,10 @@ private void CollectProjectCachePlugins()\n         {\n             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))\n             {\n-                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);\n-\n-                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);\n-\n-                var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n-\n-                BuildManager.ProjectCacheItems[pluginPath] = projectCacheItem;\n+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(_data.Directory, item.EvaluatedInclude));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public void NotAllNodesDefineAPlugin()\r\n```",
              "createdAt": "2022-08-09T13:45:37Z",
              "path": "src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs",
              "diffHunk": "@@ -1093,23 +1030,29 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()\n                 },\n                 extraContentForAllNodes: @$\"\n <ItemGroup>\n-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />\n+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />\n </ItemGroup>\n \");\n+            var mockCache = new InstanceMockCache();\n+\n+            var buildParameters =  new BuildParameters\n+            {\n+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache),\n+            };\n \n             MockLogger logger;\n             GraphBuildResult graphResult;\n-            using (var buildSession = new Helpers.BuildManagerSession(_env))\n+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))\n             {\n                 logger = buildSession.Logger;\n                 graphResult = buildSession.BuildGraph(graph);\n             }\n             \n-            graphResult.ShouldHaveFailed(\"A single project cache plugin must be specified but multiple where found:\");\n+            graphResult.ShouldHaveSucceeded();\n         }\n \n         [Fact]\n-        public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()\n+        public void NotAllNodeDefineAPlugin()",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add \"... because [justification]\" please",
              "createdAt": "2022-08-09T13:51:03Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -18,148 +21,210 @@\n using Microsoft.Build.Graph;\n using Microsoft.Build.Internal;\n using Microsoft.Build.Shared;\n-using Microsoft.Build.Shared.FileSystem;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);\n \n-    internal record NullableBool(bool Value)\n+    internal sealed class ProjectCacheService : IAsyncDisposable\n     {\n-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;\n-    }\n+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };\n \n-    internal enum ProjectCacheServiceState\n-    {\n-        NotInitialized,\n-        BeginBuildStarted,\n-        BeginBuildFinished,\n-        ShutdownStarted,\n-        ShutdownFinished\n-    }\n+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { \"TargetFramework\", \"Configuration\", \"Platform\", \"TargetPlatform\", \"OutputType\" };\n \n-    internal class ProjectCacheService\n-    {\n         private readonly BuildManager _buildManager;\n         private readonly ILoggingService _loggingService;\n-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n-        private readonly CancellationToken _cancellationToken;\n-        private readonly ProjectCachePluginBase _projectCachePlugin;\n-        private readonly string _projectCachePluginTypeName;\n-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;\n+\n+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;\n+\n+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);\n+\n+        private bool _isVsScenario;\n+\n+        private bool _isDisposed;\n+\n+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);\n \n         /// <summary>\n         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,\n         /// i.e. falling back to FileSystem.Default.\n         /// </summary>\n-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }\n-\n-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).\n-        // Assume that if one request is a design time build, all of them are.\n-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.\n-        // TODO: remove after we change VS to set the cache descriptor via build parameters.\n-        public volatile NullableBool? DesignTimeBuildsDetected;\n-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;\n-\n-        private ProjectCacheService(\n-            ProjectCachePluginBase projectCachePlugin,\n-            string pluginTypeName,\n+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase\n+        {\n+            private DefaultMSBuildFileSystem()\n+            {\n+            }\n+\n+            public static DefaultMSBuildFileSystem Instance { get; } = new();\n+        }\n+\n+        public ProjectCacheService(\n             BuildManager buildManager,\n             ILoggingService loggingService,\n-            ProjectCacheDescriptor projectCacheDescriptor,\n-            CancellationToken cancellationToken\n-        )\n+            ProjectCacheDescriptor? globalProjectCacheDescriptor)\n         {\n-            _projectCachePlugin = projectCachePlugin;\n-            _projectCachePluginTypeName = pluginTypeName;\n             _buildManager = buildManager;\n             _loggingService = loggingService;\n-            _projectCacheDescriptor = projectCacheDescriptor;\n-            _cancellationToken = cancellationToken;\n+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;\n         }\n \n-        public static async Task<ProjectCacheService> FromDescriptorAsync(\n-            ProjectCacheDescriptor pluginDescriptor,\n-            BuildManager buildManager,\n-            ILoggingService loggingService,\n+        /// <summary>\n+        /// Optimization which frontloads plugin initialization since we have an entire graph.\n+        /// </summary>\n+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)\n+        {\n+            EnsureNotDisposed();\n+\n+            Parallel.ForEach(\n+                projectGraph.ProjectNodes,\n+                s_parallelOptions,\n+                node =>\n+                {\n+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))\n+                    {\n+                        // Intentionally fire-and-forget",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand the `Lazy` here, since you're calling `Value` immediately what does it provide?",
              "createdAt": "2022-08-09T13:52:43Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -18,148 +21,210 @@\n using Microsoft.Build.Graph;\n using Microsoft.Build.Internal;\n using Microsoft.Build.Shared;\n-using Microsoft.Build.Shared.FileSystem;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);\n \n-    internal record NullableBool(bool Value)\n+    internal sealed class ProjectCacheService : IAsyncDisposable\n     {\n-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;\n-    }\n+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };\n \n-    internal enum ProjectCacheServiceState\n-    {\n-        NotInitialized,\n-        BeginBuildStarted,\n-        BeginBuildFinished,\n-        ShutdownStarted,\n-        ShutdownFinished\n-    }\n+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { \"TargetFramework\", \"Configuration\", \"Platform\", \"TargetPlatform\", \"OutputType\" };\n \n-    internal class ProjectCacheService\n-    {\n         private readonly BuildManager _buildManager;\n         private readonly ILoggingService _loggingService;\n-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n-        private readonly CancellationToken _cancellationToken;\n-        private readonly ProjectCachePluginBase _projectCachePlugin;\n-        private readonly string _projectCachePluginTypeName;\n-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;\n+\n+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;\n+\n+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);\n+\n+        private bool _isVsScenario;\n+\n+        private bool _isDisposed;\n+\n+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);\n \n         /// <summary>\n         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,\n         /// i.e. falling back to FileSystem.Default.\n         /// </summary>\n-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }\n-\n-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).\n-        // Assume that if one request is a design time build, all of them are.\n-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.\n-        // TODO: remove after we change VS to set the cache descriptor via build parameters.\n-        public volatile NullableBool? DesignTimeBuildsDetected;\n-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;\n-\n-        private ProjectCacheService(\n-            ProjectCachePluginBase projectCachePlugin,\n-            string pluginTypeName,\n+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase\n+        {\n+            private DefaultMSBuildFileSystem()\n+            {\n+            }\n+\n+            public static DefaultMSBuildFileSystem Instance { get; } = new();\n+        }\n+\n+        public ProjectCacheService(\n             BuildManager buildManager,\n             ILoggingService loggingService,\n-            ProjectCacheDescriptor projectCacheDescriptor,\n-            CancellationToken cancellationToken\n-        )\n+            ProjectCacheDescriptor? globalProjectCacheDescriptor)\n         {\n-            _projectCachePlugin = projectCachePlugin;\n-            _projectCachePluginTypeName = pluginTypeName;\n             _buildManager = buildManager;\n             _loggingService = loggingService;\n-            _projectCacheDescriptor = projectCacheDescriptor;\n-            _cancellationToken = cancellationToken;\n+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;\n         }\n \n-        public static async Task<ProjectCacheService> FromDescriptorAsync(\n-            ProjectCacheDescriptor pluginDescriptor,\n-            BuildManager buildManager,\n-            ILoggingService loggingService,\n+        /// <summary>\n+        /// Optimization which frontloads plugin initialization since we have an entire graph.\n+        /// </summary>\n+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)\n+        {\n+            EnsureNotDisposed();\n+\n+            Parallel.ForEach(\n+                projectGraph.ProjectNodes,\n+                s_parallelOptions,\n+                node =>\n+                {\n+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))\n+                    {\n+                        // Intentionally fire-and-forget\n+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)\n+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                    }\n+                });\n+        }\n+\n+        public void InitializePluginsForVsScenario(\n+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,\n+            BuildRequestConfiguration buildRequestConfiguration,\n             CancellationToken cancellationToken)\n         {\n-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)\n-                .ConfigureAwait(false);\n+            EnsureNotDisposed();\n+\n+            _isVsScenario = true;\n+\n+            // Bail out for design-time builds\n+            if (IsDesignTimeBuild(buildRequestConfiguration))\n+            {\n+                return;\n+            }\n+\n+            Parallel.ForEach(\n+                projectCacheDescriptors,\n+                s_parallelOptions,\n+                projectCacheDescriptor =>\n+                {\n+                    // Intentionally fire-and-forget\n+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)\n+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                });\n+        }\n \n-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);\n+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            ProjectGraph? projectGraph,\n+            BuildRequestConfiguration? buildRequestConfiguration,\n+            CancellationToken cancellationToken)\n+            => _projectCachePlugins.GetOrAdd(\n+                projectCacheDescriptor,\n+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken))).Value;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'll add a comment.\r\n\r\nThe idea though is that `ConcurrentDictionary` doesn't guarantee that the value factories are only called exactly once; it only guarantees that only one value makes it into the dictionary. So the use of `Lazy` here is to ensure that in the race condition where multiple `GetOrAdd`s happen at the same time, only one will actually execute (2 Lazies may be created, but only 1 will ever run).",
              "createdAt": "2022-08-09T15:12:30Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -18,148 +21,210 @@\n using Microsoft.Build.Graph;\n using Microsoft.Build.Internal;\n using Microsoft.Build.Shared;\n-using Microsoft.Build.Shared.FileSystem;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);\n \n-    internal record NullableBool(bool Value)\n+    internal sealed class ProjectCacheService : IAsyncDisposable\n     {\n-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;\n-    }\n+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };\n \n-    internal enum ProjectCacheServiceState\n-    {\n-        NotInitialized,\n-        BeginBuildStarted,\n-        BeginBuildFinished,\n-        ShutdownStarted,\n-        ShutdownFinished\n-    }\n+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { \"TargetFramework\", \"Configuration\", \"Platform\", \"TargetPlatform\", \"OutputType\" };\n \n-    internal class ProjectCacheService\n-    {\n         private readonly BuildManager _buildManager;\n         private readonly ILoggingService _loggingService;\n-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n-        private readonly CancellationToken _cancellationToken;\n-        private readonly ProjectCachePluginBase _projectCachePlugin;\n-        private readonly string _projectCachePluginTypeName;\n-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;\n+\n+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;\n+\n+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);\n+\n+        private bool _isVsScenario;\n+\n+        private bool _isDisposed;\n+\n+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);\n \n         /// <summary>\n         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,\n         /// i.e. falling back to FileSystem.Default.\n         /// </summary>\n-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }\n-\n-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).\n-        // Assume that if one request is a design time build, all of them are.\n-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.\n-        // TODO: remove after we change VS to set the cache descriptor via build parameters.\n-        public volatile NullableBool? DesignTimeBuildsDetected;\n-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;\n-\n-        private ProjectCacheService(\n-            ProjectCachePluginBase projectCachePlugin,\n-            string pluginTypeName,\n+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase\n+        {\n+            private DefaultMSBuildFileSystem()\n+            {\n+            }\n+\n+            public static DefaultMSBuildFileSystem Instance { get; } = new();\n+        }\n+\n+        public ProjectCacheService(\n             BuildManager buildManager,\n             ILoggingService loggingService,\n-            ProjectCacheDescriptor projectCacheDescriptor,\n-            CancellationToken cancellationToken\n-        )\n+            ProjectCacheDescriptor? globalProjectCacheDescriptor)\n         {\n-            _projectCachePlugin = projectCachePlugin;\n-            _projectCachePluginTypeName = pluginTypeName;\n             _buildManager = buildManager;\n             _loggingService = loggingService;\n-            _projectCacheDescriptor = projectCacheDescriptor;\n-            _cancellationToken = cancellationToken;\n+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;\n         }\n \n-        public static async Task<ProjectCacheService> FromDescriptorAsync(\n-            ProjectCacheDescriptor pluginDescriptor,\n-            BuildManager buildManager,\n-            ILoggingService loggingService,\n+        /// <summary>\n+        /// Optimization which frontloads plugin initialization since we have an entire graph.\n+        /// </summary>\n+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)\n+        {\n+            EnsureNotDisposed();\n+\n+            Parallel.ForEach(\n+                projectGraph.ProjectNodes,\n+                s_parallelOptions,\n+                node =>\n+                {\n+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))\n+                    {\n+                        // Intentionally fire-and-forget\n+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)\n+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                    }\n+                });\n+        }\n+\n+        public void InitializePluginsForVsScenario(\n+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,\n+            BuildRequestConfiguration buildRequestConfiguration,\n             CancellationToken cancellationToken)\n         {\n-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)\n-                .ConfigureAwait(false);\n+            EnsureNotDisposed();\n+\n+            _isVsScenario = true;\n+\n+            // Bail out for design-time builds\n+            if (IsDesignTimeBuild(buildRequestConfiguration))\n+            {\n+                return;\n+            }\n+\n+            Parallel.ForEach(\n+                projectCacheDescriptors,\n+                s_parallelOptions,\n+                projectCacheDescriptor =>\n+                {\n+                    // Intentionally fire-and-forget\n+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)\n+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                });\n+        }\n \n-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);\n+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            ProjectGraph? projectGraph,\n+            BuildRequestConfiguration? buildRequestConfiguration,\n+            CancellationToken cancellationToken)\n+            => _projectCachePlugins.GetOrAdd(\n+                projectCacheDescriptor,\n+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken))).Value;",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "To achieve that don't you need to to store the `Lazy` and move the `.Value` to the accessing sites?",
              "createdAt": "2022-08-09T15:45:25Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -18,148 +21,210 @@\n using Microsoft.Build.Graph;\n using Microsoft.Build.Internal;\n using Microsoft.Build.Shared;\n-using Microsoft.Build.Shared.FileSystem;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);\n \n-    internal record NullableBool(bool Value)\n+    internal sealed class ProjectCacheService : IAsyncDisposable\n     {\n-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;\n-    }\n+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };\n \n-    internal enum ProjectCacheServiceState\n-    {\n-        NotInitialized,\n-        BeginBuildStarted,\n-        BeginBuildFinished,\n-        ShutdownStarted,\n-        ShutdownFinished\n-    }\n+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { \"TargetFramework\", \"Configuration\", \"Platform\", \"TargetPlatform\", \"OutputType\" };\n \n-    internal class ProjectCacheService\n-    {\n         private readonly BuildManager _buildManager;\n         private readonly ILoggingService _loggingService;\n-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n-        private readonly CancellationToken _cancellationToken;\n-        private readonly ProjectCachePluginBase _projectCachePlugin;\n-        private readonly string _projectCachePluginTypeName;\n-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;\n+\n+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;\n+\n+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);\n+\n+        private bool _isVsScenario;\n+\n+        private bool _isDisposed;\n+\n+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);\n \n         /// <summary>\n         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,\n         /// i.e. falling back to FileSystem.Default.\n         /// </summary>\n-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }\n-\n-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).\n-        // Assume that if one request is a design time build, all of them are.\n-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.\n-        // TODO: remove after we change VS to set the cache descriptor via build parameters.\n-        public volatile NullableBool? DesignTimeBuildsDetected;\n-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;\n-\n-        private ProjectCacheService(\n-            ProjectCachePluginBase projectCachePlugin,\n-            string pluginTypeName,\n+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase\n+        {\n+            private DefaultMSBuildFileSystem()\n+            {\n+            }\n+\n+            public static DefaultMSBuildFileSystem Instance { get; } = new();\n+        }\n+\n+        public ProjectCacheService(\n             BuildManager buildManager,\n             ILoggingService loggingService,\n-            ProjectCacheDescriptor projectCacheDescriptor,\n-            CancellationToken cancellationToken\n-        )\n+            ProjectCacheDescriptor? globalProjectCacheDescriptor)\n         {\n-            _projectCachePlugin = projectCachePlugin;\n-            _projectCachePluginTypeName = pluginTypeName;\n             _buildManager = buildManager;\n             _loggingService = loggingService;\n-            _projectCacheDescriptor = projectCacheDescriptor;\n-            _cancellationToken = cancellationToken;\n+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;\n         }\n \n-        public static async Task<ProjectCacheService> FromDescriptorAsync(\n-            ProjectCacheDescriptor pluginDescriptor,\n-            BuildManager buildManager,\n-            ILoggingService loggingService,\n+        /// <summary>\n+        /// Optimization which frontloads plugin initialization since we have an entire graph.\n+        /// </summary>\n+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)\n+        {\n+            EnsureNotDisposed();\n+\n+            Parallel.ForEach(\n+                projectGraph.ProjectNodes,\n+                s_parallelOptions,\n+                node =>\n+                {\n+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))\n+                    {\n+                        // Intentionally fire-and-forget\n+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)\n+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                    }\n+                });\n+        }\n+\n+        public void InitializePluginsForVsScenario(\n+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,\n+            BuildRequestConfiguration buildRequestConfiguration,\n             CancellationToken cancellationToken)\n         {\n-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)\n-                .ConfigureAwait(false);\n+            EnsureNotDisposed();\n+\n+            _isVsScenario = true;\n+\n+            // Bail out for design-time builds\n+            if (IsDesignTimeBuild(buildRequestConfiguration))\n+            {\n+                return;\n+            }\n+\n+            Parallel.ForEach(\n+                projectCacheDescriptors,\n+                s_parallelOptions,\n+                projectCacheDescriptor =>\n+                {\n+                    // Intentionally fire-and-forget\n+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)\n+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                });\n+        }\n \n-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);\n+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            ProjectGraph? projectGraph,\n+            BuildRequestConfiguration? buildRequestConfiguration,\n+            CancellationToken cancellationToken)\n+            => _projectCachePlugins.GetOrAdd(\n+                projectCacheDescriptor,\n+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken))).Value;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "No, the `ConcurrentDictionary` will always ensure only 1 \"wins\". IE `GetOrAdd` will always return the same instance.",
              "createdAt": "2022-08-09T15:47:05Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -18,148 +21,210 @@\n using Microsoft.Build.Graph;\n using Microsoft.Build.Internal;\n using Microsoft.Build.Shared;\n-using Microsoft.Build.Shared.FileSystem;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);\n \n-    internal record NullableBool(bool Value)\n+    internal sealed class ProjectCacheService : IAsyncDisposable\n     {\n-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;\n-    }\n+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };\n \n-    internal enum ProjectCacheServiceState\n-    {\n-        NotInitialized,\n-        BeginBuildStarted,\n-        BeginBuildFinished,\n-        ShutdownStarted,\n-        ShutdownFinished\n-    }\n+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { \"TargetFramework\", \"Configuration\", \"Platform\", \"TargetPlatform\", \"OutputType\" };\n \n-    internal class ProjectCacheService\n-    {\n         private readonly BuildManager _buildManager;\n         private readonly ILoggingService _loggingService;\n-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n-        private readonly CancellationToken _cancellationToken;\n-        private readonly ProjectCachePluginBase _projectCachePlugin;\n-        private readonly string _projectCachePluginTypeName;\n-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;\n+\n+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;\n+\n+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);\n+\n+        private bool _isVsScenario;\n+\n+        private bool _isDisposed;\n+\n+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);\n \n         /// <summary>\n         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,\n         /// i.e. falling back to FileSystem.Default.\n         /// </summary>\n-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }\n-\n-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).\n-        // Assume that if one request is a design time build, all of them are.\n-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.\n-        // TODO: remove after we change VS to set the cache descriptor via build parameters.\n-        public volatile NullableBool? DesignTimeBuildsDetected;\n-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;\n-\n-        private ProjectCacheService(\n-            ProjectCachePluginBase projectCachePlugin,\n-            string pluginTypeName,\n+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase\n+        {\n+            private DefaultMSBuildFileSystem()\n+            {\n+            }\n+\n+            public static DefaultMSBuildFileSystem Instance { get; } = new();\n+        }\n+\n+        public ProjectCacheService(\n             BuildManager buildManager,\n             ILoggingService loggingService,\n-            ProjectCacheDescriptor projectCacheDescriptor,\n-            CancellationToken cancellationToken\n-        )\n+            ProjectCacheDescriptor? globalProjectCacheDescriptor)\n         {\n-            _projectCachePlugin = projectCachePlugin;\n-            _projectCachePluginTypeName = pluginTypeName;\n             _buildManager = buildManager;\n             _loggingService = loggingService;\n-            _projectCacheDescriptor = projectCacheDescriptor;\n-            _cancellationToken = cancellationToken;\n+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;\n         }\n \n-        public static async Task<ProjectCacheService> FromDescriptorAsync(\n-            ProjectCacheDescriptor pluginDescriptor,\n-            BuildManager buildManager,\n-            ILoggingService loggingService,\n+        /// <summary>\n+        /// Optimization which frontloads plugin initialization since we have an entire graph.\n+        /// </summary>\n+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)\n+        {\n+            EnsureNotDisposed();\n+\n+            Parallel.ForEach(\n+                projectGraph.ProjectNodes,\n+                s_parallelOptions,\n+                node =>\n+                {\n+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))\n+                    {\n+                        // Intentionally fire-and-forget\n+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)\n+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                    }\n+                });\n+        }\n+\n+        public void InitializePluginsForVsScenario(\n+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,\n+            BuildRequestConfiguration buildRequestConfiguration,\n             CancellationToken cancellationToken)\n         {\n-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)\n-                .ConfigureAwait(false);\n+            EnsureNotDisposed();\n+\n+            _isVsScenario = true;\n+\n+            // Bail out for design-time builds\n+            if (IsDesignTimeBuild(buildRequestConfiguration))\n+            {\n+                return;\n+            }\n+\n+            Parallel.ForEach(\n+                projectCacheDescriptors,\n+                s_parallelOptions,\n+                projectCacheDescriptor =>\n+                {\n+                    // Intentionally fire-and-forget\n+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)\n+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                });\n+        }\n \n-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);\n+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            ProjectGraph? projectGraph,\n+            BuildRequestConfiguration? buildRequestConfiguration,\n+            CancellationToken cancellationToken)\n+            => _projectCachePlugins.GetOrAdd(\n+                projectCacheDescriptor,\n+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken))).Value;",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Oh, I see! I mentally missed one of the `)`. You're not calling `.Value` _immediately_, but after the `ConcurrentDictionary` retrieval. Maybe with a bit of reformatting?\r\n\r\n```suggestion\r\n                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken)))\r\n               .Value;\r\n```",
              "createdAt": "2022-08-09T17:00:50Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -18,148 +21,210 @@\n using Microsoft.Build.Graph;\n using Microsoft.Build.Internal;\n using Microsoft.Build.Shared;\n-using Microsoft.Build.Shared.FileSystem;\n \n namespace Microsoft.Build.Experimental.ProjectCache\n {\n     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);\n \n-    internal record NullableBool(bool Value)\n+    internal sealed class ProjectCacheService : IAsyncDisposable\n     {\n-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;\n-    }\n+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };\n \n-    internal enum ProjectCacheServiceState\n-    {\n-        NotInitialized,\n-        BeginBuildStarted,\n-        BeginBuildFinished,\n-        ShutdownStarted,\n-        ShutdownFinished\n-    }\n+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { \"TargetFramework\", \"Configuration\", \"Platform\", \"TargetPlatform\", \"OutputType\" };\n \n-    internal class ProjectCacheService\n-    {\n         private readonly BuildManager _buildManager;\n         private readonly ILoggingService _loggingService;\n-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n-        private readonly CancellationToken _cancellationToken;\n-        private readonly ProjectCachePluginBase _projectCachePlugin;\n-        private readonly string _projectCachePluginTypeName;\n-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;\n+\n+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;\n+\n+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);\n+\n+        private bool _isVsScenario;\n+\n+        private bool _isDisposed;\n+\n+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);\n \n         /// <summary>\n         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,\n         /// i.e. falling back to FileSystem.Default.\n         /// </summary>\n-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }\n-\n-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).\n-        // Assume that if one request is a design time build, all of them are.\n-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.\n-        // TODO: remove after we change VS to set the cache descriptor via build parameters.\n-        public volatile NullableBool? DesignTimeBuildsDetected;\n-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;\n-\n-        private ProjectCacheService(\n-            ProjectCachePluginBase projectCachePlugin,\n-            string pluginTypeName,\n+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase\n+        {\n+            private DefaultMSBuildFileSystem()\n+            {\n+            }\n+\n+            public static DefaultMSBuildFileSystem Instance { get; } = new();\n+        }\n+\n+        public ProjectCacheService(\n             BuildManager buildManager,\n             ILoggingService loggingService,\n-            ProjectCacheDescriptor projectCacheDescriptor,\n-            CancellationToken cancellationToken\n-        )\n+            ProjectCacheDescriptor? globalProjectCacheDescriptor)\n         {\n-            _projectCachePlugin = projectCachePlugin;\n-            _projectCachePluginTypeName = pluginTypeName;\n             _buildManager = buildManager;\n             _loggingService = loggingService;\n-            _projectCacheDescriptor = projectCacheDescriptor;\n-            _cancellationToken = cancellationToken;\n+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;\n         }\n \n-        public static async Task<ProjectCacheService> FromDescriptorAsync(\n-            ProjectCacheDescriptor pluginDescriptor,\n-            BuildManager buildManager,\n-            ILoggingService loggingService,\n+        /// <summary>\n+        /// Optimization which frontloads plugin initialization since we have an entire graph.\n+        /// </summary>\n+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)\n+        {\n+            EnsureNotDisposed();\n+\n+            Parallel.ForEach(\n+                projectGraph.ProjectNodes,\n+                s_parallelOptions,\n+                node =>\n+                {\n+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))\n+                    {\n+                        // Intentionally fire-and-forget\n+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)\n+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                    }\n+                });\n+        }\n+\n+        public void InitializePluginsForVsScenario(\n+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,\n+            BuildRequestConfiguration buildRequestConfiguration,\n             CancellationToken cancellationToken)\n         {\n-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)\n-                .ConfigureAwait(false);\n+            EnsureNotDisposed();\n+\n+            _isVsScenario = true;\n+\n+            // Bail out for design-time builds\n+            if (IsDesignTimeBuild(buildRequestConfiguration))\n+            {\n+                return;\n+            }\n+\n+            Parallel.ForEach(\n+                projectCacheDescriptors,\n+                s_parallelOptions,\n+                projectCacheDescriptor =>\n+                {\n+                    // Intentionally fire-and-forget\n+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)\n+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);\n+                });\n+        }\n \n-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);\n+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            ProjectGraph? projectGraph,\n+            BuildRequestConfiguration? buildRequestConfiguration,\n+            CancellationToken cancellationToken)\n+            => _projectCachePlugins.GetOrAdd(\n+                projectCacheDescriptor,\n+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken))).Value;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}