{
  "number": 9948,
  "title": "Added task assembly location to TaskStartedEventArgs",
  "body": "Fixes #9290\r\n\r\n### Context\r\nTaskStartedEventArgs now contains AssemblyName of the assembly that implements the task.\r\n\r\n### Changes Made\r\nAdding full assembly name to event and propagating the value from upper layers. `ITaskExecutionHost` interface was removed.\r\n\r\n### Testing\r\nManual testing for setting the value. Unit test for serialization\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2024-03-28T14:47:00Z",
  "updatedAt": "2024-04-19T10:28:45Z",
  "closedAt": "2024-04-19T10:28:44Z",
  "mergedAt": "2024-04-19T10:28:44Z",
  "additions": 232,
  "deletions": 191,
  "changedFiles": 30,
  "headRefName": "dev/mipavlik/taskstartedevent-taskassembly",
  "isDraft": false,
  "author": {
    "login": "MichalPavlik"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1c2f95f1a85065d555727be42a9a71340917467a",
          "message": "Added task assembly name to TaskStartedEventArgs",
          "committedDate": "2024-03-28T14:45:21Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5c6e340151ab19dec848a09588429495bb283f9",
          "message": "AssemblyName was removed in favor of simple string",
          "committedDate": "2024-04-03T11:29:17Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5b597b52aa8ae57b567227c7bfa741d4fb3d6c4b",
          "message": "Removed ITaskExecutionHost",
          "committedDate": "2024-04-03T11:47:49Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "36bc3d83186810505dc78a6ebd13d0a0fab01c7d",
          "message": "Extended serialization test",
          "committedDate": "2024-04-03T12:23:48Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92e2de4f36eebe4cb746f4b626d8b420410c7606",
          "message": "Removed FindTaskAssemblyName and incremented binlog version.",
          "committedDate": "2024-04-04T09:45:55Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "784fafef26ba5d7620b0ec52e7ab4a7f2b3ade39",
          "message": "Minor refactoring. Leaving the place in better condition:)",
          "committedDate": "2024-04-04T10:46:34Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ca16fd8e954a51928dc7b4ad7da00a84facd3385",
          "message": "Use FullName instead of Name",
          "committedDate": "2024-04-04T12:17:19Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa645e16bf587b1bf6eaca72376bba0c4bc53b85",
          "message": "Additional extended test",
          "committedDate": "2024-04-04T12:56:19Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9cba8a3f492ccf1ff62703d13b4e0a8394d96495",
          "message": "Removed unnecessary code",
          "committedDate": "2024-04-05T10:33:01Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c09b10e2d72b25eb90adab6dd360466559f5a47",
          "message": "Resolving comments",
          "committedDate": "2024-04-08T10:49:55Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cfecf4218a31b3e94a06865d8ede0627834fc1c3",
          "message": "Logging assembly location instead of assembly full name",
          "committedDate": "2024-04-08T11:22:08Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "615312206c20a0c3eb9238bffa27c129ac48a3c7",
          "message": "Minor refactoring",
          "committedDate": "2024-04-08T11:33:09Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6f31301fb9df75f5f0f774c0978400ba9010882d",
          "message": "Removed unnecessary usings",
          "committedDate": "2024-04-08T11:37:27Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c4ccc4c5e6bf58a9f11fa7cbeec7b399bf5a37a",
          "message": "Emitting message when expected task assembly location does not match loaded assembly location.",
          "committedDate": "2024-04-08T13:53:00Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21055db3ce96aa5adc21e6a207584ca7c91dfd65",
          "message": "Resolving comments",
          "committedDate": "2024-04-09T12:31:44Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39be7ea027b60ee711c5da876c5829b655f7d0a4",
          "message": "Reverted unwanted changes in resource file",
          "committedDate": "2024-04-10T12:42:27Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8d416f72157a41424aa7615b98d80c24855def15",
          "message": "Exclude in-memory assemblies from location mismatch check",
          "committedDate": "2024-04-11T12:36:19Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b185844f4639cb0397dbe2c4df79327e8bc943cb",
          "message": "Resolving comment",
          "committedDate": "2024-04-16T11:54:00Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "53f310a60ef44909c18fe34afcf37e8fd7d35c77",
          "message": "Changed the mismatch message",
          "committedDate": "2024-04-16T13:18:30Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f0dd32475d48b0423b6c81635a5d6daf6f6ec2ea",
          "message": "Updated xlfs",
          "committedDate": "2024-04-16T13:35:49Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@ladipro, is this comment still valid? I would remove the interface as part of this PR\r\nhttps://github.com/dotnet/msbuild/pull/9948/files#diff-ddd6688a0412c50705a77043f780edaec5bbb785f71dbbb1c4126a7aa8c9fcb7L45",
        "createdAt": "2024-04-03T11:11:18Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "The interface is internal and has only one internal implementation. So it looks like the comment is still valid.",
        "createdAt": "2024-04-03T11:19:04Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I had same opinion, but I wanted to check if there is a plan to implement additional execution host(s)... for whatever reason :)",
        "createdAt": "2024-04-03T11:31:58Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": ">... Plus don't forget to update the same class in Viewer repo as well (or create task in viewer repo for that)\r\n> \r\n> Having the diverging assembly path logging handled here or tracking item created would be nice as well.\r\n\r\n@JanKrivanek, I created tracking issue for the viewer: https://github.com/KirillOsenkov/MSBuildStructuredLog/issues/771",
        "createdAt": "2024-04-08T14:10:41Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "I think we need the viewer support ready and merged first, then merge this PR.",
        "createdAt": "2024-04-08T17:58:54Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Do not merge yet. Viewer update should be first (I'm struggling with the test there).",
        "createdAt": "2024-04-16T14:23:33Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "Published a new release with these changes\r\n\r\n * https://www.nuget.org/packages/MSBuild.StructuredLogger/2.2.235\r\n * https://github.com/KirillOsenkov/MSBuildStructuredLog/releases/tag/v.2.2.235\r\n * https://www.nuget.org/packages/binlogtool/1.0.14",
        "createdAt": "2024-04-18T21:17:43Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Please consider representing the full name with string here. `AssemblyName` can be [expensive to handle](https://github.com/dotnet/msbuild/blob/8fa24d94b5a0a0b164e04ea3eeb8fd102584ee5b/src/Shared/AssemblyNameExtension.cs#L50C1-L54C19) and the fewer conversions to/from string we do, the better. Also, prior art uses strings: https://github.com/dotnet/msbuild/blob/8fa24d94b5a0a0b164e04ea3eeb8fd102584ee5b/src/Framework/AssemblyLoadBuildEventArgs.cs#L39",
              "createdAt": "2024-04-02T14:51:52Z",
              "path": "src/Framework/TaskStartedEventArgs.cs",
              "diffHunk": "@@ -135,6 +186,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)\n         /// </summary>\n         public int ColumnNumber { get; internal set; }\n \n+        /// <summary>\n+        /// Full name of the assembly that implements the task\n+        /// </summary>\n+        public AssemblyName TaskAssemblyName { get; private set; }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "No problem. I checked the implementation and it's mutable, so the `FullPath` is constructed every time without caching :| I didn't expect that.",
              "createdAt": "2024-04-03T11:13:05Z",
              "path": "src/Framework/TaskStartedEventArgs.cs",
              "diffHunk": "@@ -135,6 +186,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)\n         /// </summary>\n         public int ColumnNumber { get; internal set; }\n \n+        /// <summary>\n+        /// Full name of the assembly that implements the task\n+        /// </summary>\n+        public AssemblyName TaskAssemblyName { get; private set; }",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can the return type of `FindTask` be changed instead, so that requirements and assembly name are returned from one call?",
              "createdAt": "2024-04-02T14:59:37Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -424,9 +424,11 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n                     TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    AssemblyName taskAssemblyName = _taskExecutionHost.FindTaskAssemblyName(taskIdentityParameters);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Done",
              "createdAt": "2024-04-04T09:53:59Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -424,9 +424,11 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n                     TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    AssemblyName taskAssemblyName = _taskExecutionHost.FindTaskAssemblyName(taskIdentityParameters);",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@JanKrivanek, could you please check that versions are set correctly? :) ",
              "createdAt": "2024-04-04T09:52:34Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -69,14 +69,16 @@ public sealed class BinaryLogger : ILogger\n         //   - Adding serialized events lengths - to support forward compatible reading\n         // version 19:\n         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)\n+        // version 20:\n+        //   - TaskStartedEventArgs: Added TaskAssemblyName property\n \n         // This should be never changed.\n         // The minimum version of the binary log reader that can read log of above version.\n         internal const int ForwardCompatibilityMinimalVersion = 18;\n \n         // The current version of the binary log representation.\n         // Changes with each update of the binary log format.\n-        internal const int FileFormatVersion = 18;\n+        internal const int FileFormatVersion = 20;",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Thank you for checking! Yes - this is safest option",
              "createdAt": "2024-04-05T21:40:42Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -69,14 +69,16 @@ public sealed class BinaryLogger : ILogger\n         //   - Adding serialized events lengths - to support forward compatible reading\n         // version 19:\n         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)\n+        // version 20:\n+        //   - TaskStartedEventArgs: Added TaskAssemblyName property\n \n         // This should be never changed.\n         // The minimum version of the binary log reader that can read log of above version.\n         internal const int ForwardCompatibilityMinimalVersion = 18;\n \n         // The current version of the binary log representation.\n         // Changes with each update of the binary log format.\n-        internal const int FileFormatVersion = 18;\n+        internal const int FileFormatVersion = 20;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The _name_ of the assembly seems to me less useful than its absolute path. Could we log that instead?\r\n\r\nNote that we currently already try to do that but lie about it: https://github.com/dotnet/msbuild/issues/584. Can this be massaged to fix that as well?",
              "createdAt": "2024-04-04T16:00:48Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I will use the absolute path instead of name, and I looked at the \"path accuracy\" problem. If I understood it correctly, `AssemblyTaskLoader` can load different assembly than expected, so we have to postpone logging of the event after we have instance of the task.\r\n\r\nThat would mean to extract the logic from ctor of `TaskLoggingContext` and log task started event in `InitializeAndExecuteTask` after invocation of `InitializeForBatch` when task host ask for task instance from loader.\r\nOR\r\nForce task host to get task instance early (and outside of task logging context).\r\nOR\r\nLog mismatch between expected and loaded assembly inside task logging context (only if there is a mismatch).\r\nOR\r\nSome better solution :)\r\n\r\nI don't have strong opinion nor experience with this MSBuild part, so please share your preference.\r\n\r\n",
              "createdAt": "2024-04-05T10:25:35Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Discussed with @rainersigwald offline. We settled on logging extra message if there is a mismatch.",
              "createdAt": "2024-04-05T14:05:27Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "![image](https://github.com/dotnet/msbuild/assets/12775388/951e2781-dea1-4d0a-9f5a-386db6093bee)\r\n\r\nSo far I could hit the mismatch with task generated by Roslyn Code Task factory. I'm wondering if I should exclude these cases when the dynamically created assembly doesn't have a location.",
              "createdAt": "2024-04-08T13:57:59Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Sounds like good candidate for exception (if it's easy) as something that looks like a problem ('mismatch detected') for an expected case can be confusing.",
              "createdAt": "2024-04-10T06:26:08Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I can filter out cases when assembly doesn't have a location at all (usually in-memory assemblies). @rainersigwald ",
              "createdAt": "2024-04-10T12:46:49Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Works for me.",
              "createdAt": "2024-04-10T13:48:33Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2024-04-11T13:29:51Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b\n                 {\n                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event\n                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);\n-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);\n+                    string taskAssemblyName = taskFactoryWrapper?.TaskFactoryLoadedType?.LoadedAssemblyName?.FullName;",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Is the `GetTypeInfo()` call needed?\r\n```suggestion\r\n            TaskLoggingContext talc = tlc.LogTaskBatchStarted(\".\", taskInstance, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).Assembly.GetName().FullName);\r\n```",
              "createdAt": "2024-04-04T20:43:48Z",
              "path": "src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs",
              "diffHunk": "@@ -1190,7 +1190,7 @@ private void InitializeHost(bool throwOnExecute)\n                 CancellationToken.None);\n \n             ProjectTaskInstance taskInstance = project.Targets[\"foo\"].Tasks.First();\n-            TaskLoggingContext talc = tlc.LogTaskBatchStarted(\".\", taskInstance);\n+            TaskLoggingContext talc = tlc.LogTaskBatchStarted(\".\", taskInstance, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().Assembly.GetName().FullName);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good catch. I think it's copy&paste mistake :)",
              "createdAt": "2024-04-05T08:45:11Z",
              "path": "src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs",
              "diffHunk": "@@ -1190,7 +1190,7 @@ private void InitializeHost(bool throwOnExecute)\n                 CancellationToken.None);\n \n             ProjectTaskInstance taskInstance = project.Targets[\"foo\"].Tasks.First();\n-            TaskLoggingContext talc = tlc.LogTaskBatchStarted(\".\", taskInstance);\n+            TaskLoggingContext talc = tlc.LogTaskBatchStarted(\".\", taskInstance, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().Assembly.GetName().FullName);",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it's worth pointing out that `MSBuild` and `CallTarget` are public non-sealed classes so there can be subclasses for which this will now behave differently.",
              "createdAt": "2024-04-04T20:56:44Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -754,20 +756,13 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta\n                 Exception taskException = null;\n \n                 // If this is the MSBuild task, we need to execute it's special internal method.\n-                TaskExecutionHost host = taskExecutionHost as TaskExecutionHost;\n-                Type taskType = host.TaskInstance.GetType();\n-\n                 try\n                 {\n-                    if (taskType == typeof(MSBuild))\n+                    if (taskExecutionHost.TaskInstance is MSBuild msbuildTask)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "These references targets internal intrinsic types:\r\nhttps://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs#L23\r\nhttps://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs#L22\r\n\r\nIt's confusing to have different types with the same name...\r\n",
              "createdAt": "2024-04-05T08:42:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -754,20 +756,13 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta\n                 Exception taskException = null;\n \n                 // If this is the MSBuild task, we need to execute it's special internal method.\n-                TaskExecutionHost host = taskExecutionHost as TaskExecutionHost;\n-                Type taskType = host.TaskInstance.GetType();\n-\n                 try\n                 {\n-                    if (taskType == typeof(MSBuild))\n+                    if (taskExecutionHost.TaskInstance is MSBuild msbuildTask)",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "I stand corrected, ignore me!",
              "createdAt": "2024-04-05T08:56:43Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -754,20 +756,13 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta\n                 Exception taskException = null;\n \n                 // If this is the MSBuild task, we need to execute it's special internal method.\n-                TaskExecutionHost host = taskExecutionHost as TaskExecutionHost;\n-                Type taskType = host.TaskInstance.GetType();\n-\n                 try\n                 {\n-                    if (taskType == typeof(MSBuild))\n+                    if (taskExecutionHost.TaskInstance is MSBuild msbuildTask)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I admire your vigilance :)",
              "createdAt": "2024-04-05T10:34:37Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -754,20 +756,13 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta\n                 Exception taskException = null;\n \n                 // If this is the MSBuild task, we need to execute it's special internal method.\n-                TaskExecutionHost host = taskExecutionHost as TaskExecutionHost;\n-                Type taskType = host.TaskInstance.GetType();\n-\n                 try\n                 {\n-                    if (taskType == typeof(MSBuild))\n+                    if (taskExecutionHost.TaskInstance is MSBuild msbuildTask)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it needed?",
              "createdAt": "2024-04-05T21:42:13Z",
              "path": "src/Build/BackEnd/Components/Logging/ILoggingService.cs",
              "diffHunk": "@@ -4,6 +4,7 @@\n using System;\n using System.Collections;\n using System.Collections.Generic;\n+using System.Reflection;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "That is relict of using `AssemblyName`. For some reason, my VS doesn't detect unused usings...",
              "createdAt": "2024-04-08T10:51:26Z",
              "path": "src/Build/BackEnd/Components/Logging/ILoggingService.cs",
              "diffHunk": "@@ -4,6 +4,7 @@\n using System;\n using System.Collections;\n using System.Collections.Generic;\n+using System.Reflection;",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Seems unused as well (applies to couple other cases in other files)",
              "createdAt": "2024-04-05T21:43:31Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -4,6 +4,7 @@\n using System;\n using System.Collections;\n using System.Collections.Generic;\n+using System.Reflection;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            var taskAssemblyNameString = _fileFormatVersion > 19 ? ReadOptionalString() : null;\r\n```\r\n\r\nLet's make sure this can read older binlogs as well.",
              "createdAt": "2024-04-05T21:49:10Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -806,14 +806,16 @@ private BuildEventArgs ReadTaskStartedEventArgs()\n             var taskName = ReadOptionalString();\n             var projectFile = ReadOptionalString();\n             var taskFile = ReadOptionalString();\n+            var taskAssemblyNameString = ReadOptionalString();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Good one, fixed.",
              "createdAt": "2024-04-08T10:52:15Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -806,14 +806,16 @@ private BuildEventArgs ReadTaskStartedEventArgs()\n             var taskName = ReadOptionalString();\n             var projectFile = ReadOptionalString();\n             var taskFile = ReadOptionalString();\n+            var taskAssemblyNameString = ReadOptionalString();",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            TaskAssemblyName = reader.ReadOptionalString();\r\n```",
              "createdAt": "2024-04-05T21:51:29Z",
              "path": "src/Framework/TaskStartedEventArgs.cs",
              "diffHunk": "@@ -107,6 +157,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)\n             taskFile = reader.ReadByte() == 0 ? null : reader.ReadString();\n             LineNumber = reader.Read7BitEncodedInt();\n             ColumnNumber = reader.Read7BitEncodedInt();\n+            TaskAssemblyName = reader.ReadByte() == 0 ? null : reader.ReadString();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Thanks, I changed also other instances in this method.",
              "createdAt": "2024-04-08T10:53:32Z",
              "path": "src/Framework/TaskStartedEventArgs.cs",
              "diffHunk": "@@ -107,6 +157,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)\n             taskFile = reader.ReadByte() == 0 ? null : reader.ReadString();\n             LineNumber = reader.Read7BitEncodedInt();\n             ColumnNumber = reader.Read7BitEncodedInt();\n+            TaskAssemblyName = reader.ReadByte() == 0 ? null : reader.ReadString();",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\n        /// <param name=\"taskAssemblyName\">The unique identity of the assembly containing the implementation of the task.</param>\n```\n",
              "createdAt": "2024-04-05T22:55:16Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -714,9 +717,10 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN\n         /// <param name=\"projectFileOfTaskNode\">Project file which contains the task</param>\n         /// <param name=\"line\">The line number in the file where the task invocation is located.</param>\n         /// <param name=\"column\">The column number in the file where the task invocation is located.</param>\n+        /// <param name=\"taskAssemblyName\">An assembly's unique identity where the task is implemented</param>",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I used some existing doc from `AssemblyName` related code for this, but I had to change it anyway as we will log the assembly location. I used your proposal as the template. Thanks.",
              "createdAt": "2024-04-08T14:01:15Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -714,9 +717,10 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN\n         /// <param name=\"projectFileOfTaskNode\">Project file which contains the task</param>\n         /// <param name=\"line\">The line number in the file where the task invocation is located.</param>\n         /// <param name=\"column\">The column number in the file where the task invocation is located.</param>\n+        /// <param name=\"taskAssemblyName\">An assembly's unique identity where the task is implemented</param>",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "when passing literals such as `true`, `false` or `null` it's good to add the argument name",
              "createdAt": "2024-04-08T17:59:59Z",
              "path": "src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs",
              "diffHunk": "@@ -1089,7 +1090,7 @@ public void TaskStartedNullBuildEventContext()\n             Assert.Throws<InternalErrorException>(() =>\n             {\n                 ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);\n-                service.LogTaskStarted(null, \"MyTask\", \"ProjectFile\", \"ProjectFileOfTask\");\n+                service.LogTaskStarted(null, \"MyTask\", \"ProjectFile\", \"ProjectFileOfTask\", null);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do we need to preserve this comment?",
              "createdAt": "2024-04-08T18:09:39Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2095,11 +2095,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.\n     </comment>\n   </data>\n-  <!--",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I guess we do. I edited this file with VS editor and it probably removed it + I missed that change. Fixed.",
              "createdAt": "2024-04-09T12:33:10Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2095,11 +2095,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.\n     </comment>\n   </data>\n-  <!--",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Unfortunately this file must be edited manually - otherwise not only comments, but as well some functional data (like conditions) are lost",
              "createdAt": "2024-04-10T06:21:50Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2095,11 +2095,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.\n     </comment>\n   </data>\n-  <!--",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I reverted all changes and added manually only what I wanted to add :)",
              "createdAt": "2024-04-10T12:44:32Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2095,11 +2095,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.\n     </comment>\n   </data>\n-  <!--",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you have to do this in the deprecated engine? I would rather not make changes there when possible. Maybe just pass null?",
              "createdAt": "2024-04-10T20:38:54Z",
              "path": "src/Deprecated/Engine/Engine/EngineLoggingServices.cs",
              "diffHunk": "@@ -863,7 +863,7 @@ internal virtual void LogTargetFinished(BuildEventContext buildEventContext, str\n         /// <param name=\"taskName\"></param>\n         /// <param name=\"projectFile\"></param>\n         /// <param name=\"projectFileOfTaskNode\">project file actually containing the task</param>\n-        internal virtual void LogTaskStarted(BuildEventContext buildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)\n+        internal virtual void LogTaskStarted(BuildEventContext buildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I should start using slnf without deprecated projects :)",
              "createdAt": "2024-04-16T11:55:32Z",
              "path": "src/Deprecated/Engine/Engine/EngineLoggingServices.cs",
              "diffHunk": "@@ -863,7 +863,7 @@ internal virtual void LogTargetFinished(BuildEventContext buildEventContext, str\n         /// <param name=\"taskName\"></param>\n         /// <param name=\"projectFile\"></param>\n         /// <param name=\"projectFileOfTaskNode\">project file actually containing the task</param>\n-        internal virtual void LogTaskStarted(BuildEventContext buildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)\n+        internal virtual void LogTaskStarted(BuildEventContext buildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Is the string equality comparison OK here? Should this be something like `FileUtilities.ComparePathsNoThrow` instead?",
              "createdAt": "2024-04-11T10:21:45Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -313,6 +332,11 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It\n                 return false;\n             }\n \n+            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Value set to `TaskFactoryLoadedType.Path` is from `Assembly.Location`. During OrchadCore build, all locations were equal (except in-memory assemblies).",
              "createdAt": "2024-04-11T10:53:13Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -313,6 +332,11 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It\n                 return false;\n             }\n \n+            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Gotcha. So even if the project has `UsingTask`'s with different casing this would probably work fine because the path is normalized when we load the task assembly. I have no objections then!",
              "createdAt": "2024-04-11T11:23:11Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -313,6 +332,11 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It\n                 return false;\n             }\n \n+            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Actually - is it possible to cover this with a test?",
              "createdAt": "2024-04-11T11:39:12Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -313,6 +332,11 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It\n                 return false;\n             }\n \n+            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I will take a deeper look. Finding the right test to extend is not always an easy task :)",
              "createdAt": "2024-04-11T13:43:42Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -313,6 +332,11 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It\n                 return false;\n             }\n \n+            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "We agreed with @ladipro (offline) that we will skip the test due the complexity, but the message was changed.",
              "createdAt": "2024-04-16T13:21:32Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -313,6 +332,11 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It\n                 return false;\n             }\n \n+            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: store Location in a variable so you only have to get it once please",
              "createdAt": "2024-04-11T14:12:04Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -332,7 +332,8 @@ public bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket bat\n                 return false;\n             }\n \n-            if (TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)\n+            if (!string.IsNullOrWhiteSpace(TaskInstance.GetType().Assembly.Location) &&\n+                TaskInstance.GetType().Assembly.Location != _taskFactoryWrapper.TaskFactoryLoadedType.Path)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}