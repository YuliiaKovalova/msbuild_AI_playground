{
  "number": 6316,
  "title": "\u0421urrent directory virtualization for RAR task",
  "body": "Fixes #6218\r\n\r\n### Context\r\nThis PR is part of RAR as a service user story #3139. The current design supposes RAR tasks run concurrently in threads. However, the RAR task also depends on the current directory which is shared between the threads. \r\n\r\n### Changes Made\r\nIn the PR we implement current directory virtualization.\r\nFor all the inputs we either absolutize the paths at the start of the RAR task or if we are unable to recognize the input's type, absolutize an entry when we use it, i.e. when we know the type of the entry (path/assembly name/etc). \r\n\r\n### Testing\r\nThere already were unit tests for relative inputs in `Miscellaneous.cs`, we leverage them to check that the virtualization of the current directory works well. \r\n\r\n### Notes\r\n",
  "state": "CLOSED",
  "createdAt": "2021-04-01T09:18:28Z",
  "updatedAt": "2024-03-01T15:30:19Z",
  "closedAt": "2021-06-02T12:17:07Z",
  "mergedAt": null,
  "additions": 600,
  "deletions": 71,
  "changedFiles": 27,
  "headRefName": "current-diretory-virtualization-3",
  "isDraft": true,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c229ca87beb0243e38c4b6ff6700f614caeca5c0",
          "message": "add TaskExecutionContext to rar (from rokonec, revert later, when rebasing on his changes)",
          "committedDate": "2021-03-31T20:28:16Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ae2474a756c7387e6137c4a36264a8f03ca81ad",
          "message": "current directory virtualization: processing inputs - in work",
          "committedDate": "2021-03-31T20:28:16Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2e5e3b63e55192f843d5cbf327dca66067dbc506",
          "message": "add unit tests",
          "committedDate": "2021-03-31T20:28:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79c7b5e815f7128ae9672cfdd7991b3a385e6c45",
          "message": "fixing failing unit test: fix cache (de)serialization",
          "committedDate": "2021-03-31T20:28:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a8310dcae5c5a2669a4dd40ce932bf0e8c7d7659",
          "message": "fix name, remove unused functions, move absolutization under the try section.",
          "committedDate": "2021-04-01T12:59:47Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c398f16b4ddfa5b3b5798d9602be8e2f59f49a7",
          "message": "remove unnecessary unit tests, fix unit tests.",
          "committedDate": "2021-04-01T14:30:08Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5f2bec03cdb84d79a4b9a0d29d96a7499cf45d4a",
          "message": "Revert \"remove unnecessary unit tests, fix unit tests.\"\n\nThis reverts commit 7c398f16b4ddfa5b3b5798d9602be8e2f59f49a7.",
          "committedDate": "2021-04-05T15:06:36Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5db2554cb665330eca47f55f8ea747b16a18b364",
          "message": "Revert \"add unit tests\"\n\nThis reverts commit 2e5e3b63e55192f843d5cbf327dca66067dbc506.",
          "committedDate": "2021-04-05T15:07:08Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1a847319c69cb8431f3514caf16042d5338dc52",
          "message": "testing absolutization for inputs. this commit is for running ci tests for this pr, remove it later.",
          "committedDate": "2021-04-05T16:03:48Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "032bcba8740a68de18ed65c48ac357080aa828d7",
          "message": "Fix path absolutization in TaskExecutionContext",
          "committedDate": "2021-04-05T17:38:56Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4e9a5daef3229aa7f957f069dc7633649a5a6ff2",
          "message": "Revert \"testing absolutization for inputs. this commit is for running ci tests for this pr, remove it later.\"\n\nThis reverts commit b1a847319c69cb8431f3514caf16042d5338dc52.",
          "committedDate": "2021-04-07T07:51:07Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3e64191ed6f6f0b393d03ce9836aedf2aee682c0",
          "message": "add unit tests",
          "committedDate": "2021-04-07T16:57:47Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "82ab5c05614d1539fa3bc04ac48d57450e0affd2",
          "message": "current directory virtualization: processing inputs - fixing bugs",
          "committedDate": "2021-04-07T16:58:00Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68653c1cde14e28a00c520c4a698a05de5792d54",
          "message": "Small fixes: renames, etc.",
          "committedDate": "2021-04-08T12:29:22Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd32c79995e6fb35aae0501a603ab64f8f30dc6b",
          "message": "Fix paths' comparison in ResolveAssemblyReferenceTestFixture",
          "committedDate": "2021-04-08T12:29:43Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4f259cbcdafac8be679f349047e2bcf2c37aa3e",
          "message": "fix GetFullPath function so it works for unix",
          "committedDate": "2021-04-09T12:13:30Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c875b359043f1ac78a77037dd836e94256b025c",
          "message": "Fix the file name of unit tests.",
          "committedDate": "2021-04-09T13:36:32Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0510d9dc32d4ad42a1182a774433bd31f2ac5ab1",
          "message": "add comments",
          "committedDate": "2021-04-12T07:15:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "935bdabfc932ffdedd013ffa2c0d0bfe58ba8f86",
          "message": "Turn on unit tests on unix.",
          "committedDate": "2021-04-12T07:16:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a2a35f0948cf83dc0b46efa4e2da2035cb8c6f2b",
          "message": "Moving functions from TaskExecutionContext to its extension, fixing comments.",
          "committedDate": "2021-04-13T10:34:34Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c375f85a825449d2c1192eac5d1e342daa86267",
          "message": "Small fix to a comment.",
          "committedDate": "2021-04-27T11:21:37Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> In the issue, you mentioned both normalizing and denormalizing as necessary. I saw the first but not the second. Did you determine it's unnecessary?\r\n\r\nI currently think denormalizing is not necessary, but I would like to ask about that more. It is my current understanding that all output is currently supposed to be absolute.\r\nIn the exp branch I also checked if we get any problems if we normalize all the output and insertion VS tests does not show any.",
        "createdAt": "2021-04-19T15:31:42Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "Moved this PR to draft. We should merge this only with RAR as a Service feature PR, as it is meaningless to have this code otherwise. The future of RAR as a Service feature (when/if it will be merged) is currently unclear.",
        "createdAt": "2021-04-19T17:25:28Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "Is the future of RARaaS more clear? Wondering if we should close this temporarily until we're ready to go back to it.",
        "createdAt": "2021-06-01T21:09:45Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": " Work on \"RAR as a service\" was cut off, I close this PR.",
        "createdAt": "2021-06-02T12:17:07Z",
        "author": {
          "login": "AR-May"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Need to consider possible switch from Path.GetFullPath -> PathInternal.RemoveRelativeSegments to avoid extra actions in Path.GetFullPath. Unfortunately, RemoveRelativeSegments is not yet available in the Path (https://github.com/dotnet/runtime/issues/2162), so it might only be code duplication.",
              "createdAt": "2021-04-13T13:17:45Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension\n+    {\n+        /// <summary>\n+        /// Absolutize the given path with the startup directory.\n+        /// </summary>\n+        /// <param name=\"taskExecutionContext\"></param>\n+        /// <param name=\"path\">Relative or absolute path.</param>\n+        /// <returns></returns>\n+        public static string GetFullPath(this TaskExecutionContext taskExecutionContext,  string path)\n+        {\n+            if (String.IsNullOrEmpty(taskExecutionContext.StartupDirectory) || String.IsNullOrEmpty(path))\n+            {\n+                return path;\n+            }\n+\n+            try\n+            {\n+                // Path.GetFullPath is using in order to eliminate possible \"./\" and \"../\" in the resulted path.\n+                // However, if the combined path consists of different path separators (both windows and unix style),\n+                // then the behavior of Path.GetFullPath differs in windows and unix systems, as in Windows both Windows and Unix style separators works and in Unix - not.\n+                // Windows' function eleminates the internal \"./\" and \"../\", Unix's function does not. We are using FixFilePath to remove windows-style separators when on unix machine.\n+                return Path.GetFullPath(Path.Combine(taskExecutionContext.StartupDirectory, FileUtilities.FixFilePath(path)));",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do not need public here?",
              "createdAt": "2021-04-13T13:23:14Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I don't think so, at least as long as these methods are fixed rather than user-manipulatable. Should this explicitly extend TaskExecutionContext?",
              "createdAt": "2021-04-18T16:10:27Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "yes, there was no need for \"?\" mark in my comment, actually, this has to be private. That is a reminder for myself to fix this together with the other changes.",
              "createdAt": "2021-04-19T15:24:20Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2021-04-15T10:14:45Z",
              "path": "src/Framework/TaskExecutionContext.cs",
              "diffHunk": "@@ -0,0 +1,40 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.IO;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class TaskExecutionContext\n+    {\n+        public string StartupDirectory { get; }\n+        public Dictionary<string, string> BuildProcessEnvironment { get; }\n+        public CultureInfo Culture { get; }\n+        public CultureInfo UICulture { get; }\n+\n+        public TaskExecutionContext()\n+        {\n+            StartupDirectory = null;\n+            BuildProcessEnvironment = null;\n+            Culture = null;\n+            UICulture = null;\n+        }\n+\n+        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)\n+        {\n+            StartupDirectory = startupDirectory;\n+            BuildProcessEnvironment = buildProcessEnvironment;\n+            Culture = culture;\n+            UICulture = uiCulture;\n+        }\n+    }\n+\n+    // TODO: move to own file",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Lets keep it here.",
              "createdAt": "2021-04-15T10:15:02Z",
              "path": "src/Framework/TaskExecutionContext.cs",
              "diffHunk": "@@ -0,0 +1,40 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.IO;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class TaskExecutionContext\n+    {\n+        public string StartupDirectory { get; }\n+        public Dictionary<string, string> BuildProcessEnvironment { get; }\n+        public CultureInfo Culture { get; }\n+        public CultureInfo UICulture { get; }\n+\n+        public TaskExecutionContext()\n+        {\n+            StartupDirectory = null;\n+            BuildProcessEnvironment = null;\n+            Culture = null;\n+            UICulture = null;\n+        }\n+\n+        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)\n+        {\n+            StartupDirectory = startupDirectory;\n+            BuildProcessEnvironment = buildProcessEnvironment;\n+            Culture = culture;\n+            UICulture = uiCulture;\n+        }\n+    }\n+\n+    // TODO: move to own file",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, directory: FullSearchPath, assembliesConsideredAndRejected);\r\n```\r\nOn the second though, I think we can have it even more readable by above changes:",
              "createdAt": "2021-04-15T12:35:30Z",
              "path": "src/Tasks/AssemblyDependency/DirectoryResolver.cs",
              "diffHunk": "@@ -53,8 +61,8 @@ public override bool Resolve\n             foundPath = null;\n             userRequestedSpecificFile = false;\n \n-            // Resolve to the given path.\n-            string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, searchPathElement, assembliesConsideredAndRejected);\n+            string directory = FullSearchPath;\n+            string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, directory, assembliesConsideredAndRejected);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "copyright header",
              "createdAt": "2021-04-18T15:14:12Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Creating a temporary directory can be a little cleaner with TestEnvironment, though that might be overkill here.",
              "createdAt": "2021-04-18T15:16:16Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this failing on linux/mac?",
              "createdAt": "2021-04-18T15:16:40Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"..\\RawFileNameRelative\\System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"{RawFileName}\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative searchPath is passed in through the search path parameter\n+        /// then try to resolve the file but make sure it is a full name with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RelativeDirectoryResolverWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+            string previousCurrentDirectory = Directory.GetCurrentDirectory();\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"..\\\\RawFileNameRelative\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-linux-failing\")]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "There is a problem I recently discovered with unit tests for RAR in unix. ResolveAssemblyReferenceTestFixture does not work correctly with unix paths. A lot of tests currently are just excluded for unix/mac because of that (well, that is my suggestion). I managed to fix ResolveAssemblyReferenceTestFixture for all other tests I introduced except this one. This one (and other tests that are currently just do not run in unix) need much more fixes in ResolveAssemblyReferenceTestFixture. I think we should fix it in another PR. ",
              "createdAt": "2021-04-19T15:53:39Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"..\\RawFileNameRelative\\System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"{RawFileName}\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative searchPath is passed in through the search path parameter\n+        /// then try to resolve the file but make sure it is a full name with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RelativeDirectoryResolverWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+            string previousCurrentDirectory = Directory.GetCurrentDirectory();\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"..\\\\RawFileNameRelative\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-linux-failing\")]",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "so, the problem is in the testing system, with file system's mocking, not with RAR.",
              "createdAt": "2021-04-19T15:56:55Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"..\\RawFileNameRelative\\System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"{RawFileName}\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative searchPath is passed in through the search path parameter\n+        /// then try to resolve the file but make sure it is a full name with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RelativeDirectoryResolverWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+            string previousCurrentDirectory = Directory.GetCurrentDirectory();\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"..\\\\RawFileNameRelative\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-linux-failing\")]",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I tried to glance through that to see if it was a quick fix, and it's clear that some parts were designed with cross-plat in mind...but that's a really big class, and a lot of it wasn't. Sounds like a lot of work for not enough return on investment to me.",
              "createdAt": "2021-04-19T17:24:46Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"..\\RawFileNameRelative\\System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"{RawFileName}\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative searchPath is passed in through the search path parameter\n+        /// then try to resolve the file but make sure it is a full name with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RelativeDirectoryResolverWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+            string previousCurrentDirectory = Directory.GetCurrentDirectory();\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"..\\\\RawFileNameRelative\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-linux-failing\")]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "hmm, so far I saw the only problem with this class which prevents it to be cross-plat: the comparison of paths (well, at least tests I saw were failing because of that). Yes, this is a big class and you need to fix it in a lot of places, that's why I did not want to do this in this PR. This is very technical fix and I did not think it will take so much time. But maybe you are right, there also might be other changes needed to make it cross platform, I did not thought much about that.",
              "createdAt": "2021-04-20T08:07:45Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"..\\RawFileNameRelative\\System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"{RawFileName}\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative searchPath is passed in through the search path parameter\n+        /// then try to resolve the file but make sure it is a full name with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RelativeDirectoryResolverWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+            string previousCurrentDirectory = Directory.GetCurrentDirectory();\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"..\\\\RawFileNameRelative\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-linux-failing\")]",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: please use Shouldly for asserts.",
              "createdAt": "2021-04-18T15:17:01Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceEnvironmentVirtualizationTests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks;\n+using Microsoft.Build.Utilities;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests\n+{\n+    /// <summary>\n+    /// Unit tests for the ResolveAssemblyReference task.\n+    /// </summary>\n+    public sealed class ResolveAssemblyReferenceEnvironmentVirtualizationTests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceEnvironmentVirtualizationTests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}\n+        /// then try to resolve directly to that file name and make it a full path with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RawFileNameRelativeWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"..\\RawFileNameRelative\\System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"{RawFileName}\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);\n+                Assert.Equal(Path.Combine(testPath, \"System.Xml.dll\"), rarTask.ResolvedFiles[0].ItemSpec);\n+            }\n+            finally\n+            {\n+                if (Directory.Exists(testPath))\n+                {\n+                    FileUtilities.DeleteWithoutTrailingBackslash(testPath);\n+                }\n+            }\n+        }\n+\n+\n+        /// <summary>\n+        /// If a relative searchPath is passed in through the search path parameter\n+        /// then try to resolve the file but make sure it is a full name with current directory virtualization.\n+        /// </summary>\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void RelativeDirectoryResolverWithActiveDirectoryVirtualization()\n+        {\n+            ResolveAssemblyReference rarTask = new ResolveAssemblyReference();\n+\n+            rarTask.BuildEngine = new MockEngine(_output);\n+\n+            string testPath = Path.Combine(Path.GetTempPath(), @\"RawFileNameRelative\");\n+            string previousCurrentDirectory = Directory.GetCurrentDirectory();\n+\n+            Directory.CreateDirectory(testPath);\n+            try\n+            {\n+                rarTask.Assemblies = new ITaskItem[] { new TaskItem(@\"System.Xml.dll\") };\n+                rarTask.SearchPaths = new string[] { \"..\\\\RawFileNameRelative\" };\n+\n+                TaskExecutionContext taskExecutionContext = new TaskExecutionContext(testPath, null, null, null);\n+                (rarTask as IConcurrentTask).ConfigureForConcurrentExecution(taskExecutionContext);\n+\n+                Execute(rarTask);\n+\n+                Assert.Single(rarTask.ResolvedFiles);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "copyright header",
              "createdAt": "2021-04-18T15:17:56Z",
              "path": "src/Tasks.UnitTests/HintPathResolver_Tests.cs",
              "diffHunk": "@@ -1,4 +1,5 @@\n-\ufeffusing Microsoft.Build.Shared;\n+\ufeffusing Microsoft.Build.Framework;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "copyright header",
              "createdAt": "2021-04-18T15:19:01Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs",
              "diffHunk": "@@ -2,6 +2,7 @@\n using System.Collections.Immutable;\n using System.IO;\n using System.Linq;\n+using Microsoft.Build.Framework;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you explain how this changes what's in _filesInDirectories? It looks the same to me.",
              "createdAt": "2021-04-18T15:21:36Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs",
              "diffHunk": "@@ -40,11 +41,11 @@ internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFolder\n             }\n             else\n             {\n-                _filesInDirectories = assemblyFoldersFromConfig.AsParallel()\n-                    .Where(assemblyFolder => FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))\n+                _filesInDirectories = assemblyFoldersFromConfig.Select(assemblyFolder => executionContext.GetFullPath(assemblyFolder.DirectoryPath)).AsParallel()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What is added here: we apply executionContext.GetFullPath() to the path.\r\nIf we have any execution context (so, this is RAR as a service), then it applies the current directory to the path, making it a full path, if not - nothing happens. (maybe I should rename this func to be more clear.)",
              "createdAt": "2021-04-19T16:53:31Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs",
              "diffHunk": "@@ -40,11 +41,11 @@ internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFolder\n             }\n             else\n             {\n-                _filesInDirectories = assemblyFoldersFromConfig.AsParallel()\n-                    .Where(assemblyFolder => FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))\n+                _filesInDirectories = assemblyFoldersFromConfig.Select(assemblyFolder => executionContext.GetFullPath(assemblyFolder.DirectoryPath)).AsParallel()",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NormalizePath just calls GetFullPath then FixFilePath. Simplify?",
              "createdAt": "2021-04-18T15:24:22Z",
              "path": "src/Tasks/AssemblyDependency/HintPathResolver.cs",
              "diffHunk": "@@ -57,7 +65,7 @@ public override bool Resolve\n             // However, we should consider Trim() the hintpath https://github.com/microsoft/msbuild/issues/4603\n             if (!string.IsNullOrEmpty(hintPath) && !FileUtilities.PathIsInvalid(hintPath))\n             {\n-                if (ResolveAsFile(FileUtilities.NormalizePath(hintPath), assemblyName, isPrimaryProjectReference, wantSpecificVersion, true, assembliesConsideredAndRejected))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nope, _executionContext.GetFullPath sometimes, if we do not have any execution context, should not absolutize the path. This is to keep previous behavior as an escape hatch when we do not use RAR as a service. ",
              "createdAt": "2021-04-19T17:21:17Z",
              "path": "src/Tasks/AssemblyDependency/HintPathResolver.cs",
              "diffHunk": "@@ -57,7 +65,7 @@ public override bool Resolve\n             // However, we should consider Trim() the hintpath https://github.com/microsoft/msbuild/issues/4603\n             if (!string.IsNullOrEmpty(hintPath) && !FileUtilities.PathIsInvalid(hintPath))\n             {\n-                if (ResolveAsFile(FileUtilities.NormalizePath(hintPath), assemblyName, isPrimaryProjectReference, wantSpecificVersion, true, assembliesConsideredAndRejected))",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is calling GetFullPath twice. Simplify? (Same for other occurrences.)",
              "createdAt": "2021-04-18T15:25:16Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -438,7 +445,7 @@ string assemblyFileName\n \n             if (!Path.IsPathRooted(assemblyFileName))\n             {\n-                reference.FullPath = Path.GetFullPath(assemblyFileName);\n+                reference.FullPath = Path.GetFullPath(_executionContext.GetFullPath(assemblyFileName));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nope, _executionContext.GetFullPath sometimes, if we do not have any execution context, should not absolutize the path. This is to keep previous behavior as an escape hatch when we do not use RAR as a service. Maybe I should rename the func to clarify this.",
              "createdAt": "2021-04-19T17:19:45Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -438,7 +445,7 @@ string assemblyFileName\n \n             if (!Path.IsPathRooted(assemblyFileName))\n             {\n-                reference.FullPath = Path.GetFullPath(assemblyFileName);\n+                reference.FullPath = Path.GetFullPath(_executionContext.GetFullPath(assemblyFileName));",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Maybe renaming to _executionContext.MapPath can imply it is not just FullPath what can happen.",
              "createdAt": "2021-05-03T23:34:06Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -438,7 +445,7 @@ string assemblyFileName\n \n             if (!Path.IsPathRooted(assemblyFileName))\n             {\n-                reference.FullPath = Path.GetFullPath(assemblyFileName);\n+                reference.FullPath = Path.GetFullPath(_executionContext.GetFullPath(assemblyFileName));",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this be an auto-property?",
              "createdAt": "2021-04-18T15:26:39Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -777,6 +786,16 @@ public string[] FullFrameworkFolders\n             }\n         }\n \n+        /// <summary>\n+        /// Execution context used when task is supposed to run concurrently in multiple threads.\n+        /// If null hosting process do not run this task concurrently and set it execution context on process level.\n+        /// </summary>\n+        public TaskExecutionContext ConcurrencyExecutionContext",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: private",
              "createdAt": "2021-04-18T15:56:22Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3049,5 +3074,60 @@ public override bool Execute()\n         }\n \n         #endregion\n+\n+        void IConcurrentTask.ConfigureForConcurrentExecution(TaskExecutionContext executionContext)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is almost identical to FileUtilities.GetFullPath, though that does some extra escaping/unescaping. Do you think any of that is necessary here, and if so, should we just call that?",
              "createdAt": "2021-04-18T16:09:26Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension\n+    {\n+        /// <summary>\n+        /// Absolutize the given path with the startup directory.\n+        /// </summary>\n+        /// <param name=\"taskExecutionContext\"></param>\n+        /// <param name=\"path\">Relative or absolute path.</param>\n+        /// <returns></returns>\n+        public static string GetFullPath(this TaskExecutionContext taskExecutionContext,  string path)\n+        {\n+            if (String.IsNullOrEmpty(taskExecutionContext.StartupDirectory) || String.IsNullOrEmpty(path))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "FileUtilities.GetFullPath take path and if it is relative absolutize it based on running process 'current directory' while\r\nmethod takes path and if it is relative absolutize it based on taskExecutionContext.StartupDirectory.\r\n@Forgind  What escaping do you have on mind on particular?",
              "createdAt": "2021-04-18T23:40:46Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension\n+    {\n+        /// <summary>\n+        /// Absolutize the given path with the startup directory.\n+        /// </summary>\n+        /// <param name=\"taskExecutionContext\"></param>\n+        /// <param name=\"path\">Relative or absolute path.</param>\n+        /// <returns></returns>\n+        public static string GetFullPath(this TaskExecutionContext taskExecutionContext,  string path)\n+        {\n+            if (String.IsNullOrEmpty(taskExecutionContext.StartupDirectory) || String.IsNullOrEmpty(path))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "FileUtilities.GetFullPath gives absolute path using the wrong current directory, without virtualization. Here we use taskExecutionContext.StartupDirectory as our current directory to complete the relative path (if it exists).",
              "createdAt": "2021-04-19T17:16:37Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension\n+    {\n+        /// <summary>\n+        /// Absolutize the given path with the startup directory.\n+        /// </summary>\n+        /// <param name=\"taskExecutionContext\"></param>\n+        /// <param name=\"path\">Relative or absolute path.</param>\n+        /// <returns></returns>\n+        public static string GetFullPath(this TaskExecutionContext taskExecutionContext,  string path)\n+        {\n+            if (String.IsNullOrEmpty(taskExecutionContext.StartupDirectory) || String.IsNullOrEmpty(path))",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "FileUtilities has an overload to let you specify currentDirectory:\r\nhttps://github.com/dotnet/msbuild/blob/369631b4b21ef485f4d6f35e16b0c839a971b0e9/src/Shared/FileUtilities.cs#L661-L680",
              "createdAt": "2021-04-19T17:18:37Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension\n+    {\n+        /// <summary>\n+        /// Absolutize the given path with the startup directory.\n+        /// </summary>\n+        /// <param name=\"taskExecutionContext\"></param>\n+        /// <param name=\"path\">Relative or absolute path.</param>\n+        /// <returns></returns>\n+        public static string GetFullPath(this TaskExecutionContext taskExecutionContext,  string path)\n+        {\n+            if (String.IsNullOrEmpty(taskExecutionContext.StartupDirectory) || String.IsNullOrEmpty(path))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ohh. I wasn't aware of that. I believe this method is to be used during evaluation or other processing on unescaped data. Its name should be `GetFullPathEscaped`. Since changed code under review deals with already unescaped Task inputs, we can't use `FileUtilities.GetFullPath` for that matter.",
              "createdAt": "2021-04-20T18:54:55Z",
              "path": "src/Tasks/AssemblyDependency/TaskExecutionContextExtension.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public static class TaskExecutionContextExtension\n+    {\n+        /// <summary>\n+        /// Absolutize the given path with the startup directory.\n+        /// </summary>\n+        /// <param name=\"taskExecutionContext\"></param>\n+        /// <param name=\"path\">Relative or absolute path.</param>\n+        /// <returns></returns>\n+        public static string GetFullPath(this TaskExecutionContext taskExecutionContext,  string path)\n+        {\n+            if (String.IsNullOrEmpty(taskExecutionContext.StartupDirectory) || String.IsNullOrEmpty(path))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                rawFileNameCandidate = executionContext.GetFullPath(rawFileNameCandidate);\r\n```\r\nNIT: unnecessary empty lines",
              "createdAt": "2021-05-03T14:38:51Z",
              "path": "src/Tasks/AssemblyDependency/RawFilenameResolver.cs",
              "diffHunk": "@@ -54,8 +62,11 @@ public override bool Resolve\n             foundPath = null;\n             userRequestedSpecificFile = false;\n \n-            if (rawFileNameCandidate != null)\n-            {\n+            if (rawFileNameCandidate is object)\n+            {  \n+\n+                rawFileNameCandidate = executionContext.GetFullPath(rawFileNameCandidate);\n+",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please comment here the intent of using default TaskExecutionContext behavior i.e. using 'process current directory' for relative paths.",
              "createdAt": "2021-05-03T14:51:24Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1991,10 +2005,20 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader\n         )\n         {\n             bool success = true;\n+\n             MSBuildEventSource.Log.RarOverallStart();\n             {\n                 try\n                 {\n+                    if (_concurrencyExecutionContext is object)\n+                    {\n+                        AbsolutizePathsInInputs();\n+                    }\n+                    else\n+                    {\n+                        _concurrencyExecutionContext = new TaskExecutionContext();",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            Reference reference\r\n        )\r\n```",
              "createdAt": "2021-05-03T23:35:15Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -1266,8 +1273,7 @@ private void ResolveReference\n         (\n             AssemblyNameExtension assemblyName,\n             string rawFileNameCandidate,\n-            Reference reference\n-        )\n+            Reference reference)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      }
    ]
  }
}