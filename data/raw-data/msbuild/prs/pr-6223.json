{
  "number": 6223,
  "title": "Allow users that have certain special characters in their username to build successfully when using exec",
  "body": "Fixes https://dev.azure.com/devdiv/DevDiv/_workitems/edit/1264667\r\n\r\n### Context\r\nUsers with profile names that contain parens in them will never be able to succesfully build a program that calls `Exec` with any command. This is because exec does the following:\r\n1. Generate a cmd file in the users temp directory\r\n2. Calls `cmd /Q /D /C <path-to-temp-file>`\r\n\r\nThe problem with this is that running `cmd /C \"some command\"` does not work if the command has any parens in it. It needs to be escaped like so: `^(` and `^)`.\r\n\r\n### Changes Made\r\n- When user sets EscapeSpecialCharacters in the exec task (boolean parameter), we escape characters that need to be escaped when calling `cmd /c`. We preserve the original functionality of always removing spaces and escaping '^'\r\n- Added under changewave 16.10\r\n- Added documentation for it.\r\n\r\n### Testing\r\nAdded tests under exec_tests.cs\r\nTested this on my personal laptop with a `ben(dev)` account. Here's the output of those builds:\r\n\r\n#### Test Project\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net5.0</TargetFramework>\r\n    <RootNamespace>_1264667_special_char_in_username</RootNamespace>\r\n  </PropertyGroup>\r\n  \r\n  <Target Name=\"PreBuild\" BeforeTargets=\"PreBuildEvent\">\r\n    <Exec Command=\"ECHO Hello\" />\r\n  </Target>\r\n\r\n</Project>\r\n\r\n```\r\n\r\n#### Before\r\n```\r\nc:\\src\\repros\\1264667-special-char>\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\"\r\nMicrosoft (R) Build Engine version 16.9.0+57a23d249 for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nBuild started 3/3/2021 5:27:56 PM.\r\nProject \"c:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj\" on node 1 (default targets).\r\nPreBuild:\r\n  ECHO Hello\r\n  'C:\\Users\\ben' is not recognized as an internal or external command,\r\n  operable program or batch file.\r\nc:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj(10,5): error MSB3073: The command \"ECHO Hello\" exited wi\r\nth code 1.\r\nDone Building Project \"c:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj\" (default targets) -- FAILED.\r\n\r\n\r\nBuild FAILED.\r\n\r\n\"c:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj\" (default target) (1) ->\r\n(PreBuild target) ->\r\n  c:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj(10,5): error MSB3073: The command \"ECHO Hello\" exited\r\nwith code 1.\r\n\r\n    0 Warning(s)\r\n    1 Error(s)\r\n\r\nTime Elapsed 00:00:01.13\r\n\r\nc:\\src\\repros\\1264667-special-char>\r\n```\r\n\r\n#### After\r\n```\r\nc:\\src\\repros\\1264667-special-char>\"C:\\src\\git\\msbuild\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\MSBuild.exe\"\r\nMicrosoft (R) Build Engine version 16.10.0-dev-21153-01+9084023d9 for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nBuild started 3/3/2021 5:30:00 PM.\r\nProject \"c:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj\" on node 1 (default targets).\r\nPreBuild:\r\n  ECHO Hello\r\n  Hello\r\nGenerateTargetFrameworkMonikerAttribute:\r\nSkipping target \"GenerateTargetFrameworkMonikerAttribute\" because all output files are up-to-date with respect to the i\r\nnput files.\r\nCoreGenerateAssemblyInfo:\r\nSkipping target \"CoreGenerateAssemblyInfo\" because all output files are up-to-date with respect to the input files.\r\nCoreCompile:\r\nSkipping target \"CoreCompile\" because all output files are up-to-date with respect to the input files.\r\n_CreateAppHost:\r\nSkipping target \"_CreateAppHost\" because all output files are up-to-date with respect to the input files.\r\n_CopyOutOfDateSourceItemsToOutputDirectory:\r\nSkipping target \"_CopyOutOfDateSourceItemsToOutputDirectory\" because all output files are up-to-date with respect to th\r\ne input files.\r\nGenerateBuildDependencyFile:\r\nSkipping target \"GenerateBuildDependencyFile\" because all output files are up-to-date with respect to the input files.\r\nGenerateBuildRuntimeConfigurationFiles:\r\nSkipping target \"GenerateBuildRuntimeConfigurationFiles\" because all output files are up-to-date with respect to the in\r\nput files.\r\nCopyFilesToOutputDirectory:\r\n  1264667-special-char -> c:\\src\\repros\\1264667-special-char\\bin\\Debug\\net5.0\\1264667-special-char.dll\r\nDone Building Project \"c:\\src\\repros\\1264667-special-char\\1264667-special-char.csproj\" (default targets).\r\n\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:01.45\r\n\r\nc:\\src\\repros\\1264667-special-char>\r\n```\r\n\r\n### Notes\r\nConsidering working more on exec, that task (and tooltask for that matter) could use a lot of sprucing up.",
  "state": "MERGED",
  "createdAt": "2021-03-04T01:42:47Z",
  "updatedAt": "2021-04-08T16:10:28Z",
  "closedAt": "2021-04-08T16:10:28Z",
  "mergedAt": "2021-04-08T16:10:28Z",
  "additions": 226,
  "deletions": 12,
  "changedFiles": 5,
  "headRefName": "fix-tooltask-escape-parentheses",
  "isDraft": false,
  "author": {
    "login": "benvillalobos"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open",
    "changewave16.10"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1314a77de8e0f50425dcef6468ab3b586f366051",
          "message": "Initial fix. Escape parentheses that exist in the path of the generated cmd file",
          "committedDate": "2021-03-04T01:06:55Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9084023d94e76e54b07814b407a00f71a8999080",
          "message": "Replace both parens at the same time",
          "committedDate": "2021-03-04T01:24:08Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19c9e4c1499415134a04f813bb4069acac600a59",
          "message": "Add test case for parentheses. Escape all instances of parens or &",
          "committedDate": "2021-03-05T23:52:18Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "94dde5c73d822e4f2c30263227c909b82578fe58",
          "message": "Clean up unit test",
          "committedDate": "2021-03-08T03:20:41Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7ce00b3c780463c78d4f7bc2c6928d786ab562d3",
          "message": "Name folder generated in TEMP as 'MSBuild' instead of 'Temporary'",
          "committedDate": "2021-03-08T03:21:59Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95fca99f19e396cedb0d36ab928b785fea246f25",
          "message": "This fix is specifically for windows",
          "committedDate": "2021-03-08T03:29:01Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "34126e14765441c83ca8a8c982117c8914629073",
          "message": "Append characters one at a time.",
          "committedDate": "2021-03-08T17:16:37Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c5a2b3a8510780c775bc4c97e597188dc3be460",
          "message": "Update src/Tasks/Exec.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-03-08T18:50:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c268b32e10c7cbe4a4542f2c7ae3c77459bf792e",
          "message": "Revert \"Name folder generated in TEMP as 'MSBuild' instead of 'Temporary'\"\n\nThis reverts commit 7ce00b3c780463c78d4f7bc2c6928d786ab562d3.",
          "committedDate": "2021-03-10T22:45:36Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7b58784e671485c50716f7c33d33561bacb933bc",
          "message": "Add metadata that allows users to set special characters to escape.",
          "committedDate": "2021-03-29T18:51:13Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "803cadfc9eb61abc4a9c5c5ad7ec4b9d812cc723",
          "message": "Add test cases",
          "committedDate": "2021-03-29T19:18:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aff34258ffce702ef8486d070931834fab2ecf2f",
          "message": "Add non-windows OS failing traits for end to end test",
          "committedDate": "2021-03-29T19:28:29Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d07c7d608e9577748ff4c0a14f08613dbeab1f4",
          "message": "PR Feedback: Improve performance by using an array instead of a hashset. Change task parameter to boolean",
          "committedDate": "2021-04-02T22:58:57Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e2d8c0c352ebfa6b4aa68af765b67ccb3bdc9353",
          "message": "Fix parens for checking whether or not to escape the '&'",
          "committedDate": "2021-04-02T23:02:14Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "828dedc463992175c0989e3475eedad058b9e71c",
          "message": "Move ampersand and space to the end of the array. User _shouldnt_ have any in their path as its handled earlier. Keeping it because if they end up in the file exec will fail.",
          "committedDate": "2021-04-02T23:05:23Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11c0021cc52660906ae2b9f5e0cdd7f32f4143d9",
          "message": "Simplify equals check",
          "committedDate": "2021-04-05T15:20:22Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73e8c5cd9bf5122d0dda16d27b2bf2c9d6d872b9",
          "message": "Ampersand and space cases are already handled.",
          "committedDate": "2021-04-05T15:29:38Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9cca2dbb3d360c9abab92c404ff0217a0a8d814f",
          "message": "Add escaping under changewave 16.10",
          "committedDate": "2021-04-05T17:41:40Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e05b2e14f272f51aa9ee5c2ffc36e95ae9523c39",
          "message": "Add to changewave documentation",
          "committedDate": "2021-04-05T23:13:41Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ef369fb619b1d49fe23493d0c8d11915e61c0560",
          "message": "PR Feedback: make characters to escape static. Remove unnecessary test",
          "committedDate": "2021-04-06T20:02:42Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee791119cd427012cfed5ca14629924b6bf5cd63",
          "message": "Avoid stringbuilder allocation until necessary",
          "committedDate": "2021-04-06T21:02:01Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "674dccdc1fd78cb8953b06e3e9d9c4ed9e0c8ee6",
          "message": "Merge branch 'main' into fix-tooltask-escape-parentheses",
          "committedDate": "2021-04-06T22:01:03Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "~~Note to self: There are other areas to change the folder to `MSBuild`~~ Won't do in this PR.",
        "createdAt": "2021-03-10T16:33:56Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "yes let\u2019s do one thing at a time, fix TEMP separately",
        "createdAt": "2021-03-10T22:45:26Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Looking for one more signoff (of latest changes). /cc: @ladipro @KirillOsenkov @cdmihai \r\n\r\nPrevious implementation:\r\n1. Users set a `CharactersToEscape` to something like \"()&\", those characters are escaped.\r\n2. Implementation is the characters get placed into a hashset that we check contains on\r\n\r\nCurrent implementation:\r\n1. User sets a `EscapeSpecialCharacters` boolean on the exec task that escapes specific characters that need to be escaped. The characters that need to be escaped were tested individually and taken from `help cmd`. \r\n2. Implementation is an array of characters which is _much_ faster than the hashset implementation.\r\n\r\nNathan asked a perfectly valid question, whether or not we always want to escape these characters. Which...we totally should but this code has been this way for 5+ years. A case can be made for putting this under a changewave and _always_ escaping these characters.",
        "createdAt": "2021-04-05T17:02:27Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "After chatting with marc and nathan a bit. I'm putting this under a changewave rather than an opt-in because there is no case where users having special characters in their username that will result in a successful run of exec. It's under a changewave because we are \"changing\" how these temp files have been generated for 5+ years.\r\n\r\nDefault case will be: Escape all special characters (listed under `help cmd`) that need escaping, except `^`, the escape character.",
        "createdAt": "2021-04-05T17:44:17Z",
        "author": {
          "login": "benvillalobos"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Why aren't you just escaping all instances of `(`/`)` without preceding `^`? Seems like you'll miss some this way in, for instance, `ben(dev^(atMS^))`",
              "createdAt": "2021-03-05T21:19:34Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -617,6 +617,15 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n                         batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    // cmd needs parens to be escaped when executing files with the /C flag.\n+                    // consider the case where the user has a parenthesis in ther username (which is uncommon, but valid)\n+                    if ((batchFileForCommandLine.Contains(\"(\") && !batchFileForCommandLine.Contains(\"^(\")) || (batchFileForCommandLine.Contains(\")\") && !batchFileForCommandLine.Contains(\"^)\")))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "While we're here, this was always bugging me. Should we have a root folder \"MSBuild\" inside TEMP, and stick all our stuff inside that? Otherwise you can't attribute to which process a given file belongs to. Just being good citizens of TEMP. Maybe replace Temporary with MSBuild (and have a subfolder).\r\n\r\nSee https://github.com/dotnet/msbuild/issues/6219",
              "createdAt": "2021-03-06T21:01:27Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -19,9 +19,10 @@ internal static partial class FileUtilities\n         /// Caller must delete when finished.\n         /// </summary>\n         /// <param name=\"createDirectory\"></param>\n-        internal static string GetTemporaryDirectory(bool createDirectory = true)\n+        /// <param name=\"subfolder\"></param>\n+        internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"));\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Might that trip some customers into a path-too-long situation?",
              "createdAt": "2021-03-22T17:39:04Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -19,9 +19,10 @@ internal static partial class FileUtilities\n         /// Caller must delete when finished.\n         /// </summary>\n         /// <param name=\"createDirectory\"></param>\n-        internal static string GetTemporaryDirectory(bool createDirectory = true)\n+        /// <param name=\"subfolder\"></param>\n+        internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"));\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is flaky, if the number of temp files in the directory changes during the run we'll fail and it'll be hard to investigate.\r\n\r\nIn general, I think we should have a single folder under TEMP, \"MSBuild\", and have everything under that folder. Maybe tests should use \"MSBuildTest\" to keep it separate. We should never enumerate the root of TEMP as it might be huge and some files might be locked, files are created and deleted and renamed there all the time.",
              "createdAt": "2021-03-06T21:03:46Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -48,6 +48,38 @@ private ExecWrapper PrepareExecWrapper(string command)\n             return exec;\n         }\n \n+        [Fact]\n+        public void EscapeParenthesesInPathToGeneratedBatchFile()\n+        {\n+            using (var testEnvironment = TestEnvironment.Create())\n+            {\n+                // This test counts files in TEMP. If it uses the system TEMP, some\n+                // other process may interfere. Use a private TEMP instead.\n+                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder(\"hello()wo(rld)\").TempPath;\n+\n+                string tempPath = Path.GetTempPath();\n+                Assert.StartsWith(newTempPath, tempPath);\n+\n+                // Get a count of how many temp files there are right now.\n+                string[] tempFiles = Directory.GetFiles(tempPath);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "My question is why you're doing this in the first place. We care about Exec succeeding and producing the correct output, but I wouldn't bother with verifying we don't have garbage lying around\u2014that has nothing to do with your change.",
              "createdAt": "2021-03-07T05:26:42Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -48,6 +48,38 @@ private ExecWrapper PrepareExecWrapper(string command)\n             return exec;\n         }\n \n+        [Fact]\n+        public void EscapeParenthesesInPathToGeneratedBatchFile()\n+        {\n+            using (var testEnvironment = TestEnvironment.Create())\n+            {\n+                // This test counts files in TEMP. If it uses the system TEMP, some\n+                // other process may interfere. Use a private TEMP instead.\n+                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder(\"hello()wo(rld)\").TempPath;\n+\n+                string tempPath = Path.GetTempPath();\n+                Assert.StartsWith(newTempPath, tempPath);\n+\n+                // Get a count of how many temp files there are right now.\n+                string[] tempFiles = Directory.GetFiles(tempPath);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This was leftover logic I forgot to get rid of.",
              "createdAt": "2021-03-08T03:27:31Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -48,6 +48,38 @@ private ExecWrapper PrepareExecWrapper(string command)\n             return exec;\n         }\n \n+        [Fact]\n+        public void EscapeParenthesesInPathToGeneratedBatchFile()\n+        {\n+            using (var testEnvironment = TestEnvironment.Create())\n+            {\n+                // This test counts files in TEMP. If it uses the system TEMP, some\n+                // other process may interfere. Use a private TEMP instead.\n+                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder(\"hello()wo(rld)\").TempPath;\n+\n+                string tempPath = Path.GetTempPath();\n+                Assert.StartsWith(newTempPath, tempPath);\n+\n+                // Get a count of how many temp files there are right now.\n+                string[] tempFiles = Directory.GetFiles(tempPath);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we do `\"MSBuild\", Guid...` so that MSBuild is its own directory, and Guids are subdirectories within it?",
              "createdAt": "2021-03-08T04:09:34Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -22,7 +22,7 @@ internal static partial class FileUtilities\n         /// <param name=\"subfolder\"></param>\n         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"MSBuild\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Also modify any similar methods (if they exist)?",
              "createdAt": "2021-03-08T16:44:21Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -22,7 +22,7 @@ internal static partial class FileUtilities\n         /// <param name=\"subfolder\"></param>\n         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"MSBuild\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Currently changing the name to MSBuild here works, but there are places where this method could be called instead of Path.GetTempDirectory (even within FileUtilities). Unfortunately this means changing a bunch of tests and I'd rather not piggy-back that onto this PR.\r\n\r\nI say we take this change and I can make a new PR that refactors `TempFileUtilities.cs`.\r\n\r\nIf not, I can revert the change to using the MSBuild folder and we can merge this PR as is.\r\n\r\nThoughts?",
              "createdAt": "2021-03-10T22:18:13Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -22,7 +22,7 @@ internal static partial class FileUtilities\n         /// <param name=\"subfolder\"></param>\n         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"MSBuild\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I just realized what you were asking for wasn't many `MSBuild<guid>` folders, but `temp/MSBuild/<all the guids folders>`. Given that this commit didn't actually help much, I'm going to revert it and _actually_ fix it in a different PR that's based off of this one.",
              "createdAt": "2021-03-10T22:43:47Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -22,7 +22,7 @@ internal static partial class FileUtilities\n         /// <param name=\"subfolder\"></param>\n         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"MSBuild\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "sounds great",
              "createdAt": "2021-03-10T22:44:47Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -22,7 +22,7 @@ internal static partial class FileUtilities\n         /// <param name=\"subfolder\"></param>\n         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"MSBuild\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "tracking this here: https://github.com/dotnet/msbuild/pull/6239",
              "createdAt": "2021-03-12T17:52:00Z",
              "path": "src/Shared/TempFileUtilities.cs",
              "diffHunk": "@@ -22,7 +22,7 @@ internal static partial class FileUtilities\n         /// <param name=\"subfolder\"></param>\n         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)\n         {\n-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"Temporary\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);\n+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), \"MSBuild\" + Guid.NewGuid().ToString(\"N\"), subfolder ?? string.Empty);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: no newline",
              "createdAt": "2021-03-08T16:35:51Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -48,6 +48,28 @@ private ExecWrapper PrepareExecWrapper(string command)\n             return exec;\n         }\n \n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-osx-failing\")]\n+        [Trait(\"Category\", \"netcore-linux-failing\")]\n+        public void EscapeParenthesesInPathToGeneratedBatchFile()\n+        {\n+            using (var testEnvironment = TestEnvironment.Create())\n+            {\n+                // This test counts files in TEMP. If it uses the system TEMP, some\n+                // other process may interfere. Use a private TEMP instead.\n+                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder(\"hello()wo(rld)\").TempPath;\n+\n+                string tempPath = Path.GetTempPath();\n+                Assert.StartsWith(newTempPath, tempPath);\n+\n+                // Now run the Exec task on a simple command.\n+                Exec exec = PrepareExec(\"echo Hello World!\");\n+                exec.Execute().ShouldBeTrue();\n+",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not append each character individually so you don't have to insert into the middle?\r\n\r\nAlso, why not start at 0?",
              "createdAt": "2021-03-08T16:42:43Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,22 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length).Append(batchFileForCommandLine);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for(int i = 1; i < fileName.Length; i++)\n+                    {\n+                        if((fileName[i] == '(' || fileName[i] == ')' || fileName[i] == '&') && fileName[i-1] != '^')\n+                        {\n+                            fileName.Insert(i++, '^');",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "also cache `fileName[i]` in a local char variable to save on access\r\nadd spaces around `[i - 1]` or format this area using Format Selection or Format Document",
              "createdAt": "2021-03-08T16:52:35Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,22 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length).Append(batchFileForCommandLine);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for(int i = 1; i < fileName.Length; i++)\n+                    {\n+                        if((fileName[i] == '(' || fileName[i] == ')' || fileName[i] == '&') && fileName[i-1] != '^')\n+                        {\n+                            fileName.Insert(i++, '^');",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Not starting at 0 here because we're on windows and `batchFileForComandLine` points to a `.cmd` file in the temp folder. It really should start at 3 to skip over `c:/`.",
              "createdAt": "2021-03-08T17:03:24Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,22 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length).Append(batchFileForCommandLine);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for(int i = 1; i < fileName.Length; i++)\n+                    {\n+                        if((fileName[i] == '(' || fileName[i] == ')' || fileName[i] == '&') && fileName[i-1] != '^')\n+                        {\n+                            fileName.Insert(i++, '^');",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\r\n```",
              "createdAt": "2021-03-08T18:41:37Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i > 0 && batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "For the record I can't think of a scenario that ever hits this when i == 0. I suppose users can set their temp path via env var, and could theoretically set it to `(...` where it should be local to whatever their working directory is I guess?\r\n\r\nTaking it as a \"likely never going to happen, but doesn't hurt\" change.",
              "createdAt": "2021-03-08T18:52:54Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i > 0 && batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "For the record\u2014I don't disagree, so I wouldn't mind if you reduced it to `batchFileForCommandLine[i - 1] != '^'`.",
              "createdAt": "2021-03-08T19:15:36Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i > 0 && batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this failing on other OSes? Does it need fixing there too?",
              "createdAt": "2021-03-13T17:28:03Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -48,6 +48,27 @@ private ExecWrapper PrepareExecWrapper(string command)\n             return exec;\n         }\n \n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Yes, but since we don't currently have a customer asking for it, BenVillalobos wanted to hold off on fixing it until we have feedback that it's needed.",
              "createdAt": "2021-03-13T17:58:39Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -48,6 +48,27 @@ private ExecWrapper PrepareExecWrapper(string command)\n             return exec;\n         }\n \n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`^` just before the character does not mean that the character is escaped. The escaped character may be `^` itself.\r\n\r\nExample: `^^(` the open paren won't be escaped.",
              "createdAt": "2021-03-15T14:52:24Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good point. @BenVillalobos, can you add something to verify that the previous character was not ^? And I think putting it behind a change wave is reasonable.",
              "createdAt": "2021-03-15T14:57:00Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Turns out there's some behavior I didn't expect with `cmd /C`. Check this out:\r\n\r\nNotice that having a carat escapes an open and closing parens?\r\n```\r\ncmd /C \"c:\\hello^()\\\"\r\n'c:\\hello()\\' is not recognized...\r\n```\r\n\r\nNot two open parens though.\r\n```\r\ncmd /C \"c:\\hello^(()\\\"\r\n'c:\\hello(' is not recognized...\r\n```\r\n\r\nWhat about some closed parens?\r\n```\r\nC:\\Users\\bevillal>cmd /C \"c:\\hello^)))))\\\"\r\n'c:\\hello)))))\\' is not recognized <--- What??\r\n```\r\n\r\nWhat if we put stuff inside the parens?\r\n```\r\ncmd /C \"c:\\hello^(ab^c)\\\"\r\n'c:\\hello(abc)\\' is not recognized\r\n```\r\n\r\nOkay so we keep parsing even after seeing a '^' between escaped parens. But not if those parens are escaped.\r\n```\r\nC:\\Users\\bevillal>cmd /C \"c:\\hello(ab^c)\\\"\r\n'c:\\hello' is not recognized\r\n```",
              "createdAt": "2021-03-19T23:36:48Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "### The plot thickens!\r\n\r\nSome more test cases I played with during standup.\r\n\r\n@marcpopMSFT suggested testing with `Program Files(x86)`, which was a great idea. I created c:/temp/test folder(x86) and... `cmd /C \"C:\\temp\\test folder(x86)\\a.txt\"` works.\r\n\r\nHere are some other variations:\r\n\r\nNo space in folder: `cmd /C \"C:\\temp\\testfolder(x86)\\a.txt\"`: `'C:\\temp\\testfolder' is not recognized`\r\nSpace and x86: `cmd /C \"C:\\temp\\test folder(x86)\\a.txt\"`: Works\r\nSpace and no x86: `cmd /C \"C:\\temp\\test folder(123)\\a.txt\"`: Works",
              "createdAt": "2021-03-22T19:18:48Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Sounds like everything is escaped if there's a space\u2014we're detecting that separately? If so, and you can find where that's happening, that might be a much easier fix: detect characters other than spaces in addition to spaces.",
              "createdAt": "2021-03-22T20:45:51Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> Sounds like everything is escaped if there's a space\r\n\r\nIf only \ud83d\ude15\r\n`cmd /C \"C:\\temp - Copy\\testfolder(x86)\\a^.txt\"` fails\r\n`cmd /C \"C:\\temp - Copy\\testfolder(x86)\\a(.txt\"` succeeds\r\n`cmd /C \"C:\\temp - Copy\\testfolder(x86)\\a(()()$.txt\"` succeeds.\r\nIt definitely breaks on unescaped `&` and `^`\r\n\r\nOther fun fact:\r\nCopy pasting a file called `a(()()$.txt` resulted in `a(()$ - Copy.txt` being generated.",
              "createdAt": "2021-03-22T23:45:28Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Notes from PR review, consider the following:\r\n- Consider just executing the file.\r\n- Have an optional metadata that either:\r\n\t- \tIs some string containing for specific characters to escape\r\n\t- \tIs some boolean flag that will escape all special characters except the escape character itself (or some variation of that to give a better user experience)\r\n- Is there some existing library to PInvoke into?\r\n- Consider what the `/S` flag does",
              "createdAt": "2021-03-23T15:49:29Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "The purpose of `/s` is apparently to handle commands that have quotes within them. Something like `cmd /s /c \"\"command1.exe\" > \"some/path with/spaces\"\"` (notice the quotes around the entire expression). It looks like if we passed `/s` and surrounded the entire command in an extra set of quotes, it would properly execute the batch file if it had parens, but not improperly escaped paths. So that's a no-go.\r\n\r\nI'll implement this by allowing a custom metadata string for \"characters to escape\". This is the most general solution that allows customers to fix issues with characters in their paths.",
              "createdAt": "2021-03-29T18:18:15Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "So I've implemented the custom metadata escaping, but accounting for items that are \"already escaped\" is something I'm willing to make an issue for and tackle that when the demand arises. There are too many niche scenarios to handle (see above) for a scenario that is much less likely to occur for customers.",
              "createdAt": "2021-03-29T19:21:47Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'm still in favor of making Exec just execute the command instead of writing and reading from a batch file, but at this point, it's probably better to wait for rainersigwald to tell us why that's a no-go. Will review this version instead.",
              "createdAt": "2021-04-02T16:47:28Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,12 +611,26 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any '(', ')', or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if ((c == '(' || c == ')' || c == '&') && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You said you wanted to put off fixing edge cases like not escaping a character preceded by an escaped ^, correct?",
              "createdAt": "2021-04-02T19:06:30Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Correct. at the moment we've only gotten a request for the parentheses case (user's username was something(dev) which seems reasonable). So this fix will account for _most_ other special characters, and I'll make an issue tracking that we don't account for '^''s that are already escaped and the other special cases that arise with it. If it gains traction we can worry about it then. For now this is a \"better than it was before\" PR.",
              "createdAt": "2021-04-02T21:22:17Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm thinking about performance here...this function should be fast, but the batch file could be huge, in which case this would be called an immense number of times. It would be nice to factor out things like the null check to make this particular function call even faster.\r\n\r\nIf you want it even faster, you could make a bit array representing the characters to escape (i.e., bit x is 1 iff (int)c is in _charactersToEscape) and check that instead of this HashSet. On the other hand, I wouldn't be surprised if there's an optimization to HashSet<char> to do just that, so it would be worth checking whether it makes a difference first.",
              "createdAt": "2021-04-02T19:11:51Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                        {\n+                            fileName.Append('^');\n+                        }\n+                        fileName.Append(c);\n+                    }\n+\n+                    batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            // Escape '&' to preserve previous functionality\n+            return c == '&' || (_charactersToEscape != null && _charactersToEscape.Contains(c));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Fair point. In theory we could swap the implementation from: \"Supply a set of the characters you want escaped\" to \"Escape all special characters (but if some are already escaped, or you fall into a specific edge case, you're out of luck)\".\r\n\r\nIf we have an array of the characters we know need to be escaped and the user sets \"TheMagicFlag\", we could iterate through the array and check `if ((c | specialChars[i]) == c)`.\r\n\r\nThoughts? /cc: @ladipro ",
              "createdAt": "2021-04-02T22:02:32Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                        {\n+                            fileName.Append('^');\n+                        }\n+                        fileName.Append(c);\n+                    }\n+\n+                    batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            // Escape '&' to preserve previous functionality\n+            return c == '&' || (_charactersToEscape != null && _charactersToEscape.Contains(c));",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Did some rough testing with stopwatches comparing hashset.contains with a for loop through an array of special characters that checks `if ((c | specialChars[i])==c)`. The loop/array beats out the hashset.contains by several orders of magnitude (in terms of ticks).",
              "createdAt": "2021-04-02T22:15:10Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                        {\n+                            fileName.Append('^');\n+                        }\n+                        fileName.Append(c);\n+                    }\n+\n+                    batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            // Escape '&' to preserve previous functionality\n+            return c == '&' || (_charactersToEscape != null && _charactersToEscape.Contains(c));",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Here I am on a weekend realizing \"wait, why not just do a simple comparison?\" I was incepted by the bit comment above \ud83d\ude05 ",
              "createdAt": "2021-04-04T17:30:18Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                        {\n+                            fileName.Append('^');\n+                        }\n+                        fileName.Append(c);\n+                    }\n+\n+                    batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            // Escape '&' to preserve previous functionality\n+            return c == '&' || (_charactersToEscape != null && _charactersToEscape.Contains(c));",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Also, (c | specialChars[i] == c) would actually be wrong if, for example, specialChars[i] were 0, it would always return true.",
              "createdAt": "2021-04-05T14:06:25Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -611,18 +624,38 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n \n                     // If for some crazy reason the path has a & character and a space in it\n                     // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n                     if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n                     {\n                         batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n                     }\n+\n+                    StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                    // Escape any characters specified by the CharactersToEscape metadata, or '&'\n+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                    {\n+                        char c = batchFileForCommandLine[i];\n+\n+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                        {\n+                            fileName.Append('^');\n+                        }\n+                        fileName.Append(c);\n+                    }\n+\n+                    batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            // Escape '&' to preserve previous functionality\n+            return c == '&' || (_charactersToEscape != null && _charactersToEscape.Contains(c));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Wondering how `IndexOf` would compare to the manual loop in terms of perf for such a small array.\r\n\r\n```suggestion\r\n            return Array.IndexOf(_charactersToEscape, c) != -1;\r\n```",
              "createdAt": "2021-04-06T11:08:41Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -609,20 +612,53 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n                     }\n                     commandLine.AppendSwitch(\"/C\"); // run then terminate\n \n-                    // If for some crazy reason the path has a & character and a space in it\n-                    // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n-                    if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                     {\n-                        batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                        // Escape special characters that need to be escaped.\n+                        for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                        {\n+                            char c = batchFileForCommandLine[i];\n+\n+                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                            {\n+                                fileName.Append('^');\n+                            }\n+                            fileName.Append(c);\n+                        }\n+                        batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n+                    }\n+                    else\n+                    {\n+                        // If for some crazy reason the path has a & character and a space in it\n+                        // then get the short path of the temp path, which should not have spaces in it\n+                        // and then escape the &\n+                        if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                        {\n+                            batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n+                            batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        }\n                     }\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            for (int i = 0; i < _charactersToEscape.Length; i++)\n+            {\n+                if (c == _charactersToEscape[i])\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            return false;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Did some rough testing here. On small cases (~200 iterations) the array performed marginally faster (about ~500 ticks). Array.IndexOf performs better under more iterations. But this was only when run ~10k+ times, which paths aren't likely to get to.\r\n\r\nThe more realistic case seems to be 150~250 characters, depending on temp and how long someone's username is. Will keep it as a for loop through the array.",
              "createdAt": "2021-04-06T20:08:29Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -609,20 +612,53 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n                     }\n                     commandLine.AppendSwitch(\"/C\"); // run then terminate\n \n-                    // If for some crazy reason the path has a & character and a space in it\n-                    // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n-                    if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                     {\n-                        batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                        // Escape special characters that need to be escaped.\n+                        for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                        {\n+                            char c = batchFileForCommandLine[i];\n+\n+                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                            {\n+                                fileName.Append('^');\n+                            }\n+                            fileName.Append(c);\n+                        }\n+                        batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n+                    }\n+                    else\n+                    {\n+                        // If for some crazy reason the path has a & character and a space in it\n+                        // then get the short path of the temp path, which should not have spaces in it\n+                        // and then escape the &\n+                        if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                        {\n+                            batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n+                            batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        }\n                     }\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            for (int i = 0; i < _charactersToEscape.Length; i++)\n+            {\n+                if (c == _charactersToEscape[i])\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            return false;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Note the \"average\" case looks something like this `C:\\\\Users\\\\username\\\\AppData\\\\Local\\\\Temp\\\\sh4yq5zn.hpc\\\\Temporary4476f4a8231944f0959781eebe164cdb\\\\hello()w]o(rld)\\\\tmpb547f707b5e34e4e9f9b5d49ac496be4.exec.cmd`",
              "createdAt": "2021-04-06T20:09:18Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -609,20 +612,53 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n                     }\n                     commandLine.AppendSwitch(\"/C\"); // run then terminate\n \n-                    // If for some crazy reason the path has a & character and a space in it\n-                    // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n-                    if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                     {\n-                        batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                        // Escape special characters that need to be escaped.\n+                        for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                        {\n+                            char c = batchFileForCommandLine[i];\n+\n+                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                            {\n+                                fileName.Append('^');\n+                            }\n+                            fileName.Append(c);\n+                        }\n+                        batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);\n+                    }\n+                    else\n+                    {\n+                        // If for some crazy reason the path has a & character and a space in it\n+                        // then get the short path of the temp path, which should not have spaces in it\n+                        // and then escape the &\n+                        if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                        {\n+                            batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n+                            batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        }\n                     }\n                 }\n \n                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);\n             }\n         }\n \n+        private bool ShouldEscapeCharacter(char c)\n+        {\n+            for (int i = 0; i < _charactersToEscape.Length; i++)\n+            {\n+                if (c == _charactersToEscape[i])\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            return false;",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`private static readonly`. No need to create an array per `Exec` instance as it is immutable.",
              "createdAt": "2021-04-06T11:12:52Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -54,6 +54,9 @@ public Exec()\n         private Encoding _standardOutputEncoding;\n         private string _command;\n \n+        // '^' before _any_ character escapes that character, don't escape it.\n+        private char[] _charactersToEscape = { '(', ')', '=', ';', '!', ',', '&', ' '};",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: If you wanted to squeeze a bit more perf out of this, you could acquire the StringBuilder first time you hit this line. Then in the common case of no escaping, there would be no StringBuilder and you wouldn't allocate a new string (allocation is happening inside `StringBuilderCache.GetStringAndRelease`).",
              "createdAt": "2021-04-06T11:18:01Z",
              "path": "src/Tasks/Exec.cs",
              "diffHunk": "@@ -609,20 +612,53 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens\n                     }\n                     commandLine.AppendSwitch(\"/C\"); // run then terminate\n \n-                    // If for some crazy reason the path has a & character and a space in it\n-                    // then get the short path of the temp path, which should not have spaces in it\n-                    // and then escape the &\n-                    if (batchFileForCommandLine.Contains(\"&\") && !batchFileForCommandLine.Contains(\"^&\"))\n+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                     {\n-                        batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);\n-                        batchFileForCommandLine = batchFileForCommandLine.Replace(\"&\", \"^&\");\n+                        StringBuilder fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);\n+\n+                        // Escape special characters that need to be escaped.\n+                        for (int i = 0; i < batchFileForCommandLine.Length; i++)\n+                        {\n+                            char c = batchFileForCommandLine[i];\n+\n+                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))\n+                            {\n+                                fileName.Append('^');",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}