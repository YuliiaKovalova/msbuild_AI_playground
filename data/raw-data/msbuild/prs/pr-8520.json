{
  "number": 8520,
  "title": "Proposal for secrets metadata feature",
  "body": "related to #8401\r\n\r\n### Context\r\nPreliminary design proposal for the Sensitivity Metadata feature\r\nThis PR is meant to be a form of design review\r\n",
  "state": "MERGED",
  "createdAt": "2023-03-02T12:51:18Z",
  "updatedAt": "2023-05-04T18:18:20Z",
  "closedAt": "2023-05-04T18:18:20Z",
  "mergedAt": "2023-05-04T18:18:20Z",
  "additions": 253,
  "deletions": 0,
  "changedFiles": 1,
  "headRefName": "doce/security-metadata",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Documentation",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d2072408f6f9a6535cab84dc2a316e1b628a155b",
          "message": "Initial proposal for secrets metadata feature",
          "committedDate": "2023-03-02T12:49:21Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7df2601f28b6fa2c6246c0986c244e99a9476f71",
          "message": "Reflect offline feedback from @rainersigwald",
          "committedDate": "2023-03-03T16:26:59Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c4393f4855266985cffb51d86e67dfe03ebc26b",
          "message": "Updating info",
          "committedDate": "2023-03-22T16:53:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ea3c2e36d48098e9341ab9d92767afcd9275dfbf",
          "message": "Incorporating offline feedback and ideas from @baronfel",
          "committedDate": "2023-03-24T13:52:10Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c81fda6997a2dcba7980317174d22182829733e",
          "message": "Add the suggested implementation",
          "committedDate": "2023-03-27T09:28:43Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5f9186c3bc87896247e422275ec65ef6d5d44d85",
          "message": "Reflect PR comments",
          "committedDate": "2023-04-04T18:15:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d31f4916b8a3a77867e3e48c69adcac45cb0b681",
          "message": "Reflect PR comments",
          "committedDate": "2023-04-04T18:24:46Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9eb12339f759ad8dc7d6d93d94e0d6425d0da46e",
          "message": "Move Doc",
          "committedDate": "2023-04-25T09:11:12Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Tagging @michaelcfanning as he has been researching and prototyping in this area quite extensively lately",
        "createdAt": "2023-03-06T18:41:04Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "@Forgind great thanks for feedback and thoughts!\r\n\r\n> Should we also permit redacting property/item names (not just the values) \r\n\r\nI'm strongly opposed to this :-)\r\nThis night look like being ok with having sensitive data within a source repository. The build logs are then not the main concern.\r\n\r\n> Is the idea that a Secrets would work a bit like a PropertyGroup but with preset things you can opt into redacting? (Looking at things like <GH_token /> and wondering how that works) \r\n\r\nExactly.\r\nThough - as mentioned - this is just longer term thinking that's likely subject to many changes (or withdrawal)\r\n\r\n> I'm wondering if it's ok to wait until events reach loggers before redacting. On the one hand, that's less secure. On the other hand, if we implement the redaction logic correctly in our loggers, and customers trust their own custom loggers, then everything will be reacted properly, and we can probably do that more efficiently than trying to look at every single message sent to a logger...which also makes it easy to miss things.\r\n\r\nIdeally we do not look on every single message - just the build events that we know were formed together using properties or items indicated as sensitive.\r\nOn the other hand within logger we already do not have this information - so we'd either need to change logging contract or inspect all events.\r\n\r\n\r\n> I'm thinking the custom plugin version might be the cleanest option but also the most difficult for a user to implement. I personally like the option you said was not recommended \ud83d\ude42 A single global property doesn't have great support for differing types, but we ultimately want to redact strings in various forms, so I think we could make it work, and properties are absurdly easy to set.\r\n\r\nThis is actually an interesting point. This might partly alleviate the problem with need to parse all properties and items prior start of redacting. It might be good idea to allow simple setting mode (fast failing if secrets indication used via items).\r\nI'm adding this thought into the doc\r\n",
        "createdAt": "2023-04-04T17:06:04Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> I'm strongly opposed to this :-)\r\nThis night look like being ok with having sensitive data within a source repository. The build logs are then not the main concern.\r\n\r\nThat's an interesting point. I certainly don't think you should have sensitive names within an OS repository. I'm less sure about how important it is within a closed source repo, especially as you might well have secret project names or function names, and those would also be exposed to anyone with access to the source. I'm currently ok with either solution \ud83d\ude42\r\n\r\n> On the other hand within logger we already do not have this information - so we'd either need to change logging contract or inspect all events.\r\n\r\nI think the worst case scenario is where we tell people that we have a new feature that hides secrets, but we also ensure that it isn't a breaking change. A customer logs some custom events, and we don't realize they contain secrets, and they end up un-redacted, but because the customer knows we hide secrets, they publish their log somewhere public. I don't think there's a perfect non-breaking solution here, so I think your proposal is reasonable; I'm just trying to think through places things could go wrong.",
        "createdAt": "2023-04-04T20:50:43Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "\r\n> I think the worst case scenario is where we tell people that we have a new feature that hides secrets, but we also ensure that it isn't a breaking change. A customer logs some custom events, and we don't realize they contain secrets, and they end up un-redacted, but because the customer knows we hide secrets, they publish their log somewhere public. I don't think there's a perfect non-breaking solution here, so I think your proposal is reasonable; I'm just trying to think through places things could go wrong.\r\n\r\nYes - this will allways be just best efforts (as frankly - ideally MSBuild doesn't handle secrets, there should be other means of handling auth/autz - valuts, roles, ...). We need to be clear about is, with clear messaging of what is not supported. Current proposal of not supported possibilities of spilling sensitive data: https://github.com/dotnet/msbuild/pull/8520/files#diff-fd2a314820444c86af18122afc82a49145ddbe37cd3730b7f3e5c01f86ff02cdR108-R113\r\nThat feels it covers the menstioned scenario - or do you think we should add something?",
        "createdAt": "2023-04-05T06:30:39Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": ">Out of scope [](http://example.com/codeflow?start=3&length=12)\r\n\r\nIn previous exploration, we explicitly excluded processing path information, as this is very copious in the processing stream. It is theoretically possible someone might encode a password in a source file or directory name but seems unlikely.",
              "createdAt": "2023-03-22T23:04:58Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -0,0 +1,146 @@\n+\n+# Security Metadata\n+\n+The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.\n+\n+It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal). Distinction here is that we want to give users option how to configure their build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.\n+\n+The feature is envisioned to be facilitated via global items and/or properties that will be masking logging of specific types of log entries.\n+\n+Out of scope vision contains categorization of tasks (e.g. 'trustworthy'/'unknown' and 'outputing input data'/'not outputing input data'/'unknown') and passing data marked as sensitive/secrets would not be allowed (would lead to build error) based on specific configurations tunable by user. So e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task).\n+\n+# Scope\n+\n+## In scope\n+ * Following data can be opted-in for redacting:\n+    * property values\n+    * item values\n+    * item metadata values\n+    * all item metadata\n+    * any combination of above\n+    * task OutputItems (? do we want to support this as additional data type? Can be hand in cases like [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))\n+ * Redacting the above select data from all log events (before they are being sent to loggers). Some examples of additional places where the data can propagate and hence attempted to be logged:   \n+    * task input parameters\n+    * task OutputItems (? do we want to support this as possible additional 'transformation' of property/item values? Possibly only when output is equal to the sensitive input) \n+    * referenced/evaluated environemnt variables\n+    * input command line\n+    * properties/items evalution - causing value to be transfered to a new holder (`<MyProp>$(SomeSecret)</MyProp>`)\n+\n+## Scope to be decided\n+ * concatentaing property with other values or flattening item values or transforming items and then passing via other property - should such be ignored or redacted as whole, or redacting just the part formed from the sensitive data?\n+ * values created via [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions) or [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions).\n+\n+## Out of scope",
              "author": {
                "login": "michaelcfanning"
              }
            },
            {
              "body": "Yeah - this is a good point. I can imagine someone would want to redact e.g. their login (https://github.com/dotnet/msbuild/issues/8493) - we need to find proper balance with acceptable performance (e.g. opt-in levels of redacting)",
              "createdAt": "2023-03-23T08:11:35Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -0,0 +1,146 @@\n+\n+# Security Metadata\n+\n+The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.\n+\n+It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal). Distinction here is that we want to give users option how to configure their build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.\n+\n+The feature is envisioned to be facilitated via global items and/or properties that will be masking logging of specific types of log entries.\n+\n+Out of scope vision contains categorization of tasks (e.g. 'trustworthy'/'unknown' and 'outputing input data'/'not outputing input data'/'unknown') and passing data marked as sensitive/secrets would not be allowed (would lead to build error) based on specific configurations tunable by user. So e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task).\n+\n+# Scope\n+\n+## In scope\n+ * Following data can be opted-in for redacting:\n+    * property values\n+    * item values\n+    * item metadata values\n+    * all item metadata\n+    * any combination of above\n+    * task OutputItems (? do we want to support this as additional data type? Can be hand in cases like [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))\n+ * Redacting the above select data from all log events (before they are being sent to loggers). Some examples of additional places where the data can propagate and hence attempted to be logged:   \n+    * task input parameters\n+    * task OutputItems (? do we want to support this as possible additional 'transformation' of property/item values? Possibly only when output is equal to the sensitive input) \n+    * referenced/evaluated environemnt variables\n+    * input command line\n+    * properties/items evalution - causing value to be transfered to a new holder (`<MyProp>$(SomeSecret)</MyProp>`)\n+\n+## Scope to be decided\n+ * concatentaing property with other values or flattening item values or transforming items and then passing via other property - should such be ignored or redacted as whole, or redacting just the part formed from the sensitive data?\n+ * values created via [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions) or [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions).\n+\n+## Out of scope",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": ">What [](http://example.com/codeflow?start=3&length=4)\r\n\r\nMy suggestion here is to allow a specific character for redaction, either 'X' or '?' are good options. We redact all or most of the secret while preserving the actual length of the redacted item. This is useful for binary log formats where we can't alter the size of any data element without compromising other indices into the data.\r\n\r\nLeaving the rightmost 6 chars is typically sufficient for users to definitively identify the exposure without exposing sufficient data for compromise. Some secret kinds (you've cited GH tokens, which are a good example) place their fixed signatures at the beginning of the token, so grabbing the rightmost sequence maximizes changes of getting the actually randomized portion.",
              "createdAt": "2023-03-22T23:10:54Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -0,0 +1,146 @@\n+\n+# Security Metadata\n+\n+The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.\n+\n+It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal). Distinction here is that we want to give users option how to configure their build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.\n+\n+The feature is envisioned to be facilitated via global items and/or properties that will be masking logging of specific types of log entries.\n+\n+Out of scope vision contains categorization of tasks (e.g. 'trustworthy'/'unknown' and 'outputing input data'/'not outputing input data'/'unknown') and passing data marked as sensitive/secrets would not be allowed (would lead to build error) based on specific configurations tunable by user. So e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task).\n+\n+# Scope\n+\n+## In scope\n+ * Following data can be opted-in for redacting:\n+    * property values\n+    * item values\n+    * item metadata values\n+    * all item metadata\n+    * any combination of above\n+    * task OutputItems (? do we want to support this as additional data type? Can be hand in cases like [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))\n+ * Redacting the above select data from all log events (before they are being sent to loggers). Some examples of additional places where the data can propagate and hence attempted to be logged:   \n+    * task input parameters\n+    * task OutputItems (? do we want to support this as possible additional 'transformation' of property/item values? Possibly only when output is equal to the sensitive input) \n+    * referenced/evaluated environemnt variables\n+    * input command line\n+    * properties/items evalution - causing value to be transfered to a new holder (`<MyProp>$(SomeSecret)</MyProp>`)\n+\n+## Scope to be decided\n+ * concatentaing property with other values or flattening item values or transforming items and then passing via other property - should such be ignored or redacted as whole, or redacting just the part formed from the sensitive data?\n+ * values created via [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions) or [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions).\n+\n+## Out of scope\n+ * spilling sensitive data via other means then logs (e.g. [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task))\n+ * passing values to task and explicit being logged there (this might be controversial for built in task - in case any is logging input values). TODO: we might want to consider revision of logging of some common tasks to form a better idea here.\n+ * passing values to task and there embedding into additional text and passing out\n+ \n+\n+# User interaction\n+\n+There needs to be a way how user specifies which data should be redacted from log. We have several options:\n+\n+ * [Not recomended] Denoting those via some metadata on a definition of the data to be redacted - this has two main drawbacks - a) For some data types (properties, metadata) we'd need new constructs how to attach additional info (property metadata; item meta-metadata). b) some data can be defined implicitly or dynamicaly\n+ * Global property - e.g. \n+   ```xml\n+   <DataToRedactFromLogs>Foo;Bar;Baz->SomeMetadata;MyItem->*</DataToRedactFromLogs>\n+   ```\n+   single property might look bit cryptic for denoting different data types\n+\n+ * Global item - e.g. \n+   ```xml\n+   <ItemGroup>\n+     <DataToRedactFromLogs Include=\"Foo\" Type=\"Property\">\n+     </DataToRedactFromLogs>\n+     <DataToRedactFromLogs Include=\"Bar\" Type=\"Item\" RedactValue=True>\n+     </DataToRedactFromLogs>\n+     <DataToRedactFromLogs Include=\"Baz\" Type=\"Item\" RedactValue=False Metadata=\"SomeMetadata\">\n+     </DataToRedactFromLogs>\n+     <DataToRedactFromLogs Include=\"MyItem\" Type=\"Item\" RedactValue=False Metadata=\"*\">\n+     </DataToRedactFromLogs>\n+   </ItemGroup>\n+   ```\n+   This can offer a more chatty, but better understandable (and possibly beter script generatable) way of denoting the redacting intent.\n+ * A regex on *value* to redact above discused data types based on their content - e.g.:\n+    ```xml\n+   <ItemGroup>\n+     <!-- Redact GH tokens based on https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available -->\n+     <DataToRedactFromLogs Include=\"ghp_[A-Za-z0-9_]\" Type=\"ValueRegex\">\n+     </DataToRedactFromLogs>\n+   </ItemGroup>\n+   ```\n+   This way we can give build architects a tool to define common `.props` files opting-in for redacting specific types strings known to be tokens/secrets/sensitive data, without the need to guess under which properties or items they would show within the build\n+* A custom plugin flagging values for redaction. e.g.:\n+    ```xml\n+   <ItemGroup>\n+     <DataToRedactFromLogs Include=\"MySecretsClassifier.dll,Contoso.Secrets.Classifier.ClassifySecrets\" Type=\"ValueClassifierPlugin\">\n+     </DataToRedactFromLogs>\n+   </ItemGroup>\n+   ```\n+\n+   where:\n+\n+   ```csharp\n+   Contoso.Secrets;\n+\n+   public class Classifier: IValueClassifier\n+   {\n+      public bool NeedsRedaction(string value) {/* Logic goes here */}\n+   }\n+   ```\n+   This option has additional security considerations, but allows most versatile secrets redaction.\n+\n+   The last option can possibly be allowed to be injected via other means, that MSBuild currently uses for injecting pluggable fnctionality (command line argument; environment variable; binary placed in a specific search location)\n+\n+\n+Only the first presented option is definitely not to be used. All the other options might possibly be used (up to a discussions if appropriate and what should be in scope). \n+\n+# Special considerations\n+\n+* There should be no (or very minimal) performance impact to cases where redacting is not opted-in and/or to cases where there is lower/minimal level of logging. In another words - we should not spend cycles detecting and redacting secrets on log events that are not going to be loged (todo: second case might be more problematic - as loggers can decide their level of logging).\n+* Order of processing and imports is important here - if we indicate secret metadata in items, the properties are processed first and hence we can miss preanalyzing (or even redacting) some data. Same applies for order of processing of the properties.\n+* Considering above two facts - we need a opt-in commandline switch or environemnt variable (or combination) to indicate that secrets metadata might be used - in which case we'll need to buffer build/log events before we have processed all the metadata indicating what needs to be redacted.\n+* There are no global items today - this can be simulated by putting those to directory.props\n+* Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) \n+* `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).\n+\n+# Suggested Implementation\n+\n+[TBD]\n+* For dynamic functionality we need to scan the data only on it's creation - so need to identify all ways of creating properties, items, metadata (including dynamic creation - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task))\n+* We need to have a global dictionary per data type, that will be used prior passing identified messages to loggers. For this reason we might choose not to support flattened/transformed/concatenated values (would this be acceptable?)\n+* Attempt to scan textual data for presence of the flagged values (e.g. to attempt to handle cases where data is passed into task and there possibly appended with other data and passed as output, or intercepting all log events produced by a task consuming a sensitive value) might get perf expensive and as well can get confused easily - e.g.:\n+\n+```xml\n+<ItemGroup>\n+  <DataToRedactFromLogs>MySecret</DataToRedactFromLogs>\n+  <MySecret>a</MySecret>\n+  <MyInnocentData>hahaha</MyInnocentData>\n+  <SomeProp></SomeProp>\n+</ItemGroup>\n+\n+<Target Name=\"Test\">\n+  <MyTask FirstInput=\"MySecret\" SecondInput=\"MyInnocentData\">\n+    <Output PropertyName=\"SomeProp\" TaskParameter=\"Result\">\n+  </MyTask>\n+  <!-- Might log: \n+       Result from task: h<redacted>h<redacted>h<redacted>\n+  -->\n+  <Message Text=\"Result from task: $(SomeProp)\">\n+</Target>\n+```\n+\n+Should we redact all occurences of value of `MySecret` from the task result? We might get a lot of false positives and very confusing results.\n+\n+# Open questions\n+ * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) ",
              "author": {
                "login": "michaelcfanning"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "One thing is clear, any replacement needs to be the precise length of the original sensitive data, otherwise we potentially break indices into the binary log format (depending on when the redaction occurs and whether those values are already computed). In other tooling, we tend to use either `?` or `X` as a redaction character. We also typically truncate or anonymize the redacted value, i.e., we retain the last 6 characters of the sensitive data in the replacement string. This provides enough information for users to understand what pattern is getting emitted where, without being enough exposed information for a malicious actor to exploit.",
              "createdAt": "2023-03-28T14:18:23Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -215,7 +227,7 @@ First two presented option are not to be used. All the other options will likely\n </Target>\n ```\n \n-Should we redact all occurences of value of `MySecret` from the task result? We might get a lot of false positives and very confusing results.\n+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.\n \n # Open questions\n  * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) - *very likely just a static pattern ('******').*",
              "author": {
                "login": "michaelcfanning"
              }
            },
            {
              "body": "Redacting prior sending to loggers should prevent missaligning or missindexing within logs.\r\n\r\nBut - as discussed offline - we should think about user-friendly-post-redaction-troubleshooting story - keeping portion of the secret, which is otherwise high-entropy, sounds as a good way. This might end up being available only for the built-in classifier.",
              "createdAt": "2023-03-28T16:36:40Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -215,7 +227,7 @@ First two presented option are not to be used. All the other options will likely\n </Target>\n ```\n \n-Should we redact all occurences of value of `MySecret` from the task result? We might get a lot of false positives and very confusing results.\n+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.\n \n # Open questions\n  * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) - *very likely just a static pattern ('******').*",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Any feature that allows for general customizability of regex patterns will have noise problems, yes. The latest token types, however, that are provided by many prominent security models (including all GitHub PATs and a large # of Azure provider tokens) are formatted in a way that reduces noise to extremely low levels. There is an enormous difference in accuracy between these prominent token types and other typical regex-driven security detections and we might want to plan for the distinction (because high-accuracy token types enable a broad range of features that are otherwise simply not practical for users).",
              "createdAt": "2023-03-28T14:21:07Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -215,7 +227,7 @@ First two presented option are not to be used. All the other options will likely\n </Target>\n ```\n \n-Should we redact all occurences of value of `MySecret` from the task result? We might get a lot of false positives and very confusing results.\n+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.",
              "author": {
                "login": "michaelcfanning"
              }
            },
            {
              "body": "Good point here.\r\n\r\nWe might end up not exposing the regex and plugin model for external usage; or we may open it with disclaimer of the perf implications and log messing are fully responsibility of users.\r\n\r\nPrimary mode of operation should be explicit indication of properties/items which are meant to hold secrets. Plus the built-in high-accuracy detection logic that will mainly serve for the feature discoverability by users (\"oh I got something redacted in my log - let me search why - oh, there is this feature and I can denote my secrets holders and then turn off the patterns scanning\") and bridging for the time until the feature is sufficiently addopted (this may very likely mean it will stick forever :-))",
              "createdAt": "2023-03-28T16:20:15Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -215,7 +227,7 @@ First two presented option are not to be used. All the other options will likely\n </Target>\n ```\n \n-Should we redact all occurences of value of `MySecret` from the task result? We might get a lot of false positives and very confusing results.\n+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We should double-check with @rokonec, I'm not sure this figure is correct. I thought it was more like a 40% slowdown (and this was only for the binary logging scenario. Logging to console and file was lower). We did not complete sufficient profiling in the binary logging case to understand whether we're looking at an intimidating floor as far as slowdown costs. Our prototype also uses the built-in .NET regex engine, by far the slowest option (between things like SRM, RE2, etc.). The .NET 7 platform (and its regex engine) looks like it will greatly improve time-to-execute for this scenario.",
              "createdAt": "2023-03-28T14:24:28Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -187,14 +188,25 @@ First two presented option are not to be used. All the other options will likely\n * There are no global items today - this can be simulated by putting those to directory.props\n * Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) \n * `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).\n+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).\n * Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).\n \n # Suggested Implementation\n \n-[TBD]\n-* For dynamic functionality we need to scan the data only on it's creation - so need to identify all ways of creating properties, items, metadata (including dynamic creation - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task))\n-* We need to have a global dictionary per data type, that will be used prior passing identified messages to loggers. For this reason we might choose not to support flattened/transformed/concatenated values (would this be acceptable?)\n-* Attempt to scan textual data for presence of the flagged values (e.g. to attempt to handle cases where data is passed into task and there possibly appended with other data and passed as output, or intercepting all log events produced by a task consuming a sensitive value) might get perf expensive and as well can get confused easily - e.g.:\n+* Need for explicit opt-in - command line switch or environment variable.\n+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.\n+  * In the future version - with first-class citizen type for secrets, we can possibly frontload single pass through the script just for detection of the secret redaction declarations and avoid the buffering and post-process need.\n+* Buffered events need to be post-processed in respect with the redaction requests, only then dispatched.\n+* We'll maintain lookup of elements requested for redaction - those explicitly requested by the name of property/item and those identified as sensitive by value or by transfer of value from other sensitive element.\n+* We'll intercept assigments of value to property ([`TrackPropertyWrite`](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L223)), item and task parameter\n+  * If value is assigned to a task parameter and such is indicated by user as sensitive, the holder of the value (the R-value - parameter/item being assigned to the task input) needs to be as well tracked as sensitive, otherwise build waring/error will be issued.\n+  * If value is assigned to a task parameter and such is not indicated by user as sensitive, but the holder of the value (the R-value - parameter/item being assigned to the task input) is tracked as sensitive (either because it was explicitly denoted by name, or it was later marked by MSBuild due to holding value matching a sensitivity value regex or callback) - a build warning/error will be issued.\n+  * If value is assigned to property/item from a task output and such is indicated by user as sensitive, the L-value holder of the value (the property/item being assigned to) need to be as well tracked as sensitive, otherwise build waring/error will be issued.\n+  * If value is being assigned to property or item\n+    * and such is indicated by user as sensitive, the generated build event needs to be redacted.\n+    * and such is not indicated by user as sensitive, but the R-value is indicated as sensitive - the data holder (property/item) is marked as holding sensitive data and treated accordingly.\n+    * and such is not indicated by user as sensitive, the value is passed to sensitivity indicating regex or callback (in case any of those are configured by user) and if matched - the data holder (property/item) is marked as holding sensitive data and treated accordingly.\n+* No other redacting of log events will be performed. This is not a strong requirement - we can introduce another opt-in level of strict inspection of all log events. The gain is very questionable though, while the performance impact is severe (internal experiments by @michaelcfanning measured by @rokonec indicate 4-times slow-down on mid-size build). Additionally to being perf-expensive, it can possibly get easily confused - e.g.:",
              "author": {
                "login": "michaelcfanning"
              }
            },
            {
              "body": "The measured slowdown ratios for protoype with 5 secret formats were 1.03 for binlog and 1.75 for the diagnostic level of text logger. the 4x possible slow down was estimated from the increase of the patterns #.\r\n\r\nThis can likely be tackled a lot, but still feels as candidate for extra opt-in (as compared to best-efforts quick solution scanning just most likely sources of input info).",
              "createdAt": "2023-03-28T16:13:58Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -187,14 +188,25 @@ First two presented option are not to be used. All the other options will likely\n * There are no global items today - this can be simulated by putting those to directory.props\n * Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) \n * `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).\n+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).\n * Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).\n \n # Suggested Implementation\n \n-[TBD]\n-* For dynamic functionality we need to scan the data only on it's creation - so need to identify all ways of creating properties, items, metadata (including dynamic creation - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task))\n-* We need to have a global dictionary per data type, that will be used prior passing identified messages to loggers. For this reason we might choose not to support flattened/transformed/concatenated values (would this be acceptable?)\n-* Attempt to scan textual data for presence of the flagged values (e.g. to attempt to handle cases where data is passed into task and there possibly appended with other data and passed as output, or intercepting all log events produced by a task consuming a sensitive value) might get perf expensive and as well can get confused easily - e.g.:\n+* Need for explicit opt-in - command line switch or environment variable.\n+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.\n+  * In the future version - with first-class citizen type for secrets, we can possibly frontload single pass through the script just for detection of the secret redaction declarations and avoid the buffering and post-process need.\n+* Buffered events need to be post-processed in respect with the redaction requests, only then dispatched.\n+* We'll maintain lookup of elements requested for redaction - those explicitly requested by the name of property/item and those identified as sensitive by value or by transfer of value from other sensitive element.\n+* We'll intercept assigments of value to property ([`TrackPropertyWrite`](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L223)), item and task parameter\n+  * If value is assigned to a task parameter and such is indicated by user as sensitive, the holder of the value (the R-value - parameter/item being assigned to the task input) needs to be as well tracked as sensitive, otherwise build waring/error will be issued.\n+  * If value is assigned to a task parameter and such is not indicated by user as sensitive, but the holder of the value (the R-value - parameter/item being assigned to the task input) is tracked as sensitive (either because it was explicitly denoted by name, or it was later marked by MSBuild due to holding value matching a sensitivity value regex or callback) - a build warning/error will be issued.\n+  * If value is assigned to property/item from a task output and such is indicated by user as sensitive, the L-value holder of the value (the property/item being assigned to) need to be as well tracked as sensitive, otherwise build waring/error will be issued.\n+  * If value is being assigned to property or item\n+    * and such is indicated by user as sensitive, the generated build event needs to be redacted.\n+    * and such is not indicated by user as sensitive, but the R-value is indicated as sensitive - the data holder (property/item) is marked as holding sensitive data and treated accordingly.\n+    * and such is not indicated by user as sensitive, the value is passed to sensitivity indicating regex or callback (in case any of those are configured by user) and if matched - the data holder (property/item) is marked as holding sensitive data and treated accordingly.\n+* No other redacting of log events will be performed. This is not a strong requirement - we can introduce another opt-in level of strict inspection of all log events. The gain is very questionable though, while the performance impact is severe (internal experiments by @michaelcfanning measured by @rokonec indicate 4-times slow-down on mid-size build). Additionally to being perf-expensive, it can possibly get easily confused - e.g.:",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just an implementation note, handling the command-line itself will be a special complication, this data is reflected back to the user early in logging for at least one logger (console, I think).",
              "createdAt": "2023-03-28T14:26:05Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -187,14 +188,25 @@ First two presented option are not to be used. All the other options will likely\n * There are no global items today - this can be simulated by putting those to directory.props\n * Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) \n * `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).\n+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).\n * Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).\n \n # Suggested Implementation\n \n-[TBD]\n-* For dynamic functionality we need to scan the data only on it's creation - so need to identify all ways of creating properties, items, metadata (including dynamic creation - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task))\n-* We need to have a global dictionary per data type, that will be used prior passing identified messages to loggers. For this reason we might choose not to support flattened/transformed/concatenated values (would this be acceptable?)\n-* Attempt to scan textual data for presence of the flagged values (e.g. to attempt to handle cases where data is passed into task and there possibly appended with other data and passed as output, or intercepting all log events produced by a task consuming a sensitive value) might get perf expensive and as well can get confused easily - e.g.:\n+* Need for explicit opt-in - command line switch or environment variable.\n+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.",
              "author": {
                "login": "michaelcfanning"
              }
            },
            {
              "body": "Right. Great point!\r\n\r\nIt's ome of the deffered messages (https://github.com/dotnet/msbuild/blob/main/src/MSBuild/XMake.cs#L1515-L1519) - that should be easy,\r\n\r\nWhat's more complicated is that it's emited to EventSource right after startup to anchor the run duration event: https://github.com/dotnet/msbuild/blob/main/src/MSBuild/XMake.cs#L655\r\n\r\nWe need to rethink this one - start and end events might possibly get just hash of commandline and there might be a separate event with the redacted commandline - as soon as it's available.",
              "createdAt": "2023-03-28T16:10:01Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -187,14 +188,25 @@ First two presented option are not to be used. All the other options will likely\n * There are no global items today - this can be simulated by putting those to directory.props\n * Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) \n * `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).\n+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).\n * Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).\n \n # Suggested Implementation\n \n-[TBD]\n-* For dynamic functionality we need to scan the data only on it's creation - so need to identify all ways of creating properties, items, metadata (including dynamic creation - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task))\n-* We need to have a global dictionary per data type, that will be used prior passing identified messages to loggers. For this reason we might choose not to support flattened/transformed/concatenated values (would this be acceptable?)\n-* Attempt to scan textual data for presence of the flagged values (e.g. to attempt to handle cases where data is passed into task and there possibly appended with other data and passed as output, or intercepting all log events produced by a task consuming a sensitive value) might get perf expensive and as well can get confused easily - e.g.:\n+* Need for explicit opt-in - command line switch or environment variable.\n+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We should build on the classifier interface. A string value presumably may be non-tokenized (a chunk of text) and may contain multiple sensitive tokens. If we don't return information on those individual tokens (for a string replacement), we can only redact the complete string value provided to us. Maybe something that returns a non-empty list of sensitive tokens that need to be replaced from the input.\r\n\r\n~~~\r\npublic ISet<string> NeedsRedaction(string value)\r\n~~~",
              "createdAt": "2023-03-28T15:01:15Z",
              "path": "documentation/design/security-metadata.md",
              "diffHunk": "@@ -187,14 +188,25 @@ First two presented option are not to be used. All the other options will likely\n * There are no global items today - this can be simulated by putting those to directory.props\n * Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) \n * `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).\n+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).\n * Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).\n \n # Suggested Implementation",
              "author": {
                "login": "michaelcfanning"
              }
            }
          ]
        }
      }
    ]
  }
}