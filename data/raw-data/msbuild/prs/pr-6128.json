{
  "number": 6128,
  "title": "Optimize property expansion",
  "body": "Fixes #6063\r\n\r\n### Context\r\nProperty expansion has been identified as one of the hot spots in project evaluation and `ExpandPropertiesLeaveEscaped` alone\r\naccounts for almost 20% of overall evaluation time of simple projects.\r\n\r\n### Changes Made\r\nSeveral optimizations have been made to the calltree under `ExpandPropertiesLeaveEscaped`. Notably:\r\n- Unnecessary and counter-productive string pinning has been removed.\r\n- A slow `strchr`-like function has been replaced with a simple call to `String.IndexOf`.\r\n- Series of `if`s have been replaced with a `switch`.\r\n- Allocation of `List<object> results` has been eliminated.\r\n- Allocation of temporary substrings extracted from the expression has been eliminated.\r\n\r\nThe combined performance win is 10% in `ExpandPropertiesLeaveEscaped`, so close to 2% for evaluation overall.\r\n\r\n### Testing\r\nExpander is well covered by existing unit tests.\r\n\r\n### Notes\r\nPlease review commit by commit for easier to read diffs.",
  "state": "MERGED",
  "createdAt": "2021-02-07T18:05:37Z",
  "updatedAt": "2021-03-03T09:53:02Z",
  "closedAt": "2021-03-03T09:53:02Z",
  "mergedAt": "2021-03-03T09:53:02Z",
  "additions": 265,
  "deletions": 163,
  "changedFiles": 4,
  "headRefName": "6063-faster-property-expansion",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "30d47eec9d7afe903baf1155b9947b8c00368f02",
          "message": "Simplify ScanForClosingParenthesis",
          "committedDate": "2021-02-10T11:58:08Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63dea112a65b2d74e21158b3216b42cb854c1e2d",
          "message": "Simplify ScanForClosingQuote",
          "committedDate": "2021-02-10T11:58:08Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "849c727957f13ad6fabe8d1e8578444b02c67749",
          "message": "Refactor ConvertToString",
          "committedDate": "2021-02-10T11:58:08Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "206e58686a400ec6d06a33c2a91a56f9241214ba",
          "message": "Remove lazy initialization of results (prep for more changes)",
          "committedDate": "2021-02-10T11:58:08Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "baf3373431653b9fe4760d68f3fc61c633595dfb",
          "message": "Add SpanBasedStringBuilder.Append(ReadOnlyMemory<char>)",
          "committedDate": "2021-02-10T11:58:08Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "96faf2ca20a1f8798797a97f47b2c4a1e124be1b",
          "message": "Add MaybeAdjustFilePath(ReadOnlyMemory<char>)",
          "committedDate": "2021-02-10T12:05:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "334033b8de35d8b7da302897842e13d10377d58f",
          "message": "Add Expander<P,I>.SpanBasedConcatenator",
          "committedDate": "2021-02-10T12:05:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86b65b7435d12462419f491c0763af21c4698da2",
          "message": "Use SpanBasedConcatenator in ExpandPropertiesLeaveTypedAndEscaped",
          "committedDate": "2021-02-10T12:05:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I feel like there was a rumor of eventually replacing Expander entirely, but I might be misremembering.",
        "createdAt": "2021-02-08T18:00:08Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I looked around, and what I found suggested no concrete plans\u2014just an idea:\r\nhttps://github.com/dotnet/msbuild/pull/5226#discussion_r402683435\r\n\r\nI was probably a little premature here \ud83d\ude42",
        "createdAt": "2021-02-08T23:24:24Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> Looks great! Did you get a sense of how many properties were being expanded that only had a single object?\r\n\r\nThat's a great question. When building a .NET Core hello world console app, out of 5632 invocations of `ExpandPropertiesLeaveTypedAndEscaped`,\r\n- 3002 don't expand any property (the string is a literal),\r\n- 2261 expand to just one property (e.g. `\"$(Prop)\"`), out of which 52 expands to a non-string value,\r\n- 122 expand to one property followed by a literal (e.g. `\"$(Prop)SomeString\"`),\r\n- 22 expand to one property prepended by a literal (e.g. `\"SomeString$(Prop)\"`),\r\n- 46 expand to one property followed and prepended by string literals (e.g. `\"Some$(Prop)String\"`),\r\n- 182 expand multiple properties (e.g. `\"$(Prop)and$(AnotherProp)\"`).",
        "createdAt": "2021-02-08T23:27:26Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: seeing how the flow in both Add methods is similar, is there a way to consolidate and parametrize the implementation?",
              "createdAt": "2021-02-08T11:33:52Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I'm afraid that the current shape of the two methods is the best we can do. The common part is already in its own helper `FlushFirstValueIfNeeded`.",
              "createdAt": "2021-02-08T14:22:41Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "very minor: 2 ternary operator opportunities in this method.\r\nExample:\r\n```\r\nreturn _firstObject is string stringValue ? FileUtilities.MaybeAdjustFilePath(stringValue) : _firstObject;\r\n```",
              "createdAt": "2021-02-08T11:37:05Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(span));\n+                }\n+                else\n+                {\n+                    _firstSpan = span;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Lazily initializes <see cref=\"_builder\"/> and populates it with the first value\n+            /// when the second value is being added.\n+            /// </summary>\n+            private void FlushFirstValueIfNeeded()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstObject.ToString()));\n+                    _firstObject = null;\n+                }\n+                else if (!_firstSpan.IsEmpty)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+#if FEATURE_SPAN\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan));\n+#else\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan.ToString()));\n+#endif\n+                    _firstSpan = new ReadOnlyMemory<char>();\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns the result of the concatenation.\n+            /// </summary>\n+            /// <returns>\n+            /// If only one value has been added and it is not a string, it is returned unchanged.\n+            /// In all other cases (no value, one string value, multiple values) the result is a\n+            /// concatenation of the string representation of the values, each additionally subjected\n+            /// to file path adjustment.\n+            /// </returns>\n+            public object GetResult()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    if (_firstObject is string stringValue)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Done, thanks!",
              "createdAt": "2021-02-08T14:22:48Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(span));\n+                }\n+                else\n+                {\n+                    _firstSpan = span;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Lazily initializes <see cref=\"_builder\"/> and populates it with the first value\n+            /// when the second value is being added.\n+            /// </summary>\n+            private void FlushFirstValueIfNeeded()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstObject.ToString()));\n+                    _firstObject = null;\n+                }\n+                else if (!_firstSpan.IsEmpty)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+#if FEATURE_SPAN\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan));\n+#else\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan.ToString()));\n+#endif\n+                    _firstSpan = new ReadOnlyMemory<char>();\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns the result of the concatenation.\n+            /// </summary>\n+            /// <returns>\n+            /// If only one value has been added and it is not a string, it is returned unchanged.\n+            /// In all other cases (no value, one string value, multiple values) the result is a\n+            /// concatenation of the string representation of the values, each additionally subjected\n+            /// to file path adjustment.\n+            /// </returns>\n+            public object GetResult()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    if (_firstObject is string stringValue)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should we test if the object has already been disposed prior to executing public method bodies?",
              "createdAt": "2021-02-08T11:37:47Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Done. Checking this invariant is relatively inexpensive.",
              "createdAt": "2021-02-08T14:21:34Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "would there be problems calling dispose multiple times on ```_builder```?",
              "createdAt": "2021-02-08T11:38:43Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(span));\n+                }\n+                else\n+                {\n+                    _firstSpan = span;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Lazily initializes <see cref=\"_builder\"/> and populates it with the first value\n+            /// when the second value is being added.\n+            /// </summary>\n+            private void FlushFirstValueIfNeeded()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstObject.ToString()));\n+                    _firstObject = null;\n+                }\n+                else if (!_firstSpan.IsEmpty)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+#if FEATURE_SPAN\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan));\n+#else\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan.ToString()));\n+#endif\n+                    _firstSpan = new ReadOnlyMemory<char>();\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns the result of the concatenation.\n+            /// </summary>\n+            /// <returns>\n+            /// If only one value has been added and it is not a string, it is returned unchanged.\n+            /// In all other cases (no value, one string value, multiple values) the result is a\n+            /// concatenation of the string representation of the values, each additionally subjected\n+            /// to file path adjustment.\n+            /// </returns>\n+            public object GetResult()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    if (_firstObject is string stringValue)\n+                    {\n+                        return FileUtilities.MaybeAdjustFilePath(stringValue);\n+                    }\n+                    return _firstObject;\n+                }\n+                if (!_firstSpan.IsEmpty)\n+                {\n+                    return FileUtilities.MaybeAdjustFilePath(_firstSpan).ToString();\n+                }\n+                return _builder?.ToString() ?? string.Empty;\n+            }\n+\n+            /// <summary>\n+            /// Disposes of the struct by delegating the call to the underlying <see cref=\"SpanBasedStringBuilder\"/>.\n+            /// </summary>\n+            public void Dispose() => _builder?.Dispose();",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "That `Dispose` call is idempotent. I have added the check for multiple `Dispose` calls, however, so it is now guaranteed to be executed at most once.",
              "createdAt": "2021-02-08T14:24:11Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,123 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(span));\n+                }\n+                else\n+                {\n+                    _firstSpan = span;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Lazily initializes <see cref=\"_builder\"/> and populates it with the first value\n+            /// when the second value is being added.\n+            /// </summary>\n+            private void FlushFirstValueIfNeeded()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstObject.ToString()));\n+                    _firstObject = null;\n+                }\n+                else if (!_firstSpan.IsEmpty)\n+                {\n+                    _builder = Strings.GetSpanBasedStringBuilder();\n+#if FEATURE_SPAN\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan));\n+#else\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan.ToString()));\n+#endif\n+                    _firstSpan = new ReadOnlyMemory<char>();\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns the result of the concatenation.\n+            /// </summary>\n+            /// <returns>\n+            /// If only one value has been added and it is not a string, it is returned unchanged.\n+            /// In all other cases (no value, one string value, multiple values) the result is a\n+            /// concatenation of the string representation of the values, each additionally subjected\n+            /// to file path adjustment.\n+            /// </returns>\n+            public object GetResult()\n+            {\n+                if (_firstObject != null)\n+                {\n+                    if (_firstObject is string stringValue)\n+                    {\n+                        return FileUtilities.MaybeAdjustFilePath(stringValue);\n+                    }\n+                    return _firstObject;\n+                }\n+                if (!_firstSpan.IsEmpty)\n+                {\n+                    return FileUtilities.MaybeAdjustFilePath(_firstSpan).ToString();\n+                }\n+                return _builder?.ToString() ?? string.Empty;\n+            }\n+\n+            /// <summary>\n+            /// Disposes of the struct by delegating the call to the underlying <see cref=\"SpanBasedStringBuilder\"/>.\n+            /// </summary>\n+            public void Dispose() => _builder?.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I was under the impression that this sort of thing was supposed to be fast. What makes IndexOf faster?",
              "createdAt": "2021-02-08T17:21:12Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -556,24 +556,8 @@ private static int ScanForClosingParenthesis(string expression, int index, out b\n         /// </summary>\n         private static int ScanForClosingQuote(char quoteChar, string expression, int index)\n         {\n-            unsafe\n-            {\n-                fixed (char* pchar = expression)\n-                {\n-                    // Scan for our closing quoteChar\n-                    while (index < expression.Length)\n-                    {\n-                        if (pchar[index] == quoteChar)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What we had here was a na\u00efve implementation of `IndexOf`. This is the real thing:\r\n\r\nhttps://github.com/dotnet/runtime/blob/1bff0cce7ba7de077c09e331d24e3b27c3779888/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Char.cs#L213-L493\r\n\r\nI bet it's faster because of 1) HW acceleration and 2) lack of pinning. Making character enumeration faster by pinning the string and accessing the `char *` with unsafe code might have been the case in very early versions of .NET but it is counter-productive now as it prevents the GC from moving the object.\r\n\r\nIt's OK to not use advanced vector code when writing custom specialized string search functions. But if the function is literally `IndexOf`, there is absolutely no reason why it shouldn't just call `IndexOf`.",
              "createdAt": "2021-02-08T20:48:41Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -556,24 +556,8 @@ private static int ScanForClosingParenthesis(string expression, int index, out b\n         /// </summary>\n         private static int ScanForClosingQuote(char quoteChar, string expression, int index)\n         {\n-            unsafe\n-            {\n-                fixed (char* pchar = expression)\n-                {\n-                    // Scan for our closing quoteChar\n-                    while (index < expression.Length)\n-                    {\n-                        if (pchar[index] == quoteChar)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I didn't realize the GC moves strings around\u2014presumably to reduce fragmentation? When I built my simplistic GC for a class, it tried to combine consecutive chunks of free memory to make larger chunks, but it certainly wouldn't move anything. I'm curious how much of an improvement that made, since less frequent GCs would presumably be partially balanced by the cost of moving things, though that's the sort of task computers excel at.",
              "createdAt": "2021-02-08T21:07:38Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -556,24 +556,8 @@ private static int ScanForClosingParenthesis(string expression, int index, out b\n         /// </summary>\n         private static int ScanForClosingQuote(char quoteChar, string expression, int index)\n         {\n-            unsafe\n-            {\n-                fixed (char* pchar = expression)\n-                {\n-                    // Scan for our closing quoteChar\n-                    while (index < expression.Length)\n-                    {\n-                        if (pchar[index] == quoteChar)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The .NET GC indeed moves objects. When promoting to a higher generation for example, as Gen0/1 and Gen2 are always in different segments.\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#what-happens-during-a-garbage-collection",
              "createdAt": "2021-02-08T21:55:17Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -556,24 +556,8 @@ private static int ScanForClosingParenthesis(string expression, int index, out b\n         /// </summary>\n         private static int ScanForClosingQuote(char quoteChar, string expression, int index)\n         {\n-            unsafe\n-            {\n-                fixed (char* pchar = expression)\n-                {\n-                    // Scan for our closing quoteChar\n-                    while (index < expression.Length)\n-                    {\n-                        if (pchar[index] == quoteChar)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I thought you were eliminating FEATURE_SPAN? And this is under the CLR2COMPATIBILITY check.",
              "createdAt": "2021-02-08T17:32:44Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -485,6 +485,42 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =\n             return shouldAdjust ? newValue.ToString() : value;\n         }\n \n+#if !CLR2COMPATIBILITY\n+        /// <summary>\n+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.\n+        /// This overload takes and returns ReadOnlyMemory of characters.\n+        /// </summary>\n+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = \"\")\n+        {\n+            if (NativeMethodsShared.IsWindows || value.IsEmpty)\n+            {\n+                return value;\n+            }\n+\n+            // Don't bother with arrays or properties or network paths.\n+            if (value.Length >= 2)\n+            {\n+                var span = value.Span;\n+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||\n+                    (span[1] == '\\\\' && span[0] == '\\\\'))\n+                {\n+                    return value;\n+                }\n+            }\n+\n+            // For Unix-like systems, we may want to convert backslashes to slashes\n+#if FEATURE_SPAN",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's correct. If #6130 is merged first, I'll tweak this PR to remove the ifdef. And vice versa.",
              "createdAt": "2021-02-08T20:50:12Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -485,6 +485,42 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =\n             return shouldAdjust ? newValue.ToString() : value;\n         }\n \n+#if !CLR2COMPATIBILITY\n+        /// <summary>\n+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.\n+        /// This overload takes and returns ReadOnlyMemory of characters.\n+        /// </summary>\n+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = \"\")\n+        {\n+            if (NativeMethodsShared.IsWindows || value.IsEmpty)\n+            {\n+                return value;\n+            }\n+\n+            // Don't bother with arrays or properties or network paths.\n+            if (value.Length >= 2)\n+            {\n+                var span = value.Span;\n+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||\n+                    (span[1] == '\\\\' && span[0] == '\\\\'))\n+                {\n+                    return value;\n+                }\n+            }\n+\n+            // For Unix-like systems, we may want to convert backslashes to slashes\n+#if FEATURE_SPAN",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have rebased this PR on top of current master and resolved conflicts.",
              "createdAt": "2021-02-10T14:33:01Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -485,6 +485,42 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =\n             return shouldAdjust ? newValue.ToString() : value;\n         }\n \n+#if !CLR2COMPATIBILITY\n+        /// <summary>\n+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.\n+        /// This overload takes and returns ReadOnlyMemory of characters.\n+        /// </summary>\n+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = \"\")\n+        {\n+            if (NativeMethodsShared.IsWindows || value.IsEmpty)\n+            {\n+                return value;\n+            }\n+\n+            // Don't bother with arrays or properties or network paths.\n+            if (value.Length >= 2)\n+            {\n+                var span = value.Span;\n+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||\n+                    (span[1] == '\\\\' && span[0] == '\\\\'))\n+                {\n+                    return value;\n+                }\n+            }\n+\n+            // For Unix-like systems, we may want to convert backslashes to slashes\n+#if FEATURE_SPAN",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks a little faster than in the method above, but it's a little harder to understand what it's trying to do, since $ on its own doesn't scream property at me, etc. Not saying you should change it; just making a note.",
              "createdAt": "2021-02-08T17:33:52Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -485,6 +485,42 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =\n             return shouldAdjust ? newValue.ToString() : value;\n         }\n \n+#if !CLR2COMPATIBILITY\n+        /// <summary>\n+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.\n+        /// This overload takes and returns ReadOnlyMemory of characters.\n+        /// </summary>\n+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = \"\")\n+        {\n+            if (NativeMethodsShared.IsWindows || value.IsEmpty)\n+            {\n+                return value;\n+            }\n+\n+            // Don't bother with arrays or properties or network paths.\n+            if (value.Length >= 2)\n+            {\n+                var span = value.Span;\n+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have added a comment. Thank you!",
              "createdAt": "2021-02-08T22:53:35Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -485,6 +485,42 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =\n             return shouldAdjust ? newValue.ToString() : value;\n         }\n \n+#if !CLR2COMPATIBILITY\n+        /// <summary>\n+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.\n+        /// This overload takes and returns ReadOnlyMemory of characters.\n+        /// </summary>\n+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = \"\")\n+        {\n+            if (NativeMethodsShared.IsWindows || value.IsEmpty)\n+            {\n+                return value;\n+            }\n+\n+            // Don't bother with arrays or properties or network paths.\n+            if (value.Length >= 2)\n+            {\n+                var span = value.Span;\n+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This might look nicer as a VerifyThrow operation instead.",
              "createdAt": "2021-02-08T17:46:37Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,141 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// True if this instance is already disposed.\n+            /// </summary>\n+            private bool _disposed;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                CheckDisposed();\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                CheckDisposed();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have added `ErrorUtilities.VerifyThrowObjectDisposed`. Please let me know what you think.",
              "createdAt": "2021-02-08T22:49:19Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,141 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// True if this instance is already disposed.\n+            /// </summary>\n+            private bool _disposed;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                CheckDisposed();\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                CheckDisposed();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "LGTM!",
              "createdAt": "2021-02-08T23:28:41Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,141 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion\n+        /// as used in e.g. property expansion.\n+        /// </summary>\n+        /// <remarks>\n+        /// If exactly one value is added and no concatenation takes places, this value is returned without\n+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths\n+        /// before concatenation.\n+        /// </remarks>\n+        private struct SpanBasedConcatenator : IDisposable\n+        {\n+            /// <summary>\n+            /// The backing <see cref=\"SpanBasedStringBuilder\"/>, null until the second value is added.\n+            /// </summary>\n+            private SpanBasedStringBuilder _builder;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator. Tracked in its own field so it can be returned\n+            /// without conversion if no concatenation takes place.\n+            /// </summary>\n+            private object _firstObject;\n+\n+            /// <summary>\n+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the\n+            /// <see cref=\"SpanBasedStringBuilder\"/> functionality doesn't have to be invoked if no concatenation\n+            /// takes place.\n+            /// </summary>\n+            private ReadOnlyMemory<char> _firstSpan;\n+\n+            /// <summary>\n+            /// True if this instance is already disposed.\n+            /// </summary>\n+            private bool _disposed;\n+\n+            /// <summary>\n+            /// Adds an object to be concatenated.\n+            /// </summary>\n+            public void Add(object obj)\n+            {\n+                CheckDisposed();\n+                FlushFirstValueIfNeeded();\n+                if (_builder != null)\n+                {\n+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));\n+                }\n+                else\n+                {\n+                    _firstObject = obj;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Adds a span to be concatenated.\n+            /// </summary>\n+            public void Add(ReadOnlyMemory<char> span)\n+            {\n+                CheckDisposed();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this need a CLR2 compatibility check?",
              "createdAt": "2021-02-08T17:57:24Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1125,7 +1125,7 @@ private static class PropertyExpander<T>\n                     // (but not including) the \"$(\", and advance the sourceIndex pointer.\n                     if (propertyStartIndex - sourceIndex > 0)\n                     {\n-                        results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));\n+                        results.Add(expression.AsMemory(sourceIndex, propertyStartIndex - sourceIndex));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It does not because `MSBuildTaskHost is not doing evaluation and this file is not compiled for CLR2. ",
              "createdAt": "2021-02-08T20:52:32Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1125,7 +1125,7 @@ private static class PropertyExpander<T>\n                     // (but not including) the \"$(\", and advance the sourceIndex pointer.\n                     if (propertyStartIndex - sourceIndex > 0)\n                     {\n-                        results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));\n+                        results.Add(expression.AsMemory(sourceIndex, propertyStartIndex - sourceIndex));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are there any other places that might benefit from this?",
              "createdAt": "2021-02-08T17:58:05Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,141 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It may find its use in other parts of `Expander`, although a cursory look through metadata and item expansion does not really suggest that they are suffering from the same problems. They actually look reasonable.\r\n\r\nIf I find other places where this may be useful I'll pull it out into its own top-level type, add functionality as needed, maybe rename, etc.",
              "createdAt": "2021-02-08T21:00:52Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -123,6 +123,141 @@ internal class Expander<P, I>\n         where P : class, IProperty\n         where I : class, IItem\n     {\n+        /// <summary>\n+        /// A helper struct wrapping a <see cref=\"SpanBasedStringBuilder\"/> and providing file path conversion",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}