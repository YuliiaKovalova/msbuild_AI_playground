{
  "number": 9387,
  "title": "Shorten UTD marker file",
  "body": "Fixes #9346, #7131\r\n\r\n### Context\r\nWith long project paths CopyUpToDate mareker file can get long and break build in VS as long file support is not on.\r\nThis is a proposal of short/mid term remedy by shortening the marker file path a bit. However it applies only to non-CPS cases and it applies to CopyUpToDate marker file only.\r\nConsidering those facts it's questionable if this should be part of the MSBuild repo.\r\nAlternatively we can decide to fix it more widely by renaming the `MSBuildCopyMarkerName` to `MSBuildProjectMarkerName` and use it in various other scenarios where marker/cache files are generated in a similar way - though that would have much higher breaking possibility.\r\n",
  "state": "MERGED",
  "createdAt": "2023-11-02T08:36:58Z",
  "updatedAt": "2023-12-02T09:52:03Z",
  "closedAt": "2023-11-30T09:18:28Z",
  "mergedAt": "2023-11-30T09:18:28Z",
  "additions": 154,
  "deletions": 37,
  "changedFiles": 4,
  "headRefName": "proto/shorten-utd-marker",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1772571dbee4bad6805fbe90ed558a1b09d98e5b",
          "message": "Shorten UTD marker file",
          "committedDate": "2023-11-02T08:34:13Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a4544cb4d4971772086f0f55f51385e6ea3e59a",
          "message": "Improve the StableStringHash intrinsic function and use it in the copy mareker filename",
          "committedDate": "2023-11-03T15:29:09Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8fe5c17fcf65a88c81b25d4885ef130b8da1790b",
          "message": "Unify FNV implementations",
          "committedDate": "2023-11-06T14:16:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "97ceb6aab29212942b4b4f1df65eb6a917bcc828",
          "message": "Merge branch 'dotnet:main' into proto/shorten-utd-marker",
          "committedDate": "2023-11-08T10:42:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "krivanek.j@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e02ba1c3aaaa3a33a7e704a7b173602588f67916",
          "message": "Apply PR suggestions",
          "committedDate": "2023-11-23T11:20:36Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dee22d1f17518454a2eb5232474b661cb69a773a",
          "message": "Move FNV hashing to stringtools",
          "committedDate": "2023-11-23T13:06:35Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0add56177437e6b07ef7e5a1f9d4f44a60b4ba74",
          "message": "Fix leftovers",
          "committedDate": "2023-11-23T13:28:47Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c58eb9015d8bf0e16d53e1d0a30509a7bb32ab42",
          "message": "Add comments",
          "committedDate": "2023-11-23T13:30:24Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Do you have an experimental insertion for this fix?\r\nIt would be nice to see how if affects VS in advance. ",
        "createdAt": "2023-11-06T14:47:07Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "> Do you have an experimental insertion for this fix? It would be nice to see how if affects VS in advance.\r\n\r\nhttps://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/509283\r\n\r\nI'm looking into the checks failures.\r\nDid you have anything else specific in your mind to watch for?\r\n\r\n**UPDATE:** Just a single test is failing for insertion which is by design (as built packages are missing in the public feed)",
        "createdAt": "2023-11-08T10:35:27Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Closing in order to rekick the confused git pull",
        "createdAt": "2023-11-08T10:38:48Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "CI blocked by ADO issue. IcM [internal]: https://portal.microsofticm.com/imp/v3/incidents/details/439851463/home",
        "createdAt": "2023-11-09T14:47:02Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2023-11-13T10:31:07Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2023-11-13T10:31:18Z",
        "author": {
          "login": "azure-pipelines"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This can potentially have a slightly faster implementation if we care enough.\r\n\r\n```suggestion\r\n            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text);\r\n            for (int i = 0; i < span.Length; i++)\r\n            {\r\n                hash = unchecked((hash ^ span[i]) * fnvPrimeA64Bit);\r\n            }\r\n```",
              "createdAt": "2023-11-21T08:43:34Z",
              "path": "src/Build/Utilities/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,107 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Utilities\n+{\n+    internal static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const ulong fnvPrimeA64Bit = 1099511628211;\n+        private const ulong fnvOffsetBasisA64Bit = 14695981039346656037;\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        internal static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        internal static ulong ComputeHash64Fast(string text)\n+        {\n+            ulong hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        internal static ulong ComputeHash64(string text)\n+        {\n+            ulong hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Love it!! Adopting..",
              "createdAt": "2023-11-23T11:08:13Z",
              "path": "src/Build/Utilities/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,107 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Utilities\n+{\n+    internal static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const ulong fnvPrimeA64Bit = 1099511628211;\n+        private const ulong fnvOffsetBasisA64Bit = 14695981039346656037;\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        internal static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        internal static ulong ComputeHash64Fast(string text)\n+        {\n+            ulong hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        internal static ulong ComputeHash64(string text)\n+        {\n+            ulong hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Indentation in this `PropertyGroup` doesn't look right.",
              "createdAt": "2023-11-21T08:44:29Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -385,11 +385,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n   <PropertyGroup>\n     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>\n   </PropertyGroup>\n+  \n+  <PropertyGroup>\n+    <MSBuildCopyMarkerName Condition =\"'$(MSBuildCopyMarkerName)' == ''\">$(MSBuildProjectFile)</MSBuildCopyMarkerName>\n+\t<!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 chars of the filename and either the ProjectGuid if it exists -->\n+    <MSBuildCopyMarkerName Condition =\"'$(MSBuildCopyMarkerName.Length)' &gt; '17' and '$(ProjectGuid)' != ''\">$(MSBuildProjectFile.Substring(0,8)).$(ProjectGuid.Substring(1,8))</MSBuildCopyMarkerName>\n+\t<!-- or a filename hash if the guid is not present (in such case the filename was not shortened and is still over 17 chars long). -->\n+\t<MSBuildCopyMarkerName Condition =\"'$(MSBuildCopyMarkerName.Length)' &gt; '17'\">$(MSBuildProjectFile.Substring(0,8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString(\"X8\"))</MSBuildCopyMarkerName>\n+  </PropertyGroup>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The [StringTools library](https://github.com/dotnet/msbuild/tree/main/src/StringTools) would be a slightly preferred place for this.",
              "createdAt": "2023-11-21T08:47:17Z",
              "path": "src/Build/Utilities/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,107 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Utilities\n+{\n+    internal static class FowlerNollVo1aHash",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Moved and adjusted to be CLS compliant and .NET Framework 3.5 compatible",
              "createdAt": "2023-11-23T13:09:07Z",
              "path": "src/Build/Utilities/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,107 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Utilities\n+{\n+    internal static class FowlerNollVo1aHash",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I believe it would be safer to append the new extension to the property and use just `$(MSBuildCopyMarkerName)` here. That way users who, for whatever reason, want to keep the old filename can actually do it.",
              "createdAt": "2023-11-21T08:52:35Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -385,11 +385,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n   <PropertyGroup>\n     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>\n   </PropertyGroup>\n+  \n+  <PropertyGroup>\n+    <MSBuildCopyMarkerName Condition =\"'$(MSBuildCopyMarkerName)' == ''\">$(MSBuildProjectFile)</MSBuildCopyMarkerName>\n+\t<!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 chars of the filename and either the ProjectGuid if it exists -->\n+    <MSBuildCopyMarkerName Condition =\"'$(MSBuildCopyMarkerName.Length)' &gt; '17' and '$(ProjectGuid)' != ''\">$(MSBuildProjectFile.Substring(0,8)).$(ProjectGuid.Substring(1,8))</MSBuildCopyMarkerName>\n+\t<!-- or a filename hash if the guid is not present (in such case the filename was not shortened and is still over 17 chars long). -->\n+\t<MSBuildCopyMarkerName Condition =\"'$(MSBuildCopyMarkerName.Length)' &gt; '17'\">$(MSBuildProjectFile.Substring(0,8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString(\"X8\"))</MSBuildCopyMarkerName>\n+  </PropertyGroup>\n \n   <ItemGroup>\n     <IntermediateAssembly Include=\"$(IntermediateOutputPath)$(TargetName)$(TargetExt)\"/>\n     <FinalDocFile Include=\"@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')\"/>\n-    <CopyUpToDateMarker Include=\"$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildProjectFile).CopyComplete'))\" />\n+    <CopyUpToDateMarker Include=\"$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildCopyMarkerName).Up2Date'))\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this needed? Also nit: Missing doc-comments for the parameters.",
              "createdAt": "2023-11-23T13:18:16Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,136 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }\n+#endif\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Combines two 64 bit hashes into one.\n+        /// </summary>\n+        /// <param name=\"left\"></param>\n+        /// <param name=\"right\"></param>\n+        /// <returns></returns>\n+        [CLSCompliant(false)]",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: There's a space before but not after `=`. The convention in this file seems to be no spaces.",
              "createdAt": "2023-11-23T13:22:23Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -385,11 +385,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n   <PropertyGroup>\n     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>\n   </PropertyGroup>\n+  \n+  <PropertyGroup Condition =\"'$(MSBuildCopyMarkerName)' == ''\">",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does MSBuild support big-endian platforms?  It looks like this would not be stable between big-endian and little-endian.",
              "createdAt": "2023-11-30T09:45:08Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "@KalleOlaviNiemitalo - Thank you for bringing this up! \r\nWe're not declaring what can be the expectations of stableness of the hashing between different systems (we actually do not declare anything ... yet :-)) - but it'd certainly be nice to have it more universal.\r\n\r\n@uweigand - would you be willing to chime in and share your thoughts on the following?\r\n\r\nBasically - since the `MemoryMarshal.Cast<char, byte>` changes how we fetch data from memory to processor - it'll behave differently between Endinan-ness representations. But how anout the version which manually splits each char to bytes:\r\n```csharp\r\nfor (int i = 0; i < text.Length; i++)\r\n{\r\n    char ch = text[i];\r\n    byte b = (byte)ch;\r\n    hash ^= b;\r\n    hash *= fnvPrimeA64Bit;\r\n\r\n    b = (byte)(ch >> 8);\r\n    hash ^= b;\r\n    hash *= fnvPrimeA64Bit;\r\n}\r\n```\r\nsince all this happens in processor after the data are fetched from memory - it should fetch same results regardless of endinan-ness - is that right?\r\n\r\nFYI @ladipro (and thanks for all the offline consultation)",
              "createdAt": "2023-11-30T13:06:54Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes that would work the same in either endianness.\r\n\r\nYou could also check [BitConverter.IsLittleEndian](https://learn.microsoft.com/dotnet/api/system.bitconverter.islittleendian?view=netstandard-2.0) and use MemoryMarshal.Cast on little-endian platforms but fall back to the slower NET35-compatible implementation on big-endian platforms.",
              "createdAt": "2023-11-30T14:07:25Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "\u2026although I have not measured whether the NET35-compatible implementation actually _is_ slower.  In both implementations, each operation on `hash` depends on the previous one, so it doesn't look like there is much that the CPU could do in parallel.  And the strings probably are pretty short anyway.",
              "createdAt": "2023-11-30T14:14:10Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "It seems to me the code above implements *three* methods that are (potentially) different.  There's the `NET35` method in `ComputeHash64` (which operates on single bytes at a time, splitting the 2-byte char in an endian-independent way), the `!NET35` method in `ComputeHash64` (which also operates on single bytes at a time, but splits the 2-byte char in an endian-dependent way), and then there's `ComputeHash64Fast` (which operates on 2-byte chars at a time, which appears to give a different result from either of the two other methods).\r\n\r\nIn general, I agree that it would be preferable to use a method that is stable across native endianness.  Unless the `NET35` method is really slower (and I also suspect it actually isn't), and performance matters at this place, it might be best to just use that method unconditionally?\r\n",
              "createdAt": "2023-11-30T15:17:50Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "uweigand"
              }
            },
            {
              "body": "Re ComputeHash64Fast, this comment seems to be false: <https://github.com/dotnet/msbuild/blob/e1652ea4983c7b0f9ad0e46e2a6bff640073a165/src/StringTools/FowlerNollVo1aHash.cs#L64>",
              "createdAt": "2023-11-30T15:46:58Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "Thank you for all the detailed input! I'll remove the Spans version.\r\n\r\nThe Spans version is indeed not superior (it has slight to no advantage for large strings, but performs worse for a very short strings). It's nice that it doesn't need unchecked code and is more brief - but given the fact that it can perform worse and that the other version anyways need to be maintained - it's an easy choice.\r\n\r\nI'll as well fix the description for the `ComputeHash64Fast`",
              "createdAt": "2023-12-02T09:52:03Z",
              "path": "src/StringTools/FowlerNollVo1aHash.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Runtime.InteropServices;\n+using System;\n+\n+namespace Microsoft.NET.StringTools\n+{\n+    /// <summary>\n+    /// Fowler/Noll/Vo hashing.\n+    /// </summary>\n+    public static class FowlerNollVo1aHash\n+    {\n+        // Fowler/Noll/Vo hashing.\n+        // http://www.isthe.com/chongo/tech/comp/fnv/\n+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c\n+\n+        // 32 bit FNV prime and offset basis for FNV-1a.\n+        private const uint fnvPrimeA32Bit = 16777619;\n+        private const uint fnvOffsetBasisA32Bit = 2166136261;\n+\n+        // 64 bit FNV prime and offset basis for FNV-1a.\n+        private const long fnvPrimeA64Bit = 1099511628211;\n+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);\n+\n+        /// <summary>\n+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>32 bit signed hash</returns>\n+        public static int ComputeHash32(string text)\n+        {\n+            uint hash = fnvOffsetBasisA32Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA32Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA32Bit);\n+            }\n+#endif\n+\n+            return unchecked((int)hash);\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash optimized for ASCII strings.\n+        /// The hashing algorithm considers only the first 8 bits of each character.\n+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64Fast(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+\n+                    hash = (hash ^ ch) * fnvPrimeA64Bit;\n+                }\n+            }\n+\n+            return hash;\n+        }\n+\n+        /// <summary>\n+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).\n+        /// </summary>\n+        /// <param name=\"text\">String to be hashed.</param>\n+        /// <returns>64 bit unsigned hash</returns>\n+        public static long ComputeHash64(string text)\n+        {\n+            long hash = fnvOffsetBasisA64Bit;\n+\n+#if NET35\n+            unchecked\n+            {\n+                for (int i = 0; i < text.Length; i++)\n+                {\n+                    char ch = text[i];\n+                    byte b = (byte)ch;\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+\n+                    b = (byte)(ch >> 8);\n+                    hash ^= b;\n+                    hash *= fnvPrimeA64Bit;\n+                }\n+            }\n+#else\n+            ReadOnlySpan<byte> span = MemoryMarshal.Cast<char, byte>(text.AsSpan());\n+            foreach (byte b in span)\n+            {\n+                hash = unchecked((hash ^ b) * fnvPrimeA64Bit);\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}