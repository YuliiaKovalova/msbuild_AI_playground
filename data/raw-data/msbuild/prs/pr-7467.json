{
  "number": 7467,
  "title": "Find assemblies by path from RoslynCodeTaskFactory Fixes #5106",
  "body": "Fixes #5106\r\n\r\n### Context\r\nWhen using an inline task with CodeTaskFactory (Framework-specific), it automatically adds resolving information to AppDomain.CurrentDomain if necessary. That didn't happen with RoslynCodeTaskFactory. This adds it.\r\n\r\n### Changes Made\r\nAdded referenced assemblies for inline tasks using RoslynCodeTaskFactory to the current AppDomain/AssemblyLoadContext.\r\n\r\n### Testing\r\nNot enough yet, but the repro no longer repros.\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2022-03-14T18:58:31Z",
  "updatedAt": "2022-04-21T02:15:44Z",
  "closedAt": "2022-04-21T02:15:43Z",
  "mergedAt": "2022-04-21T02:15:42Z",
  "additions": 153,
  "deletions": 2,
  "changedFiles": 3,
  "headRefName": "roslycodetaskfactory-with-reference",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rainersigwald"
      }
    ]
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "e117e7a81df58855eef13a2ee86aa22e6858a857",
          "message": "Find custom assembly\n\nFrom roslyn code task factory",
          "committedDate": "2022-03-14T18:55:34Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "422be4fa1702b1ba12b6991b2568a8d7147e08bf",
          "message": "Add S.Runtime.Loader",
          "committedDate": "2022-03-14T18:56:36Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8e70512e709a7858f2f3dc6bcbb0d5b094b8676c",
          "message": "Add test",
          "committedDate": "2022-03-15T19:40:12Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1ca4458ccc6072b0c751f64eafc40023eaa412e",
          "message": "Add tfv",
          "committedDate": "2022-03-16T00:25:08Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1c94dfd3c1cc070f088a1395293147e1a023485",
          "message": "PR review comments",
          "committedDate": "2022-03-21T17:09:38Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fced5899310d044f05d715a98d4440af343e63e1",
          "message": "Revert \"Add S.Runtime.Loader\"\n\nThis reverts commit 422be4fa1702b1ba12b6991b2568a8d7147e08bf.",
          "committedDate": "2022-03-25T15:57:42Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ae7c9daf7830b7f26d91e7f724c9f2041c6a1c22",
          "message": "Remove reference to System.Runtime.Loader",
          "committedDate": "2022-03-25T17:26:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "69a699f366cd077840a609b732d1e6396f10725e",
          "message": "One handler",
          "committedDate": "2022-04-04T20:36:23Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1994621dc71c9fd3018a612790b386423eec07b6",
          "message": "Add OS-agnostic unit test",
          "committedDate": "2022-04-08T17:29:26Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d2245d81a7b64baef84e01bcb35d8e2d5d9325b",
          "message": "Capture output in message",
          "committedDate": "2022-04-08T18:54:06Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f7a99d9e67a19b1ab843b517637497b75aac7a5a",
          "message": "Update src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
          "committedDate": "2022-04-11T17:06:53Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43fbe68e9d15e0f1c95c8b0d66fa9c69f5f78f42",
          "message": "Update src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
          "committedDate": "2022-04-11T17:07:18Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c37e52a0fdcb6e85644b1b719bd60bae8599f74",
          "message": "Check for configuration\n\n$(Configuration) returned empty for some reason? Will try to remember to look again later",
          "committedDate": "2022-04-11T18:55:53Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5d1dacb3fc8606eee0c266edd3be3e27bd746d9",
          "message": "#if check for DEBUG",
          "committedDate": "2022-04-13T21:25:09Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "652d7d66ccb56b188bf92d9c9f0178378420492a",
          "message": "Also search culture",
          "committedDate": "2022-04-13T23:29:25Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "179fbfb93b4780bedfa20d9b9c4f0e96f6c6e117",
          "message": "Switch order of search",
          "committedDate": "2022-04-18T16:52:05Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I've been working on a test. My current issue is that I have a simple project:\r\n```XML\r\n<Project Sdk=\"\"Microsoft.NET.Sdk\"\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netstandard2.0</TargetFramework>\r\n  </PropertyGroup>\r\n</Project>\r\n```\r\n\r\nthat builds perfectly fine from the command line with `msbuild /p:OutDir={folder} /restore` but not using RunnerUtilities.ExeMSBuild(pathToProject + $\" /p:OutDir={folder} /restore\", out bool success);\r\n\r\nIf you have quick thoughts as to what might be going wrong, I'm happy to hear them. Otherwise, I might look a little more tomorrow.",
        "createdAt": "2022-03-15T00:19:37Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "That's not a simple project; it uses the whole .NET SDK. What are you trying to test, exactly?",
        "createdAt": "2022-03-15T14:45:42Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I was essentially embedding my repro into a unit test:\r\nMake a project\r\nBuild it\r\nMake a second project with an inline task that relies on the newly-built assembly and uses a RoslynCodeTaskFactory\r\nBuild that\r\n\r\nI skipped the first build step and did that from a command line, and the rest of the test passed. So I guess I need a project that compiles C# code? So maybe import some .targets file (which?), add the C# file to <Compile Include= />, and call CoreCompile?",
        "createdAt": "2022-03-15T16:06:33Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "It's usually much easier to compile a type into an existing assembly, like the test assembly. That seems like it'd be an option here.",
        "createdAt": "2022-03-15T16:39:15Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "If I remember correctly, it was looking for the assembly next to MSBuild, so it would find the test assembly, just not a custom assembly or an assembly in a weird spot.",
        "createdAt": "2022-03-15T16:43:49Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Got it to work \ud83d\ude42",
        "createdAt": "2022-03-15T17:09:33Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we attach this to the plugin ALC that we're in, instead of `Default`?",
              "createdAt": "2022-03-14T19:12:53Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "So I _think_ that would be AssemblyLoadContext.GetLoadContext(typeof(RoslynCodeTaskFactory).Assembly)...\r\n\r\nIs that right? I vaguely remember that we started make a separate load context for every task a couple years ago, but I never had a solid understanding of all that was going on.",
              "createdAt": "2022-03-14T20:23:15Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Current version works for dotnet build scenarios; changing Default to GetLoadContext(typeof(RoslynCodeTaskFactory).Assembly) did not work. Is it something else?",
              "createdAt": "2022-03-14T21:21:50Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What does `CodeTaskFactory` do for .NET Framework? Does it just add it to the default appdomain?",
              "createdAt": "2022-03-14T22:24:36Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes:\r\nhttps://github.com/dotnet/msbuild/blob/9476453a935b612482332633abc4b1c144e1e483/src/Tasks/CodeTaskFactory.cs#L54\r\n(Though it has to flesh out that function.)",
              "createdAt": "2022-03-14T22:38:43Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Team triage:\r\nTry just using AppDomain.CurrentDomain.AssemblyResolve even on Core",
              "createdAt": "2022-03-21T15:08:58Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "And remove the new assembly resolving behavior",
              "createdAt": "2022-03-21T15:14:55Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -539,7 +542,14 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n                 if (FileSystems.Default.FileExists(reference))\n                 {\n                     // The path could be relative like ..\\Assembly.dll so we need to get the full path\n-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));\n+                    string fullPath = Path.GetFullPath(reference);\n+                    string directory = Path.GetDirectoryName(fullPath);\n+                    resolvedAssemblyReferences.Add(fullPath);\n+#if NETFRAMEWORK\n+                    AppDomain.CurrentDomain.AssemblyResolve += (_, eventArgs) => TryLoadAssembly(directory, new AssemblyName(eventArgs.Name).Name);\n+#else\n+                    AssemblyLoadContext.Default.Resolving += (_, assemblyName) => TryLoadAssembly(directory, assemblyName.Name);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like a pretty bad test to be OS-specific, since it's testing functionality that needs to be cross-platform. We talked offline about building a task into the test assembly that points to a dependency that's built in the normal build--is that possible?",
              "createdAt": "2022-03-25T14:43:51Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +26,70 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Did we? All I remember is the comment you had above. I had a series of commits in which I tried to make 5106.csproj build on core; building a project on its own was easy but making it also compile a C# file stymied my progress for a bit. (We don't currently have any other tests that use RunnerUtilities.ExecMSBuild with a project that has a C# file to compile, and if we do it some other way (without relying on framework), I didn't see it.) Ultimately, I think it matters that it works on both core and framework, and this still verifies that it works on both, just not on other platforms.\r\n\r\nIf it's a dependency built as a normal part of build, I'd worry that we aren't testing anything; if it's already loaded into the current appdomain, the test could pass without this change. (And even if I have a test that currently fails without the change and passes with it, I'd worry that we'd start loading it at some point before this test just by introducing a new unit test, and then we could break this without noticing.",
              "createdAt": "2022-03-25T15:48:40Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +26,70 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> If it's a dependency built as a normal part of build, I'd worry that we aren't testing anything; if it's already loaded into the current appdomain, the test could pass without this change.\r\n\r\nThat won't be the case if you continue to use ExecMSBuild and push it into its own process, and it's also the sort of thing that you could validate in the test. I think it's worth doing this to avoid OS-specific tests where possible.",
              "createdAt": "2022-04-06T15:47:34Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +26,70 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you avoid this dependency?",
              "createdAt": "2022-03-25T14:48:48Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -25,6 +25,7 @@\n     <PackageReference Update=\"System.Reflection.Metadata\" Version=\"1.6.0\" />\n     <PackageReference Update=\"System.Resources.Extensions\" Version=\"$(SystemResourcesExtensionsPackageVersion)\" />\n     <PackageReference Update=\"System.Runtime.CompilerServices.Unsafe\" Version=\"6.0.0\" />\n+    <PackageReference Update=\"System.Runtime.Loader\" Version=\"4.3.0\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That was for ALC, and that's completely gone now, so yes. Thanks!",
              "createdAt": "2022-03-25T15:38:40Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -25,6 +25,7 @@\n     <PackageReference Update=\"System.Reflection.Metadata\" Version=\"1.6.0\" />\n     <PackageReference Update=\"System.Resources.Extensions\" Version=\"$(SystemResourcesExtensionsPackageVersion)\" />\n     <PackageReference Update=\"System.Runtime.CompilerServices.Unsafe\" Version=\"6.0.0\" />\n+    <PackageReference Update=\"System.Runtime.Loader\" Version=\"4.3.0\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it possible to have a single method that looks at the list? That feels more robust to me.",
              "createdAt": "2022-03-25T15:00:09Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -573,6 +590,12 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(string directory, string name)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I thought about that, and I think the answer is \"not cleanly.\" As I currently understand this, the fact that RoslynCodeTaskFactory is your TaskFactory is essentially a detail as part of execute a particular task. It notices that you said you wanted that, and some RoslynCodeTaskFactory code runs to set up the task for execution, but when it's finished, the task hasn't yet executed, so we can't remove the ResolveEventHandler yet. Then it executes the task in code not associated with RoslynCodeTaskFactory and comes back at the end to call a generic \"cleanup\" that calls this. If I want it all to be in one method as would be ideal, I think I'd have to first make all TaskFactories return a list of ResolveEventHandlers at some point (though most of them would return null), then check if it's non-null just before actually executing the task and add them to the AssemblyResolve if so and remove them afterwards. CleanupTask should always run even if the task's execution throws an exception (it's in a finally block) and briefly returns control back to the RoslynCodeTaskFactory with the relevant information, so it seemed like the best option. I did verify in a debugger that it got to that point and found a list with the expected number of ResolveEventHandlers in it and removed them all without exceptions. (I don't remember if I verified they were attached beforehand\u2014either I did or I didn't see how to.)",
              "createdAt": "2022-03-25T15:57:04Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -573,6 +590,12 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(string directory, string name)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "NTS: Condense various handlers into one handler",
              "createdAt": "2022-04-04T15:27:49Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -573,6 +590,12 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(string directory, string name)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}, \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", \"Debug\", \"net472\", \"Dependency.dll\") }\"\" />\r\n```",
              "createdAt": "2022-04-11T17:06:48Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,101 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\\..\\..\\..\\Samples\\Dependency\\Debug\\net472\\Dependency.dll\"\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", \"Debug\", \"net472\", \"Dependency.dll\") }\"\" />\r\n```",
              "createdAt": "2022-04-11T17:07:13Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,101 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}, \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", \"Debug\", \"net472\", \"Dependency.dll\") }\"\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this add anything over the cross-plat version now?",
              "createdAt": "2022-04-13T20:32:00Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />\n+      <Using Namespace=\"\"Dependency\"\" />\n+      <Code Type=\"\"Fragment\"\" Language=\"\"cs\"\" >\n+<![CDATA[\n+Log.LogError(Alpha.GetString());\n+]]>\n+      </Code>\n+    </Task>\n+  </UsingTask>\n+\n+<Target Name=\"\"ToRun\"\">\n+  <MyInlineTask/>\n+</Target>\n+\n+</Project>\n+\");\n+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);\n+                success.ShouldBeTrue(output);\n+                output.ShouldContain(\"Alpha.GetString\");\n+            }\n+        }\n+\n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]\n+        public void InlineTaskWithAssembly()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes:\r\nIt's a brand new assembly, so if we start always loading Dependency, it'll still be able to break.\r\nIt's an example of how to compile an assembly with C# code in a test that I may want to refer back to in the future.\r\nI trust it a lot more than I trust the cross-plat version. I did run a test, and it seems to fail without my change and work with it, but I still don't trust it.",
              "createdAt": "2022-04-13T21:00:57Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />\n+      <Using Namespace=\"\"Dependency\"\" />\n+      <Code Type=\"\"Fragment\"\" Language=\"\"cs\"\" >\n+<![CDATA[\n+Log.LogError(Alpha.GetString());\n+]]>\n+      </Code>\n+    </Task>\n+  </UsingTask>\n+\n+<Target Name=\"\"ToRun\"\">\n+  <MyInlineTask/>\n+</Target>\n+\n+</Project>\n+\");\n+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);\n+                success.ShouldBeTrue(output);\n+                output.ShouldContain(\"Alpha.GetString\");\n+            }\n+        }\n+\n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]\n+        public void InlineTaskWithAssembly()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I regard this method of building an assembly during tests as unreliable and suspect, because it's so different from \"normal\" projects. I don't understand the \"start loading Dependency\" comments--we're starting a fresh process for the test so how would it have loaded Dependency?",
              "createdAt": "2022-04-13T21:14:20Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />\n+      <Using Namespace=\"\"Dependency\"\" />\n+      <Code Type=\"\"Fragment\"\" Language=\"\"cs\"\" >\n+<![CDATA[\n+Log.LogError(Alpha.GetString());\n+]]>\n+      </Code>\n+    </Task>\n+  </UsingTask>\n+\n+<Target Name=\"\"ToRun\"\">\n+  <MyInlineTask/>\n+</Target>\n+\n+</Project>\n+\");\n+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);\n+                success.ShouldBeTrue(output);\n+                output.ShouldContain(\"Alpha.GetString\");\n+            }\n+        }\n+\n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]\n+        public void InlineTaskWithAssembly()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If it turns out to be a flaky test, we can remove it. Good enough?",
              "createdAt": "2022-04-13T21:16:35Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />\n+      <Using Namespace=\"\"Dependency\"\" />\n+      <Code Type=\"\"Fragment\"\" Language=\"\"cs\"\" >\n+<![CDATA[\n+Log.LogError(Alpha.GetString());\n+]]>\n+      </Code>\n+    </Task>\n+  </UsingTask>\n+\n+<Target Name=\"\"ToRun\"\">\n+  <MyInlineTask/>\n+</Target>\n+\n+</Project>\n+\");\n+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);\n+                success.ShouldBeTrue(output);\n+                output.ShouldContain(\"Alpha.GetString\");\n+            }\n+        }\n+\n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]\n+        public void InlineTaskWithAssembly()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's a fresh process, but it's a fresh MSBuild process, so it automatically knows about things next to itself. If we start including Dependency.dll next to MSBuild for some reason.",
              "createdAt": "2022-04-13T21:17:45Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />\n+      <Using Namespace=\"\"Dependency\"\" />\n+      <Code Type=\"\"Fragment\"\" Language=\"\"cs\"\" >\n+<![CDATA[\n+Log.LogError(Alpha.GetString());\n+]]>\n+      </Code>\n+    </Task>\n+  </UsingTask>\n+\n+<Target Name=\"\"ToRun\"\">\n+  <MyInlineTask/>\n+</Target>\n+\n+</Project>\n+\");\n+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);\n+                success.ShouldBeTrue(output);\n+                output.ShouldContain(\"Alpha.GetString\");\n+            }\n+        }\n+\n+        [Fact]\n+        [SkipOnPlatform(TestPlatforms.AnyUnix, \".NETFramework 4.0 isn't on unix machines.\")]\n+        public void InlineTaskWithAssembly()",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think I'd do `#if DEBUG` instead of the path-contains check (it's more reliable in the case that e.g. some dev has all their source in `Q:\\Debug\\msbuild`) but that's pretty nitpicky.",
              "createdAt": "2022-04-13T20:33:11Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is doable but a bit fiddly because I don't think you can put a #if in the middle of a string. I can make it three strings and concat them, I guess.",
              "createdAt": "2022-04-13T20:58:48Z",
              "path": "src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs",
              "diffHunk": "@@ -19,6 +27,102 @@ public class RoslynCodeTaskFactory_Tests\n     {\n         private const string TaskName = \"MyInlineTask\";\n \n+        [Fact]\n+        public void InlineTaskWithAssemblyPlatformAgnostic()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFolder folder = env.CreateFolder(createFolder: true);\n+                string location = Assembly.GetExecutingAssembly().Location;\n+                TransientTestFile inlineTask = env.CreateFile(folder, \"5106.proj\", @$\"\n+<Project>\n+\n+  <UsingTask TaskName=\"\"MyInlineTask\"\" TaskFactory=\"\"RoslynCodeTaskFactory\"\" AssemblyFile=\"\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\"\">\n+    <Task>\n+      <Reference Include=\"\"{ Path.Combine(Path.GetDirectoryName(location), \"..\", \"..\", \"..\", \"Samples\", \"Dependency\", location.Contains(\"Debug\") ? \"Debug\" : \"Release\", \"net472\", \"Dependency.dll\") }\"\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is different and less complicated than what we have in `CoreCLRAssemblyLoader`. Do we need the culture-subdirectory lookup and the check-that-name-actually-matches stuff here, too?",
              "createdAt": "2022-04-13T20:52:08Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,24 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name).Name);\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, string name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name + \".dll\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't think so. As I understand RoslynCodeTaskFactory, for this case, you have to pass it the exact path to your assembly, in which case it isn't in a subfolder, or you would've had to provide that. I only turned it into a directory and back into a file here to prevent a search for (unrelated) Foo to match Bar.dll just because I was too permissive.",
              "createdAt": "2022-04-13T21:03:33Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,24 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name).Name);\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, string name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name + \".dll\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's true for the assembly you directly reference, but what about _its_ dependencies and satellites?",
              "createdAt": "2022-04-13T21:12:12Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,24 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name).Name);\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, string name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name + \".dll\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It'll silently work as long as its dependencies are next to it. If you have dependencies that you don't copy to your output directory, we don't have a great way of finding them anyway.",
              "createdAt": "2022-04-13T21:19:04Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,24 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name).Name);\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, string name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name + \".dll\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "And if you're thinking I should use an AssemblyDependencyResolver to read a deps.json file, that feels like overkill here \ud83d\ude42",
              "createdAt": "2022-04-13T21:20:01Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,24 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name).Name);\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, string name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name + \".dll\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I am not suggesting that, I am suggesting this:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/18fc0b3dd9dfd7cbb83272f13de4a89e8aa30531/src/Shared/CoreCLRAssemblyLoader.cs#L148-L175\r\n\r\nNote specifically the culture-subdirectory stuff, which breaks the \"next-to-it\" rule but is predictable.",
              "createdAt": "2022-04-13T22:06:58Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,24 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name).Name);\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, string name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name + \".dll\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you swap this to be first?",
              "createdAt": "2022-04-18T15:34:19Z",
              "path": "src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs",
              "diffHunk": "@@ -572,7 +585,33 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC\n             // Transform the list of resolved assemblies to TaskItems if they were all resolved\n             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();\n \n+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name));\n+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;\n+\n             return !hasInvalidReference;\n+\n+            static Assembly TryLoadAssembly(List<string> directories, AssemblyName name)\n+            {\n+                foreach (string directory in directories)\n+                {\n+                    string path = Path.Combine(directory, name.Name + \".dll\");\n+                    if (File.Exists(path))\n+                    {\n+                        return Assembly.LoadFrom(path);\n+                    }\n+\n+                    if (!string.IsNullOrEmpty(name.CultureName))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}