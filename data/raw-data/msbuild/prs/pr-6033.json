{
  "number": 6033,
  "title": "Optimize FileExists lookup",
  "body": "### Performance\r\nhttps://github.com/dotnet/msbuild/issues/5018\r\n\r\n### Context\r\nOptimize FileExists lookup for Resolver.ResolveFromDirectory used cases, by caching list of files in the lookup directory and verify its existence against it.\r\n\r\n### Changes Made\r\nRAR Resolver.ResolveFromDirectory, changes needed to propagate new FileIO delegate and fixing related unit tests\r\n\r\n### Testing\r\nTested to build OrchadCore and Roslyn\r\n\r\n### Notes\r\nPerformance saving:\r\n- OrchardCore - none, this project has all references externally resolved and Resolver.ResolveFromDirectory is not called\r\n- Roslyn t:Rebuild - 6% or RAR execution time\r\n- dotnet new mvc; dotnet build - none, seems like all SDK based projects have all references externally resolved\r\n\r\nI am not 100% sure if increased code complexity and introduced risk is worth the potential saving.",
  "state": "MERGED",
  "createdAt": "2021-01-14T10:25:59Z",
  "updatedAt": "2021-02-08T00:11:15Z",
  "closedAt": "2021-02-08T00:11:14Z",
  "mergedAt": "2021-02-08T00:11:14Z",
  "additions": 432,
  "deletions": 169,
  "changedFiles": 24,
  "headRefName": "rokonec/5018-file-exists-optimization",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d65fc9f793e5bc7e5e0afdf7886bfccd10e34c5a",
          "message": "Code and unit tests",
          "committedDate": "2021-01-15T14:08:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ae89ede9845a6e0cf33e924e2380eb1e844b18e2",
          "message": "Tolerate files which differs only in casing",
          "committedDate": "2021-01-15T14:08:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9594987bbbe92cf42128278943b838e576f3642",
          "message": "Fix one unit test category",
          "committedDate": "2021-01-15T14:08:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8033332c7323cbd0d9bd274da05f1a2c53518236",
          "message": "Review changes #1",
          "committedDate": "2021-01-18T19:16:55Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d05abea112a7bd328e3ee325c75e0518dde7ee8a",
          "message": "Review changes #2 - minor style changes",
          "committedDate": "2021-01-20T18:29:13Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f93561b756dfd13e8d9da7956951f75b67ce88b",
          "message": "Change directory cache into <string, HashSet<string>>",
          "committedDate": "2021-01-20T21:09:06Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5190c1336185d67cb59a69ea9c47cf89e64698b4",
          "message": "Not using concurent dictionary in unit test",
          "committedDate": "2021-01-20T21:29:03Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dcaa4013f98eebfb8f8bdc9d782c3a9d3f7ffccd",
          "message": "Added unit test for FileUtilities",
          "committedDate": "2021-01-21T12:49:35Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4862f1ae063aeca5232adb31338ab0e9e9ec3c9",
          "message": "Minor changes",
          "committedDate": "2021-01-21T13:05:34Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "This PR is now ready to be merged",
        "createdAt": "2021-01-21T16:02:02Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "We should wait for a successful RPS run with arcade in first, though.",
        "createdAt": "2021-01-21T16:13:06Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10);\r\n```",
              "createdAt": "2021-01-15T01:22:52Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-01-18T19:02:05Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there an advantage to this over `weakNameBase + executableExtension`?",
              "createdAt": "2021-01-15T01:23:28Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "As for generated code there is no difference between those two. Both are compiled into `String.Concat(s1, s2);`\r\nChoosing between those two is matter of coding habits or standards. In this particular case I prefer string interpolation as more readable and maintainable but I do not have strong opinion here.\r\nWhich would you prefer?",
              "createdAt": "2021-01-15T09:14:01Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I slightly prefer `weakNameBase + executableExtension` because then I don't have to check for any extra characters you may or may not have inserted, but it's a very weak preference. This is fine.",
              "createdAt": "2021-01-15T15:51:03Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                            throw new InvalidParameterValueException(\"SearchPaths\", Path.Combine(directory, fileName), e.Message);\r\n```",
              "createdAt": "2021-01-15T01:26:34Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Unfortunately Path.Combine will throw, on .NET Framework, if directory contains invalid character.\r\nI recommend to keep it as is.",
              "createdAt": "2021-01-18T19:04:05Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                            // file does not exists; try next file extension\r\n```",
              "createdAt": "2021-01-15T01:27:37Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);\n+                        }\n+\n+                        if (!fileExistenceVerified)\n+                        {\n+                            // file do not exists, try next file extension",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "related code was deleted",
              "createdAt": "2021-01-18T19:18:49Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);\n+                        }\n+\n+                        if (!fileExistenceVerified)\n+                        {\n+                            // file do not exists, try next file extension",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        throw new InvalidParameterValueException(\"SearchPaths\", Path.Combine(directory, fileName), e.Message);\r\n```",
              "createdAt": "2021-01-15T01:29:08Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);\n+                        }\n+\n+                        if (!fileExistenceVerified)\n+                        {\n+                            // file do not exists, try next file extension\n+                            continue;\n+                        }\n+                    }\n \n                     try\n                     {\n-                        fullPath = Path.Combine(directory, baseName);\n+                        fullPath = Path.Combine(directory, fileName);\n                     }\n                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n                     {\n                         // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n-                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + baseName, e.Message);\n+                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Path.Combine could throw",
              "createdAt": "2021-01-20T13:01:08Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);\n+                        }\n+\n+                        if (!fileExistenceVerified)\n+                        {\n+                            // file do not exists, try next file extension\n+                            continue;\n+                        }\n+                    }\n \n                     try\n                     {\n-                        fullPath = Path.Combine(directory, baseName);\n+                        fullPath = Path.Combine(directory, fileName);\n                     }\n                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n                     {\n                         // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n-                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + baseName, e.Message);\n+                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Should still use `Path.DirectorySeparatorChar` instead of the hard-coded backslash so it works well on Linux and Mac as well.",
              "createdAt": "2021-01-21T10:22:16Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -312,23 +321,47 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n             if (directory != null)\n             {\n                 string weakNameBase = assemblyName.Name;\n+\n+                // feature flag by ChangeWaves \n+                bool useFileEnumerationOptimization = Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave17_0);\n+\n                 foreach (string executableExtension in executableExtensions)\n                 {\n-                    string baseName = weakNameBase + executableExtension;\n                     string fullPath;\n+                    bool fileExistenceVerified = false;\n+\n+                    string fileName = $\"{weakNameBase}{executableExtension}\";\n+                    if (useFileEnumerationOptimization)\n+                    {\n+                        try\n+                        {\n+                            fileExistenceVerified = getDirectoryFile(directory, fileName) != null;\n+                        }\n+                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                        {\n+                            // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                            throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);\n+                        }\n+\n+                        if (!fileExistenceVerified)\n+                        {\n+                            // file do not exists, try next file extension\n+                            continue;\n+                        }\n+                    }\n \n                     try\n                     {\n-                        fullPath = Path.Combine(directory, baseName);\n+                        fullPath = Path.Combine(directory, fileName);\n                     }\n                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n                     {\n                         // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n-                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + baseName, e.Message);\n+                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + fileName, e.Message);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                                        // file does not exists; try next file extension\r\n```",
              "createdAt": "2021-01-15T01:30:33Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -375,10 +408,31 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n                         {\n                             if (String.Equals(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase))\n                             {\n+                                bool fileExistenceVerified = false;\n+\n+                                if (useFileEnumerationOptimization)\n+                                {\n+                                    try\n+                                    {\n+                                        fileExistenceVerified = getDirectoryFile(directory, weakNameBase) != null;\n+                                    }\n+                                    catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                                    {\n+                                        // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + weakNameBase, e.Message);\n+                                    }\n+\n+                                    if (!fileExistenceVerified)\n+                                    {\n+                                        // file do not exists, try next file extension",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "code was deleted",
              "createdAt": "2021-01-18T19:19:15Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -375,10 +408,31 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected\n                         {\n                             if (String.Equals(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase))\n                             {\n+                                bool fileExistenceVerified = false;\n+\n+                                if (useFileEnumerationOptimization)\n+                                {\n+                                    try\n+                                    {\n+                                        fileExistenceVerified = getDirectoryFile(directory, weakNameBase) != null;\n+                                    }\n+                                    catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                                    {\n+                                        // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.\n+                                        throw new InvalidParameterValueException(\"SearchPaths\", directory + (directory.EndsWith(\"\\\\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : \"\\\\\") + weakNameBase, e.Message);\n+                                    }\n+\n+                                    if (!fileExistenceVerified)\n+                                    {\n+                                        // file do not exists, try next file extension",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should casing here depend on OS?",
              "createdAt": "2021-01-15T01:32:01Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,38 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = files.ToDictionary(fn => Path.GetFileName(fn), StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "code was deleted",
              "createdAt": "2021-01-18T19:19:43Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,38 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = files.ToDictionary(fn => Path.GetFileName(fn), StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If it fails, should we not find it and add it?",
              "createdAt": "2021-01-15T01:32:34Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,38 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = files.ToDictionary(fn => Path.GetFileName(fn), StringComparer.OrdinalIgnoreCase);\n+                instanceLocalDirectoryFiles[path] = cached;\n+            }\n+\n+            cached.TryGetValue(fileName, out string fullPathFileName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This does exactly what we want, return file full path if file is present or null if it does not exists.\r\nOn the other hand, it is unusual usage pattern for `TryGetValue` - I will create comment here to describe it.",
              "createdAt": "2021-01-18T19:10:30Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,38 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = files.ToDictionary(fn => Path.GetFileName(fn), StringComparer.OrdinalIgnoreCase);\n+                instanceLocalDirectoryFiles[path] = cached;\n+            }\n+\n+            cached.TryGetValue(fileName, out string fullPathFileName);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should casing here depend on OS?",
              "createdAt": "2021-01-15T01:33:17Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -861,6 +867,52 @@ internal static bool FileExists(string path)\n             return false;\n         }\n \n+        /// <summary>\n+        /// Mock the Directory.GetFiles method.\n+        /// </summary>\n+        /// <param name=\"path\">The path to directory.</param>\n+        /// <returns>'true' if the file is supposed to exist</returns>\n+\n+        internal static string[] GetDirectoryFiles(string path, string pattern)\n+        {\n+            if (!Path.IsPathRooted(path))\n+            {\n+                path = Path.GetFullPath(path);\n+            }\n+\n+            // remove trailing path separator\n+            path = Path.GetDirectoryName(Path.Combine(path, \"a.txt\"));\n+\n+            if (pattern != \"*\")\n+            {\n+                throw new InvalidOperationException(\"In this context, directory listing with pattern is neither supported not expected to be used.\");\n+            }\n+\n+            // Do IO monitoring if needed.\n+            if (uniqueGetDirectoryFiles != null)\n+            {\n+                uniqueGetDirectoryFiles.AddOrUpdate(path, 1, (_, n) => n+1);\n+            }\n+\n+            return s_existentFiles\n+                .Where(fn => Path.GetDirectoryName(fn).Equals(path, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "msbuild does not seems to be case sensitive.\r\nIn many other places, for example `SystemState.cs` there are many caching dictionaries initialized with StringComparison.OrdinalIgnoreCase. The most closely relevant is `private Dictionary<string, DateTime> instanceLocalLastModifiedCache = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);` which is internally used to caching FileExists delegate invocations.",
              "createdAt": "2021-01-18T19:00:36Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -861,6 +867,52 @@ internal static bool FileExists(string path)\n             return false;\n         }\n \n+        /// <summary>\n+        /// Mock the Directory.GetFiles method.\n+        /// </summary>\n+        /// <param name=\"path\">The path to directory.</param>\n+        /// <returns>'true' if the file is supposed to exist</returns>\n+\n+        internal static string[] GetDirectoryFiles(string path, string pattern)\n+        {\n+            if (!Path.IsPathRooted(path))\n+            {\n+                path = Path.GetFullPath(path);\n+            }\n+\n+            // remove trailing path separator\n+            path = Path.GetDirectoryName(Path.Combine(path, \"a.txt\"));\n+\n+            if (pattern != \"*\")\n+            {\n+                throw new InvalidOperationException(\"In this context, directory listing with pattern is neither supported not expected to be used.\");\n+            }\n+\n+            // Do IO monitoring if needed.\n+            if (uniqueGetDirectoryFiles != null)\n+            {\n+                uniqueGetDirectoryFiles.AddOrUpdate(path, 1, (_, n) => n+1);\n+            }\n+\n+            return s_existentFiles\n+                .Where(fn => Path.GetDirectoryName(fn).Equals(path, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Rebase to pick up this change from the `master` branch.",
              "createdAt": "2021-01-15T10:54:09Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -5,9 +5,6 @@\n     <add key=\"dotnet-core\" value=\"https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json\" />\n     <add key=\"arcade\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json\" />\n     <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />\n-    <add key=\"roslyn\" value=\"https://dotnet.myget.org/F/roslyn/api/v3/index.json\" />\n-    <add key=\"nuget-build\" value=\"https://dotnet.myget.org/F/nuget-build/api/v3/index.json\" />\n-    <add key=\"roslyn-tools\" value=\"https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json\" />",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-01-15T14:10:47Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -5,9 +5,6 @@\n     <add key=\"dotnet-core\" value=\"https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json\" />\n     <add key=\"arcade\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json\" />\n     <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />\n-    <add key=\"roslyn\" value=\"https://dotnet.myget.org/F/roslyn/api/v3/index.json\" />\n-    <add key=\"nuget-build\" value=\"https://dotnet.myget.org/F/nuget-build/api/v3/index.json\" />\n-    <add key=\"roslyn-tools\" value=\"https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json\" />",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you explain why the `fileExists` callback isn't modified to use the new caching logic based on caching directory listings, and why the `isFileExistenceVerified` flag is being passed around instead?",
              "createdAt": "2021-01-15T12:21:41Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +190,7 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            if (isFileExistenceVerified || fileExists(pathToCandidateAssembly))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I was trying to isolate changes just to context of 'ResolveFromDirectory' method. 'fileExists' delegate is used by other methods in base and/or derived classes and it would be very hard, I think, to verify that changes in those usages would render better performance and would not cause a regresion. \r\nUsage of 'isFileExistenceVerified' is also driven by attempt to isolate changes just to `ResolveFromDirectory' method.",
              "createdAt": "2021-01-15T14:29:03Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +190,7 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            if (isFileExistenceVerified || fileExists(pathToCandidateAssembly))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Gotcha. Still not sure why the check is made a few levels up and not here. It would probably read a little better if instead of `bool isFileExistenceVerified` you passed `bool useDirectoryCache` and this method would call one or the other. To me the way it's written now feels inconsistent.",
              "createdAt": "2021-01-15T14:43:17Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +190,7 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            if (isFileExistenceVerified || fileExists(pathToCandidateAssembly))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Changed. I were also considering to pass new fileExists delegate as oppose to pass three new arguments. \r\nFrom Clean Code perspective it would be probably better, but it requires another two allocations per call. \r\nShall I trade it?",
              "createdAt": "2021-01-18T19:01:07Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +190,7 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            if (isFileExistenceVerified || fileExists(pathToCandidateAssembly))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: The method is returning the result of `ToArray()` which cannot be null.",
              "createdAt": "2021-01-20T09:44:41Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -966,6 +966,19 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =\n             }\n         }\n \n+        /// <summary>\n+        /// Get all files from directory matching pattern\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"pattern\"></param>\n+        /// <param name=\"fileSystem\"></param>\n+        /// <returns>list of files or null if it is impossible to get files</returns>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "fixed - leftover from initial version with try catch",
              "createdAt": "2021-01-20T12:15:45Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -966,6 +966,19 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =\n             }\n         }\n \n+        /// <summary>\n+        /// Get all files from directory matching pattern\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"pattern\"></param>\n+        /// <param name=\"fileSystem\"></param>\n+        /// <returns>list of files or null if it is impossible to get files</returns>",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Indentation.",
              "createdAt": "2021-01-20T10:28:03Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs",
              "diffHunk": "@@ -7658,7 +7623,74 @@ public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()\n                 }\n                 finally\n                 {\n-                    fileExists = cachedFileExists;\n+                    s_existentFiles = preservedExistentFiles;\n+                    getAssemblyName = cachedGetAssemblyName;\n+                }\n+\n+                Assert.True(success); // \"Expected no errors.\"\n+                Assert.Single(t.ResolvedFiles); // \"Expected one resolved assembly.\"\n+                Assert.Contains(\"System.Xml\", t.ResolvedFiles[0].ItemSpec); // \"Expected System.Xml to resolve.\"\n+            }\n+            finally\n+            {\n+                File.Delete(redistListPath);\n+            }\n+        }\n+\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void HandleFilesInSearchPathsWhichDiffersOnlyInCasing()\n+        {\n+            string redistListPath = CreateGenericRedistList();\n+            try\n+            {\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+\n+                t.BuildEngine = new MockEngine(_output);\n+\n+                t.Assemblies = new ITaskItem[]\n+                {\n+                    new TaskItem(\"System.Xml\")\n+                };\n+\n+                t.SearchPaths = new string[]\n+                {\n+                        @\"{TargetFrameworkDirectory}\"",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "fixed",
              "createdAt": "2021-01-20T12:17:22Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs",
              "diffHunk": "@@ -7658,7 +7623,74 @@ public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()\n                 }\n                 finally\n                 {\n-                    fileExists = cachedFileExists;\n+                    s_existentFiles = preservedExistentFiles;\n+                    getAssemblyName = cachedGetAssemblyName;\n+                }\n+\n+                Assert.True(success); // \"Expected no errors.\"\n+                Assert.Single(t.ResolvedFiles); // \"Expected one resolved assembly.\"\n+                Assert.Contains(\"System.Xml\", t.ResolvedFiles[0].ItemSpec); // \"Expected System.Xml to resolve.\"\n+            }\n+            finally\n+            {\n+                File.Delete(redistListPath);\n+            }\n+        }\n+\n+        [Fact]\n+        [Trait(\"Category\", \"mono-osx-failing\")]\n+        public void HandleFilesInSearchPathsWhichDiffersOnlyInCasing()\n+        {\n+            string redistListPath = CreateGenericRedistList();\n+            try\n+            {\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+\n+                t.BuildEngine = new MockEngine(_output);\n+\n+                t.Assemblies = new ITaskItem[]\n+                {\n+                    new TaskItem(\"System.Xml\")\n+                };\n+\n+                t.SearchPaths = new string[]\n+                {\n+                        @\"{TargetFrameworkDirectory}\"",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the reason for using `ConcurrentDictionary` just so you can call `AddOrUpdate` or do we actually expect concurrency?",
              "createdAt": "2021-01-20T10:34:21Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -300,6 +305,7 @@ internal void StartIOMonitoring()\n             // If tables are present then the corresponding IO function will do some monitoring.\n             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n+            uniqueGetDirectoryFiles = new ConcurrentDictionary<string, int>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I believe that current implementation is not thread safe. Default xunit execution runs tests in derived classes concurrently and since this (uniqueFileExists, uniqueGetAssemblyName  and uniqueGetDirectoryFiles) are static, they can be damaged by concurrent write. \r\nIn theory it could be that only one class actually write to those but to be sure we would have to carefully review all 20ish derived classes.\r\nI did wanted to make situation with thread safety worse, so I have decided to plat safe and use ConcurrentDictionary\r\n",
              "createdAt": "2021-01-20T12:32:40Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -300,6 +305,7 @@ internal void StartIOMonitoring()\n             // If tables are present then the corresponding IO function will do some monitoring.\n             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n+            uniqueGetDirectoryFiles = new ConcurrentDictionary<string, int>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This should guarantee that tests in the same assembly never run in parallel, making statics and other shared state legal:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/f98579d50f8b08c4efe13ca07327e3e5222b50f8/src/Shared/UnitTests/TestAssemblyInfo.cs#L11\r\n\r\nI would personally lean towards not using `ConcurrentDictionary` to avoid making a false impression that tests are thread-safe. On the other hand I accept your argument of not making it worse, so fine either way.",
              "createdAt": "2021-01-20T12:40:45Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -300,6 +305,7 @@ internal void StartIOMonitoring()\n             // If tables are present then the corresponding IO function will do some monitoring.\n             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n+            uniqueGetDirectoryFiles = new ConcurrentDictionary<string, int>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "+1",
              "createdAt": "2021-01-20T17:16:51Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -300,6 +305,7 @@ internal void StartIOMonitoring()\n             // If tables are present then the corresponding IO function will do some monitoring.\n             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n+            uniqueGetDirectoryFiles = new ConcurrentDictionary<string, int>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I was looking for it, but I have missed it, maybe because it is included in `src\\Directory.Build.targets` as conditional item.\r\nChanged to `Dictionary`.",
              "createdAt": "2021-01-20T21:24:27Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -300,6 +305,7 @@ internal void StartIOMonitoring()\n             // If tables are present then the corresponding IO function will do some monitoring.\n             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n+            uniqueGetDirectoryFiles = new ConcurrentDictionary<string, int>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Indentation. Same issue in the next hunk below.",
              "createdAt": "2021-01-20T10:36:50Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -3006,6 +3058,7 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC\n \t                    fileExists,\n \t                    directoryExists,\n \t                    getDirectories,\n+                        getDirectoryFiles,",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "hmmm, there was couple of \\t whitespaces, i replaced them all by spaces - it was not a regression...",
              "createdAt": "2021-01-20T12:37:05Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -3006,6 +3058,7 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC\n \t                    fileExists,\n \t                    directoryExists,\n \t                    getDirectories,\n+                        getDirectoryFiles,",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `fill`.",
              "createdAt": "2021-01-20T10:40:56Z",
              "path": "src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs",
              "diffHunk": "@@ -26,10 +26,11 @@ internal class CandidateAssemblyFilesResolver : Resolver\n         /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n         /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n         /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n+        /// <param name=\"getDirectoryFile\">Delegate to test if file exists in directory and return fill file name</param>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "fixed",
              "createdAt": "2021-01-20T12:38:47Z",
              "path": "src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs",
              "diffHunk": "@@ -26,10 +26,11 @@ internal class CandidateAssemblyFilesResolver : Resolver\n         /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n         /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n         /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n+        /// <param name=\"getDirectoryFile\">Delegate to test if file exists in directory and return fill file name</param>",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `fill`.",
              "createdAt": "2021-01-20T10:41:10Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs",
              "diffHunk": "@@ -18,10 +18,11 @@ internal class AssemblyFoldersResolver : Resolver\n         /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n         /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n         /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n+        /// <param name=\"getDirectoryFile\">Delegate to test if file exists in directory and return fill file name</param>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "fixed 'fill -> full'",
              "createdAt": "2021-01-20T12:38:27Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs",
              "diffHunk": "@@ -18,10 +18,11 @@ internal class AssemblyFoldersResolver : Resolver\n         /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n         /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n         /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n+        /// <param name=\"getDirectoryFile\">Delegate to test if file exists in directory and return fill file name</param>",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Use the same descriptive comment as on the ctor below?\r\n\r\n```suggestion\r\n        /// <summary>Delegate used for checking for the existence of a file in a directory and mapping it to full path.</summary>\r\n```",
              "createdAt": "2021-01-20T10:43:43Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -79,6 +79,8 @@ internal sealed class ReferenceTable\n         private readonly DirectoryExists _directoryExists;\n         /// <summary>Delegate used for getting directories.</summary>\n         private readonly GetDirectories _getDirectories;\n+        /// <summary>Delegate used for verify file in directories.</summary>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-01-20T12:39:52Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -79,6 +79,8 @@ internal sealed class ReferenceTable\n         private readonly DirectoryExists _directoryExists;\n         /// <summary>Delegate used for getting directories.</summary>\n         private readonly GetDirectories _getDirectories;\n+        /// <summary>Delegate used for verify file in directories.</summary>",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you remind me why this call takes directory + filename as opposed to full path? Is it an optimization where we don't want to burn cycles splitting the full path when we already have the two components? Or would something break functionally if the implementation was abstracted away and the signature was simply `bool (string)`?",
              "createdAt": "2021-01-20T11:28:29Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +196,27 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            bool fileFound;\n+            if (useDirectoryCache && Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10))\n+            {\n+                // this verifies file existence using getDirectoryFile delegate which internally used cached list of all files in a particular directory\n+                // if some cases it render better performance than one by one FileExists\n+                try\n+                {\n+                    fileFound = getDirectoryFile(directory, fileName) != null;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It is optimization. `bool (string)` would require Path.GetFileName and Path.GetDirectoryName with two related string allocations. Since this is known and initialized upper in call stack, I have decided to pass it down for perf reasons.\r\nHadn't this been perf critical part of code, I'd go with `bool (string)`.\r\nThe reasons why it is `string:filename (directory, file)` and not `bool:exists (directory, file)` is that returning full path string has better reusability as it could have potentially safe `string fullPath = directory + file`, in my code it is however not used, as unit tests are sensitive to casing and expect preserve casing of query directory and file.",
              "createdAt": "2021-01-20T12:49:56Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +196,27 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            bool fileFound;\n+            if (useDirectoryCache && Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10))\n+            {\n+                // this verifies file existence using getDirectoryFile delegate which internally used cached list of all files in a particular directory\n+                // if some cases it render better performance than one by one FileExists\n+                try\n+                {\n+                    fileFound = getDirectoryFile(directory, fileName) != null;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Extra empty line.",
              "createdAt": "2021-01-20T11:29:41Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "fixed",
              "createdAt": "2021-01-20T13:03:25Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Missing space after `foreach`.",
              "createdAt": "2021-01-20T11:30:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = new Dictionary<string, string>(files.Length, StringComparer.OrdinalIgnoreCase);\n+                foreach(var file in files)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Missing space after `catch`.",
              "createdAt": "2021-01-20T11:32:47Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-01-20T13:04:13Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is anything actually using the string return value? Can we save memory by changing the cache to `Dictionary<string, Dictionary<string, bool>>`?",
              "createdAt": "2021-01-20T11:42:18Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Originally I was using cached full path value, by callers, as opposed to Path.Combine it. But since that approach cause few unit tests failures (file name case sensitivity) I had to get back to original behavior.\r\nI was hoping that we might revisit the need for that case sensitivity in unit tests, btu since this is not likely to happen, I have just rewritten the code to `Dictionary<string, HashSet<string>>`",
              "createdAt": "2021-01-20T19:26:39Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: why a custom delegate instead of ```Func<string, string, string>```?",
              "createdAt": "2021-01-20T17:08:12Z",
              "path": "src/Shared/FileDelegates.cs",
              "diffHunk": "@@ -6,13 +6,22 @@\n namespace Microsoft.Build.Shared\n {\n     /// <summary>\n-    /// delegate for System.IO.Directory.GetFiles, used for testing\n+    /// delegate for System.IO.Directory.GetFiles\n     /// </summary>\n     /// <param name=\"path\">Directory path to start search for files in</param>\n     /// <param name=\"searchPattern\">pattern of files to match</param>\n     /// <returns>string array of files which match search pattern</returns>\n     internal delegate string[] DirectoryGetFiles(string path, string searchPattern);\n \n+    /// <summary>\n+    /// delegate for optimized looking up files in directory\n+    /// designed to be used for testing and to verify file existence by directory listing\n+    /// </summary>\n+    /// <param name=\"path\">Directory path to start search for files in</param>\n+    /// <param name=\"fileName\">name of file</param>\n+    /// <returns>return full path file name or null if file do not exists</returns>\n+    internal delegate string DirectoryFile(string path, string fileName);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "That's how it was previously...though honestly, I do like the idea of a Func<string, string, string>",
              "createdAt": "2021-01-20T18:05:06Z",
              "path": "src/Shared/FileDelegates.cs",
              "diffHunk": "@@ -6,13 +6,22 @@\n namespace Microsoft.Build.Shared\n {\n     /// <summary>\n-    /// delegate for System.IO.Directory.GetFiles, used for testing\n+    /// delegate for System.IO.Directory.GetFiles\n     /// </summary>\n     /// <param name=\"path\">Directory path to start search for files in</param>\n     /// <param name=\"searchPattern\">pattern of files to match</param>\n     /// <returns>string array of files which match search pattern</returns>\n     internal delegate string[] DirectoryGetFiles(string path, string searchPattern);\n \n+    /// <summary>\n+    /// delegate for optimized looking up files in directory\n+    /// designed to be used for testing and to verify file existence by directory listing\n+    /// </summary>\n+    /// <param name=\"path\">Directory path to start search for files in</param>\n+    /// <param name=\"fileName\">name of file</param>\n+    /// <returns>return full path file name or null if file do not exists</returns>\n+    internal delegate string DirectoryFile(string path, string fileName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I was trying to be consistent with existing code. \r\nI am not used to use delegates for DI purposes and have not wrapped my head around it yet, given my past experience I'd rather use interfaces here, but as for readability in this particular case using predefined delegate is more readable - to me.\r\nAll in all, for code consistency reasons I do not recommend to use Func<...> here.",
              "createdAt": "2021-01-20T18:42:27Z",
              "path": "src/Shared/FileDelegates.cs",
              "diffHunk": "@@ -6,13 +6,22 @@\n namespace Microsoft.Build.Shared\n {\n     /// <summary>\n-    /// delegate for System.IO.Directory.GetFiles, used for testing\n+    /// delegate for System.IO.Directory.GetFiles\n     /// </summary>\n     /// <param name=\"path\">Directory path to start search for files in</param>\n     /// <param name=\"searchPattern\">pattern of files to match</param>\n     /// <returns>string array of files which match search pattern</returns>\n     internal delegate string[] DirectoryGetFiles(string path, string searchPattern);\n \n+    /// <summary>\n+    /// delegate for optimized looking up files in directory\n+    /// designed to be used for testing and to verify file existence by directory listing\n+    /// </summary>\n+    /// <param name=\"path\">Directory path to start search for files in</param>\n+    /// <param name=\"fileName\">name of file</param>\n+    /// <returns>return full path file name or null if file do not exists</returns>\n+    internal delegate string DirectoryFile(string path, string fileName);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can you confirm ```AttemptToShortenPath``` handles NULL or path.Length = 0 cases?  If not, should this method validate ```path```?",
              "createdAt": "2021-01-20T17:09:46Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -966,6 +966,19 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =\n             }\n         }\n \n+        /// <summary>\n+        /// Get all files from directory matching pattern\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"pattern\"></param>\n+        /// <param name=\"fileSystem\"></param>\n+        /// <returns>list of files or null if it is impossible to get files</returns>\n+        internal static string[] DirectoryGetFiles(string path, string pattern = \"*\", IFileSystem fileSystem = null)\n+        {\n+            path = AttemptToShortenPath(path);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I used this method at some places and for same reason as it was used in `FileExistsNoThrow`, but no, this function do not test nullOrEmpty. I have not looked it, but I believe this is handled somewhere upper in call stack.",
              "createdAt": "2021-01-20T18:48:24Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -966,6 +966,19 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =\n             }\n         }\n \n+        /// <summary>\n+        /// Get all files from directory matching pattern\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"pattern\"></param>\n+        /// <param name=\"fileSystem\"></param>\n+        /// <returns>list of files or null if it is impossible to get files</returns>\n+        internal static string[] DirectoryGetFiles(string path, string pattern = \"*\", IFileSystem fileSystem = null)\n+        {\n+            path = AttemptToShortenPath(path);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "It might be reasonable to check and make sure there are tests for that, as that sort of behavior could be changed in the future, possibly by accident.",
              "createdAt": "2021-01-20T22:13:04Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -966,6 +966,19 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =\n             }\n         }\n \n+        /// <summary>\n+        /// Get all files from directory matching pattern\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"pattern\"></param>\n+        /// <param name=\"fileSystem\"></param>\n+        /// <returns>list of files or null if it is impossible to get files</returns>\n+        internal static string[] DirectoryGetFiles(string path, string pattern = \"*\", IFileSystem fileSystem = null)\n+        {\n+            path = AttemptToShortenPath(path);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "null is handled here:\r\nhttps://github.com/dotnet/msbuild/blob/5190c1336185d67cb59a69ea9c47cf89e64698b4/src/Tasks/AssemblyDependency/Resolver.cs#L347\r\nI will write some unit tests to cover these use cases with current behavior.",
              "createdAt": "2021-01-20T23:25:02Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -966,6 +966,19 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =\n             }\n         }\n \n+        /// <summary>\n+        /// Get all files from directory matching pattern\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"pattern\"></param>\n+        /// <param name=\"fileSystem\"></param>\n+        /// <returns>list of files or null if it is impossible to get files</returns>\n+        internal static string[] DirectoryGetFiles(string path, string pattern = \"*\", IFileSystem fileSystem = null)\n+        {\n+            path = AttemptToShortenPath(path);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "not actionable....I am unsure how I feel about this.  I know you only updated a parameter.",
              "createdAt": "2021-01-20T17:11:20Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs",
              "diffHunk": "@@ -3312,7 +3312,7 @@ public void ParentAssemblyResolvedFromAForGac()\n         /// <returns></returns>\n         private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string location)\n         {\n-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,\n+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, getDirectoryFile, null, null, null, null,",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Refactoring unit tests, although it would be beneficial, was not target of this PR.\r\nPossible action would be to create 'issue' to do so - if there is reasonable chance anyone will get to it.",
              "createdAt": "2021-01-20T18:51:29Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs",
              "diffHunk": "@@ -3312,7 +3312,7 @@ public void ParentAssemblyResolvedFromAForGac()\n         /// <returns></returns>\n         private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string location)\n         {\n-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,\n+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, getDirectoryFile, null, null, null, null,",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider ternary operator.",
              "createdAt": "2021-01-20T17:18:11Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -861,6 +867,52 @@ internal static bool FileExists(string path)\n             return false;\n         }\n \n+        /// <summary>\n+        /// Mock the Directory.GetFiles method.\n+        /// </summary>\n+        /// <param name=\"path\">The path to directory.</param>\n+        /// <returns>'true' if the file is supposed to exist</returns>\n+\n+        internal static string[] GetDirectoryFiles(string path, string pattern)\n+        {\n+            if (!Path.IsPathRooted(path))\n+            {\n+                path = Path.GetFullPath(path);\n+            }\n+\n+            // remove trailing path separator\n+            path = Path.GetDirectoryName(Path.Combine(path, \"a.txt\"));\n+\n+            if (pattern != \"*\")\n+            {\n+                throw new InvalidOperationException(\"In this context, directory listing with pattern is neither supported not expected to be used.\");\n+            }\n+\n+            // Do IO monitoring if needed.\n+            if (uniqueGetDirectoryFiles != null)\n+            {\n+                uniqueGetDirectoryFiles.AddOrUpdate(path, 1, (_, n) => n+1);\n+            }\n+\n+            return s_existentFiles\n+                .Where(fn => Path.GetDirectoryName(fn).Equals(path, StringComparison.OrdinalIgnoreCase))\n+                .Select(fn => Path.Combine(path, Path.GetFileName(fn)))\n+                .Distinct()\n+                .ToArray();\n+        }\n+\n+        internal static string GetDirectoryFile(string path, string fileName)\n+        {\n+            string fullName = Path.Combine(path, fileName);\n+\n+            if (!FileExists(fullName))\n+            {",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "code was reworked",
              "createdAt": "2021-01-20T19:08:28Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -861,6 +867,52 @@ internal static bool FileExists(string path)\n             return false;\n         }\n \n+        /// <summary>\n+        /// Mock the Directory.GetFiles method.\n+        /// </summary>\n+        /// <param name=\"path\">The path to directory.</param>\n+        /// <returns>'true' if the file is supposed to exist</returns>\n+\n+        internal static string[] GetDirectoryFiles(string path, string pattern)\n+        {\n+            if (!Path.IsPathRooted(path))\n+            {\n+                path = Path.GetFullPath(path);\n+            }\n+\n+            // remove trailing path separator\n+            path = Path.GetDirectoryName(Path.Combine(path, \"a.txt\"));\n+\n+            if (pattern != \"*\")\n+            {\n+                throw new InvalidOperationException(\"In this context, directory listing with pattern is neither supported not expected to be used.\");\n+            }\n+\n+            // Do IO monitoring if needed.\n+            if (uniqueGetDirectoryFiles != null)\n+            {\n+                uniqueGetDirectoryFiles.AddOrUpdate(path, 1, (_, n) => n+1);\n+            }\n+\n+            return s_existentFiles\n+                .Where(fn => Path.GetDirectoryName(fn).Equals(path, StringComparison.OrdinalIgnoreCase))\n+                .Select(fn => Path.Combine(path, Path.GetFileName(fn)))\n+                .Distinct()\n+                .ToArray();\n+        }\n+\n+        internal static string GetDirectoryFile(string path, string fileName)\n+        {\n+            string fullName = Path.Combine(path, fileName);\n+\n+            if (!FileExists(fullName))\n+            {",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: naming consistency.  Elsewhere, instance fields are prefixed with \"_\"; thus, ```_getFiles\".",
              "createdAt": "2021-01-20T17:23:52Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -94,6 +102,11 @@ internal sealed class SystemState : StateFileBase, ISerializable\n         /// </summary>\n         private DirectoryExists directoryExists;\n \n+        /// <summary>\n+        /// Cached delegate.\n+        /// </summary>\n+        private DirectoryGetFiles getFiles;",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "In this particular class 'SystemState' are all private fields without _\r\nNot happy about this inconsistency with rest of the solution at all.",
              "createdAt": "2021-01-20T19:11:22Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -94,6 +102,11 @@ internal sealed class SystemState : StateFileBase, ISerializable\n         /// </summary>\n         private DirectoryExists directoryExists;\n \n+        /// <summary>\n+        /// Cached delegate.\n+        /// </summary>\n+        private DirectoryGetFiles getFiles;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor:  consider string instead of var for consistency.",
              "createdAt": "2021-01-20T17:25:17Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = new Dictionary<string, string>(files.Length, StringComparer.OrdinalIgnoreCase);\n+                foreach(var file in files)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Code was reworked",
              "createdAt": "2021-01-20T19:09:08Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,47 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.\n+        /// </summary>\n+        /// <param name=\"path\"></param>\n+        /// <param name=\"fileName\"></param>\n+        /// <returns>file full path or null if file do not exists</returns>\n+        private string GetDirectoryFile(string path, string fileName)\n+        {\n+\n+            instanceLocalDirectoryFiles.TryGetValue(path, out Dictionary<string, string> cached);\n+            if (cached == null)\n+            {\n+                string[] files;\n+                try\n+                {\n+                    files = getFiles(path, \"*\");\n+                }\n+                catch(DirectoryNotFoundException)\n+                {\n+                    files = Array.Empty<string>();\n+                }\n+\n+                cached = new Dictionary<string, string>(files.Length, StringComparer.OrdinalIgnoreCase);\n+                foreach(var file in files)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: prefer to add new variables to the end if possible. Also in other places.",
              "createdAt": "2021-01-20T22:03:01Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs",
              "diffHunk": "@@ -74,11 +74,11 @@ internal class AssemblyFoldersFromConfigResolver : Resolver\n         /// Construct.\n         /// </summary>\n         public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyName getAssemblyName,\n-            FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,\n+            FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does it mean for the search path to be bad? That it has invalid characters? That's the only time I could imagine it throwing.",
              "createdAt": "2021-01-20T22:08:24Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +196,27 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            bool fileFound;\n+            if (useDirectoryCache && Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10))\n+            {\n+                // this verifies file existence using fileExistsInDirectory delegate which internally used cached set of all files in a particular directory\n+                // if some cases it render better performance than one by one FileExists\n+                try\n+                {\n+                    fileFound = fileExistsInDirectory(directory, fileName);\n+                }\n+                catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                {\n+                    // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "yes, it is invalid character, and it throws only on full .Net Framework.",
              "createdAt": "2021-01-20T22:43:17Z",
              "path": "src/Tasks/AssemblyDependency/Resolver.cs",
              "diffHunk": "@@ -181,7 +196,27 @@ ResolutionSearchLocation searchLocation\n \n             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;\n \n-            if (fileExists(pathToCandidateAssembly))\n+            bool fileFound;\n+            if (useDirectoryCache && Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10))\n+            {\n+                // this verifies file existence using fileExistsInDirectory delegate which internally used cached set of all files in a particular directory\n+                // if some cases it render better performance than one by one FileExists\n+                try\n+                {\n+                    fileFound = fileExistsInDirectory(directory, fileName);\n+                }\n+                catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n+                {\n+                    // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty line.",
              "createdAt": "2021-01-21T08:53:38Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -861,6 +867,48 @@ internal static bool FileExists(string path)\n             return false;\n         }\n \n+        /// <summary>\n+        /// Mock the Directory.GetFiles method.\n+        /// </summary>\n+        /// <param name=\"path\">The path to directory.</param>\n+        /// <returns>'true' if the file is supposed to exist</returns>\n+",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation (tabs vs. spaces?).",
              "createdAt": "2021-01-21T08:54:20Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -3001,26 +3049,27 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC\n                     t.FindSerializationAssemblies = false;\n                     t.FindRelatedFiles = false;\n                     t.StateFile = null;\n-\t                t.Execute\n-\t                (\n-\t                    fileExists,\n-\t                    directoryExists,\n-\t                    getDirectories,\n-\t                    getAssemblyName,\n-\t                    getAssemblyMetadata,\n-\t#if FEATURE_WIN32_REGISTRY\n-\t                    getRegistrySubKeyNames,\n-\t                    getRegistrySubKeyDefaultValue,\n-\t#endif\n-\t                    getLastWriteTime,\n-\t                    getRuntimeVersion,\n-\t#if FEATURE_WIN32_REGISTRY\n-\t                    openBaseKey,\n-\t#endif\n-\t                    checkIfAssemblyIsInGac,\n-\t                    isWinMDFile,\n-\t                    readMachineTypeFromPEHeader\n-\t                );\n+                    t.Execute\n+                    (\n+                        fileExists,\n+                        directoryExists,\n+                        getDirectories,\n+                            getDirectoryFiles,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Typo `do` -> `does`.",
              "createdAt": "2021-01-21T10:14:52Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -573,6 +592,36 @@ private string[] GetDirectories(string path, string pattern)\n             return getDirectories(path, pattern);\n         }\n \n+        /// <summary>\n+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.\n+        /// It does not throw if directory do not exists.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}