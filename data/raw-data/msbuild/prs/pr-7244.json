{
  "number": 7244,
  "title": "Simplify MainNodeSdkResolverService",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/7137\r\n\r\n### Context\r\nThe MainNodeSdkResolverService process incoming requests from out-of-proc nodes to handle SDK resolution.  The main node has a queue of all incoming packets that are processed by appropriate handlers.  The MainNodeSdkResolverService currently takes SdkResolverRequests and places them in a queue for processing.  This seems unnecessary to have two queues and two threads draining the queues.\r\n\r\n### Changes Made\r\nRemove queue and thread that process it in favor of launching a fire-and-forget task that resolves the SDK and sends the response.\r\n\r\n### Testing\r\nExisting tests cover this area\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2022-01-10T18:08:44Z",
  "updatedAt": "2022-03-04T10:29:26Z",
  "closedAt": "2022-03-04T10:29:26Z",
  "mergedAt": "2022-03-04T10:29:25Z",
  "additions": 33,
  "deletions": 150,
  "changedFiles": 1,
  "headRefName": "simplify-mainnodesdkresolverservice",
  "isDraft": false,
  "author": {
    "login": "jeffkl"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3c224ae593368836b12da8843f7e6cef16b702e2",
          "message": "Simplify MainNodeSdkResolverService",
          "committedDate": "2022-02-14T18:53:50Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c9115b4999036632e9a0041bcc6e7545cad55c0",
          "message": "Stop using Task.Run and don't name the thread",
          "committedDate": "2022-02-14T18:53:50Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7ba2fe98d5cdf359369dfaca2aa399efce43e16c",
          "message": "Address comment",
          "committedDate": "2022-02-14T18:53:50Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I saw your commit is called WIP, but this isn't a draft, and it doesn't have the WIP label. Do you want reviews?",
        "createdAt": "2022-01-10T18:27:31Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind Yeah sorry my original commit was a work in progress and I ran the tests locally with some failures.  So I pushed the commit and remembered that some tests just don't pass locally so I opened the PR and forgot my commit name was WIP.  Should I update the commit message or will we just update it if/when this is merged?",
        "createdAt": "2022-01-10T19:00:39Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "Not a problem; we can update it when it's merged. I just wasn't sure whether you'd wanted it reviewed \ud83d\ude42",
        "createdAt": "2022-01-10T22:55:50Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> Does this still react properly to shutdown events? I didn't see anything about that.\r\n\r\nGood question, I _think_ the packets will just stop coming in but existing requests will still be running.  Let me see if I can simulate a shutdown an see what actually happens.  If it doesn't respond well, I'll add cancellation support to the `Task.Run()`.",
        "createdAt": "2022-01-11T20:38:30Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "> Does this still react properly to shutdown events?\r\n\r\nI looked into this and shutdown events aren't really applicable anymore since the tasks that respond are fire-and-forget and there's nothing to shutdown.  Cancellation doesn't work, but it never has before since cancellation tokens aren't passed into evaluator.\r\n",
        "createdAt": "2022-01-18T17:25:24Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "Also, how do you assess risk here? Would it be possible to preserve the old behavior under a changewave Just In Case\u2122\ufe0f?",
        "createdAt": "2022-01-19T16:06:30Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> Also, how do you assess risk here? Would it be possible to preserve the old behavior under a changewave Just In Case\u2122\ufe0f?\r\n\r\nI don't think there's much risk here.  From what I can tell, fundamental flaws in this code would almost immediately show up for any build that's using out-of-proc nodes.  There could be a performance impact but I expect things to be faster since the new code should be launching less threads.  I think we're early enough in the release cycle to catch any big problems.  I do want to try an experimental insertion and install the build just to test out the perf.  My local builds aren't NGen'd and are always slower...",
        "createdAt": "2022-02-01T17:00:14Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "@rainersigwald can I get an experimental insertion to install and try out please?",
        "createdAt": "2022-02-02T20:05:53Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "(Resolved offline)",
        "createdAt": "2022-02-02T21:51:30Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Results are in, everything works!  I cloned https://github.com/msbuild/msbuildsdks which uses a lot of MSBuild project SDKs to test\r\n\r\n# Current version (17.0)\r\n```\r\nD:\\msbuildsdks>msbuild /version\r\nMicrosoft (R) Build Engine version 17.0.0+c9eb9dd64 for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n17.0.0.52104\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:08.96\r\n```\r\n# My Version\r\n```\r\nD:\\msbuildsdks>msbuild /version\r\nMicrosoft (R) Build Engine version 17.2.0-preview-22102-01+ab20718e2 for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n17.2.0.10201\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:05.59\r\n```\r\n\r\nSo my change doesn't make anything slower.  I'd imagine I'm also benefiting from other unshipped performance gains so I won't take any credit there.  But nothing is broken!",
        "createdAt": "2022-02-03T04:56:06Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "Also forgot to mention, builds in Visual Studio work just fine as well!",
        "createdAt": "2022-02-03T05:00:27Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "> I'd imagine I'm also benefiting from other unshipped performance gains so I won't take any credit there.\r\n\r\nVery optional, but you can try downloading a recent main build (ideally from right before your change, but eh) to see if it changes anything, I wouldn't be surprised if that was entirely your change!",
        "createdAt": "2022-02-03T15:41:10Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@rainersigwald anything we're waiting on for this PR?  ",
        "createdAt": "2022-02-18T17:41:02Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "> I'm still a bit worried about not having a way to opt back into the old behavior, but if you're super confident that this is better in all cases let's get it in for preview 2.\r\n\r\nI did a lot of testing and couldn't find any cases where it was causing issues.  I loaded a large solution in Visual Studio, did a large command-line build, I added delays to a test SDK resolver, and DDRITs passed.  The sooner this goes in the better for sure, I'm really hoping we don't need an escape hatch since this code path is used so much, we should find if there are any problems with it very soon.",
        "createdAt": "2022-02-18T17:55:20Z",
        "author": {
          "login": "jeffkl"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Renaming a ThreadPool thread feels fishy to me. This task will only be running briefly.",
              "createdAt": "2022-01-11T20:26:23Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "After a thread is returned to the ThreadPool, I would assume no one cares about it, right? The previous version renamed a newly-created thread, which presumably meant it was important for logging if something failed, and this version avoids creating the new thread.",
              "createdAt": "2022-01-11T23:05:51Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> After a thread is returned to the ThreadPool, I would assume no one cares about it, right?\r\n\r\nIf the thread retains the name assigned here after it is returned to the pool it would be pretty confusing. Also, `Thread.Name` is documented to be a write-once property. It should be used only on a newly created thread when the first ones setting it or under an `if (Name == null)` check. The implementation seems to be more permissive, at least on Core but I believe that this line should be removed.",
              "createdAt": "2022-01-19T12:46:33Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'll remove this, it was kinda cool to see the thread name under the debugger and I didn't see it crash anything but better safe than sorry...",
              "createdAt": "2022-02-01T16:38:32Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Does `continueOnCapturedContext: false` make a difference when the task has no continuation? ",
              "createdAt": "2022-01-19T12:54:31Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";\n \n-            // Signal that one or more requests have been received\n-            _requestReceivedEvent.Set();\n-        }\n+                SdkResult response = null;\n \n-        /// <summary>\n-        /// Processes all requests that are currently in the queue.\n-        /// </summary>\n-        private void ProcessRequests()\n-        {\n-            // Store a list of threads which are resolving SDKs\n-            List<Task> tasks = new List<Task>(_requests.Count);\n-\n-            SdkResolverRequest item;\n+                try\n+                {\n+                    // Create an SdkReference from the request\n+                    SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n \n-            while (_requests.TryDequeue(out item))\n-            {\n-                SdkResolverRequest request = item;\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-                // Start a thread to resolve an SDK and add it to the list of threads\n-                tasks.Add(Task.Run(() =>\n+                    // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n+                    response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n+                }\n+                catch (Exception e)\n                 {\n-                    SdkResult response = null;\n-                    try\n-                    {\n-                        // Create an SdkReference from the request\n-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n-\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n-                    }\n-                    catch (Exception e)\n-                    {\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n-\n-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n-                    }\n-                    finally\n-                    {\n-                        // Get the node manager and send the response back to the node that requested the SDK\n-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n-\n-                        nodeManager.SendData(request.NodeId, response);\n-                    }\n-                }));\n-            }\n-\n-            // Wait for all tasks to complete\n-            Task.WaitAll(tasks.ToArray());\n-        }\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-        /// <summary>\n-        /// A background thread that waits for requests to be received.\n-        /// </summary>\n-        private void RequestHandlerPumpProc()\n-        {\n-            try\n-            {\n-                Thread.CurrentThread.Name = \"MSBuild SDK Resolver\";\n+                    EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n \n-                while (true)\n+                    loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n+                }\n+                finally\n                 {\n-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };\n-\n-                    int waitId = WaitHandle.WaitAny(handles);\n-                    switch (waitId)\n-                    {\n-                        case 0:\n-                            return;\n+                    // Get the node manager and send the response back to the node that requested the SDK\n+                    INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n \n-                        case 1:\n-                            _requestReceivedEvent.Reset();\n+                    nodeManager.SendData(request.NodeId, response);\n+                }\n+            }).ConfigureAwait(continueOnCapturedContext: false);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "The more I look into it, it seems like this method is already running on a thread pool thread.  The communication receives packets and runs these with a worker queue.  Maybe I don't even need to use `Task.Run()` at all.  Let me look into it.",
              "createdAt": "2022-02-01T16:58:02Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";\n \n-            // Signal that one or more requests have been received\n-            _requestReceivedEvent.Set();\n-        }\n+                SdkResult response = null;\n \n-        /// <summary>\n-        /// Processes all requests that are currently in the queue.\n-        /// </summary>\n-        private void ProcessRequests()\n-        {\n-            // Store a list of threads which are resolving SDKs\n-            List<Task> tasks = new List<Task>(_requests.Count);\n-\n-            SdkResolverRequest item;\n+                try\n+                {\n+                    // Create an SdkReference from the request\n+                    SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n \n-            while (_requests.TryDequeue(out item))\n-            {\n-                SdkResolverRequest request = item;\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-                // Start a thread to resolve an SDK and add it to the list of threads\n-                tasks.Add(Task.Run(() =>\n+                    // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n+                    response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n+                }\n+                catch (Exception e)\n                 {\n-                    SdkResult response = null;\n-                    try\n-                    {\n-                        // Create an SdkReference from the request\n-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n-\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n-                    }\n-                    catch (Exception e)\n-                    {\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n-\n-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n-                    }\n-                    finally\n-                    {\n-                        // Get the node manager and send the response back to the node that requested the SDK\n-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n-\n-                        nodeManager.SendData(request.NodeId, response);\n-                    }\n-                }));\n-            }\n-\n-            // Wait for all tasks to complete\n-            Task.WaitAll(tasks.ToArray());\n-        }\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-        /// <summary>\n-        /// A background thread that waits for requests to be received.\n-        /// </summary>\n-        private void RequestHandlerPumpProc()\n-        {\n-            try\n-            {\n-                Thread.CurrentThread.Name = \"MSBuild SDK Resolver\";\n+                    EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n \n-                while (true)\n+                    loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n+                }\n+                finally\n                 {\n-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };\n-\n-                    int waitId = WaitHandle.WaitAny(handles);\n-                    switch (waitId)\n-                    {\n-                        case 0:\n-                            return;\n+                    // Get the node manager and send the response back to the node that requested the SDK\n+                    INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n \n-                        case 1:\n-                            _requestReceivedEvent.Reset();\n+                    nodeManager.SendData(request.NodeId, response);\n+                }\n+            }).ConfigureAwait(continueOnCapturedContext: false);",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Latest version doesn't call `Task.Run()` this this method is already running in a thread pool",
              "createdAt": "2022-02-02T20:05:10Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";\n \n-            // Signal that one or more requests have been received\n-            _requestReceivedEvent.Set();\n-        }\n+                SdkResult response = null;\n \n-        /// <summary>\n-        /// Processes all requests that are currently in the queue.\n-        /// </summary>\n-        private void ProcessRequests()\n-        {\n-            // Store a list of threads which are resolving SDKs\n-            List<Task> tasks = new List<Task>(_requests.Count);\n-\n-            SdkResolverRequest item;\n+                try\n+                {\n+                    // Create an SdkReference from the request\n+                    SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n \n-            while (_requests.TryDequeue(out item))\n-            {\n-                SdkResolverRequest request = item;\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-                // Start a thread to resolve an SDK and add it to the list of threads\n-                tasks.Add(Task.Run(() =>\n+                    // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n+                    response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n+                }\n+                catch (Exception e)\n                 {\n-                    SdkResult response = null;\n-                    try\n-                    {\n-                        // Create an SdkReference from the request\n-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n-\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n-                    }\n-                    catch (Exception e)\n-                    {\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n-\n-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n-                    }\n-                    finally\n-                    {\n-                        // Get the node manager and send the response back to the node that requested the SDK\n-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n-\n-                        nodeManager.SendData(request.NodeId, response);\n-                    }\n-                }));\n-            }\n-\n-            // Wait for all tasks to complete\n-            Task.WaitAll(tasks.ToArray());\n-        }\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-        /// <summary>\n-        /// A background thread that waits for requests to be received.\n-        /// </summary>\n-        private void RequestHandlerPumpProc()\n-        {\n-            try\n-            {\n-                Thread.CurrentThread.Name = \"MSBuild SDK Resolver\";\n+                    EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n \n-                while (true)\n+                    loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n+                }\n+                finally\n                 {\n-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };\n-\n-                    int waitId = WaitHandle.WaitAny(handles);\n-                    switch (waitId)\n-                    {\n-                        case 0:\n-                            return;\n+                    // Get the node manager and send the response back to the node that requested the SDK\n+                    INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n \n-                        case 1:\n-                            _requestReceivedEvent.Reset();\n+                    nodeManager.SendData(request.NodeId, response);\n+                }\n+            }).ConfigureAwait(continueOnCapturedContext: false);",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Wait, it is running in the thread pool but it doesn't mean that it can be synchronous. Here's the callstack I see with my test build:\r\n\r\n```\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService.PacketReceived(int node, Microsoft.Build.BackEnd.INodePacket packet) Line 81\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord.RoutePacket(int nodeId, Microsoft.Build.BackEnd.INodePacket packet) Line 110\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.NodePacketFactory.PacketFactoryRecord.DeserializeAndRoutePacket(int nodeId, Microsoft.Build.BackEnd.ITranslator translator) Line 102\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.NodePacketFactory.DeserializeAndRoutePacket(int nodeId, Microsoft.Build.BackEnd.NodePacketType packetType, Microsoft.Build.BackEnd.ITranslator translator) Line 58\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.NodeManager.DeserializeAndRoutePacket(int nodeId, Microsoft.Build.BackEnd.NodePacketType packetType, Microsoft.Build.BackEnd.ITranslator translator) Line 261\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext.ReadAndRoutePacket(Microsoft.Build.BackEnd.NodePacketType packetType, byte[] packetData, int packetLength) Line 1090\tC#\r\n>\tMicrosoft.Build.dll!Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.NodeContext.BodyReadComplete(System.IAsyncResult result) Line 1144\tC#\r\n```\r\n\r\nThe frame at the bottom has:\r\n```C#\r\n                    // Read the next packet.\r\n                    BeginAsyncPacketRead();\r\n```\r\nas the next statement to execute. Can we really afford to block processing of further packets from the node until the SDK is resolved?",
              "createdAt": "2022-02-07T13:00:56Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";\n \n-            // Signal that one or more requests have been received\n-            _requestReceivedEvent.Set();\n-        }\n+                SdkResult response = null;\n \n-        /// <summary>\n-        /// Processes all requests that are currently in the queue.\n-        /// </summary>\n-        private void ProcessRequests()\n-        {\n-            // Store a list of threads which are resolving SDKs\n-            List<Task> tasks = new List<Task>(_requests.Count);\n-\n-            SdkResolverRequest item;\n+                try\n+                {\n+                    // Create an SdkReference from the request\n+                    SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n \n-            while (_requests.TryDequeue(out item))\n-            {\n-                SdkResolverRequest request = item;\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-                // Start a thread to resolve an SDK and add it to the list of threads\n-                tasks.Add(Task.Run(() =>\n+                    // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n+                    response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n+                }\n+                catch (Exception e)\n                 {\n-                    SdkResult response = null;\n-                    try\n-                    {\n-                        // Create an SdkReference from the request\n-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n-\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n-                    }\n-                    catch (Exception e)\n-                    {\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n-\n-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n-                    }\n-                    finally\n-                    {\n-                        // Get the node manager and send the response back to the node that requested the SDK\n-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n-\n-                        nodeManager.SendData(request.NodeId, response);\n-                    }\n-                }));\n-            }\n-\n-            // Wait for all tasks to complete\n-            Task.WaitAll(tasks.ToArray());\n-        }\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-        /// <summary>\n-        /// A background thread that waits for requests to be received.\n-        /// </summary>\n-        private void RequestHandlerPumpProc()\n-        {\n-            try\n-            {\n-                Thread.CurrentThread.Name = \"MSBuild SDK Resolver\";\n+                    EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n \n-                while (true)\n+                    loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n+                }\n+                finally\n                 {\n-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };\n-\n-                    int waitId = WaitHandle.WaitAny(handles);\n-                    switch (waitId)\n-                    {\n-                        case 0:\n-                            return;\n+                    // Get the node manager and send the response back to the node that requested the SDK\n+                    INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n \n-                        case 1:\n-                            _requestReceivedEvent.Reset();\n+                    nodeManager.SendData(request.NodeId, response);\n+                }\n+            }).ConfigureAwait(continueOnCapturedContext: false);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I was looked at it. With current state of code we can afford to block packet processing until SDK is resolved. Nodes are single threaded, and node is blocked and wait for response while it sends request to main node for SDK resolution. So it is guaranteed, if I understand it correctly, that there is actually no other packet to be processed - on that particular namedpipe.",
              "createdAt": "2022-02-12T00:51:43Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,57 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)\n             {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n-            {\n-                // Start the background thread which will process queued requests if it has not already been started.\n-                lock (_lockObject)\n-                {\n-                    if (_requestHandler == null)\n-                    {\n-                        // Create the event used to signal that a request was received\n-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);\n-\n-                        // Create the queue used to store requests that need to be processed\n-                        _requests = new ConcurrentQueue<SdkResolverRequest>();\n-\n-                        // Create the thread which processes requests\n-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);\n-                    }\n-                }\n+                return;\n             }\n \n             // Associate the node with the request\n             request.NodeId = node;\n \n-            _requests.Enqueue(request);\n+            Task.Run(() =>\n+            {\n+                Thread.CurrentThread.Name = $\"Process SDK request {request.Name} for node {request.NodeId}\";\n \n-            // Signal that one or more requests have been received\n-            _requestReceivedEvent.Set();\n-        }\n+                SdkResult response = null;\n \n-        /// <summary>\n-        /// Processes all requests that are currently in the queue.\n-        /// </summary>\n-        private void ProcessRequests()\n-        {\n-            // Store a list of threads which are resolving SDKs\n-            List<Task> tasks = new List<Task>(_requests.Count);\n-\n-            SdkResolverRequest item;\n+                try\n+                {\n+                    // Create an SdkReference from the request\n+                    SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n \n-            while (_requests.TryDequeue(out item))\n-            {\n-                SdkResolverRequest request = item;\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-                // Start a thread to resolve an SDK and add it to the list of threads\n-                tasks.Add(Task.Run(() =>\n+                    // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n+                    response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n+                }\n+                catch (Exception e)\n                 {\n-                    SdkResult response = null;\n-                    try\n-                    {\n-                        // Create an SdkReference from the request\n-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);\n-\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations\n-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);\n-                    }\n-                    catch (Exception e)\n-                    {\n-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n-\n-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n-\n-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n-                    }\n-                    finally\n-                    {\n-                        // Get the node manager and send the response back to the node that requested the SDK\n-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n-\n-                        nodeManager.SendData(request.NodeId, response);\n-                    }\n-                }));\n-            }\n-\n-            // Wait for all tasks to complete\n-            Task.WaitAll(tasks.ToArray());\n-        }\n+                    ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;\n \n-        /// <summary>\n-        /// A background thread that waits for requests to be received.\n-        /// </summary>\n-        private void RequestHandlerPumpProc()\n-        {\n-            try\n-            {\n-                Thread.CurrentThread.Name = \"MSBuild SDK Resolver\";\n+                    EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);\n \n-                while (true)\n+                    loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));\n+                }\n+                finally\n                 {\n-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };\n-\n-                    int waitId = WaitHandle.WaitAny(handles);\n-                    switch (waitId)\n-                    {\n-                        case 0:\n-                            return;\n+                    // Get the node manager and send the response back to the node that requested the SDK\n+                    INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;\n \n-                        case 1:\n-                            _requestReceivedEvent.Reset();\n+                    nodeManager.SendData(request.NodeId, response);\n+                }\n+            }).ConfigureAwait(continueOnCapturedContext: false);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: I think `if (packet is not SdkResolverRequest request)` might be sufficient here?",
              "createdAt": "2022-02-08T18:29:18Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,52 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n-            {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I left it like this just because the code used to check both, packet type in a `switch` and then a safe cast.  Technically since this service registers to only receive `SdkResolverRequest` it might not really be necessary to check anything.  But I'll do whatever you folks want.",
              "createdAt": "2022-02-09T21:13:41Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,52 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n-            {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "No that it matter, but since packets are deserialized to concrete class based on `packetType` it is guaranteed, by packet factory, that when `packet is not SdkResolverRequest` its Type cannot be `NodePacketType.ResolveSdkRequest`.",
              "createdAt": "2022-02-12T00:55:48Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,52 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n-            {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I've changed the logic to just do a safe cast",
              "createdAt": "2022-02-14T20:56:22Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs",
              "diffHunk": "@@ -78,148 +57,52 @@ public override void ClearCaches()\n         /// <inheritdoc cref=\"INodePacketHandler.PacketReceived\"/>\n         public override void PacketReceived(int node, INodePacket packet)\n         {\n-            switch (packet.Type)\n-            {\n-                case NodePacketType.ResolveSdkRequest:\n-                    HandleRequest(node, packet as SdkResolverRequest);\n-                    break;\n-            }\n-        }\n-\n-        /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n-        {\n-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));\n-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));\n-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));\n-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));\n-\n-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n-        }\n-\n-        /// <summary>\n-        /// Handles a request from a remote node.\n-        /// </summary>\n-        /// <param name=\"node\">The ID of the remote node.</param>\n-        /// <param name=\"request\">The <see cref=\"SdkResolverRequest\"/> containing information about the SDK to resolve.</param>\n-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply\n-        /// adds requests to a queue which are processed by a background thread.</remarks>\n-        private void HandleRequest(int node, SdkResolverRequest request)\n-        {\n-            if (_requestHandler == null)\n+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      }
    ]
  }
}