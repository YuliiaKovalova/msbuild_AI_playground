{
  "number": 6994,
  "title": "Enable TaskHostFactory for .NET (Core) MSBuild",
  "body": "Fixes #5158\r\n\r\n### Context\r\n\r\nA task author can force any task to run out of process by specifying that it must run with `TaskFactory=\"TaskHostFactory\"`. But we never made this work on .NET Core; it fails with an error like\r\n\r\n```\r\nS:\\msbuild\\foo.proj(8,5): error MSB4216: Could not run the \"Message\" task because MSBuild could not create or connect to a task host with runtime \"CLR4\" and architecture \"x64\".  Please ensure that (1) the requested runtime and/or architecture are available on the machine, and (2) that the required executable \"S:\\msbuild\\.dotnet\\sdk\\6.0.100-rc.1.21458.32\\MSBuild.exe\" exists and can be run.\r\n```\r\n\r\nThat's because the \"default\" task host runtime was hardcoded to be `CLR4` (even when on .NET 6.0+).\r\n\r\n\r\n### Changes Made\r\n\r\nCreated `GetCurrentMSBuildRuntime()` and used it; plumbed the new value around and checked for it in a few places. Eliminated `FEATURE_TASKHOST` since it's on everywhere now. Unified the named-pipe-name computation code (before it was using a different pipe name for taskhost pipes on UNIX).\r\n\r\n### Testing\r\n\r\nRe-enabled tests for this behavior that have been disabled on .NET Core. Extended some to account for the `NET` runtime.\r\n",
  "state": "MERGED",
  "createdAt": "2021-10-25T20:03:22Z",
  "updatedAt": "2022-05-02T22:04:42Z",
  "closedAt": "2021-11-15T19:25:18Z",
  "mergedAt": "2021-11-15T19:25:18Z",
  "additions": 206,
  "deletions": 89,
  "changedFiles": 22,
  "headRefName": "core-taskhost",
  "isDraft": false,
  "author": {
    "login": "rainersigwald"
  },
  "milestone": {
    "title": "VS 17.1"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    ".NET Core",
    "Area: Engine",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c3f95760a1764ecac85778efd4c013c186d37e17",
          "message": "Enable out-of-proc TaskHosts on .NET Core",
          "committedDate": "2021-11-02T19:39:20Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "315e0debefab84015ea717652a645d5ee717a55d",
          "message": "Promote FEATURE_TASKHOST to no-flag-needed\n\nThis enables taskhost tests on .NET Core. Includes a couple of low-\ncomplexity test fixes.",
          "committedDate": "2021-11-02T19:39:20Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d62c4bc070ecb9d0fb83267976ecb6374044d961",
          "message": "Enable checking runtimetype in .tasks file",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c6c5cef2c7a4a884be0a7bb1c970a04955b52155",
          "message": "Check runtime type in tasks file",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "67338c82610fcecc5b1d72382cd0358e19d6a4ca",
          "message": "Extend TestRuntimeValuesMatch for net",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6aa77954aa8caefcf12e5034071cf31a0c7c12fb",
          "message": "Extend RuntimeValuesMatch for net",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "459ce25ac6118e366f4153db4ace6b2531140e05",
          "message": "Split and shouldly-ify TestMergeRuntimeValues",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "825c79689e6486657fe63972ef792feb6b8bcafb",
          "message": "Use explicit current runtime/arch in CreatableByTaskFactoryMatchingIdentity",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd98059ac91b100653b5e8bf55d726b8b8edbbc6",
          "message": "Unify to NamedPipeUtil.GetPipeNameOrPath",
          "committedDate": "2021-11-03T19:41:48Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8bd8bb8320dc005b9f1598f2722b267e63a981a3",
          "message": "fixup! Enable out-of-proc TaskHosts on .NET Core",
          "committedDate": "2021-11-15T15:50:34Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d2ac982118e1923176cd1361e82d04bcf437e46f",
          "message": "fixup! Enable out-of-proc TaskHosts on .NET Core",
          "committedDate": "2021-11-15T16:22:34Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Oh, and I'm curious if there are any other issues (disabled tests) we can close with this PR. Have you checked/just know there aren't?",
        "createdAt": "2021-11-05T17:43:51Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> I'm curious if there are any other issues (disabled tests) we can close with this PR. Have you checked/just know there aren't?\r\n\r\nI checked lightly and didn't see anything.",
        "createdAt": "2021-11-15T16:50:38Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I see this hit the main branch. I'm wondering what SDK version(s) this was/will be released in? And/or how to find that information myself. Thanks!",
        "createdAt": "2022-05-02T21:43:49Z",
        "author": {
          "login": "mooredynasty"
        }
      },
      {
        "body": "I don't know if this is a good way to do it at all, but you can look at the release/version branches in the dotnet/sdk repo then go to eng/Versions.Details.xml and find Microsoft.Build. That gives you a commit hash for the last MSBuild in that version, and you can go to our commits list to figure out if that's before or after this.\r\n\r\nLike for release/6.0.2xx, https://github.com/dotnet/sdk/blob/release/6.0.2xx/eng/Version.Details.xml#L71 says a02f73656613e752c73ff442cdd72540f4b09f57, which is https://github.com/dotnet/msbuild/commit/a02f73656613e752c73ff442cdd72540f4b09f57, which came out in February, so it should also include this commit.\r\n\r\nFrom there, you can do binary search.",
        "createdAt": "2022-05-02T22:04:41Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "@baronfel I'd like your input on this new name please. We need to add an entry to the list that indicates \".NET Core or .NET 5.0+\" and is distinguishable from the longstanding `CLR2` and `CLR4`. We should probably get buyoff from somebody in .NET Runtime PM about it.",
              "createdAt": "2021-11-03T19:47:01Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues\n             internal const string clr2 = \"CLR2\";\n             internal const string clr4 = \"CLR4\";\n             internal const string currentRuntime = \"CurrentRuntime\";\n+            internal const string net = \"NET\";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Reaching out to some folks for discussion :thumbsup:",
              "createdAt": "2021-11-04T21:11:32Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues\n             internal const string clr2 = \"CLR2\";\n             internal const string clr4 = \"CLR4\";\n             internal const string currentRuntime = \"CurrentRuntime\";\n+            internal const string net = \"NET\";",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Where are these values exposed? Presumably you want input on the literal itself, not the name of the constant field, right?",
              "createdAt": "2021-11-04T21:28:01Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues\n             internal const string clr2 = \"CLR2\";\n             internal const string clr4 = \"CLR4\";\n             internal const string currentRuntime = \"CurrentRuntime\";\n+            internal const string net = \"NET\";",
              "author": {
                "login": "terrajobst"
              }
            },
            {
              "body": "Correct. They are exposed to MSBuild task authors in the UsingTask element or \"phantom parameters\" on task invocations within targets ([docs on existing CLR2/CLR4 options](https://docs.microsoft.com/visualstudio/msbuild/how-to-configure-targets-and-tasks?view=vs-2019#usingtask-attributes-and-task-parameters)).\r\n\r\nThe existing options are \"CLR2\" which means \"run on .NET Framework 3.5\" and \"CLR4\" which means \"run on .NET Framework 4.7.2+\". We need one for \"run on .NET 6.0+\". If we'd done this before .NET 5.0, I would have selected `CORE` which I still kinda like, but since it's not .NET Core any more that's probably not the best choice.",
              "createdAt": "2021-11-04T21:32:43Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues\n             internal const string clr2 = \"CLR2\";\n             internal const string clr4 = \"CLR4\";\n             internal const string currentRuntime = \"CurrentRuntime\";\n+            internal const string net = \"NET\";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I lean towards \"NET\" now, personally. There's a long internal email thread where I think we've settled on this nomenclature.",
              "createdAt": "2021-11-15T17:14:56Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues\n             internal const string clr2 = \"CLR2\";\n             internal const string clr4 = \"CLR4\";\n             internal const string currentRuntime = \"CurrentRuntime\";\n+            internal const string net = \"NET\";",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: The new handshake option is `NET` which refers to a net core build. Here the runtime is being set to `Core` if it's on net core. For consistency should they have the same name? When I first saw the handshake option I felt like it should be named `NETCORE` or something.",
              "createdAt": "2021-11-03T19:57:31Z",
              "path": "src/Build/Definition/Toolset.cs",
              "diffHunk": "@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon\n                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));\n                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));\n \n+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,\n+#if RUNTIME_TYPE_NETCORE\n+                        \"Core\",",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "grumbling out loud: funny how we ended up in a scenario where `MSBuildRuntimeValues.currentRuntime` and `GetCurrentMSBuildRuntime()` are two different things. Which lead to the variable name on line 221 `string actualCurrentRuntime` \ud83d\ude05",
              "createdAt": "2021-11-03T20:03:41Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)\n                 return true;\n             }\n \n-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||\n-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))\n+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||\n+                (runtimeA.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: checking clr2 first is more intuitive. Or is this ordering intentional?",
              "createdAt": "2021-11-03T20:14:46Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), \"Should always have an explicit runtime when we call this method.\");\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), \"Should always have an explicit architecture when we call this method.\");\n \n-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;\n+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        clrVersion = 4;\n+                    }\n+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Just a straight port of the existing logic but I agree that putting it in order makes sense.",
              "createdAt": "2021-11-03T20:23:11Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), \"Should always have an explicit runtime when we call this method.\");\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), \"Should always have an explicit architecture when we call this method.\");\n \n-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;\n+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        clrVersion = 4;\n+                    }\n+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "We should do the ordering based on which is expected to occur most often, so I'd even bump MSBuildRuntimeValue.net to the top.",
              "createdAt": "2021-11-05T17:21:43Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), \"Should always have an explicit runtime when we call this method.\");\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), \"Should always have an explicit architecture when we call this method.\");\n \n-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;\n+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        clrVersion = 4;\n+                    }\n+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "1. That's an optimization that PGO should be great at and with small effect, so I don't think it's worth a readability hit without proof (and this isn't a super hot loop or anything).\r\n2. Why do you think `net` would happen most often?",
              "createdAt": "2021-11-15T15:53:45Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), \"Should always have an explicit runtime when we call this method.\");\n                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), \"Should always have an explicit architecture when we call this method.\");\n \n-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;\n+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        clrVersion = 4;\n+                    }\n+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit whitespace",
              "createdAt": "2021-11-03T20:15:57Z",
              "path": "src/Shared/UnitTests/XmakeAttributes_Tests.cs",
              "diffHunk": "@@ -2,6 +2,8 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using Microsoft.Build.Shared;\n+",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "This is actually my preferred style:\r\n\r\n1. Block for `System.` / BCL usings\r\n2. Block for local-repo usings\r\n3. Block for third-party usings",
              "createdAt": "2021-11-15T15:55:04Z",
              "path": "src/Shared/UnitTests/XmakeAttributes_Tests.cs",
              "diffHunk": "@@ -2,6 +2,8 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using Microsoft.Build.Shared;\n+",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Thinking this should be `netcore` or `core` to be extra clear.",
              "createdAt": "2021-11-03T20:17:01Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -425,6 +430,19 @@ internal static string GetCurrentMSBuildArchitecture()\n             return currentArchitecture;\n         }\n \n+        /// <summary>\n+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. \n+        /// </summary>\n+        internal static string GetCurrentMSBuildRuntime()\n+        {\n+#if NET40_OR_GREATER\n+            return MSBuildRuntimeValues.clr4;\n+#else\n+            return MSBuildRuntimeValues.net;",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the comment below still accurate? I'm wondering when we wouldn't have task hosts available.",
              "createdAt": "2021-11-05T17:15:26Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Tests.cs",
              "diffHunk": "@@ -1598,7 +1598,7 @@ public void CancelledBuildWithDelay20()\n             _logger.AssertLogDoesntContain(\"[errormessage]\");\n         }\n \n-#if FEATURE_TASKHOST && !NO_MSBUILDTASKHOST\n+#if !NO_MSBUILDTASKHOST",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We don't have the 3.5 task host on .NET Core or Mono builds.",
              "createdAt": "2021-11-12T19:02:05Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Tests.cs",
              "diffHunk": "@@ -1598,7 +1598,7 @@ public void CancelledBuildWithDelay20()\n             _logger.AssertLogDoesntContain(\"[errormessage]\");\n         }\n \n-#if FEATURE_TASKHOST && !NO_MSBUILDTASKHOST\n+#if !NO_MSBUILDTASKHOST",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why would it be MONO but not IsMono?",
              "createdAt": "2021-11-05T17:18:56Z",
              "path": "src/Build/Definition/Toolset.cs",
              "diffHunk": "@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon\n                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));\n                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));\n \n+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,\n+#if RUNTIME_TYPE_NETCORE\n+                        \"Core\",\n+#elif MONO\n+                        NativeMethodsShared.IsMono ? \"Mono\" : \"Full\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "MSBuild compiled for mono but running on .NET Framework was a possible thing for a while. I don't think it's super relevant any more but this is copypasta from existing code and I'd rather have consistent behavior.",
              "createdAt": "2021-11-12T18:25:24Z",
              "path": "src/Build/Definition/Toolset.cs",
              "diffHunk": "@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon\n                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));\n                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));\n \n+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,\n+#if RUNTIME_TYPE_NETCORE\n+                        \"Core\",\n+#elif MONO\n+                        NativeMethodsShared.IsMono ? \"Mono\" : \"Full\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like we're using this more. I'm curious if it will show up as extra MSBuild# string allocations.",
              "createdAt": "2021-11-05T17:24:47Z",
              "path": "src/Shared/NamedPipeUtil.cs",
              "diffHunk": "@@ -1,15 +1,24 @@\n // Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n-using System;\n+using System.Diagnostics;\n using System.IO;\n \n+#nullable enable\n+\n namespace Microsoft.Build.Shared\n {\n     internal static class NamedPipeUtil\n     {\n-        internal static string GetPipeNameOrPath(string pipeName)\n+        internal static string GetPipeNameOrPath(int? processId = null)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit:\r\nThis test and the previous one are similar in content but different in style. Switch to same style?",
              "createdAt": "2021-11-05T17:26:57Z",
              "path": "src/Shared/UnitTests/XmakeAttributes_Tests.cs",
              "diffHunk": "@@ -47,35 +49,82 @@ public void TestIsNonBatchingTargetAttribute()\n         public void TestRuntimeValuesMatch()\n         {\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime));\n+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.net));\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4));\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any));\n+#if NET5_0_OR_GREATER\n+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.net));\n+#else\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4));\n+#endif\n \n+            // Never true\n             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2));\n+\n             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2));\n+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.net));\n+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.net));\n         }\n \n-        [Fact]\n-        public void TestMergeRuntimeValues()\n+        [Theory]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't think the juice is worth the squeeze on this.",
              "createdAt": "2021-11-15T15:56:00Z",
              "path": "src/Shared/UnitTests/XmakeAttributes_Tests.cs",
              "diffHunk": "@@ -47,35 +49,82 @@ public void TestIsNonBatchingTargetAttribute()\n         public void TestRuntimeValuesMatch()\n         {\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime));\n+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.net));\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4));\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any));\n+#if NET5_0_OR_GREATER\n+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.net));\n+#else\n             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4));\n+#endif\n \n+            // Never true\n             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2));\n+\n             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2));\n+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.net));\n+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.net));\n         }\n \n-        [Fact]\n-        public void TestMergeRuntimeValues()\n+        [Theory]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "When would both runtimeA and runtimeB match the current runtime but not match each other?",
              "createdAt": "2021-11-05T17:29:15Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)\n                 return true;\n             }\n \n-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||\n-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))\n+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Not sure I understand what you're asking. This case is for `(current, clr4)` or `(clr4, current)` when running on `clr4`.",
              "createdAt": "2021-11-15T15:58:20Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)\n                 return true;\n             }\n \n-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||\n-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))\n+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like it might ignore runtimeA and runtimeB if they're the same and MSBuildRuntimeValue.currentRuntime but not the GetCurrentMSBuildRuntime() if that's different.",
              "createdAt": "2021-11-05T17:32:27Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -216,13 +218,15 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out\n                 runtimeB = MSBuildRuntimeValues.any;\n             }\n \n+            string actualCurrentRuntime = GetCurrentMSBuildRuntime();\n+\n             // if they're equal, then there's no problem -- just return the equivalent runtime.  \n             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))\n             {\n                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||\n                     runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))\n                 {\n-                    mergedRuntime = MSBuildRuntimeValues.clr4;\n+                    mergedRuntime = actualCurrentRuntime;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't think I understand this question, either. `MSBuildRuntimeValue.currentRuntime` indicates that the task should run on \"whatever the current build is running on\", so that's inherently whatever's returned from `GetCurrentMSBuildRuntime()`.",
              "createdAt": "2021-11-15T16:21:19Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -216,13 +218,15 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out\n                 runtimeB = MSBuildRuntimeValues.any;\n             }\n \n+            string actualCurrentRuntime = GetCurrentMSBuildRuntime();\n+\n             // if they're equal, then there's no problem -- just return the equivalent runtime.  \n             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))\n             {\n                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||\n                     runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))\n                 {\n-                    mergedRuntime = MSBuildRuntimeValues.clr4;\n+                    mergedRuntime = actualCurrentRuntime;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: extra space",
              "createdAt": "2021-11-05T17:37:08Z",
              "path": "src/Shared/XMakeAttributes.cs",
              "diffHunk": "@@ -425,6 +430,19 @@ internal static string GetCurrentMSBuildArchitecture()\n             return currentArchitecture;\n         }\n \n+        /// <summary>\n+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. \n+        /// </summary>\n+        internal static string GetCurrentMSBuildRuntime()\n+        {\n+#if NET40_OR_GREATER\n+            return MSBuildRuntimeValues.clr4;\n+#else\n+            return MSBuildRuntimeValues.net;\n+#endif\n+        }\n+",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need a core version of RegisterAssembly? Not sure if it's been ported. Same for UnregisterAssembly.",
              "createdAt": "2021-11-05T17:39:18Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -141,8 +142,8 @@\n     <UsingTask TaskName=\"Microsoft.Build.Tasks.ReadLinesFromFile\"                     AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildAssemblyVersion)' != ''\" />\n \n     <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''\" />\n-    <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Runtime=\"CLR4\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''\" />\n-    <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Runtime=\"CLR2\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''\" />\n+    <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Runtime=\"CLR4\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "COM build operations in general aren't functional on Core today. This doesn't change that but does potentially make it slightly clearer.",
              "createdAt": "2021-11-15T16:38:42Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -141,8 +142,8 @@\n     <UsingTask TaskName=\"Microsoft.Build.Tasks.ReadLinesFromFile\"                     AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildAssemblyVersion)' != ''\" />\n \n     <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''\" />\n-    <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Runtime=\"CLR4\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''\" />\n-    <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Runtime=\"CLR2\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''\" />\n+    <UsingTask TaskName=\"Microsoft.Build.Tasks.RegisterAssembly\"                      AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Runtime=\"CLR4\" Condition=\"('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n\r\n```suggestion\r\n                if (!mergedParameters.ContainsKey(XMakeAttributes.runtime))\r\n```",
              "createdAt": "2021-11-15T15:03:26Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -355,15 +355,12 @@ string taskProjectFile\n \n                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n \n-                string runtime = null;\n-                string architecture = null;\n-\n-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))\n+                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out _))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "\ud83e\udd26\ud83c\udffb thanks",
              "createdAt": "2021-11-15T15:43:40Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -355,15 +355,12 @@ string taskProjectFile\n \n                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n \n-                string runtime = null;\n-                string architecture = null;\n-\n-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))\n+                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out _))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n\r\n```suggestion\r\n                if (!mergedParameters.ContainsKey(XMakeAttributes.architecture))\r\n```",
              "createdAt": "2021-11-15T15:03:54Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -355,15 +355,12 @@ string taskProjectFile\n \n                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n \n-                string runtime = null;\n-                string architecture = null;\n-\n-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))\n+                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out _))\n                 {\n-                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.MSBuildRuntimeValues.clr4;\n+                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.GetCurrentMSBuildRuntime();\n                 }\n \n-                if (!mergedParameters.TryGetValue(XMakeAttributes.architecture, out architecture))\n+                if (!mergedParameters.TryGetValue(XMakeAttributes.architecture, out _))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like this comment should be updated:\r\nhttps://github.com/dotnet/msbuild/blob/37c61113335898d83fcae3203846402f2af31bf1/src/Shared/CommunicationsUtilities.cs#L78",
              "createdAt": "2021-11-15T15:08:42Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -60,7 +60,12 @@ internal enum HandshakeOptions\n         /// <summary>\n         /// Building with administrator privileges\n         /// </summary>\n-        Administrator = 32\n+        Administrator = 32,\n+\n+        /// <summary>\n+        /// Using the .NET Core/.NET 5.0+ runtime\n+        /// </summary>\n+        NET = 64,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}