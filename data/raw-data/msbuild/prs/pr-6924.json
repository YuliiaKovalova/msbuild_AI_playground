{
  "number": 6924,
  "title": "Don't flow self contained command-line option to referenced projects",
  "body": "Fixes dotnet/sdk#21677\r\n\r\n### Context\r\n\r\nIn .NET 6, if you run a command such as `dotnet build -r win-x64`, you will get the following error:\r\n\r\n> C:\\Program Files\\dotnet\\sdk\\6.0.100-rtm.21474.29\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.Sdk.targets(1105,5): warning NETSDK1179: One of '--self-contained' or '--no-self-contained' options are required when '--runtime' is used. [C:\\git\\repro\\ConsoleTest\\ConsoleTest.csproj]\r\n\r\nHowever, if you follow the suggestion and change it to `dotnet build -r win-x64 --self-contained`, then you will likely get an error such as the following if there are any referenced projects:\r\n\r\n> C:\\Program Files\\dotnet\\sdk\\6.0.100-rc.2.21501.4\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.RuntimeIdentifierInference.targets(150,5): error NETSDK1031: It is not supported to build or publish a self-contained application without specifying a RuntimeIdentifier. You must either specify a RuntimeIdentifier or set SelfContained to false. [C:\\Users\\brady\\source\\TodoApp\\TodoApp.API\\TodoApp.API.csproj]\r\n\r\nThis happens because\r\n\r\n- Global properties (ie those specified on the command line) flow to referenced projects by default\r\n- We normally stop the `RuntimeIdentifier` from flowing to referenced projects\r\n- We don't currently stop the `SelfContained` property from flowing to referenced projects\r\n- So the referenced project gets built with `SelfContained` set to true but no `RuntimeIdentifier`, which is an error\r\n\r\n### Changes Made\r\n\r\nIf `--self-contained` is specified on the command-line, and the `RuntimeIdentifier` is blocked from flowing to referenced projects, then we also block the `SelfContained` property from flowing to referenced projects.\r\n\r\nNote that this treats `--self-contained` differently from `/p:SelfContained=true`, as there is at least one project that relies on `/p:SelfContained=true` flowing across project references, and they set `RuntimeIdentifier` in their .props files if `SelfContained` is true.\r\n\r\n### Testing\r\n\r\nI will add automated tests to the SDK repo for this scenario, and test locally with those tests and the changes in this PR before merging.\r\n\r\n### Notes\r\n\r\nFYI @richlander @sfoslund @marcpopMSFT, I think we should take this for 17.0 GA",
  "state": "MERGED",
  "createdAt": "2021-10-07T22:47:22Z",
  "updatedAt": "2022-08-19T23:30:26Z",
  "closedAt": "2022-08-19T23:30:26Z",
  "mergedAt": "2022-08-19T23:30:26Z",
  "additions": 122,
  "deletions": 20,
  "changedFiles": 8,
  "headRefName": "stop-selfcontained-flow",
  "isDraft": false,
  "author": {
    "login": "dsplaisted"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "9c56b5e49a2395b1d42529f74809664a5795f6ea",
          "message": "Don't flow self contained command-line option to referenced projects\n\nFixes dotnet/sdk#21677",
          "committedDate": "2022-07-22T00:45:42Z",
          "author": {
            "name": "Daniel Plaisted",
            "email": "daplaist@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f849bea8c999c06571fd8cb9a6dfea8a9cf9000e",
          "message": "Switch from IsRidAgnostic metadata to AcceptsRuntimeIdentifier property\n\nAlso always treat SelfContained the same as RuntimeIdentifier as far as whether the properties should be allowed to flow across project references",
          "committedDate": "2022-07-22T00:45:51Z",
          "author": {
            "name": "Daniel Plaisted",
            "email": "daplaist@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59bf77d5a930f5fd063180a846d98ffb49747b4e",
          "message": "Use IsRidAgnostic instead of AcceptsRuntimeIdentifier",
          "committedDate": "2022-08-12T00:45:14Z",
          "author": {
            "name": "Daniel Plaisted",
            "email": "daplaist@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ab2662a1c20858f3a7fe4f2227f72e1766e97f00",
          "message": "Add task to handle IsRidAgnostic metadata for multitargeted projects",
          "committedDate": "2022-08-18T03:44:38Z",
          "author": {
            "name": "Daniel Plaisted",
            "email": "daplaist@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "512a0652036407e60662e02c7828dd847aebe668",
          "message": "Apply code review feedback",
          "committedDate": "2022-08-18T21:07:57Z",
          "author": {
            "name": "Daniel Plaisted",
            "email": "daplaist@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "If `_CommandLineDefinedSelfContained` is the expected escape hatch,  why mark it with an underscore? \r\n\r\nI'm a little confused at why there's a distinction between --self-contained and /p:SelfContained=true, but I won't block on it.\r\n\r\nAlso I'm not familiar with the self contained flag, is this a new concept or has it been around for a while?",
        "createdAt": "2021-10-07T23:24:41Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "@BenVillalobos More background than you probably want to dig into is available here: https://github.com/dotnet/designs/blob/main/accepted/2021/architecture-targeting.md\r\n\r\nWe wouldn't expect someone to define `_CommandLineDefinedSelfContained` themselves, the CLI automatically sets it if you use the `--self-contained` or `--no-self-contained` options: https://github.com/dotnet/sdk/blob/f72371bb4e6b5d3394ec2c261cf8c43a6697b815/src/Cli/dotnet/CommonOptions.cs#L115-L125\r\n\r\nSo the escape hatch is basically to use `/p:SelfContained=true` instead of `--self-contained`.\r\n\r\n@Forgind We shouldn't merge this yet until I've had a chance to test it.  I plan on writing automated tests in dotnet/sdk, but we won't be able to enable them in CI until the fix merges and flows.  But I should still run them manually first.",
        "createdAt": "2021-10-08T01:25:17Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "Ok; sounds good. I didn't actually look at the change, just saw three approvals and added the label. Feel free to add it after testing.",
        "createdAt": "2021-10-08T14:45:02Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I tried testing this, and this isn't ready.\r\n\r\nFirst the good news: The impact of the bug is less than I thought.  It only affects cases where the referenced project has an OutputType of Exe (or similar).  For Library projects, the fact that SelfContained flows through doesn't really affect anything.\r\n\r\nHowever, once I made the change to prevent the SelfContained value from flowing, I got this error:\r\n\r\n> NETSDK1150: The referenced project '..\\TodoApp.API\\TodoApp.API.csproj' is a non self-contained executable.  A non self-contained executable cannot be referenced by a self-contained executable.  For more information, see https://aka.ms/netsdk1150\r\n\r\nPerhaps in this case both the RuntimeIdentifier and the SelfContained value should flow to the referenced Exe project, for example by setting the `IsRidAgnostic` metadata on the project build metadata to false if the output type is Exe or similar.  However, it's still not simple to do that, as the NETSDK1150 check is based on the value of SelfContained from the GetTargetFrameworks call, where we're unconditionally removing SelfContained from the global properties.\r\n\r\nI'll try to think about this some more, but it seems like we probably won't take a fix for this in 17.0.",
        "createdAt": "2021-10-08T22:31:33Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "I've done some more work and I think I have a pretty good idea of how we should solve this.  It involves changes to MSBuild (now included in this PR) as well as to the SDK, in dotnet/sdk#21986.\r\n\r\nI'd like some feedback on whether that's the right direction.  It will be a breaking change (see the breaking change document in the SDK PR), so I think we *probably* would want to target these fixes for 6.0.200 rather than 6.0.100 GA.",
        "createdAt": "2021-10-12T19:45:46Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "@rainersigwald I've retargeted this to vs17.1, and I think it (together with https://github.com/dotnet/sdk/pull/21986) is ready for review again",
        "createdAt": "2021-11-18T01:30:47Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "Our primary 17.1 branch is `main` so I retargeted for you again. Reviewing.",
        "createdAt": "2021-11-18T16:30:44Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I'm looking into this due to dotnet/sdk/issues/10566, and I've found that just checking for `_CommandLineDefinedRuntimeIdentifier` works for my simple case (no `rid` in the projects, `self-contained` / `rid` are supplied via the commandline):\r\n\r\n```xml\r\n<IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' and $(_CommandLineDefinedRuntimeIdentifier) == '' \">true</IsRidAgnostic>\r\n```\r\n\r\nObviously, I've just skimmed the target source and I have no deep knowledge, but I hope this helps.",
        "createdAt": "2021-11-24T18:33:36Z",
        "author": {
          "login": "beatcracker"
        }
      },
      {
        "body": "@dsplaisted, are you going to be able to get around to this soon? Or should we close it for now or mark it as a draft?",
        "createdAt": "2022-04-20T21:36:24Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind Is there a way to convert a pull request back to a draft PR?",
        "createdAt": "2022-04-25T17:41:49Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "@rainersigwald @dotnet/msbuild I've updated and rebased this PR, and I believe it is now ready for review again.  I switched back to using `IsRidAgnostic` instead of creating `AcceptsRuntimeIdentifier`, which should help make this more compatible.",
        "createdAt": "2022-08-12T14:37:56Z",
        "author": {
          "login": "dsplaisted"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it possible to keep these and respect them if they're manually implemented? We documented `IsRidAgnostic` in https://github.com/dotnet/msbuild/blob/a7d579050450d7ee8c156cd652af18ee42b3570c/documentation/ProjectReference-Protocol.md?plain=1#L71-L73",
              "createdAt": "2021-10-15T20:06:06Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1844,9 +1844,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>\n       </AnnotatedProjects>\n \n-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->\n-      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'\">\n-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Do you think anyone would have actually used that?  It seems like it would be hard to hook into.  Searching GitHub seems to give about 7 results, though it's not actually displaying them for me correctly so I can't tell if they're real.",
              "createdAt": "2021-10-18T21:56:40Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1844,9 +1844,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>\n       </AnnotatedProjects>\n \n-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->\n-      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'\">\n-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "I'm still worried about this. It looks like at least CsWinRT uses it: https://github.com/microsoft/CsWinRT/blob/3ec398157f17baedec341de5d852747d420b9ecf/nuget/Microsoft.Windows.CsWinRT.Authoring.targets#L162",
              "createdAt": "2021-11-18T16:39:34Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1844,9 +1844,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>\n       </AnnotatedProjects>\n \n-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->\n-      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'\">\n-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This would be multivalued since it's a transform over a list, right? Is that what you expect? I would expect maybe something like `AnyHasMetadataValue('AcceptsRuntimeIdentifier', 'true')`.",
              "createdAt": "2021-11-18T19:45:22Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1879,9 +1882,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>\n         <HasSingleTargetFramework>true</HasSingleTargetFramework>\n-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n-        <IsRidAgnostic>false</IsRidAgnostic>\n-        <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <AcceptsRuntimeIdentifier>@(_TargetFrameworkInfo->'%(AcceptsRuntimeIdentifier)')</AcceptsRuntimeIdentifier>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "When is '@(AnnotatedProjects)' != '%(Identity)'?",
              "createdAt": "2022-08-12T21:45:01Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1863,9 +1863,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>\n       </AnnotatedProjects>\n \n-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->\n-      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'\">\n-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>\n+      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,\n+           unless the project is expecting those properties to flow.\n+           We include SelfContained together with RuntimeIdentifier, because otherwise a referenced project could try to build with\n+           SelfContained set to true but no RuntimeIdentifier set, which causes an error (for Exe projects). -->\n+      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'\">",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think you have to do this when updating metadata this way, otherwise each update will apply to all the items, or something like that.  @rainersigwald probably knows the details.  Anyway my changes don't change that pattern here, they just change the other conditions.",
              "createdAt": "2022-08-16T20:27:51Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1863,9 +1863,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>\n       </AnnotatedProjects>\n \n-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->\n-      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'\">\n-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>\n+      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,\n+           unless the project is expecting those properties to flow.\n+           We include SelfContained together with RuntimeIdentifier, because otherwise a referenced project could try to build with\n+           SelfContained set to true but no RuntimeIdentifier set, which causes an error (for Exe projects). -->\n+      <AnnotatedProjects Condition=\"'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'\">",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should GetTargetFrameworks depend on GetTargetFrameworksWithPlatformForSingleSingleTargetFramework explicitly?",
              "createdAt": "2022-08-12T21:49:58Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -42,9 +42,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>\n         <HasSingleTargetFramework>false</HasSingleTargetFramework>\n-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n-        <IsRidAgnostic>false</IsRidAgnostic>\n-        <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's what it does for single-targeted projects: https://github.com/dotnet/msbuild/blob/5d102ae37163fc1f22610bb433c3ab9a2fff91f0/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1889-L1890\r\n\r\nFor multi-targeted projects it has to do inner builds for each target framework, which the `GetTargetFrameworksWithPlatformFromInnerBuilds` target handles.",
              "createdAt": "2022-08-18T20:56:28Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -42,9 +42,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>\n         <HasSingleTargetFramework>false</HasSingleTargetFramework>\n-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n-        <IsRidAgnostic>false</IsRidAgnostic>\n-        <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It was previously RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences) (no semicolon)\r\nThat looks like a bug to me, but I just wanted to make sure that's intentional \ud83d\ude42",
              "createdAt": "2022-08-12T21:50:55Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1779,7 +1779,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         BuildInParallel=\"$(BuildInParallel)\"\n         Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)\"\n         ContinueOnError=\"!$(BuildingProject)\"\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)\"",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good point.  It does seem like it might have been a bug before.  Now there may be extra semicolons, but that should be OK, right?  The MSBuild task should just ignore the extra ones I think.",
              "createdAt": "2022-08-18T21:01:13Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1779,7 +1779,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         BuildInParallel=\"$(BuildInParallel)\"\n         Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)\"\n         ContinueOnError=\"!$(BuildingProject)\"\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)\"",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Yes",
              "createdAt": "2022-08-18T22:06:41Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1779,7 +1779,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         BuildInParallel=\"$(BuildInParallel)\"\n         Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)\"\n         ContinueOnError=\"!$(BuildingProject)\"\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)\"",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be true and the next one false?",
              "createdAt": "2022-08-12T21:51:43Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1941,6 +1942,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>\n         <TargetPlatformMonikers Condition=\"'$(TargetPlatformMoniker)' == ''\">None</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>\n+\n+        <!-- Determine whether a project is \"RID agnostic\" for each TargetFramework.  \"RID agnostic\" means that global properties such as SelfContained and RuntimeIdentifier should\n+             not flow across project references.\n+\n+             Generally this value will come from the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the fallback logic here will be that the project\n+             is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->\n+        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>\n+        <IsRidAgnostic Condition=\" '$(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">false</IsRidAgnostic>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "+1, it looks like it will set `IsRidAgnostic` to false when there are no runtime identifiers",
              "createdAt": "2022-08-18T19:51:45Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1941,6 +1942,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>\n         <TargetPlatformMonikers Condition=\"'$(TargetPlatformMoniker)' == ''\">None</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>\n+\n+        <!-- Determine whether a project is \"RID agnostic\" for each TargetFramework.  \"RID agnostic\" means that global properties such as SelfContained and RuntimeIdentifier should\n+             not flow across project references.\n+\n+             Generally this value will come from the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the fallback logic here will be that the project\n+             is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->\n+        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>\n+        <IsRidAgnostic Condition=\" '$(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">false</IsRidAgnostic>",
              "author": {
                "login": "joeloff"
              }
            },
            {
              "body": "Yes, thanks for catching this.",
              "createdAt": "2022-08-18T21:05:37Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1941,6 +1942,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>\n         <TargetPlatformMonikers Condition=\"'$(TargetPlatformMoniker)' == ''\">None</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>\n+\n+        <!-- Determine whether a project is \"RID agnostic\" for each TargetFramework.  \"RID agnostic\" means that global properties such as SelfContained and RuntimeIdentifier should\n+             not flow across project references.\n+\n+             Generally this value will come from the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the fallback logic here will be that the project\n+             is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->\n+        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>\n+        <IsRidAgnostic Condition=\" '$(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">false</IsRidAgnostic>",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does _TargetFrameworkInfo ever have more than just $(TargetFramework) included in it?",
              "createdAt": "2022-08-12T21:53:14Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1941,6 +1942,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>\n         <TargetPlatformMonikers Condition=\"'$(TargetPlatformMoniker)' == ''\">None</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>\n+",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, it does for multi-targeted projects, which will run this target for each target framework and combine the results.",
              "createdAt": "2022-08-18T21:07:01Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1941,6 +1942,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>\n         <TargetPlatformMonikers Condition=\"'$(TargetPlatformMoniker)' == ''\">None</TargetPlatformMonikers>\n         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>\n+",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need a `;` between `Configuration` and `$(_GlobalPropertiesToRemoveFromProjectReferences)`?",
              "createdAt": "2022-08-18T19:44:59Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1795,7 +1795,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         Targets=\"GetTargetFrameworks\"\n         BuildInParallel=\"$(BuildInParallel)\"\n         ContinueOnError=\"!$(BuildingProject)\"\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)\"",
              "author": {
                "login": "joeloff"
              }
            },
            {
              "body": "Looking at all usages of _GlobalPropertiesToRemoveFromProjectReferences in MSBuild, it seems that it is always expected to have a `;` in front of it. That said, I think adding a ; is better anyway.",
              "createdAt": "2022-08-18T20:14:36Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1795,7 +1795,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         Targets=\"GetTargetFrameworks\"\n         BuildInParallel=\"$(BuildInParallel)\"\n         ContinueOnError=\"!$(BuildingProject)\"\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)\"",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why did you choose !false rather than true? Could it be null here? If so, this seems like wrong behavior.",
              "createdAt": "2022-08-18T22:10:11Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If the value is not set I want this to be a no-op.  That seems the safest.\r\n\r\nFor projects using the .NET SDK, this should always be set.  For other types of projects it might not be.",
              "createdAt": "2022-08-19T20:36:24Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we have a Debug.Assert here or something?",
              "createdAt": "2022-08-18T22:11:59Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))\n+                    {\n+                        // No change to item, it should already have a single-valued IsRidAgnostic value",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`Debug.Assert` gets compiled out in release builds, so that would be pretty unlikely to catch anything anyway, wouldn't it be?",
              "createdAt": "2022-08-19T20:39:53Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))\n+                    {\n+                        // No change to item, it should already have a single-valued IsRidAgnostic value",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "It is, but if something goes wrong, we'd probably try to debug with a debug build, so I thought it might be helpful. Not a big deal if you don't want to add it.",
              "createdAt": "2022-08-19T21:22:43Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))\n+                    {\n+                        // No change to item, it should already have a single-valued IsRidAgnostic value",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are projects actually expected to have all of this information? I feel like this relies on projects carrying around a lot of (generally unimportant) baggage. Not saying that doesn't happen, but it's a bit surprising to me.",
              "createdAt": "2022-08-18T22:54:19Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))\n+                    {\n+                        // No change to item, it should already have a single-valued IsRidAgnostic value\n+                        return p;\n+                    }\n+                    var updatedItem = new TaskItem(p);\n+\n+                    var nearestTargetFramework = p.GetMetadata(\"NearestTargetFramework\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What information are you referring to?  These are part of the [Project Reference Protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md#targets-required-to-be-referenceable), or in the case of `NearestTargetFramework`, set by the `GetReferenceNearestTargetFrameworkTask` task which runs just before this one.",
              "createdAt": "2022-08-19T20:42:33Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))\n+                    {\n+                        // No change to item, it should already have a single-valued IsRidAgnostic value\n+                        return p;\n+                    }\n+                    var updatedItem = new TaskItem(p);\n+\n+                    var nearestTargetFramework = p.GetMetadata(\"NearestTargetFramework\");",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "I wasn't aware of NearestTargetFramework, but that makes sense. I was also surprisedby IsRidAgnostic being an array of IsRidAgnostic values with one per target framework. I'd expected (and the Project Reference Protocol seems to say) that it's just a boolean. It seems like you're changing the type in this task from boolean[] to boolean?",
              "createdAt": "2022-08-19T21:21:32Z",
              "path": "src/Tasks/SetRidAgnosticValueForProjects.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class SetRidAgnosticValueForProjects : TaskExtension\n+    {\n+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        [Output]\n+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();\n+\n+        public override bool Execute()\n+        {\n+            UpdatedProjects = Projects\n+                .Select(p =>\n+                {\n+                    var hasSingleTargetFrameworkString = p.GetMetadata(\"HasSingleTargetFramework\");\n+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))\n+                    {\n+                        // No change to item, it should already have a single-valued IsRidAgnostic value\n+                        return p;\n+                    }\n+                    var updatedItem = new TaskItem(p);\n+\n+                    var nearestTargetFramework = p.GetMetadata(\"NearestTargetFramework\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this line necessary?",
              "createdAt": "2022-08-18T22:56:20Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1850,6 +1850,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n                          Condition=\"'$(ReferringTargetFrameworkForProjectReferences)' == '' or\n                                     ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')\" />\n \n+    </ItemGroup>\n+\n+    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.\n+         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects\n+         the IsRidAgnostic value for the NearestTargetFramework for the project. -->\n+    <SetRidAgnosticValueForProjects Projects=\"@(AnnotatedProjects)\">\n+      <Output ItemName=\"UpdatedAnnotatedProjects\" TaskParameter=\"UpdatedProjects\" />\n+    </SetRidAgnosticValueForProjects>\n+    \n+    <ItemGroup>\n+      <AnnotatedProjects Remove=\"@(AnnotatedProjects)\" />\n+      <AnnotatedProjects Include=\"@(UpdatedAnnotatedProjects)\" />\n+      <UpdatedAnnotatedProjects Remove=\"@(UpdatedAnnotatedProjects)\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It just clears it out so that it's not taking up memory anymore.  It's a pretty clunky pattern for when you want to have a task that updates item metadata.",
              "createdAt": "2022-08-19T20:43:33Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1850,6 +1850,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n                          Condition=\"'$(ReferringTargetFrameworkForProjectReferences)' == '' or\n                                     ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')\" />\n \n+    </ItemGroup>\n+\n+    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.\n+         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects\n+         the IsRidAgnostic value for the NearestTargetFramework for the project. -->\n+    <SetRidAgnosticValueForProjects Projects=\"@(AnnotatedProjects)\">\n+      <Output ItemName=\"UpdatedAnnotatedProjects\" TaskParameter=\"UpdatedProjects\" />\n+    </SetRidAgnosticValueForProjects>\n+    \n+    <ItemGroup>\n+      <AnnotatedProjects Remove=\"@(AnnotatedProjects)\" />\n+      <AnnotatedProjects Include=\"@(UpdatedAnnotatedProjects)\" />\n+      <UpdatedAnnotatedProjects Remove=\"@(UpdatedAnnotatedProjects)\" />",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      }
    ]
  }
}