{
  "number": 11045,
  "title": "One pager writeups",
  "body": "These are the one pagers for 3 features.\r\n\r\n - Evaluation performance with @rainersigwald.\r\n - PerfStar improvements with @AR-May.\r\n - VS and SDK decoupling with @baronfel \r\n",
  "state": "MERGED",
  "createdAt": "2024-11-27T14:44:02Z",
  "updatedAt": "2025-03-10T15:05:20Z",
  "closedAt": "2025-01-21T09:42:19Z",
  "mergedAt": "2025-01-21T09:42:19Z",
  "additions": 103,
  "deletions": 0,
  "changedFiles": 3,
  "headRefName": "one-pager-writeups",
  "isDraft": false,
  "author": {
    "login": "maridematte"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1757325aaac8c03fec2e5797b97532f7e53aa288",
          "message": "Rough notes from meetings",
          "committedDate": "2024-11-25T17:42:50Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a0a1c8b9489d874da2b13724043878f91de355a4",
          "message": "decoupling write-up complete",
          "committedDate": "2024-11-27T09:44:31Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a796957b44853c454a7b82dd6c9c0c8aa748552",
          "message": "evaluation performance investigation",
          "committedDate": "2024-11-27T13:17:26Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73ca8c325f9b6e0acd63ee94a3d73ce4b88c8f7e",
          "message": "perfStar pager",
          "committedDate": "2024-11-27T14:41:34Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2cc45bb3adfc7f998a7416542e16c1d0819501ee",
          "message": "Update documentation/specs/proposed/decoupling-vs-sdk.md\n\nCo-authored-by: Jared Parsons <jared@paranoidcoding.org>",
          "committedDate": "2024-12-04T14:35:17Z",
          "author": {
            "name": "Chet Husk",
            "email": "baronfel@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "929788ccfe69e26a506e0b21d17645a90f41725f",
          "message": "Update documentation/specs/proposed/evaluation-perf.md\n\nCo-authored-by: Jared Parsons <jared@paranoidcoding.org>",
          "committedDate": "2024-12-04T14:36:39Z",
          "author": {
            "name": "Chet Husk",
            "email": "baronfel@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d2f54fa0b09291d0485b13ab4a063a23b714cefb",
          "message": "Some PR comment fiexes for decoupling paper",
          "committedDate": "2024-12-11T10:42:11Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9e3e2c8affab4329777f06780b0c99ae84626755",
          "message": "Rename parfStar.md to perfStar.md",
          "committedDate": "2025-01-08T20:38:58Z",
          "author": {
            "name": "Chet Husk",
            "email": "baronfel@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c82ca3b3e27c5c0c969f4bc0ddc5ee16ff0bd82",
          "message": "some PR commentss",
          "committedDate": "2025-01-14T12:28:12Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d222fdf73fe59d1dfade1697790a61fcbcc5bd36",
          "message": "Merge branch 'one-pager-writeups' of https://github.com/maridematte/msbuild into one-pager-writeups",
          "committedDate": "2025-01-14T12:28:21Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f9bef92c410ffb74708c9c87a0ae7f17ca58fca6",
          "message": "Finished this round of review",
          "committedDate": "2025-01-14T12:49:51Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "This LGTM to merge.",
        "createdAt": "2025-01-08T20:41:46Z",
        "author": {
          "login": "baronfel"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Think this paragraph needs more specifics. Basically, what specific problems arise when VS and .NET SDK versions mix? Should we mention that we don't test these situations? Something like \r\n\r\n> When building a .NET SDK project from Visual Studio / MSBuild the experience can differ significantly from building the same project with `dotnet build`: it can produce different diagnostics, use different language rules, etc ... That is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so. \r\n\r\n\r\n",
              "createdAt": "2024-12-02T23:55:37Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - Decoupling the .NET SDK experience from Visual Studio \r\n```\r\n\r\nDecoupling is a key word to use here as it resonates with a lot of who've dealt with problems here.",
              "createdAt": "2024-12-02T23:56:21Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You use all of the following in this doc: DotNet SDK, Dotnet SDK, .NET SDK and SDK. Fine with any but think consistency is best. \ud83d\ude04 ",
              "createdAt": "2024-12-02T23:58:24Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This paragraph seems to be combining what TFM analyzers need to target and SDK / VS analyzer tearing. Think we should split up those concerns.",
              "createdAt": "2024-12-03T00:02:05Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "I agree. Roslyn analyzers/generators targeting netstandard2 are one concern, multitargeting tasks is another, SDK tearing is a third.",
              "createdAt": "2025-01-08T21:27:00Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This only manifests when we move tasks to .NET Core and use an MSBuild bridge for them correct? If so should we list out the phases / dials we have for this effort? The low end is just using .NTE Core tools and then we dial up to running tasks on core.",
              "createdAt": "2024-12-03T00:03:21Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+\n+## Impact\n+There are a few area of impact:\n+ - SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their Core compiler in VS.\n+2. Tasks and other projects can be written in .NET core and the SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - There might be a performance hit on VS. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Part of our statement now is that VS and .NET SDK are de-coupled experiences so I wouldn't put this in the risk section. This is more leaning into our design of the system. I would put this in the impact section and say that an impcat of this change is it re-enforces our design that VS and .NET SDK be decoupled experiences.",
              "createdAt": "2024-12-03T00:04:36Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+\n+## Impact\n+There are a few area of impact:\n+ - SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their Core compiler in VS.\n+2. Tasks and other projects can be written in .NET core and the SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - There might be a performance hit on VS. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - The VS tooling might present have a different version than the SDK installed, which might lead to discrepancy in partial builds.",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "When you put it that way it sounds like a consequence of the design, which is not really covered in this doc specific. So I opted to take it out as a risk in this case.",
              "createdAt": "2024-12-11T10:41:36Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+\n+## Impact\n+There are a few area of impact:\n+ - SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their Core compiler in VS.\n+2. Tasks and other projects can be written in .NET core and the SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - There might be a performance hit on VS. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - The VS tooling might present have a different version than the SDK installed, which might lead to discrepancy in partial builds.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we list explicitly `%DOTNET_BUILD_HOST%` here?",
              "createdAt": "2024-12-03T00:05:08Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+\n+## Impact\n+There are a few area of impact:\n+ - SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their Core compiler in VS.\n+2. Tasks and other projects can be written in .NET core and the SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - There might be a performance hit on VS. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - The VS tooling might present have a different version than the SDK installed, which might lead to discrepancy in partial builds.\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There are no concrete deadlines for our part of the feature, but we are aiming for an early preview cycle, so we have a chance to measure the consequences and fix any issues that arise.\n+\n+## Plan\n+ 1. Ensure that MSBuild.exe provides the same execution state as the dotnet command line invocation.\n+    -  This is should take around 1 dev week to complete, and will be handed over to Roslyn team.",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "For a one-pager (high-level) I expected that it would be kept as a more general statement of \"msbuild should align with the SDK's state set-up\" and let details come out in a specific issue.",
              "createdAt": "2024-12-04T14:36:34Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,43 @@\n+# Decoupling VS builds of SDK projects\n+The behaviour of an SDK project, when built in Visual Studio and when built in the DotNet CLI can vary, as different pieces of imports can be fetched from either build agent. This situation is not great specially for some developers as it increases their coding workload. To solve this, we want to ensure that all logic from a build from an *SDK project* comes from the SDK, independently of where the build is processed.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Isolating Dotnet SDK build to only their components.\n+ - Decoupling the Dotnet SDK from VS.\n+\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+\n+## Impact\n+There are a few area of impact:\n+ - SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their Core compiler in VS.\n+2. Tasks and other projects can be written in .NET core and the SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - There might be a performance hit on VS. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - The VS tooling might present have a different version than the SDK installed, which might lead to discrepancy in partial builds.\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There are no concrete deadlines for our part of the feature, but we are aiming for an early preview cycle, so we have a chance to measure the consequences and fix any issues that arise.\n+\n+## Plan\n+ 1. Ensure that MSBuild.exe provides the same execution state as the dotnet command line invocation.\n+    -  This is should take around 1 dev week to complete, and will be handed over to Roslyn team.",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - Jit compilation of MSBuild itself. \r\n```",
              "createdAt": "2024-12-03T00:05:18Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.\n+\n+ - We could do profiling\n+ - Jit compilation o MSBuild itself. ",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The performance evaluation of tools moving to .NET Core is mostly understood correct? Is this about tasks? ",
              "createdAt": "2024-12-03T00:05:54Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "This doc isn't about Task performance on Core/non-Core - it's focused on Evaluation. So the reading of the data in the project file and any imports therein. ",
              "createdAt": "2024-12-17T17:01:58Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Super minor note, the file is named `parfStar.md` instead of `perfStar.md`",
              "createdAt": "2024-12-11T12:44:16Z",
              "path": "documentation/specs/proposed/parfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar",
              "author": {
                "login": "slang25"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe experience of building a .NET SDK project can differ significantly depending if the project was built using Visual Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc. This is because building a .NET SDK project from Visual Studio mixes components from Visual Studio and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard-to-diagnose problems. To solve this want to ensure that when building a .NET SDK project we use more components from the .NET SDK to do so.\r\n```\r\n\r\nI cut \"code workload\" because I don't think I know what it is.",
              "createdAt": "2025-01-08T20:49:55Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - More consistent end-user experience for build between .NET CLI and Visual Studio.\r\n```",
              "createdAt": "2025-01-08T20:50:20Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How do these differ?\r\n```suggestion\r\n - Decoupling the .NET SDK experience from Visual Studio \r\n```",
              "createdAt": "2025-01-08T20:50:35Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will be less divided between different versions.\r\n```\r\n\r\n(there will still be tearing on core targets for the medium term)",
              "createdAt": "2025-01-08T21:27:28Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - Reduced cost of development for external and internal teams that author Roslyn Analyzers, source generators, or MSBuild Tasks.\r\n```",
              "createdAt": "2025-01-08T21:27:40Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - End-user will not experience mismatch between analyzer versions, and gain higher confidence that their .NET SDK project builds will behave the same way in VS and in the command line.\r\n```",
              "createdAt": "2025-01-08T21:28:56Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nOther teams will need to work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\r\n```",
              "createdAt": "2025-01-08T21:29:31Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n1. After providing enough information to do so through MSBuild and the SDK, Roslyn will need to use it to invoke their .NET compiler in VS.\r\n```",
              "createdAt": "2025-01-08T21:30:43Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n2. After MSBuild enables tasks to target .NET even for VS use, task-owning teams like the .NET SDK will need to migrate their targets to use .NET Core instead of keeping them targeting .NET Framework.\r\n```",
              "createdAt": "2025-01-08T21:32:26Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe handovers should allow other teams to proceed with their work smoothly and no unexpected change in build behavior should be present within MSBuild.\r\n```",
              "createdAt": "2025-01-08T21:32:46Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - If .NET Core tasks is discovered to have too large of a performance impact (due to IPC overhead to a .NET process), core partner teams may choose to keep multitargeting their tasks for improved user perf.\r\n```",
              "createdAt": "2025-01-08T21:34:14Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How is this different from the previous bullet?",
              "createdAt": "2025-01-08T21:34:34Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There might be a performance hit on VS once we start running tasks on .NET Core. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There is a concrete deadline: 17.14. Usually we support the .NET SDK in the previous VS (when targeting older .NET versions), so if we don't hit 17.14 we'll have to either change that policy at the SDK level or not adopt the new stuff in 10.0.",
              "createdAt": "2025-01-08T21:35:34Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There might be a performance hit on VS once we start running tasks on .NET Core. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - There are no concrete deadlines for our part of the feature, but we are aiming for an early preview cycle, so we have a chance to measure the consequences and fix any issues that arise.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think there's any way this is in scope for 10 and would preemptively cut it.",
              "createdAt": "2025-01-08T21:36:04Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There might be a performance hit on VS once we start running tasks on .NET Core. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - There are no concrete deadlines for our part of the feature, but we are aiming for an early preview cycle, so we have a chance to measure the consequences and fix any issues that arise.\n+\n+## Plan\n+ 1. Ensure that MSBuild.exe provides the same execution state as the dotnet command line invocation.\n+    -  This is should take around 1 dev week to complete, and will be handed over to Roslyn team.\n+ 2. Implement .NET Core task host, tasks can be executed on the .NET Core vresion instead of .NET framework.\n+    - This should take 1 to 2 dev months to complete, including extensive testing. This would be handed over to internal teams that have custom tasks so they can be updated and tested.\n+ 3. Load common targets from the .NET SDK and not from .NET NetFramework on VS. This work depends on other team's finilizing their part of the feature and might not be in scope for .NET 10.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is already there that it is no in scope for 10. But I think we should leave it as it is part of the completion of this feature.",
              "createdAt": "2025-01-13T14:49:05Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There might be a performance hit on VS once we start running tasks on .NET Core. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - There are no concrete deadlines for our part of the feature, but we are aiming for an early preview cycle, so we have a chance to measure the consequences and fix any issues that arise.\n+\n+## Plan\n+ 1. Ensure that MSBuild.exe provides the same execution state as the dotnet command line invocation.\n+    -  This is should take around 1 dev week to complete, and will be handed over to Roslyn team.\n+ 2. Implement .NET Core task host, tasks can be executed on the .NET Core vresion instead of .NET framework.\n+    - This should take 1 to 2 dev months to complete, including extensive testing. This would be handed over to internal teams that have custom tasks so they can be updated and tested.\n+ 3. Load common targets from the .NET SDK and not from .NET NetFramework on VS. This work depends on other team's finilizing their part of the feature and might not be in scope for .NET 10.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "my estimate is that this would take much, _much_ longer than this--the code change is easy, the implications are hard to manage and so is the testing.",
              "createdAt": "2025-01-08T21:36:37Z",
              "path": "documentation/specs/proposed/decoupling-vs-sdk.md",
              "diffHunk": "@@ -0,0 +1,40 @@\n+# Decoupling VS builds of .NET SDK projects\n+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visla Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc... and that is because building a .NET SDK project from Visual Studio mixes components from MSBuild and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard to diagnose problems, as well as increased code workload. To solve this want to ensure that when building a .NET SDK project we use the components from the .NET SDK to do so.\n+\n+## Goals and Motivation\n+\n+We are aiming for:\n+ - Consistent end-user eperience for build in either DotNet CLI or Visual Studio.\n+ - Decoupling the .NET SDK experience from Visual Studio \n+ - Decoupling the .NET SDK from VS.\n+\n+The reason we are persuing this is for a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS. Another options is to multi-target but it takes a lot more effort and time spent on that. Another aspect is the user experience, if the Roslyn version for VS analyzers and generators doesn't match the one in Visual Studio, they do not work.\n+\n+## Impact\n+There are a few area of impact:\n+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.\n+ - Reduced cost of development for external and internal teams that contribute to Roslyn Analyzers, SourceBuild generators, or MSBuild Tasks.\n+ - End-user will not experience mismatch between analyzer versions, and confirmation that their .NET SDK style builds will behave the same way in VS and in the command line.\n+\n+## Stakeholders\n+For the internal stakeholder, we have the teams that will continue the work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:\n+\n+1. Enabling the MSBuild.exe execution state to be the same as DotNet command line invocation so the Roslyn team can enable the use of their core compiler in VS.\n+2. Tasks and other projects can be written in .NET Core and the .NET SDK projects will build successuflly in VS. This enables other teams to migrate their tasks to .NET Core instead of keeping them targeting .NET Framework.\n+\n+The handovers should allow other teams to proceed with their work smoothly and no change in build behaviour should be present within MSBuild.\n+\n+## Risks\n+A few risks associated with this feature:\n+ - Our work is early in the development effort. If this feature is discovered to have too large of an impact in experience of performance the work might be delayed or discarded.\n+ - There might be a performance hit on VS once we start running tasks on .NET Core. It would depending on the amount of non-framwork tasks that the project will need to load when opening it in VS. The performance gain from pre-loading will not be available in this scenario.\n+ - There are no concrete deadlines for our part of the feature, but we are aiming for an early preview cycle, so we have a chance to measure the consequences and fix any issues that arise.\n+\n+## Plan\n+ 1. Ensure that MSBuild.exe provides the same execution state as the dotnet command line invocation.\n+    -  This is should take around 1 dev week to complete, and will be handed over to Roslyn team.\n+ 2. Implement .NET Core task host, tasks can be executed on the .NET Core vresion instead of .NET framework.\n+    - This should take 1 to 2 dev months to complete, including extensive testing. This would be handed over to internal teams that have custom tasks so they can be updated and tested.\n+ 3. Load common targets from the .NET SDK and not from .NET NetFramework on VS. This work depends on other team's finilizing their part of the feature and might not be in scope for .NET 10.\n+    - This should take a dev week, if there are no major bugs or regressions.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nIn the current effort to improve performance of MSBuild, we identified evaluation as one of the focus areas of this effort. Evaluation is the first step when loading or building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every MSBuild scenario, from solution load and design-time builds in Visual Studio, to up-to-date builds or full builds in VS or on the command line.\r\n```",
              "createdAt": "2025-01-08T21:38:27Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nConstraint - needs to work as it does today, but faster. We may be able to break some edge cases.\r\n```\r\n\r\n(we can't, we can't break edge cases . . . but maybe!)",
              "createdAt": "2025-01-08T21:39:19Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.\n+\n+ - We could do profiling\n+ - Jit compilation of MSBuild itself. \n+ - We could cache at eval\n+\n+ Constraint - needs to work as it does today, but fast. We can break some edge cases.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels a little harsh. I'd say it's not tracked or dashboarded, but it is measured in several ways.\r\n\r\nThe work here is to have a live report we can use to a) justify investment in eval perf and b) guide what that investment entails.",
              "createdAt": "2025-01-08T21:42:42Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How is this different from \"description\"? Maybe keep this here and change description to be \"we want to track the data better\"?",
              "createdAt": "2025-01-08T21:44:51Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.\n+\n+ - We could do profiling\n+ - Jit compilation of MSBuild itself. \n+ - We could cache at eval\n+\n+ Constraint - needs to work as it does today, but fast. We can break some edge cases.\n+\n+## Goals and Motivation\n+We are trying to make evaluation phase of the build more performant, since it is almost always executed any performance gain becomes noticeable. A performant evaluation phase would decrease build times in general, in CI cases it frees up resources, and in individual cases it can increase dev-loop performance by making up-to-date and incremental builds go faster.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The markers are already there for the most part, is there something specific we're planning to add?",
              "createdAt": "2025-01-08T21:45:17Z",
              "path": "documentation/specs/proposed/evaluation-perf.md",
              "diffHunk": "@@ -0,0 +1,24 @@\n+# Evaluation performance investigations\n+In the current effort to improve performance of MSBuild, we ideantified the evaluation as one of the focus areas of this effort. Evalution is the ifrst step when building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every single build, be it Design-time builds in Visual Studio, up-to-date builds or full builds.\n+\n+## Description\n+Current performance state of evaluation is mostly unkown, as it is not measured in any ways by the team. As such, we are unsure which specific areas can be improve. The investigation about this is necessary so we can identify weaknesses, and possible fixes.\n+\n+ - We could do profiling\n+ - Jit compilation of MSBuild itself. \n+ - We could cache at eval\n+\n+ Constraint - needs to work as it does today, but fast. We can break some edge cases.\n+\n+## Goals and Motivation\n+We are trying to make evaluation phase of the build more performant, since it is almost always executed any performance gain becomes noticeable. A performant evaluation phase would decrease build times in general, in CI cases it frees up resources, and in individual cases it can increase dev-loop performance by making up-to-date and incremental builds go faster.\n+\n+In this moment we are still in investigation phase, the obejective is to add code markers, so we can idetentify low hanging fixes, and improvement areas when testing builds within PerfStar.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nPerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of the `main` MSBuild branch on a schedule and allows us to request experimental runs and collect performance data for proposed changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\r\n```",
              "createdAt": "2025-01-08T21:46:27Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nMSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance with less interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.\r\n```",
              "createdAt": "2025-01-08T21:47:06Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\n+\n+## Goals and Motivation\n+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance without interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nPerfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about performance improvement work, as well as implementation of new features. In turn, those decisions will accrue value to users via higher build performance.\r\n```",
              "createdAt": "2025-01-08T21:48:10Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\n+\n+## Goals and Motivation\n+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance without interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.\n+\n+## Impact\n+Perfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about taking performance improvement work, as well as future and implementation of new features.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd extend this: PerfStar is a service, even if it's one primarily for our own use, and introduces a bunch of risks related to service maintenance.",
              "createdAt": "2025-01-08T21:48:53Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\n+\n+## Goals and Motivation\n+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance without interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.\n+\n+## Impact\n+Perfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about taking performance improvement work, as well as future and implementation of new features.\n+\n+## Risks\n+The risks associated with our dependencies is about Crank, which is owned by the ASP.NET team and we use it to help us with machine setup to run the performance tests. ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n3. New performance tests for new features, and writing docs on how to write those tests. Next feature planned for tests: BuildCheck.\r\n```",
              "createdAt": "2025-01-08T21:49:11Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\n+\n+## Goals and Motivation\n+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance without interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.\n+\n+## Impact\n+Perfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about taking performance improvement work, as well as future and implementation of new features.\n+\n+## Risks\n+The risks associated with our dependencies is about Crank, which is owned by the ASP.NET team and we use it to help us with machine setup to run the performance tests. \n+\n+## Plan\n+Investiment for .NET 10:\n+ 1. Making PerfStar execute automatically the way the design doc indicates\n+    - Around 1 dev week.\n+2. The PowerBI reporting is working and updating the new information\n+   - Around 2 dev weeks.\n+3. New performance tests for new features, and writting docs on how to write those tests. Next feature planned for tests: BuildCheck.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n5. Add more tests using `msbuild.exe` for build in addition to `dotnet build`.\r\n```",
              "createdAt": "2025-01-08T21:49:35Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\n+\n+## Goals and Motivation\n+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance without interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.\n+\n+## Impact\n+Perfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about taking performance improvement work, as well as future and implementation of new features.\n+\n+## Risks\n+The risks associated with our dependencies is about Crank, which is owned by the ASP.NET team and we use it to help us with machine setup to run the performance tests. \n+\n+## Plan\n+Investiment for .NET 10:\n+ 1. Making PerfStar execute automatically the way the design doc indicates\n+    - Around 1 dev week.\n+2. The PowerBI reporting is working and updating the new information\n+   - Around 2 dev weeks.\n+3. New performance tests for new features, and writting docs on how to write those tests. Next feature planned for tests: BuildCheck.\n+   - Around 3 dev days per feature.\n+4. Analyze stability of performance tests, and fix any noise found. This will be done through multiple iterations of the same test in the same machine, as well as updating the PowerBI report to handle the new data.\n+   - Around 2 dev weeks.\n+5. Add more tests using `msbuild.exe` for build instead of `dotnet build`.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThere are more improvements form PerfStar, but these are not planned for .NET 10 as they depend on the team's feedback to PerfStar.\r\n```",
              "createdAt": "2025-01-08T21:49:56Z",
              "path": "documentation/specs/proposed/perfStar.md",
              "diffHunk": "@@ -0,0 +1,38 @@\n+# PerfStar\n+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of main MSBuild branch on schedule and allows us to request experimental runs and collect performance of the new changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.\n+\n+## Goals and Motivation\n+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance without interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.\n+\n+## Impact\n+Perfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about taking performance improvement work, as well as future and implementation of new features.\n+\n+## Risks\n+The risks associated with our dependencies is about Crank, which is owned by the ASP.NET team and we use it to help us with machine setup to run the performance tests. \n+\n+## Plan\n+Investiment for .NET 10:\n+ 1. Making PerfStar execute automatically the way the design doc indicates\n+    - Around 1 dev week.\n+2. The PowerBI reporting is working and updating the new information\n+   - Around 2 dev weeks.\n+3. New performance tests for new features, and writting docs on how to write those tests. Next feature planned for tests: BuildCheck.\n+   - Around 3 dev days per feature.\n+4. Analyze stability of performance tests, and fix any noise found. This will be done through multiple iterations of the same test in the same machine, as well as updating the PowerBI report to handle the new data.\n+   - Around 2 dev weeks.\n+5. Add more tests using `msbuild.exe` for build instead of `dotnet build`.\n+   - Around 1 dev week.\n+6. Timeboxed collection of feedback from our team, as well as performance investigations that can derive from those.\n+   - 1 - 2 dev month depending on feedback and requests for improvement from the team.\n+7. Add more test cases. For example, build time with different verbosity levels.\n+   - Around 1 dev week.\n+\n+There are more improvements form PerfStar, but these are not established for .NET 10 yet as they depend on the team's feedback to PerfStar.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}