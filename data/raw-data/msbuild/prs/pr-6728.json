{
  "number": 6728,
  "title": "Introduce public interfaces for per-project and per-evaluation disk I/O callbacks",
  "body": "Fixes #6068 \r\n\r\n### Context\r\nWe're looking to use the CPS FS cache for file/directory enumeration and file/directory existence checks done by MSBuild during evaluation. The currently exposed `MSBuildFileSystemBase` base class does not work well for this purpose:\r\n1. Due to its use of `IEnumerable<string>` with full paths. Even if we currently end up constructing full paths internally, the interface should be future-proof. We would like to use something more efficient, preferably close to the modern .NET Core file enumeration API, which we're switching to in another related effort. \r\n2. Due to the scope. `MSBuildFileSystemBase` is applied across all evaluations of all projects sharing the same `EvaluationContext`. CPS wants to know which project is being evaluated and which evaluation (as in evaluation ID) is running. CPS also prefers to set the callbacks for the lifetime of the `Project` object as opposed to having to pass them in `EvaluationContext` for each evaluation. This is because `Project` objects are exposed to other components and anyone can reevaluate them without going through CPS.\r\n\r\n### Changes Made\r\n1. Refactoring\r\n   - Made `EngineFileUtilities` static. This class was wrapping a `FileMatcher` making the code less readable and slightly more complex. A static class is a better fit for the suffix \"Utilitites\" and `FileMatcher` is explicitly passed to methods that need it.\r\n   - Made a few evaluation-related classes and methods take `EvaluationContext` rather than `IFileSystem`. The former also has `FileMatcher` on it and it's more efficient to reuse it instead of creating a new one. It is generally more future-proof to be passing around a reference to \"context\" rather than to only a single part of it.\r\n   - Made `FileMatcher.IsMatch` take `ReadOnlySpan<char>` instead of string but left the string overload in the code for now. Now that we can use `Microsoft.IO.Redist` several callsites were converted to use the span - the common pattern is to extract the filename from full path and this can be a non-allocating operation on .NET Core and on Framework with `Microsoft.IO.Redist`.\r\n2. Interfaces\r\n   - Added `IDirectoryCache` with efficient file/directory existence and file/directory enumeration API. The interface is to be implemented by hosts that have their file system caches and want them to be used during evaluation instead of having MSBuild hit disk.\r\n   - Added `IDirectoryCacheFactory` with a factory method to create `IDirectoryCache` for an evaluation ID. The host can choose to return null to make MSBuild fall back to the existing behavior of hitting disk. `IDirectoryCacheFactory` is passed as a field on `ProjectOptions`. If the host specifies this interface and also an evaluation context with a `MSBuildFileSystemBase`-derived class, this new interface will be used for file/directory existence checks and file/directory enumeration while the rest of the operations (are there any such operations used during evaluation?) would go to `MSBuildFileSystemBase`.\r\n\r\n### Testing\r\nExisting and new unit tests, experimental insertion, validation by the CPS team.\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2021-08-03T14:51:20Z",
  "updatedAt": "2021-10-21T12:29:11Z",
  "closedAt": "2021-10-21T12:28:30Z",
  "mergedAt": "2021-10-21T12:28:29Z",
  "additions": 533,
  "deletions": 90,
  "changedFiles": 21,
  "headRefName": "6068-disk-scan-interface",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "b6fd14cbbd3ee9fbac04fc7a72b5c65fd53c140d",
          "message": "Introduce IDirectoryCache & IDirectoryCacheFactory",
          "committedDate": "2021-10-15T10:27:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7dae6293fd507e1f39c92e2d82d5d91da17f4d50",
          "message": "PR feedback: Pass Project instead of project path",
          "committedDate": "2021-10-15T10:27:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9dcb52ac42286eedc8f18b3dafd4aa056d579192",
          "message": "Don't depend on System.IO.Enumeration",
          "committedDate": "2021-10-15T10:27:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "521d0425776d25e19802540b2e499f012eb170b2",
          "message": "Make EngineFileUtilities static",
          "committedDate": "2021-10-15T10:27:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e235b15577855ae6cf649056e54441fbd209976a",
          "message": "Implement DirectoryCacheOverFileSystem",
          "committedDate": "2021-10-15T10:27:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "62737b672cd70301bd2bb5072e6d89846a092744",
          "message": "Basic wiring of EvaluationContext-specific FileMatcher",
          "committedDate": "2021-10-15T10:27:43Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "10fff0f4ae992d6c368319379542c4f0c7008728",
          "message": "Make FileMatcher consume IDirectoryCache instead of IFileSystem",
          "committedDate": "2021-10-15T10:29:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "200e03746296e223e32c4248930e7374db8af14a",
          "message": "Revert \"Make FileMatcher consume IDirectoryCache instead of IFileSystem\"\n\nThis reverts commit fde5ed67ba18f3f41b272b4549f296209e56592a.",
          "committedDate": "2021-10-15T10:30:01Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1004b54eb2874388b4cb82c070a53f4fa3c4e331",
          "message": "Introduce DirectoryCacheFileSystemWrapper",
          "committedDate": "2021-10-15T10:30:04Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "faeda3e4705370d3ce568bbc3e53f08b7d1fd7c7",
          "message": "Avoid string allocations when calling IsMatch",
          "committedDate": "2021-10-15T10:30:04Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1d0a741a130eb779c764da18660d400512a7d681",
          "message": "Pass IDirectoryCacheFactory to Project ctor (reverts most changes to EvaluationContext)",
          "committedDate": "2021-10-15T10:31:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "65c4942543440f7f5da90dcce7d3bd2131c93aed",
          "message": "Fix bugs",
          "committedDate": "2021-10-15T10:31:24Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0340b7697f28f1d133cf32913c2fa8c9be85682",
          "message": "Use directory cache in all of evaluation",
          "committedDate": "2021-10-15T10:31:25Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "77ed3ffcb2c57331fa9d6946548f6636f30dab1c",
          "message": "Add unit test",
          "committedDate": "2021-10-15T10:31:25Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "90a6bde08e1bf31dc66186642e8fb7532996b4ec",
          "message": "Tweaks and bug fixes",
          "committedDate": "2021-10-15T10:31:25Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73d7636a5cb09eb114cac7398e15e05f9d0e4a73",
          "message": "More internal IFileSystem deprecation and tweaks",
          "committedDate": "2021-10-15T10:31:25Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f91659262773f64947a1a94b13e33ced425303c6",
          "message": "Add pattern parameter to EnumerateFiles and EnumerateDirectories",
          "committedDate": "2021-10-15T10:31:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43f1323387da8a8649470c93126f5539eb42f80a",
          "message": "Revert \"More internal IFileSystem deprecation and tweaks\"\n\nThis reverts commit 180f7a83ff3cf43ed8370e5dcd67fa5dbb77b818.",
          "committedDate": "2021-10-15T10:31:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "89f7cc6af405419aee344b3afa4cb5bdb04dd501",
          "message": "Redo some of the minor tweaks reverted in previous commit",
          "committedDate": "2021-10-15T10:31:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e800fa86e2601b3abc30912e33f0e4e5228231d5",
          "message": "Optimize path manipulations (Microsoft.IO.Redist)",
          "committedDate": "2021-10-15T12:17:25Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "231a8693f21e4bf57352b8665d1f45e402d7c9db",
          "message": "Tweaks and comments",
          "committedDate": "2021-10-15T13:25:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2348cd8ca67bef75fd039ad6e5eabaeae830ffd2",
          "message": "Remove unused parameter",
          "committedDate": "2021-10-20T10:51:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e30d2393d86cbf24b81a189ff9636fb9d77302ff",
          "message": "Add and update comments",
          "committedDate": "2021-10-21T11:08:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "- I believe CPS will also need the particular project evaluation asking for the enumeration, not just the project path. It's a 1:1 mapping from MSBuild.Project to ConfiguredProject that is made unique by a tuple of (ProjectPath, ProjectConfiguration(2 or 3 dimensional configuration that includes configuration, platform and targetframework in the case of netcore)). Depending on how simple you want to keep the contract you can choose between those 2 params. The 3rd dimension is project system specific.\r\n   - CPS uses that to map globbing/file matching. This exists via GetAllGlobs today. But that doesn't cover file probing paths where if a user adds a new directory.props file we don't know if it needs an evaluation.\r\n- It looks like you take 1 predicate for the inclusion. Do you also need another for the recursion separately?",
        "createdAt": "2021-08-03T18:30:04Z",
        "author": {
          "login": "arunchndr"
        }
      },
      {
        "body": "https://github.com/lifengl is Lifeng if you want to add him to the review.",
        "createdAt": "2021-08-03T18:32:18Z",
        "author": {
          "login": "arunchndr"
        }
      },
      {
        "body": "Thank you! I will make the change to better identify the project evaluation for which the interface is requested.\r\n\r\nMSBuild handles recursion internally and doesn't ask the filesystem for recursive file enumeration so I omitted this from the interface.\r\n\r\nAlso adding @lifengl to reviewers as suggested.\r\nEdit: It looks like his handle cannot be added, hope he'll see the mention.",
        "createdAt": "2021-08-03T20:36:58Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> I believe CPS will also need the particular project evaluation asking for the enumeration, not just the project path. It's a 1:1 mapping from MSBuild.Project to ConfiguredProject that is made unique by a tuple of (ProjectPath, ProjectConfiguration(2 or 3 dimensional configuration that includes configuration, platform and targetframework in the case of netcore)). Depending on how simple you want to keep the contract you can choose between those 2 params. The 3rd dimension is project system specific.\r\n\r\n@arkalyanms I have a hard time parsing this. If there's a 1:1 mapping between Project and ConfiguredProject, then it should be enough to pass the Project being evaluated, is that not true? Or are you saying that that there's a **1:N** mapping between Project and ConfiguredProject and it has to be disambiguated with an additional parameter?",
        "createdAt": "2021-08-04T14:55:40Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> > I believe CPS will also need the particular project evaluation asking for the enumeration, not just the project path. It's a 1:1 mapping from MSBuild.Project to ConfiguredProject that is made unique by a tuple of (ProjectPath, ProjectConfiguration(2 or 3 dimensional configuration that includes configuration, platform and targetframework in the case of netcore)). Depending on how simple you want to keep the contract you can choose between those 2 params. The 3rd dimension is project system specific.\r\n> \r\n> @arkalyanms I have a hard time parsing this. If there's a 1:1 mapping between Project and ConfiguredProject, then it should be enough to pass the Project being evaluated, is that not true? Or are you saying that that there's a **1:N** mapping between Project and ConfiguredProject and it has to be disambiguated with an additional parameter?\r\n\r\nYes Project will work. It's a 1:1 from Project to ConfiguredProject. \r\n\r\nI was just saying what makes a ConfiguredProject unique is the combination of Project path and ProjectConfiguration which in turn is 3 dimensional(config, platform, targetframework).",
        "createdAt": "2021-08-04T18:19:50Z",
        "author": {
          "login": "arunchndr"
        }
      },
      {
        "body": "Got it, thank you for bearing with me. I have updated `GetDirectoryCacheForProject` to take Project rather than project path.",
        "createdAt": "2021-08-04T19:50:23Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I have updated the interface. The predicate and transform callbacks now pass only the file name as `ReadOnlySpan<char>` instead of the full `FileSystemEntry` because the latter\r\n- Is not CLS compliant,\r\n- Exposes no construction API,\r\n- Contains data that CPS does not have and MSBuild does not need. MSBuild needs just names.",
        "createdAt": "2021-08-05T20:11:31Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "Notes to self:\r\n- Consider reverting the last commit and instead of propagating `IDirectoryCache` down to `FileMatcher` just change `IFileSystem`. It will require an adapter but the change would be much less invasive overall.\r\n- Wait for #6075 to land before finalizing this.",
        "createdAt": "2021-08-10T10:45:08Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "The test failure is caused by the new code having no restrictions on file path length as filtering is always done in `FileMatcher` and not in file I/O routines as before. Looks like another reason for changing `FileSystem`. We could keep passing `pattern` down to the OS for full backward compatibility and filter entries MSBuild-side only if `IDirectoryCache` is provided by the host.",
        "createdAt": "2021-08-10T11:11:43Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "Back to draft as we're still discussing the design. This work is now targeting 17.1.",
        "createdAt": "2021-08-31T09:25:26Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "We're investigating a code path where CPS is seeing MSBuild hit the disk despite `IDirectoryCacheFactory` having been passed to the `Project`. It may be a pre-existing issue of not propagating `IFileSystem` to all places where file I/O is happening. The fix will likely be a targeted change so I am marking this PR ready for review.",
        "createdAt": "2021-10-15T15:17:11Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "@ladipro : there are some gaps between this contract & CPS design:\r\n 1, CPS cache is directory based, not project based, and not complete. So it is more like IDirectoryCache GetCacheForDirectory(string directoryPath). If we don't have cache for a directory, can we fall back to msbuild ones? (I am not sure how often this will hit SDK folders, or parent folder chains. CPS basically caches the project tree itself, and  some glob cones, but it is not a complete list. Otherwise, we will repeat the same logic your team has built for other folders.\r\n\r\n2, one key scenario we use this is the initial evaluation of a project or a new configuration (configurations will share the directory cone most of the time, which we always have after evaluating the first configuration). However, that happens in the construction of the Project, and when we receive the instance of the project back in the middle of the construction, it would be problematic -- we don't know the instance yet, and when we access its internal structure, we don't know what is valid and what is not. It is also a dangerous to leak the instance in the middle of the construction through public contracts. ",
              "createdAt": "2021-08-13T18:15:18Z",
              "path": "ref/Microsoft.Build/netstandard/Microsoft.Build.cs",
              "diffHunk": "@@ -1489,6 +1490,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache\n+    {\n+        bool DirectoryExists(string path);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        bool FileExists(string path);\n+    }\n+    public partial interface IDirectoryCacheFactory\n+    {\n+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForProject(Microsoft.Build.Evaluation.Project project);",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "maybe CPS can always provide IDirectoryCache, and use our cached folder if it is possible, otherwise just fall back to the file system. It will allow us to capture all probing path during evaluation, and use it in project evaluation cache in the future (@arkalyanms). In that case, maybe the design is fine, except that we will get Project before the constructor finishes, which is still a design issue.",
              "createdAt": "2021-08-13T18:28:52Z",
              "path": "ref/Microsoft.Build/netstandard/Microsoft.Build.cs",
              "diffHunk": "@@ -1489,6 +1490,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache\n+    {\n+        bool DirectoryExists(string path);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        bool FileExists(string path);\n+    }\n+    public partial interface IDirectoryCacheFactory\n+    {\n+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForProject(Microsoft.Build.Evaluation.Project project);",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "> maybe CPS can always provide IDirectoryCache, and use our cached folder if it is possible, otherwise just fall back to the file system.\r\n\r\n@lifengl when we discussed this a few months ago, I remember mentioning the fact that CPS wants to be made aware of directories outside of the project cone - so it can cache and monitor them. So the API has no \"I don't know\" answer and the implementation is expected to handle all paths. Let me know if I misunderstood.\r\n\r\nThank you for bringing up the issue with `Project` being constructed when these callbacks would fire. What else would work for you, other than passing `IDirectoryCache` to `Project` during construction as described in the other comment? Earlier @arkalyanms also mentioned using the tuple of (ProjectPath, ProjectConfiguration) to identify the configured project. Still an option?",
              "createdAt": "2021-08-16T16:00:47Z",
              "path": "ref/Microsoft.Build/netstandard/Microsoft.Build.cs",
              "diffHunk": "@@ -1489,6 +1490,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache\n+    {\n+        bool DirectoryExists(string path);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        bool FileExists(string path);\n+    }\n+    public partial interface IDirectoryCacheFactory\n+    {\n+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForProject(Microsoft.Build.Evaluation.Project project);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "maybe some information similar to what is in the ProjectEvaluationStartedEventArgs, ProjectFile, some kind of context, especially the EvaluationId. See my other comments, it is important for us to know the exact evaluation each request comes from, we have already monitor evaluation start/end, which will allow us to collect what belongs a single evaluation.",
              "createdAt": "2021-08-16T19:03:33Z",
              "path": "ref/Microsoft.Build/netstandard/Microsoft.Build.cs",
              "diffHunk": "@@ -1489,6 +1490,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache\n+    {\n+        bool DirectoryExists(string path);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        bool FileExists(string path);\n+    }\n+    public partial interface IDirectoryCacheFactory\n+    {\n+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForProject(Microsoft.Build.Evaluation.Project project);",
              "author": {
                "login": "lifengl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A problem of this design is that we need change every code calls into RevaluateProjectIfNecessary, which can be very difficult. Any chance we can provide the CacheFactory to the project, which is used in the lifetime of the project?  If the evaluation should not use cache, maybe it can be controlled on CPS side?",
              "createdAt": "2021-08-13T23:25:38Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -872,6 +872,7 @@ public partial class EvaluationContext\n     {\n         internal EvaluationContext() { }\n         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }\n+        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.IDirectoryCacheFactory directoryCacheFactory) { throw null; }",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "If there are no scenarios where you would want to evaluate the same `Project` with different backing caches, then I guess we could add `IDirectoryCache` as a `Project` constructor parameter. It's not as clean, though, because this conceptually belongs in evaluation context. Which I thought CPS wanted to use for (all?) evaluations anyway.",
              "createdAt": "2021-08-16T15:53:22Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -872,6 +872,7 @@ public partial class EvaluationContext\n     {\n         internal EvaluationContext() { }\n         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }\n+        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.IDirectoryCacheFactory directoryCacheFactory) { throw null; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "One problem is that we want to keep using the same disk cache for a single project evaluation, so the result can be consistent (if the project has two globs to match the same file, we should match both them together or none to keep it consistent.)  So, maybe we should pass in the evaluationId here?",
              "createdAt": "2021-08-16T18:54:19Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -1495,6 +1496,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache\n+    {\n+        bool DirectoryExists(string path);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        bool FileExists(string path);\n+    }\n+    public partial interface IDirectoryCacheFactory\n+    {\n+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForProject(Microsoft.Build.Evaluation.Project project);",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "Consistency is controlled by the lifetime of the EvaluationContext instance. When you want msbuild evaluations to read a different state of the disk, you create a new EvaluationContext and start using that one. At least that's the assumption on which the evaluation context code is built on, there's no separation based on the evaluation ID. Also, the evaluation ID isn't propagated to all all the evaluation components, so it's hard for an arbitrary point of evaluation code to know what evaluation ID is using it.",
              "createdAt": "2021-08-17T21:39:48Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -1495,6 +1496,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache\n+    {\n+        bool DirectoryExists(string path);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);\n+        bool FileExists(string path);\n+    }\n+    public partial interface IDirectoryCacheFactory\n+    {\n+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForProject(Microsoft.Build.Evaluation.Project project);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't it be better to augment MSBuildFileSystemBase with these new methods instead of creating a new interface?. With a new interface, the APIs will get harded to use. Users will have to think whether to implement one or the other, or both, Maybe a new generic MSBuildFileSystemBase<T> that extends MSBuildFileSystemBase.",
              "createdAt": "2021-08-17T21:42:10Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -1495,6 +1496,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I pushed an update where the interface is now provided via `Project` and not `EvaluationContext` so having a separate one should be easier to justify. I would argue that having multiple methods providing the same functionality in `MSBuildFileSystemBase` would also be confusing for users because it wouldn't be clear which one is used when.",
              "createdAt": "2021-08-18T20:49:22Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -1495,6 +1496,19 @@ public partial class ProxyTargets\n }\n namespace Microsoft.Build.FileSystem\n {\n+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);\n+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);\n+    public partial interface IDirectoryCache",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does the file matcher have to be sensitive to the Project VS having one for the entire evaluation context? The purpose of the evaluation context was to share common state between projects, not keep per-project state. The Project/Evaluator can keep per Project/evaluation state, maybe building it on top of common state from the evaluation context.",
              "createdAt": "2021-08-17T21:55:27Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -260,6 +266,10 @@ internal class Evaluator<P, I, M, D>\n             _streamImports = new List<string>();\n             // When the imports are concatenated with a semicolon, this automatically prepends a semicolon if and only if another element is later added.\n             _streamImports.Add(string.Empty);\n+\n+            // Create a FileMatcher for the given combination of EvaluationContext and the project being evaluated.\n+            IFileSystem fileSystem = _evaluationContext.GetFileSystemForProject(project);\n+            _fileMatcher = new FileMatcher(fileSystem, evaluationContext.FileEntryExpansionCache);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "My understanding is that CPS maintains its cache per configured project so its content can be different depending on which project is being evaluated, even if they share one evaluation context. I'll let @lifengl / @arkalyanms confirm this requirement.\r\n\r\nI have just pushed an updated based on yesterday's sync (too bad we did not record it) where I was asked to couple `IDirectoryCacheFactory` with the `Project` rather than with `EvaluationContext`. I do agree that having the cache be part of `EvaluationContext` would be cleaner but unfortunately it wouldn't work well for the intended use here.",
              "createdAt": "2021-08-18T20:45:04Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -260,6 +266,10 @@ internal class Evaluator<P, I, M, D>\n             _streamImports = new List<string>();\n             // When the imports are concatenated with a semicolon, this automatically prepends a semicolon if and only if another element is later added.\n             _streamImports.Add(string.Empty);\n+\n+            // Create a FileMatcher for the given combination of EvaluationContext and the project being evaluated.\n+            IFileSystem fileSystem = _evaluationContext.GetFileSystemForProject(project);\n+            _fileMatcher = new FileMatcher(fileSystem, evaluationContext.FileEntryExpansionCache);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "An alternative is for CPS to maintain multiple evaluation contexts, one for each cache \"universe\". I'm assuming that they don't have a unique cache per project (what's the point of having a unique cache per project?), but instead a few larger buckets, maybe based on different FS states?",
              "createdAt": "2021-08-19T21:24:27Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -260,6 +266,10 @@ internal class Evaluator<P, I, M, D>\n             _streamImports = new List<string>();\n             // When the imports are concatenated with a semicolon, this automatically prepends a semicolon if and only if another element is later added.\n             _streamImports.Add(string.Empty);\n+\n+            // Create a FileMatcher for the given combination of EvaluationContext and the project being evaluated.\n+            IFileSystem fileSystem = _evaluationContext.GetFileSystemForProject(project);\n+            _fileMatcher = new FileMatcher(fileSystem, evaluationContext.FileEntryExpansionCache);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "It is primary not for that reason, but couple issues we discussed.\r\n\r\n1, we want to use this to capture project dependencies, so when things are changed, we can trigger reevaluation. For example, we can capture the project evaluation tries to load Directory.Build.Props file in the folder, although it does not exist, so when the user adds the file, we can trigger a new evaluation. Without something connecting to a specific project evaluation, we cannot do that.\r\n\r\n2, for each project, we want to use IDirectoryCache beyond one evaluation context, because ReevaluateIfNecessary() can be called in any random place in CPS extensions. If DirectoryCache need be passed in each of them (as evaluationContext), so if it is called outside of CPS, it may not pass in evaluationContext, and it will hit disk on those calls, then others using the cache state.  This can lead into lots of problems because the cache might be slightly behind the real disk, and we can unpredictable behavior in the product scenarios. \r\n\r\n\r\nHowever, i noticed a potential problem later in the FindPredicate contract. Because the file/folder patterns are not passed to the CPS side, but it always scan all files/folders under the folder, it might cause excessive invalidation of the evaluation result. I am not sure whether it would become a real problem or not, mostly depending how SDK uses those glob patterns.",
              "createdAt": "2021-08-20T20:24:42Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -260,6 +266,10 @@ internal class Evaluator<P, I, M, D>\n             _streamImports = new List<string>();\n             // When the imports are concatenated with a semicolon, this automatically prepends a semicolon if and only if another element is later added.\n             _streamImports.Add(string.Empty);\n+\n+            // Create a FileMatcher for the given combination of EvaluationContext and the project being evaluated.\n+            IFileSystem fileSystem = _evaluationContext.GetFileSystemForProject(project);\n+            _fileMatcher = new FileMatcher(fileSystem, evaluationContext.FileEntryExpansionCache);",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "Great point about the missing file/folder pattern. It's intentionally designed like this (i.e. that filtering is done MSBuild-side) so the logic stays in one place and we don't risk running into slightly different behavior depending on how it's implemented. Also, I don't believe that all patterns supported by MSBuild are handled by `System.IO` or the underlying filesystem calls so there would still be cases where invalidation would not be precise.\r\n\r\nCan you use the result of `FindPredicate` to mark files/folders that are actually used by the project and should cause invalidation? In other words, items for which the predicate returns false would still be cached but if the file watcher fires for them the project will not be re-evaluated.",
              "createdAt": "2021-08-30T14:45:48Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -260,6 +266,10 @@ internal class Evaluator<P, I, M, D>\n             _streamImports = new List<string>();\n             // When the imports are concatenated with a semicolon, this automatically prepends a semicolon if and only if another element is later added.\n             _streamImports.Add(string.Empty);\n+\n+            // Create a FileMatcher for the given combination of EvaluationContext and the project being evaluated.\n+            IFileSystem fileSystem = _evaluationContext.GetFileSystemForProject(project);\n+            _fileMatcher = new FileMatcher(fileSystem, evaluationContext.FileEntryExpansionCache);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Thanks \ud83d\ude42",
              "createdAt": "2021-08-20T20:26:33Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -436,26 +446,29 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,\n         /// <param name=\"projectCollection\">The collection with which this project should be associated. May not be null.</param>\n         /// <param name=\"loadSettings\">The load settings for this project.</param>\n         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)\n-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)\n+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)\n         {\n         }\n \n-        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\n+        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,\n+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));\n             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));\n             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));\n \n             ProjectCollection = projectCollection;\n-            var defailtImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This was recently fixed by @KirillOsenkov so the credit goes to him \ud83d\ude42. I think you commented on an older version.",
              "createdAt": "2021-10-18T14:55:35Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -436,26 +446,29 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,\n         /// <param name=\"projectCollection\">The collection with which this project should be associated. May not be null.</param>\n         /// <param name=\"loadSettings\">The load settings for this project.</param>\n         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)\n-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)\n+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)\n         {\n         }\n \n-        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\n+        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,\n+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));\n             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));\n             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));\n \n             ProjectCollection = projectCollection;\n-            var defailtImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's special about NETSTANDARD2_0?",
              "createdAt": "2021-10-15T15:35:02Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1664,12 +1664,39 @@ internal Result()\n             internal string wildcardDirectoryPart = string.Empty;\n         }\n \n+        /// <summary>\n+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.\n+        /// </summary>\n+        /// <param name=\"path\">The path whose file name is matched against the pattern.</param>\n+        /// <param name=\"pattern\">The pattern.</param>\n+        internal static bool IsFileNameMatch(string path, string pattern)\n+        {\n+            // Use a span-based Path.GetFileName if it is available.\n+#if FEATURE_MSIOREDIST\n+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);\n+#elif NETSTANDARD2_0",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": ".NET Standard 2.0 unfortunately does not have the `Span`-based `GetFileName` overload. It was introduced in 2.1.\r\n\r\nCompare:\r\nhttps://raw.githubusercontent.com/dotnet/standard/master/docs/versions/netstandard2.0_ref.md\r\nhttps://raw.githubusercontent.com/dotnet/standard/master/docs/versions/netstandard2.1_ref.md\r\n\r\nI'm curious if we can upgrade but it would most likely be a separate PR.",
              "createdAt": "2021-10-18T14:52:58Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1664,12 +1664,39 @@ internal Result()\n             internal string wildcardDirectoryPart = string.Empty;\n         }\n \n+        /// <summary>\n+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.\n+        /// </summary>\n+        /// <param name=\"path\">The path whose file name is matched against the pattern.</param>\n+        /// <param name=\"pattern\">The pattern.</param>\n+        internal static bool IsFileNameMatch(string path, string pattern)\n+        {\n+            // Use a span-based Path.GetFileName if it is available.\n+#if FEATURE_MSIOREDIST\n+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);\n+#elif NETSTANDARD2_0",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "We're stuck on 2.0 as long as we have .NET Framework MSBuild, right? 2.1 is Core + Mono only.",
              "createdAt": "2021-10-18T14:55:20Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1664,12 +1664,39 @@ internal Result()\n             internal string wildcardDirectoryPart = string.Empty;\n         }\n \n+        /// <summary>\n+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.\n+        /// </summary>\n+        /// <param name=\"path\">The path whose file name is matched against the pattern.</param>\n+        /// <param name=\"pattern\">The pattern.</param>\n+        internal static bool IsFileNameMatch(string path, string pattern)\n+        {\n+            // Use a span-based Path.GetFileName if it is available.\n+#if FEATURE_MSIOREDIST\n+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);\n+#elif NETSTANDARD2_0",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oh, but we can upgrade the TF of our libraries internally, yes: https://github.com/dotnet/msbuild/issues/6032",
              "createdAt": "2021-10-18T14:56:32Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1664,12 +1664,39 @@ internal Result()\n             internal string wildcardDirectoryPart = string.Empty;\n         }\n \n+        /// <summary>\n+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.\n+        /// </summary>\n+        /// <param name=\"path\">The path whose file name is matched against the pattern.</param>\n+        /// <param name=\"pattern\">The pattern.</param>\n+        internal static bool IsFileNameMatch(string path, string pattern)\n+        {\n+            // Use a span-based Path.GetFileName if it is available.\n+#if FEATURE_MSIOREDIST\n+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);\n+#elif NETSTANDARD2_0",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This absolutely does not matter, but I'm curious if this is faster than converting each char to uppercase and comparing them directly. A single character shouldn't need to allocate, and it saves making a for loop.",
              "createdAt": "2021-10-15T15:41:49Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1721,7 +1751,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                     // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table\n                     return inputChar == patternChar;\n                 }\n-                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;\n+                return MemoryExtensions.Equals(input.Slice(iIndex, 1), pattern.AsSpan(pIndex, 1), StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's counterintuitive but `MemoryExtensions.Equals` is actually faster on both Framework and Core when passed a non-ASCII character. On .NET Core 64-bit it's 3x faster (!!!) compared to calling `Char.ToUpperInvariant` on the two and comparing the results.\r\n\r\nThe benchmark:\r\n```C#\r\n    public class IgnoreCaseComparison_Benchmark\r\n    {\r\n        private string str1 = \"\u010f\";\r\n        private string str2 = \"\u010e\";\r\n\r\n        [Benchmark]\r\n        public bool CharToUpperInvariant()\r\n        {\r\n            return char.ToUpperInvariant(str1[0]) == char.ToUpperInvariant(str2[0]);\r\n        }\r\n\r\n        [Benchmark]\r\n        public bool MemoryExtensionsEquals()\r\n        {\r\n            return MemoryExtensions.Equals(str1.AsSpan(), str2.AsSpan(), StringComparison.OrdinalIgnoreCase);\r\n        }\r\n    }\r\n```\r\n\r\n```\r\nAMD EPYC 7452, 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=6.0.100-rc.2.21505.57\r\n  [Host]     : .NET Core 6.0.0 (CoreCLR 6.0.21.48005, CoreFX 6.0.21.48005), X64 RyuJIT\r\n  DefaultJob : .NET Core 6.0.0 (CoreCLR 6.0.21.48005, CoreFX 6.0.21.48005), X64 RyuJIT\r\n\r\n\r\n|                 Method |     Mean |    Error |   StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|----------------------- |---------:|---------:|---------:|------:|------:|------:|----------:|\r\n|   CharToUpperInvariant | 43.10 ns | 0.305 ns | 0.285 ns |     - |     - |     - |         - |\r\n| MemoryExtensionsEquals | 14.97 ns | 0.090 ns | 0.084 ns |     - |     - |     - |         - |\r\n```",
              "createdAt": "2021-10-19T19:08:59Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1721,7 +1751,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                     // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table\n                     return inputChar == patternChar;\n                 }\n-                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;\n+                return MemoryExtensions.Equals(input.Slice(iIndex, 1), pattern.AsSpan(pIndex, 1), StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we link in the docs that it should be specified in `ProjectOptions`? Seems like a helpful pointer.",
              "createdAt": "2021-10-18T15:32:46Z",
              "path": "src/Build/FileSystem/IDirectoryCache.cs",
              "diffHunk": "@@ -0,0 +1,87 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    /// <summary>\n+    /// A provider of <see cref=\"IDirectoryCache\"/> instances. To be implemented by MSBuild hosts that wish to intercept\n+    /// file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    /// <remarks>\n+    /// Unlike <see cref=\"MSBuildFileSystemBase\"/>, file enumeration returns file/directory names, not full paths.\n+    /// </remarks>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done, thank you.",
              "createdAt": "2021-10-21T11:08:39Z",
              "path": "src/Build/FileSystem/IDirectoryCache.cs",
              "diffHunk": "@@ -0,0 +1,87 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    /// <summary>\n+    /// A provider of <see cref=\"IDirectoryCache\"/> instances. To be implemented by MSBuild hosts that wish to intercept\n+    /// file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    /// <remarks>\n+    /// Unlike <see cref=\"MSBuildFileSystemBase\"/>, file enumeration returns file/directory names, not full paths.\n+    /// </remarks>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does \"normalized\" mean \"full\"? I'm finding this slightly confusing after reading \"file enumeration returns file/directory names, not full paths\" above.",
              "createdAt": "2021-10-18T15:34:13Z",
              "path": "src/Build/FileSystem/IDirectoryCache.cs",
              "diffHunk": "@@ -0,0 +1,87 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    /// <summary>\n+    /// A provider of <see cref=\"IDirectoryCache\"/> instances. To be implemented by MSBuild hosts that wish to intercept\n+    /// file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    /// <remarks>\n+    /// Unlike <see cref=\"MSBuildFileSystemBase\"/>, file enumeration returns file/directory names, not full paths.\n+    /// </remarks>\n+    public interface IDirectoryCacheFactory\n+    {\n+        /// <summary>\n+        /// Returns an <see cref=\"IDirectoryCache\"/> to be used when evaluating the project associated with this <see cref=\"IDirectoryCacheFactory\"/>.\n+        /// </summary>\n+        /// <param name=\"evaluationId\">The ID of the evaluation for which the interface is requested.</param>\n+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);\n+    }\n+\n+    /// <summary>\n+    /// A predicate taking file name.\n+    /// </summary>\n+    /// <param name=\"fileName\">The file name to check.</param>\n+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// A function taking file name and returning an arbitrary result.\n+    /// </summary>\n+    /// <typeparam name=\"TResult\">The type of the result to return</typeparam>\n+    /// <param name=\"fileName\">The file name to transform.</param>\n+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    public interface IDirectoryCache\n+    {\n+        /// <summary>\n+        /// Returns <code>true</code> if the given path points to an existing file on disk.\n+        /// </summary>\n+        /// <param name=\"path\">A normalized path.</param>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It's both, apologies for the confusion. Full = absolute/rooted, Normalized = no craziness like \"C:\\Windows\\..\\Users\". I have updated the comments.",
              "createdAt": "2021-10-21T11:11:19Z",
              "path": "src/Build/FileSystem/IDirectoryCache.cs",
              "diffHunk": "@@ -0,0 +1,87 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    /// <summary>\n+    /// A provider of <see cref=\"IDirectoryCache\"/> instances. To be implemented by MSBuild hosts that wish to intercept\n+    /// file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    /// <remarks>\n+    /// Unlike <see cref=\"MSBuildFileSystemBase\"/>, file enumeration returns file/directory names, not full paths.\n+    /// </remarks>\n+    public interface IDirectoryCacheFactory\n+    {\n+        /// <summary>\n+        /// Returns an <see cref=\"IDirectoryCache\"/> to be used when evaluating the project associated with this <see cref=\"IDirectoryCacheFactory\"/>.\n+        /// </summary>\n+        /// <param name=\"evaluationId\">The ID of the evaluation for which the interface is requested.</param>\n+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);\n+    }\n+\n+    /// <summary>\n+    /// A predicate taking file name.\n+    /// </summary>\n+    /// <param name=\"fileName\">The file name to check.</param>\n+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// A function taking file name and returning an arbitrary result.\n+    /// </summary>\n+    /// <typeparam name=\"TResult\">The type of the result to return</typeparam>\n+    /// <param name=\"fileName\">The file name to transform.</param>\n+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    public interface IDirectoryCache\n+    {\n+        /// <summary>\n+        /// Returns <code>true</code> if the given path points to an existing file on disk.\n+        /// </summary>\n+        /// <param name=\"path\">A normalized path.</param>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does `TResult` need to be a type param? What keeps it from just being a `string`?",
              "createdAt": "2021-10-18T15:36:02Z",
              "path": "src/Build/FileSystem/IDirectoryCache.cs",
              "diffHunk": "@@ -0,0 +1,87 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    /// <summary>\n+    /// A provider of <see cref=\"IDirectoryCache\"/> instances. To be implemented by MSBuild hosts that wish to intercept\n+    /// file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    /// <remarks>\n+    /// Unlike <see cref=\"MSBuildFileSystemBase\"/>, file enumeration returns file/directory names, not full paths.\n+    /// </remarks>\n+    public interface IDirectoryCacheFactory\n+    {\n+        /// <summary>\n+        /// Returns an <see cref=\"IDirectoryCache\"/> to be used when evaluating the project associated with this <see cref=\"IDirectoryCacheFactory\"/>.\n+        /// </summary>\n+        /// <param name=\"evaluationId\">The ID of the evaluation for which the interface is requested.</param>\n+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);\n+    }\n+\n+    /// <summary>\n+    /// A predicate taking file name.\n+    /// </summary>\n+    /// <param name=\"fileName\">The file name to check.</param>\n+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// A function taking file name and returning an arbitrary result.\n+    /// </summary>\n+    /// <typeparam name=\"TResult\">The type of the result to return</typeparam>\n+    /// <param name=\"fileName\">The file name to transform.</param>\n+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    public interface IDirectoryCache\n+    {\n+        /// <summary>\n+        /// Returns <code>true</code> if the given path points to an existing file on disk.\n+        /// </summary>\n+        /// <param name=\"path\">A normalized path.</param>\n+        bool FileExists(string path);\n+\n+        /// <summary>\n+        /// Returns <code>true</code> if the given path points to an existing directory on disk.\n+        /// </summary>\n+        /// <param name=\"path\">A normalized path.</param>\n+        bool DirectoryExists(string path);\n+\n+        /// <summary>\n+        /// Enumerates files in the given directory only (non-recursively).\n+        /// </summary>\n+        /// <typeparam name=\"TResult\">The desired return type.</typeparam>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It makes it possible to construct objects that don't necessarily wrap a `string`, which eliminates the intermediate allocation (`FindTransfor<TResult>` takes a span so it's up to the callback whether it wants to allocate the string or not).\r\n\r\n`TResult` will be `string` for most consumers but the extra flexibility does not cost us anything. It is modeled after https://docs.microsoft.com/en-us/dotnet/api/system.io.enumeration.filesystemenumerable-1. ",
              "createdAt": "2021-10-19T13:48:58Z",
              "path": "src/Build/FileSystem/IDirectoryCache.cs",
              "diffHunk": "@@ -0,0 +1,87 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    /// <summary>\n+    /// A provider of <see cref=\"IDirectoryCache\"/> instances. To be implemented by MSBuild hosts that wish to intercept\n+    /// file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    /// <remarks>\n+    /// Unlike <see cref=\"MSBuildFileSystemBase\"/>, file enumeration returns file/directory names, not full paths.\n+    /// </remarks>\n+    public interface IDirectoryCacheFactory\n+    {\n+        /// <summary>\n+        /// Returns an <see cref=\"IDirectoryCache\"/> to be used when evaluating the project associated with this <see cref=\"IDirectoryCacheFactory\"/>.\n+        /// </summary>\n+        /// <param name=\"evaluationId\">The ID of the evaluation for which the interface is requested.</param>\n+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);\n+    }\n+\n+    /// <summary>\n+    /// A predicate taking file name.\n+    /// </summary>\n+    /// <param name=\"fileName\">The file name to check.</param>\n+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// A function taking file name and returning an arbitrary result.\n+    /// </summary>\n+    /// <typeparam name=\"TResult\">The type of the result to return</typeparam>\n+    /// <param name=\"fileName\">The file name to transform.</param>\n+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);\n+\n+    /// <summary>\n+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.\n+    /// </summary>\n+    public interface IDirectoryCache\n+    {\n+        /// <summary>\n+        /// Returns <code>true</code> if the given path points to an existing file on disk.\n+        /// </summary>\n+        /// <param name=\"path\">A normalized path.</param>\n+        bool FileExists(string path);\n+\n+        /// <summary>\n+        /// Returns <code>true</code> if the given path points to an existing directory on disk.\n+        /// </summary>\n+        /// <param name=\"path\">A normalized path.</param>\n+        bool DirectoryExists(string path);\n+\n+        /// <summary>\n+        /// Enumerates files in the given directory only (non-recursively).\n+        /// </summary>\n+        /// <typeparam name=\"TResult\">The desired return type.</typeparam>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Question: should we consider intercepting property-function calls to `$([System.IO.File]::Exists())` and friends and having them use the callback? Or should we intentionally leave that as a direct disk access?",
              "createdAt": "2021-10-18T15:42:08Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -301,6 +302,11 @@ private void FlushFirstValueIfNeeded()\n \n         private readonly IFileSystem _fileSystem;\n \n+        /// <summary>\n+        /// Non-null if the expander was constructed for evaluation.\n+        /// </summary>\n+        internal EvaluationContext EvaluationContext { get; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Great question. Ideally we want to know about all filesystem accesses during evaluation, which these property-function calls complicate a bit. It's not just `File.Exists`, `Directory.Exists`, `Directory.GetFiles`, and friends. It's all file I/O, really.\r\n\r\nHere's a (recently introduced) example from our repo:\r\nhttps://github.com/dotnet/msbuild/blob/520ee88edb7f510744e36b969f2280bd7b10403d/eng/Versions.props#L34\r\n\r\nWe don't expect the host to cache file contents. But the contract is built on the principle that the host can be aware that evaluation depends on a file so it knows to reevaluate if it detects that the file has changed. The contract should work as is (`FileExists` would be called in this case) or can be easily extended, but having to maintain an exhaustive list of FS API to intercept is highly unfortunate.\r\n\r\nI'm not addressing this for now and will discuss with the CPS team.",
              "createdAt": "2021-10-21T10:55:57Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -301,6 +302,11 @@ private void FlushFirstValueIfNeeded()\n \n         private readonly IFileSystem _fileSystem;\n \n+        /// <summary>\n+        /// Non-null if the expander was constructed for evaluation.\n+        /// </summary>\n+        internal EvaluationContext EvaluationContext { get; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this something that should be in the interface? I don't think it's generally relevant at evaluation time though it could conceivably affect `$(MSBuildAllProjects)`.",
              "createdAt": "2021-10-18T15:45:30Z",
              "path": "src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    internal class DirectoryCacheFileSystemWrapper : IFileSystem\n+    {\n+        /// <summary>\n+        /// The base <see cref=\"IFileSystem\"/> to fall back to for functionality not provided by <see cref=\"_directoryCache\"/>.\n+        /// </summary>\n+        private readonly IFileSystem _fileSystem;\n+\n+        /// <summary>\n+        /// A host-provided cache used for file existence and directory enumeration.\n+        /// </summary>\n+        private readonly IDirectoryCache _directoryCache;\n+\n+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)\n+        {\n+            _fileSystem = fileSystem;\n+            _directoryCache = directoryCache;\n+        }\n+\n+        #region IFileSystem implementation based on IDirectoryCache\n+\n+        public bool FileOrDirectoryExists(string path)\n+        {\n+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool DirectoryExists(string path)\n+        {\n+            return _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool FileExists(string path)\n+        {\n+            return _directoryCache.FileExists(path);\n+        }\n+\n+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);\n+        }\n+\n+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);\n+        }\n+\n+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);\n+        }\n+\n+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)\n+        {\n+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>\n+            {\n+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);\n+            };\n+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);\n+\n+            IEnumerable<string> directories = includeDirectories\n+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+            IEnumerable<string> files = includeFiles\n+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+\n+            return Enumerable.Concat(directories, files);\n+        }\n+\n+        #endregion\n+\n+        #region IFileSystem pass-through implementation\n+\n+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);\n+\n+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't believe last write time is tracked in the CPS cache. @arkalyanms may I ask you to confirm?",
              "createdAt": "2021-10-19T14:02:05Z",
              "path": "src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    internal class DirectoryCacheFileSystemWrapper : IFileSystem\n+    {\n+        /// <summary>\n+        /// The base <see cref=\"IFileSystem\"/> to fall back to for functionality not provided by <see cref=\"_directoryCache\"/>.\n+        /// </summary>\n+        private readonly IFileSystem _fileSystem;\n+\n+        /// <summary>\n+        /// A host-provided cache used for file existence and directory enumeration.\n+        /// </summary>\n+        private readonly IDirectoryCache _directoryCache;\n+\n+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)\n+        {\n+            _fileSystem = fileSystem;\n+            _directoryCache = directoryCache;\n+        }\n+\n+        #region IFileSystem implementation based on IDirectoryCache\n+\n+        public bool FileOrDirectoryExists(string path)\n+        {\n+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool DirectoryExists(string path)\n+        {\n+            return _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool FileExists(string path)\n+        {\n+            return _directoryCache.FileExists(path);\n+        }\n+\n+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);\n+        }\n+\n+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);\n+        }\n+\n+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);\n+        }\n+\n+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)\n+        {\n+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>\n+            {\n+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);\n+            };\n+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);\n+\n+            IEnumerable<string> directories = includeDirectories\n+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+            IEnumerable<string> files = includeFiles\n+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+\n+            return Enumerable.Concat(directories, files);\n+        }\n+\n+        #endregion\n+\n+        #region IFileSystem pass-through implementation\n+\n+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);\n+\n+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It's not in the CPS side cache. We would hit the disk if it is needed. If we want to avoid hitting the disk for the multi target frameworks case, we could delegate the same work to CPS and do it once for all target frameworks.",
              "createdAt": "2021-10-19T18:34:55Z",
              "path": "src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    internal class DirectoryCacheFileSystemWrapper : IFileSystem\n+    {\n+        /// <summary>\n+        /// The base <see cref=\"IFileSystem\"/> to fall back to for functionality not provided by <see cref=\"_directoryCache\"/>.\n+        /// </summary>\n+        private readonly IFileSystem _fileSystem;\n+\n+        /// <summary>\n+        /// A host-provided cache used for file existence and directory enumeration.\n+        /// </summary>\n+        private readonly IDirectoryCache _directoryCache;\n+\n+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)\n+        {\n+            _fileSystem = fileSystem;\n+            _directoryCache = directoryCache;\n+        }\n+\n+        #region IFileSystem implementation based on IDirectoryCache\n+\n+        public bool FileOrDirectoryExists(string path)\n+        {\n+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool DirectoryExists(string path)\n+        {\n+            return _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool FileExists(string path)\n+        {\n+            return _directoryCache.FileExists(path);\n+        }\n+\n+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);\n+        }\n+\n+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);\n+        }\n+\n+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);\n+        }\n+\n+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)\n+        {\n+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>\n+            {\n+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);\n+            };\n+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);\n+\n+            IEnumerable<string> directories = includeDirectories\n+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+            IEnumerable<string> files = includeFiles\n+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+\n+            return Enumerable.Concat(directories, files);\n+        }\n+\n+        #endregion\n+\n+        #region IFileSystem pass-through implementation\n+\n+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);\n+\n+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);",
              "author": {
                "login": "arunchndr"
              }
            },
            {
              "body": "Thank you.",
              "createdAt": "2021-10-19T18:46:14Z",
              "path": "src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    internal class DirectoryCacheFileSystemWrapper : IFileSystem\n+    {\n+        /// <summary>\n+        /// The base <see cref=\"IFileSystem\"/> to fall back to for functionality not provided by <see cref=\"_directoryCache\"/>.\n+        /// </summary>\n+        private readonly IFileSystem _fileSystem;\n+\n+        /// <summary>\n+        /// A host-provided cache used for file existence and directory enumeration.\n+        /// </summary>\n+        private readonly IDirectoryCache _directoryCache;\n+\n+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)\n+        {\n+            _fileSystem = fileSystem;\n+            _directoryCache = directoryCache;\n+        }\n+\n+        #region IFileSystem implementation based on IDirectoryCache\n+\n+        public bool FileOrDirectoryExists(string path)\n+        {\n+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool DirectoryExists(string path)\n+        {\n+            return _directoryCache.DirectoryExists(path);\n+        }\n+\n+        public bool FileExists(string path)\n+        {\n+            return _directoryCache.FileExists(path);\n+        }\n+\n+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);\n+        }\n+\n+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);\n+        }\n+\n+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly)\n+        {\n+            if (searchOption != SearchOption.TopDirectoryOnly)\n+            {\n+                // Recursive enumeration is not used during evaluation, pass it through.\n+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);\n+            }\n+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);\n+        }\n+\n+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)\n+        {\n+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>\n+            {\n+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);\n+            };\n+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);\n+\n+            IEnumerable<string> directories = includeDirectories\n+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+            IEnumerable<string> files = includeFiles\n+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)\n+                : Enumerable.Empty<string>();\n+\n+            return Enumerable.Concat(directories, files);\n+        }\n+\n+        #endregion\n+\n+        #region IFileSystem pass-through implementation\n+\n+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);\n+\n+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is the risk of state tearing here? For instance, if a cached directory lookup returns a file that has since been deleted and we then call `GetAttributes()`, does that produce a hard-to-diagnose error, or is it no big deal?",
              "createdAt": "2021-10-18T15:46:25Z",
              "path": "src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    internal class DirectoryCacheFileSystemWrapper : IFileSystem\n+    {\n+        /// <summary>\n+        /// The base <see cref=\"IFileSystem\"/> to fall back to for functionality not provided by <see cref=\"_directoryCache\"/>.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'd say no big deal. Without this change we use an `EvaluationContext`-wide cache for file existence so we are susceptible to state tearing already. And since we're not accessing the filesystem in a transactional manner it is always a concern, even without caching.\r\n\r\nIt would be a big deal only if MSBuild itself was mutating the filesystem during evaluations, I'm afraid we have to live with races caused by external writes.",
              "createdAt": "2021-10-19T14:12:07Z",
              "path": "src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+#if FEATURE_MSIOREDIST\n+using Path = Microsoft.IO.Path;\n+#endif\n+\n+namespace Microsoft.Build.FileSystem\n+{\n+    internal class DirectoryCacheFileSystemWrapper : IFileSystem\n+    {\n+        /// <summary>\n+        /// The base <see cref=\"IFileSystem\"/> to fall back to for functionality not provided by <see cref=\"_directoryCache\"/>.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}