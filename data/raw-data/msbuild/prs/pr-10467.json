{
  "number": 10467,
  "title": "Add Buffered BinaryReader to speed up Binlog reading",
  "body": "# Improve Binlog Reading by using a Custom Binary Reader \r\n- Added Buffered-Binary-Reader that combines MemoryStream and BinaryReader. \r\n- This allows `Read7BitEncodedInt()` to inline `Stream.ReadByte()`, saving 1-5 virtual function calls per int reads.\r\n- Added BulkRead7BitEncodedInt() to further optimize multiple read operations to further save on memory allocations.\r\n- These changes resulted in 2-4X speed up when tested reading a very large binlog.\r\n- Added a IBinaryReader interface to make switching back to BCL BinaryReader easy.\r\n# Improve Binlog Writer's Write7IntEncodedInt().\r\n- Write to a buffer before writing to the stream.  Reduce from 1 - 5 virtual function calls to 1.\r\n- This change reduces the total time in the function, but since it is not on a critical path, its benefit is negligible.",
  "state": "CLOSED",
  "createdAt": "2024-07-31T19:01:50Z",
  "updatedAt": "2024-09-20T20:57:24Z",
  "closedAt": "2024-09-20T20:57:24Z",
  "mergedAt": null,
  "additions": 1277,
  "deletions": 49,
  "changedFiles": 14,
  "headRefName": "dev/yuehuang/main_buffreader",
  "isDraft": false,
  "author": {
    "login": "yuehuang010"
  },
  "milestone": {
    "title": "VS 17.13"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "556babae7b077b35b1054e81a0b89017fddefd21",
          "message": "WIP initial Buffered Binary Reader",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a675004895b5e5cb0a3b2c014e1d59e921957c28",
          "message": "Add BinaryReaderWrapper.wip",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21b5344e515c44a03407b71bac72a2ab532a21bd",
          "message": "Reduce allocation on ReadBytes",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang\ud83c\udf1f",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8483dbb945004f166c05025d8abed43d3dd1b892",
          "message": "Fix unittests.",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang\ud83c\udf1f",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92e56f5ff6a2b80cf7f20373f175f260981174ae",
          "message": "Add ReadGuid",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang\ud83c\udf1f",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9f191406ab282152d68695fd51b5a25554701ee8",
          "message": "Address feedbacks.",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang\ud83c\udf1f",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "571c8925c6af26ff784a642410c58fda5e1493bd",
          "message": "Make IBinaryReader Internal.",
          "committedDate": "2024-08-23T23:11:53Z",
          "author": {
            "name": "Felix Huang\ud83c\udf1f",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e6d59c17df0d7514c5e6f9d47309b63076cb3dc6",
          "message": "Add ReadString test for Unicode.",
          "committedDate": "2024-08-24T00:24:44Z",
          "author": {
            "name": "Felix Huang\ud83c\udf1f",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3e1d3b3bfe861a806ffe67018886f7f08259976b",
          "message": "Merge branch 'main' into dev/yuehuang/main_buffreader",
          "committedDate": "2024-08-26T19:36:33Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> Perf comparison would be nice then\r\n\r\nI ported these changes to a private [BinLogViewer](https://github.com/yuehuang010/MSBuildStructuredLog/tree/dev/yuehuang/main_bufferedreader_port) to open a 500mb binlog.\r\n\r\nBefore:\r\nTotal opening time: 1:11.670, **Loading: 51.482 s**, Analyzing: 8.743 s, Indexing: 7.944 s, Allocated: 120,133,521,336 bytes, Nodes: 143,137,731, Strings: 3,903,327\r\n\r\nAfter:\r\nTotal opening time: 52.185 s, **Loading: 31.396 s**, Analyzing: 9.339 s, Indexing: 7.796 s, Allocated: 63,378,355,056 bytes, Nodes: 143,137,731, Strings: 3,903,327\r\n\r\nNote: This removes the bottleneck and exposes other places for further optimize.  The gains are much greater in unit testing than End to End.",
        "createdAt": "2024-08-23T03:42:51Z",
        "author": {
          "login": "yuehuang010"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "We should probably check if the arg doesn't go over the `MaxBulkRead7BitLength` (and then either throw or just read at max `MaxBulkRead7BitLength`)",
              "createdAt": "2024-08-07T15:45:39Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryReaderWrapper.cs",
              "diffHunk": "@@ -0,0 +1,74 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+\n+namespace Microsoft.Build.Logging\n+{\n+    using System;\n+    using System.Collections.Generic;\n+    using System.IO;\n+    using System.Linq;\n+    using System.Text;\n+    using System.Threading.Tasks;\n+    using Microsoft.Build.Framework.Logging;\n+    using Microsoft.Build.Shared;\n+\n+    /// <summary>\n+    /// Implements <see cref=\"IBinaryReader\"/> on a <see cref=\"System.IO.BinaryReader \"/>.\n+    /// </summary>\n+    internal class BinaryReaderWrapper : IBinaryReader\n+    {\n+        private readonly BinaryReader _binaryReader;\n+\n+        // This is used to verify that events deserialization is not overreading expected size.\n+        private readonly TransparentReadStream _readStream;\n+\n+        public BinaryReaderWrapper(BinaryReader binaryReader)\n+        {\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+\n+            this._binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n+        }\n+\n+        int IBinaryReader.BytesCountAllowedToReadRemaining => _readStream.BytesCountAllowedToReadRemaining;\n+\n+        int? IBinaryReader.BytesCountAllowedToRead { set => _readStream.BytesCountAllowedToRead = value; }\n+\n+        long IBinaryReader.Position => _readStream.Position;\n+\n+        public const int MaxBulkRead7BitLength = 10;\n+        private int[] resultInt = new int[MaxBulkRead7BitLength];\n+\n+        int[] IBinaryReader.BulkRead7BitEncodedInt(int numIntegers)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Check added.",
              "createdAt": "2024-08-20T20:45:58Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryReaderWrapper.cs",
              "diffHunk": "@@ -0,0 +1,74 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+\n+namespace Microsoft.Build.Logging\n+{\n+    using System;\n+    using System.Collections.Generic;\n+    using System.IO;\n+    using System.Linq;\n+    using System.Text;\n+    using System.Threading.Tasks;\n+    using Microsoft.Build.Framework.Logging;\n+    using Microsoft.Build.Shared;\n+\n+    /// <summary>\n+    /// Implements <see cref=\"IBinaryReader\"/> on a <see cref=\"System.IO.BinaryReader \"/>.\n+    /// </summary>\n+    internal class BinaryReaderWrapper : IBinaryReader\n+    {\n+        private readonly BinaryReader _binaryReader;\n+\n+        // This is used to verify that events deserialization is not overreading expected size.\n+        private readonly TransparentReadStream _readStream;\n+\n+        public BinaryReaderWrapper(BinaryReader binaryReader)\n+        {\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+\n+            this._binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n+        }\n+\n+        int IBinaryReader.BytesCountAllowedToReadRemaining => _readStream.BytesCountAllowedToReadRemaining;\n+\n+        int? IBinaryReader.BytesCountAllowedToRead { set => _readStream.BytesCountAllowedToRead = value; }\n+\n+        long IBinaryReader.Position => _readStream.Position;\n+\n+        public const int MaxBulkRead7BitLength = 10;\n+        private int[] resultInt = new int[MaxBulkRead7BitLength];\n+\n+        int[] IBinaryReader.BulkRead7BitEncodedInt(int numIntegers)",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "I might be looking wrong - but I do not see the check :-)",
              "createdAt": "2024-08-21T09:28:51Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryReaderWrapper.cs",
              "diffHunk": "@@ -0,0 +1,74 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+\n+namespace Microsoft.Build.Logging\n+{\n+    using System;\n+    using System.Collections.Generic;\n+    using System.IO;\n+    using System.Linq;\n+    using System.Text;\n+    using System.Threading.Tasks;\n+    using Microsoft.Build.Framework.Logging;\n+    using Microsoft.Build.Shared;\n+\n+    /// <summary>\n+    /// Implements <see cref=\"IBinaryReader\"/> on a <see cref=\"System.IO.BinaryReader \"/>.\n+    /// </summary>\n+    internal class BinaryReaderWrapper : IBinaryReader\n+    {\n+        private readonly BinaryReader _binaryReader;\n+\n+        // This is used to verify that events deserialization is not overreading expected size.\n+        private readonly TransparentReadStream _readStream;\n+\n+        public BinaryReaderWrapper(BinaryReader binaryReader)\n+        {\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+\n+            this._binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n+        }\n+\n+        int IBinaryReader.BytesCountAllowedToReadRemaining => _readStream.BytesCountAllowedToReadRemaining;\n+\n+        int? IBinaryReader.BytesCountAllowedToRead { set => _readStream.BytesCountAllowedToRead = value; }\n+\n+        long IBinaryReader.Position => _readStream.Position;\n+\n+        public const int MaxBulkRead7BitLength = 10;\n+        private int[] resultInt = new int[MaxBulkRead7BitLength];\n+\n+        int[] IBinaryReader.BulkRead7BitEncodedInt(int numIntegers)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Oh, I added to the buffered reader but missed this one.",
              "createdAt": "2024-08-23T02:09:41Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryReaderWrapper.cs",
              "diffHunk": "@@ -0,0 +1,74 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+\n+namespace Microsoft.Build.Logging\n+{\n+    using System;\n+    using System.Collections.Generic;\n+    using System.IO;\n+    using System.Linq;\n+    using System.Text;\n+    using System.Threading.Tasks;\n+    using Microsoft.Build.Framework.Logging;\n+    using Microsoft.Build.Shared;\n+\n+    /// <summary>\n+    /// Implements <see cref=\"IBinaryReader\"/> on a <see cref=\"System.IO.BinaryReader \"/>.\n+    /// </summary>\n+    internal class BinaryReaderWrapper : IBinaryReader\n+    {\n+        private readonly BinaryReader _binaryReader;\n+\n+        // This is used to verify that events deserialization is not overreading expected size.\n+        private readonly TransparentReadStream _readStream;\n+\n+        public BinaryReaderWrapper(BinaryReader binaryReader)\n+        {\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+\n+            this._binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n+        }\n+\n+        int IBinaryReader.BytesCountAllowedToReadRemaining => _readStream.BytesCountAllowedToReadRemaining;\n+\n+        int? IBinaryReader.BytesCountAllowedToRead { set => _readStream.BytesCountAllowedToRead = value; }\n+\n+        long IBinaryReader.Position => _readStream.Position;\n+\n+        public const int MaxBulkRead7BitLength = 10;\n+        private int[] resultInt = new int[MaxBulkRead7BitLength];\n+\n+        int[] IBinaryReader.BulkRead7BitEncodedInt(int numIntegers)",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "let's use specific type and message (couple other cases in this file as well)",
              "createdAt": "2024-08-07T15:47:31Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new Exception();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Switched to `throw new FormatException();`",
              "createdAt": "2024-08-20T20:45:44Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new Exception();",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Where is this implementation comming from? Is it adapted from the BCL BinaryReader? We should have that info in comments. I already saw couple cases where MSBuild code had some custom implementation copied from BCL - while the BCL diverged a bit over time and nobody knew the original motivation or sometime even the source",
              "createdAt": "2024-08-07T15:52:39Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "ReadString() is effectively re-written when compared to BCL.  Should review in full.",
              "createdAt": "2024-08-20T20:45:10Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "It still is a good idea to add link to the original version (I believe it's https://github.com/dotnet/runtime/blob/779baa695d614e45f013b0ebaefc1d3889516800/src/libraries/System.Private.CoreLib/src/System/IO/BinaryReader.cs#L243) and call out what differs and why (I suppose it should be just the replacement of the _stream reading with FillBuffer - or not?)",
              "createdAt": "2024-08-21T09:41:39Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I modified to look closer to the version in BCL.  It is very similar, I moved the one time branch outside of the loop to simplified the loop.",
              "createdAt": "2024-08-24T00:38:19Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same here - where is it comming from? Is Big/Little Endian handled accordingly?",
              "createdAt": "2024-08-07T15:53:44Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new Exception();\n+            }\n+\n+            if (charBuffer == null)\n+            {\n+                charBuffer = new char[bufferCapacity + 1];\n+            }\n+\n+            int charRead = 0;\n+\n+            if (bufferLength > 0)\n+            {\n+                // Read content in the buffer.\n+                readChunk = stringLength < (bufferLength - bufferOffset) ? stringLength : bufferLength - bufferOffset;\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                if (stringLength == readChunk)\n+                {\n+                    // if the string is fits in the buffer, then cast to string without using string builder.\n+                    return new string(charBuffer, 0, charRead);\n+                }\n+                else\n+                {\n+                    cachedBuilder ??= new StringBuilder();\n+                    cachedBuilder.Append(charBuffer, 0, charRead);\n+                }\n+            }\n+\n+            cachedBuilder ??= new StringBuilder();\n+            stringOffsetPos += readChunk;\n+\n+            do\n+            {\n+                // Read up to bufferCapacity;\n+                readChunk = Math.Min(stringLength - stringOffsetPos, bufferCapacity);\n+                FillBuffer(readChunk);\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                cachedBuilder.Append(charBuffer, 0, charRead);\n+                stringOffsetPos += readChunk;\n+            } while (stringOffsetPos < stringLength);\n+\n+            string result = cachedBuilder.ToString();\n+            cachedBuilder.Clear();\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads an 8-byte signed integer.\n+        /// </summary>\n+        /// <returns></returns>\n+        public long ReadInt64()",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added note that it is from BCL.  I will need to check with the Endian, I believe the test will catch the issue on MacOS.",
              "createdAt": "2024-08-20T20:44:13Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new Exception();\n+            }\n+\n+            if (charBuffer == null)\n+            {\n+                charBuffer = new char[bufferCapacity + 1];\n+            }\n+\n+            int charRead = 0;\n+\n+            if (bufferLength > 0)\n+            {\n+                // Read content in the buffer.\n+                readChunk = stringLength < (bufferLength - bufferOffset) ? stringLength : bufferLength - bufferOffset;\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                if (stringLength == readChunk)\n+                {\n+                    // if the string is fits in the buffer, then cast to string without using string builder.\n+                    return new string(charBuffer, 0, charRead);\n+                }\n+                else\n+                {\n+                    cachedBuilder ??= new StringBuilder();\n+                    cachedBuilder.Append(charBuffer, 0, charRead);\n+                }\n+            }\n+\n+            cachedBuilder ??= new StringBuilder();\n+            stringOffsetPos += readChunk;\n+\n+            do\n+            {\n+                // Read up to bufferCapacity;\n+                readChunk = Math.Min(stringLength - stringOffsetPos, bufferCapacity);\n+                FillBuffer(readChunk);\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                cachedBuilder.Append(charBuffer, 0, charRead);\n+                stringOffsetPos += readChunk;\n+            } while (stringOffsetPos < stringLength);\n+\n+            string result = cachedBuilder.ToString();\n+            cachedBuilder.Clear();\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads an 8-byte signed integer.\n+        /// </summary>\n+        /// <returns></returns>\n+        public long ReadInt64()",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "Looks like endian doesn't matter as it is all little endian regardless of MacOS.  The binary writer should need be mindful to convert to little endian.",
              "createdAt": "2024-08-24T00:40:17Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,444 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[]? charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new Exception();\n+            }\n+\n+            if (charBuffer == null)\n+            {\n+                charBuffer = new char[bufferCapacity + 1];\n+            }\n+\n+            int charRead = 0;\n+\n+            if (bufferLength > 0)\n+            {\n+                // Read content in the buffer.\n+                readChunk = stringLength < (bufferLength - bufferOffset) ? stringLength : bufferLength - bufferOffset;\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                if (stringLength == readChunk)\n+                {\n+                    // if the string is fits in the buffer, then cast to string without using string builder.\n+                    return new string(charBuffer, 0, charRead);\n+                }\n+                else\n+                {\n+                    cachedBuilder ??= new StringBuilder();\n+                    cachedBuilder.Append(charBuffer, 0, charRead);\n+                }\n+            }\n+\n+            cachedBuilder ??= new StringBuilder();\n+            stringOffsetPos += readChunk;\n+\n+            do\n+            {\n+                // Read up to bufferCapacity;\n+                readChunk = Math.Min(stringLength - stringOffsetPos, bufferCapacity);\n+                FillBuffer(readChunk);\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                cachedBuilder.Append(charBuffer, 0, charRead);\n+                stringOffsetPos += readChunk;\n+            } while (stringOffsetPos < stringLength);\n+\n+            string result = cachedBuilder.ToString();\n+            cachedBuilder.Clear();\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads an 8-byte signed integer.\n+        /// </summary>\n+        /// <returns></returns>\n+        public long ReadInt64()",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        throw new ArgumentException(nameof(value), \"non-negative value expected.\");\r\n```",
              "createdAt": "2024-08-21T09:31:46Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,491 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferCapacity must be large enough for an BulkRead7BitEncodedInt operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+            charBuffer = new char[bufferCapacity + 1];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please add the permalink to runtime code as well",
              "createdAt": "2024-08-21T09:37:21Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,491 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferCapacity must be large enough for an BulkRead7BitEncodedInt operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+            charBuffer = new char[bufferCapacity + 1];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added.",
              "createdAt": "2024-08-23T03:17:00Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,491 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferCapacity must be large enough for an BulkRead7BitEncodedInt operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+            charBuffer = new char[bufferCapacity + 1];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Themagic num,ber should be explained",
              "createdAt": "2024-08-21T09:42:29Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,491 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferCapacity must be large enough for an BulkRead7BitEncodedInt operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+            charBuffer = new char[bufferCapacity + 1];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[] charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new FormatException();\n+            }\n+\n+            int charRead = 0;\n+\n+            if (bufferLength > 0)\n+            {\n+                // Read content in the buffer.\n+                readChunk = stringLength < (bufferLength - bufferOffset) ? stringLength : bufferLength - bufferOffset;\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                if (stringLength == readChunk)\n+                {\n+                    // if the string is fits in the buffer, then cast to string without using string builder.\n+                    return new string(charBuffer, 0, charRead);\n+                }\n+                else\n+                {\n+                    cachedBuilder ??= new StringBuilder();\n+                    cachedBuilder.Append(charBuffer, 0, charRead);\n+                }\n+            }\n+\n+            cachedBuilder ??= new StringBuilder();\n+            stringOffsetPos += readChunk;\n+\n+            do\n+            {\n+                // Read up to bufferCapacity;\n+                readChunk = Math.Min(stringLength - stringOffsetPos, bufferCapacity);\n+                FillBuffer(readChunk);\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                cachedBuilder.Append(charBuffer, 0, charRead);\n+                stringOffsetPos += readChunk;\n+            } while (stringOffsetPos < stringLength);\n+\n+            string result = cachedBuilder.ToString();\n+            cachedBuilder.Clear();\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads an 8-byte signed integer.\n+        /// </summary>\n+        /// <returns></returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>\n+        public long ReadInt64()\n+        {\n+            FillBuffer(8);\n+            uint lo = (uint)(buffer[bufferOffset + 0] | buffer[bufferOffset + 1] << 8 |\n+                             buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            uint hi = (uint)(buffer[bufferOffset + 4] | buffer[bufferOffset + 5] << 8 |\n+                             buffer[bufferOffset + 6] << 16 | buffer[bufferOffset + 7] << 24);\n+            var result = (long)((ulong)hi) << 32 | lo;\n+            bufferOffset += 8;\n+            baseStreamPosition += 8;\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads a Boolean value.\n+        /// </summary>\n+        /// <returns>true if the byte is nonzero; otherwise, false.</returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>\n+        public bool ReadBoolean()\n+        {\n+            FillBuffer(1);\n+            var result = (buffer[bufferOffset] != 0);\n+            bufferOffset++;\n+            baseStreamPosition++;\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads the specified number of bytes into a new byte array.\n+        /// </summary>\n+        /// <param name=\"count\">The number of bytes to read.</param>\n+        /// <returns>A byte array containing data read.</returns>\n+        public byte[] ReadBytes(int count)\n+        {\n+            if (count == 0)\n+            {\n+                return Array.Empty<byte>();\n+            }\n+\n+            FillBuffer(count);\n+            if (bufferLength == 0)\n+            {\n+                return Array.Empty<byte>();\n+            }\n+\n+            // Avoid an allocation if the current buffer is large enough.\n+            // Except if the allocation is 16 byte because GUID requires exactly 16 byte array.\n+            byte[] result;\n+            if (count < this.bufferCapacity)\n+            {\n+                if (this.bufferOffset > 0)\n+                {\n+                    // content to the start of the buffer.\n+                    LoadBuffer();\n+                }\n+\n+                result = this.buffer;\n+            }\n+            else\n+            {\n+                result = new byte[count];\n+            }\n+\n+            Array.Copy(buffer, bufferOffset, result, 0, count);\n+            bufferOffset += count;\n+            baseStreamPosition += count;\n+            return result;\n+        }\n+\n+        private byte[] resultGuidBytes = new byte[16];\n+\n+        /// <summary>\n+        /// Read a 16 bytes that represents a GUID.\n+        /// </summary>\n+        /// <returns>A byte array containing a GUID.</returns>\n+        public byte[] ReadGuid()\n+        {\n+            const int guidCount = 16;\n+            FillBuffer(16);\n+            Array.Copy(buffer, bufferOffset, resultGuidBytes, 0, guidCount);\n+            bufferOffset += guidCount;\n+            baseStreamPosition += guidCount;\n+\n+            return resultGuidBytes;\n+        }\n+\n+        /// <summary>\n+        /// Reads the next byte.\n+        /// </summary>\n+        /// <returns>A byte.</returns>\n+        public byte ReadByte()\n+        {\n+            FillBuffer(1);\n+            return InternalReadByte();\n+        }\n+\n+        /// <summary>\n+        /// Reads in a 32-bit integer in compressed format.\n+        /// </summary>\n+        /// <returns>A 32-bit integer.</returns>\n+        public int Read7BitEncodedInt()\n+        {\n+            FillBuffer(5, throwOnEOF: false);\n+            // Read out an Int32 7 bits at a time.  The high bit\n+            // of the byte when on means to continue reading more bytes.\n+            int count = 0;\n+            int shift = 0;\n+            byte b;\n+            do\n+            {\n+                // Check for a corrupted stream.  Read a max of 5 bytes.\n+                // In a future version, add a DataFormatException.\n+                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7\n+                {\n+                    throw new FormatException();\n+                }\n+\n+                b = InternalReadByte();\n+                count |= (b & 0x7F) << shift;\n+                shift += 7;\n+            } while ((b & 0x80) != 0);\n+\n+            return count;\n+        }\n+\n+        public const int MaxBulkRead7BitLength = 10;\n+        private int[] resultInt = new int[MaxBulkRead7BitLength];\n+\n+        /// <summary>\n+        /// An optimized bulk read of many continuous 7BitEncodedInt.\n+        /// </summary>\n+        /// <param name=\"numIntegers\">Number of 7BitEncodedInt to read up to <see cref=\"MaxBulkRead7BitLength\"/>.</param>\n+        /// <returns>An array of Integers with the results.</returns>\n+        /// <remarks>This will reuse the same array for results to avoid extra allocations.</remarks>\n+        public int[] BulkRead7BitEncodedInt(int numIntegers)\n+        {\n+            if (numIntegers > MaxBulkRead7BitLength)\n+            {\n+                throw new ArgumentOutOfRangeException();\n+            }\n+\n+            FillBuffer(5 * numIntegers, throwOnEOF: false);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Add comment about `5`.",
              "createdAt": "2024-08-23T03:16:51Z",
              "path": "src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs",
              "diffHunk": "@@ -0,0 +1,491 @@\n+\ufeffusing System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+using Microsoft.Build.Framework.Logging;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class combines BinaryReader and BufferedStream by pre-reading and inlining ReadBytes().\n+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead\n+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.\n+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.\n+    /// Use the Slice() method to create a new stream.\n+    /// </remarks>\n+    internal class BufferedBinaryReader : IBinaryReader\n+    {\n+        private Stream baseStream;\n+        private long baseStreamPosition = 0;  // virtual Position of the base stream.\n+        private long maxAllowedPosition = long.MaxValue;\n+        private int bufferCapacity;\n+        private byte[] buffer;\n+        private int bufferOffset = 0;\n+        private int bufferLength = 0;\n+        private Encoding encoding;\n+\n+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)\n+        {\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            baseStream = stream;\n+            this.bufferCapacity = bufferCapacity;  // Note: bufferCapacity must be large enough for an BulkRead7BitEncodedInt operation.\n+            this.encoding = encoding ?? new UTF8Encoding();\n+            buffer = new byte[this.bufferCapacity];\n+            charBuffer = new char[bufferCapacity + 1];\n+        }\n+\n+        /// <summary>\n+        /// Position of the base stream.\n+        /// </summary>\n+        public long Position => baseStreamPosition;\n+\n+        /// <summary>\n+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.\n+        /// </summary>\n+        public int? BytesCountAllowedToRead\n+        {\n+            set\n+            {\n+                if (value.HasValue)\n+                {\n+                    if (value.Value < 0)\n+                    {\n+                        throw new Exception();\n+                    }\n+\n+                    maxAllowedPosition = baseStreamPosition + value.Value;\n+                }\n+                else\n+                {\n+                    maxAllowedPosition = long.MaxValue;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// If <see cref=\"BytesCountAllowedToRead\"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.\n+        /// </summary>\n+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);\n+\n+        /// <summary>\n+        /// Reads a 32-bit signed integer.\n+        /// </summary>\n+        /// <returns>Return a integer.</returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>\n+        public int ReadInt32()\n+        {\n+            FillBuffer(4);\n+\n+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            bufferOffset += 4;\n+            baseStreamPosition += 4;\n+            return result;\n+        }\n+\n+        // Reusable StringBuilder for ReadString().\n+        private StringBuilder? cachedBuilder;\n+\n+        // Reusable char[] for ReadString().\n+        private char[] charBuffer;\n+\n+        /// <summary>\n+        /// Reads a string with a prefixed of the length.\n+        /// </summary>\n+        /// <returns>A string.</returns>\n+        public string ReadString()\n+        {\n+            int stringLength = Read7BitEncodedInt();\n+            int stringOffsetPos = 0;\n+            int readChunk = 0;\n+\n+            if (stringLength == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            if (stringLength < 0)\n+            {\n+                throw new FormatException();\n+            }\n+\n+            int charRead = 0;\n+\n+            if (bufferLength > 0)\n+            {\n+                // Read content in the buffer.\n+                readChunk = stringLength < (bufferLength - bufferOffset) ? stringLength : bufferLength - bufferOffset;\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                if (stringLength == readChunk)\n+                {\n+                    // if the string is fits in the buffer, then cast to string without using string builder.\n+                    return new string(charBuffer, 0, charRead);\n+                }\n+                else\n+                {\n+                    cachedBuilder ??= new StringBuilder();\n+                    cachedBuilder.Append(charBuffer, 0, charRead);\n+                }\n+            }\n+\n+            cachedBuilder ??= new StringBuilder();\n+            stringOffsetPos += readChunk;\n+\n+            do\n+            {\n+                // Read up to bufferCapacity;\n+                readChunk = Math.Min(stringLength - stringOffsetPos, bufferCapacity);\n+                FillBuffer(readChunk);\n+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);\n+                bufferOffset += readChunk;\n+                baseStreamPosition += readChunk;\n+                cachedBuilder.Append(charBuffer, 0, charRead);\n+                stringOffsetPos += readChunk;\n+            } while (stringOffsetPos < stringLength);\n+\n+            string result = cachedBuilder.ToString();\n+            cachedBuilder.Clear();\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads an 8-byte signed integer.\n+        /// </summary>\n+        /// <returns></returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>\n+        public long ReadInt64()\n+        {\n+            FillBuffer(8);\n+            uint lo = (uint)(buffer[bufferOffset + 0] | buffer[bufferOffset + 1] << 8 |\n+                             buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);\n+            uint hi = (uint)(buffer[bufferOffset + 4] | buffer[bufferOffset + 5] << 8 |\n+                             buffer[bufferOffset + 6] << 16 | buffer[bufferOffset + 7] << 24);\n+            var result = (long)((ulong)hi) << 32 | lo;\n+            bufferOffset += 8;\n+            baseStreamPosition += 8;\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads a Boolean value.\n+        /// </summary>\n+        /// <returns>true if the byte is nonzero; otherwise, false.</returns>\n+        /// <remarks>Logic copied from BCL BinaryReader.</remarks>\n+        public bool ReadBoolean()\n+        {\n+            FillBuffer(1);\n+            var result = (buffer[bufferOffset] != 0);\n+            bufferOffset++;\n+            baseStreamPosition++;\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Reads the specified number of bytes into a new byte array.\n+        /// </summary>\n+        /// <param name=\"count\">The number of bytes to read.</param>\n+        /// <returns>A byte array containing data read.</returns>\n+        public byte[] ReadBytes(int count)\n+        {\n+            if (count == 0)\n+            {\n+                return Array.Empty<byte>();\n+            }\n+\n+            FillBuffer(count);\n+            if (bufferLength == 0)\n+            {\n+                return Array.Empty<byte>();\n+            }\n+\n+            // Avoid an allocation if the current buffer is large enough.\n+            // Except if the allocation is 16 byte because GUID requires exactly 16 byte array.\n+            byte[] result;\n+            if (count < this.bufferCapacity)\n+            {\n+                if (this.bufferOffset > 0)\n+                {\n+                    // content to the start of the buffer.\n+                    LoadBuffer();\n+                }\n+\n+                result = this.buffer;\n+            }\n+            else\n+            {\n+                result = new byte[count];\n+            }\n+\n+            Array.Copy(buffer, bufferOffset, result, 0, count);\n+            bufferOffset += count;\n+            baseStreamPosition += count;\n+            return result;\n+        }\n+\n+        private byte[] resultGuidBytes = new byte[16];\n+\n+        /// <summary>\n+        /// Read a 16 bytes that represents a GUID.\n+        /// </summary>\n+        /// <returns>A byte array containing a GUID.</returns>\n+        public byte[] ReadGuid()\n+        {\n+            const int guidCount = 16;\n+            FillBuffer(16);\n+            Array.Copy(buffer, bufferOffset, resultGuidBytes, 0, guidCount);\n+            bufferOffset += guidCount;\n+            baseStreamPosition += guidCount;\n+\n+            return resultGuidBytes;\n+        }\n+\n+        /// <summary>\n+        /// Reads the next byte.\n+        /// </summary>\n+        /// <returns>A byte.</returns>\n+        public byte ReadByte()\n+        {\n+            FillBuffer(1);\n+            return InternalReadByte();\n+        }\n+\n+        /// <summary>\n+        /// Reads in a 32-bit integer in compressed format.\n+        /// </summary>\n+        /// <returns>A 32-bit integer.</returns>\n+        public int Read7BitEncodedInt()\n+        {\n+            FillBuffer(5, throwOnEOF: false);\n+            // Read out an Int32 7 bits at a time.  The high bit\n+            // of the byte when on means to continue reading more bytes.\n+            int count = 0;\n+            int shift = 0;\n+            byte b;\n+            do\n+            {\n+                // Check for a corrupted stream.  Read a max of 5 bytes.\n+                // In a future version, add a DataFormatException.\n+                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7\n+                {\n+                    throw new FormatException();\n+                }\n+\n+                b = InternalReadByte();\n+                count |= (b & 0x7F) << shift;\n+                shift += 7;\n+            } while ((b & 0x80) != 0);\n+\n+            return count;\n+        }\n+\n+        public const int MaxBulkRead7BitLength = 10;\n+        private int[] resultInt = new int[MaxBulkRead7BitLength];\n+\n+        /// <summary>\n+        /// An optimized bulk read of many continuous 7BitEncodedInt.\n+        /// </summary>\n+        /// <param name=\"numIntegers\">Number of 7BitEncodedInt to read up to <see cref=\"MaxBulkRead7BitLength\"/>.</param>\n+        /// <returns>An array of Integers with the results.</returns>\n+        /// <remarks>This will reuse the same array for results to avoid extra allocations.</remarks>\n+        public int[] BulkRead7BitEncodedInt(int numIntegers)\n+        {\n+            if (numIntegers > MaxBulkRead7BitLength)\n+            {\n+                throw new ArgumentOutOfRangeException();\n+            }\n+\n+            FillBuffer(5 * numIntegers, throwOnEOF: false);",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be `unchecked` then if negative numbers can be expected?",
              "createdAt": "2024-08-21T09:44:47Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1033,15 +1034,34 @@ private void WriteProperties(IEnumerable properties)\n             nameValueListBuffer.Clear();\n         }\n \n+        private byte[] buildEventContextBuffer = new byte[5 * 7];\n+\n         private void Write(BuildEventContext buildEventContext)\n         {\n-            Write(buildEventContext.NodeId);\n-            Write(buildEventContext.ProjectContextId);\n-            Write(buildEventContext.TargetId);\n-            Write(buildEventContext.TaskId);\n-            Write(buildEventContext.SubmissionId);\n-            Write(buildEventContext.ProjectInstanceId);\n-            Write(buildEventContext.EvaluationId);\n+            int index = 0;\n+            Span<int> ints =\n+            [\n+                buildEventContext.NodeId,\n+                buildEventContext.ProjectContextId,\n+                buildEventContext.TargetId,\n+                buildEventContext.TaskId,\n+                buildEventContext.SubmissionId,\n+                buildEventContext.ProjectInstanceId,\n+                buildEventContext.EvaluationId,\n+            ];\n+\n+            foreach(int num in ints)\n+            {\n+                uint v = (uint)num;   // support negative numbers",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "What is `unchecked`?\r\n\r\nThe code is correct as it casts a negative numbers to a big numbers unsigned number.",
              "createdAt": "2024-08-23T03:07:35Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1033,15 +1034,34 @@ private void WriteProperties(IEnumerable properties)\n             nameValueListBuffer.Clear();\n         }\n \n+        private byte[] buildEventContextBuffer = new byte[5 * 7];\n+\n         private void Write(BuildEventContext buildEventContext)\n         {\n-            Write(buildEventContext.NodeId);\n-            Write(buildEventContext.ProjectContextId);\n-            Write(buildEventContext.TargetId);\n-            Write(buildEventContext.TaskId);\n-            Write(buildEventContext.SubmissionId);\n-            Write(buildEventContext.ProjectInstanceId);\n-            Write(buildEventContext.EvaluationId);\n+            int index = 0;\n+            Span<int> ints =\n+            [\n+                buildEventContext.NodeId,\n+                buildEventContext.ProjectContextId,\n+                buildEventContext.TargetId,\n+                buildEventContext.TaskId,\n+                buildEventContext.SubmissionId,\n+                buildEventContext.ProjectInstanceId,\n+                buildEventContext.EvaluationId,\n+            ];\n+\n+            foreach(int num in ints)\n+            {\n+                uint v = (uint)num;   // support negative numbers",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This code needs explaining comment.",
              "createdAt": "2024-08-21T09:45:12Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1033,15 +1034,34 @@ private void WriteProperties(IEnumerable properties)\n             nameValueListBuffer.Clear();\n         }\n \n+        private byte[] buildEventContextBuffer = new byte[5 * 7];\n+\n         private void Write(BuildEventContext buildEventContext)\n         {\n-            Write(buildEventContext.NodeId);\n-            Write(buildEventContext.ProjectContextId);\n-            Write(buildEventContext.TargetId);\n-            Write(buildEventContext.TaskId);\n-            Write(buildEventContext.SubmissionId);\n-            Write(buildEventContext.ProjectInstanceId);\n-            Write(buildEventContext.EvaluationId);\n+            int index = 0;\n+            Span<int> ints =\n+            [\n+                buildEventContext.NodeId,\n+                buildEventContext.ProjectContextId,\n+                buildEventContext.TargetId,\n+                buildEventContext.TaskId,\n+                buildEventContext.SubmissionId,\n+                buildEventContext.ProjectInstanceId,\n+                buildEventContext.EvaluationId,\n+            ];\n+\n+            foreach(int num in ints)\n+            {\n+                uint v = (uint)num;   // support negative numbers\n+                while (v >= 0x80)\n+                {\n+                    buildEventContextBuffer[index++] = (byte)(v | 0x80);\n+                    v >>= 7;\n+                }\n+\n+                buildEventContextBuffer[index++] = (byte)v;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Should this actually call the implementation in BinaryWriterExtensions or is there a reason for code duplication?",
              "createdAt": "2024-08-21T09:46:57Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1033,15 +1034,34 @@ private void WriteProperties(IEnumerable properties)\n             nameValueListBuffer.Clear();\n         }\n \n+        private byte[] buildEventContextBuffer = new byte[5 * 7];\n+\n         private void Write(BuildEventContext buildEventContext)\n         {\n-            Write(buildEventContext.NodeId);\n-            Write(buildEventContext.ProjectContextId);\n-            Write(buildEventContext.TargetId);\n-            Write(buildEventContext.TaskId);\n-            Write(buildEventContext.SubmissionId);\n-            Write(buildEventContext.ProjectInstanceId);\n-            Write(buildEventContext.EvaluationId);\n+            int index = 0;\n+            Span<int> ints =\n+            [\n+                buildEventContext.NodeId,\n+                buildEventContext.ProjectContextId,\n+                buildEventContext.TargetId,\n+                buildEventContext.TaskId,\n+                buildEventContext.SubmissionId,\n+                buildEventContext.ProjectInstanceId,\n+                buildEventContext.EvaluationId,\n+            ];\n+\n+            foreach(int num in ints)\n+            {\n+                uint v = (uint)num;   // support negative numbers\n+                while (v >= 0x80)\n+                {\n+                    buildEventContextBuffer[index++] = (byte)(v | 0x80);\n+                    v >>= 7;\n+                }\n+\n+                buildEventContextBuffer[index++] = (byte)v;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I modify this function to write to a byte array before writing to the stream.  This reduces 7 stream writes to 1 write.\r\n\r\nThis using 7bit encoding while the calls in BinaryWriterExtensions is using 4bytes Int32.  These two function are not compatible with each other.  You might have more history as to why this is the case.",
              "createdAt": "2024-08-23T03:03:31Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1033,15 +1034,34 @@ private void WriteProperties(IEnumerable properties)\n             nameValueListBuffer.Clear();\n         }\n \n+        private byte[] buildEventContextBuffer = new byte[5 * 7];\n+\n         private void Write(BuildEventContext buildEventContext)\n         {\n-            Write(buildEventContext.NodeId);\n-            Write(buildEventContext.ProjectContextId);\n-            Write(buildEventContext.TargetId);\n-            Write(buildEventContext.TaskId);\n-            Write(buildEventContext.SubmissionId);\n-            Write(buildEventContext.ProjectInstanceId);\n-            Write(buildEventContext.EvaluationId);\n+            int index = 0;\n+            Span<int> ints =\n+            [\n+                buildEventContext.NodeId,\n+                buildEventContext.ProjectContextId,\n+                buildEventContext.TargetId,\n+                buildEventContext.TaskId,\n+                buildEventContext.SubmissionId,\n+                buildEventContext.ProjectInstanceId,\n+                buildEventContext.EvaluationId,\n+            ];\n+\n+            foreach(int num in ints)\n+            {\n+                uint v = (uint)num;   // support negative numbers\n+                while (v >= 0x80)\n+                {\n+                    buildEventContextBuffer[index++] = (byte)(v | 0x80);\n+                    v >>= 7;\n+                }\n+\n+                buildEventContextBuffer[index++] = (byte)v;",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can be removed",
              "createdAt": "2024-08-21T09:48:28Z",
              "path": "src/Shared/BinaryWriterExtensions.cs",
              "diffHunk": "@@ -67,6 +86,7 @@ public static void Write7BitEncodedInt(this BinaryWriter writer, int value)\n             }\n \n             writer.Write((byte)v);\n+            return;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}