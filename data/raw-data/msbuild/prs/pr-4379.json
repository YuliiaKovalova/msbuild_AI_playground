{
  "number": 4379,
  "title": "[Static graph] Ability to skip isolation constraints certain references",
  "body": "Projects can now skip static graph constraint checks on certain references by declaring an item, `ReferencesToSkipGraphIsolationConstraintsOn`, which contains wildcards matching the full path of the references they want excluded. This allows static graph to build WPF projects, which generate and build an undeclared project with a random name at build time.\r\n\r\nThis PR is based on #4327. Relevant commits start with 91db31c",
  "state": "MERGED",
  "createdAt": "2019-05-17T00:56:30Z",
  "updatedAt": "2020-12-30T22:53:49Z",
  "closedAt": "2019-06-11T22:35:15Z",
  "mergedAt": "2019-06-11T22:35:15Z",
  "additions": 710,
  "deletions": 182,
  "changedFiles": 32,
  "headRefName": "wpfIsolation",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "efc6a80dd6f674243c812e65c42dda5f11960299",
          "message": "Rename",
          "committedDate": "2019-06-05T21:17:14Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6aa588d6c98f013ff097371423ed85cd4d15cb6f",
          "message": "Ability to skip isolation constraints on references",
          "committedDate": "2019-06-10T22:25:28Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@cdmihai let's wait for https://github.com/microsoft/msbuild/pull/4327 to get merged and then we can review this one.",
        "createdAt": "2019-05-21T20:05:52Z",
        "author": {
          "login": "livarcocc"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "@danmosemsft \r\nCopied from https://github.com/microsoft/msbuild/pull/4407#discussion_r288699254\r\n> Is this perf sensitive code? Historically we kept LINQ out of the codebase, or at least out of perf sensitive places. It tends to have hidden costs.\r\n",
              "createdAt": "2019-05-30T17:39:29Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -710,6 +714,47 @@ public List<string> GetAfterTargetsForDefaultTargets(BuildRequest request)\n             return null;\n         }\n \n+        private Func<string, bool> shouldSkipStaticGraphIsolationOnReference;\n+\n+        public bool ShouldSkipIsolationConstraintsForReference(string referenceFullPath)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(Project, nameof(Project));\n+            ErrorUtilities.VerifyThrowInternalLength(referenceFullPath, nameof(referenceFullPath));\n+            ErrorUtilities.VerifyThrow(Path.IsPathRooted(referenceFullPath), \"Method does not treat path normalization cases\");\n+\n+            if (shouldSkipStaticGraphIsolationOnReference == null)\n+            {\n+                shouldSkipStaticGraphIsolationOnReference = GetReferenceFilter();\n+            }\n+\n+            return shouldSkipStaticGraphIsolationOnReference(referenceFullPath);\n+\n+            Func<string, bool> GetReferenceFilter()\n+            {\n+                lock (_syncLock)\n+                {\n+                    if (shouldSkipStaticGraphIsolationOnReference != null)\n+                    {\n+                        return shouldSkipStaticGraphIsolationOnReference;\n+                    }\n+\n+                    var items = Project.GetItems(ItemTypeNames.ReferencesToSkipGraphIsolationConstraintsOn);\n+\n+                    if (items.Count == 0 || items.All(i => string.IsNullOrWhiteSpace(i.EvaluatedInclude)))\n+                    {\n+                        return _ => false;\n+                    }\n+\n+                    var fragments = items.SelectMany(i => ExpressionShredder.SplitSemiColonSeparatedList(i.EvaluatedInclude));\n+                    var glob = new CompositeGlob(\n+                        fragments\n+                            .Select(s => MSBuildGlob.Parse(Project.Directory, s)));",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I think the extra boost to readability is worth it over the perf impact. The glob parsing is way more expensive than the link operation, and the code executes only once per BuildRequestConfiguration.",
              "createdAt": "2019-05-30T17:40:42Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -710,6 +714,47 @@ public List<string> GetAfterTargetsForDefaultTargets(BuildRequest request)\n             return null;\n         }\n \n+        private Func<string, bool> shouldSkipStaticGraphIsolationOnReference;\n+\n+        public bool ShouldSkipIsolationConstraintsForReference(string referenceFullPath)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(Project, nameof(Project));\n+            ErrorUtilities.VerifyThrowInternalLength(referenceFullPath, nameof(referenceFullPath));\n+            ErrorUtilities.VerifyThrow(Path.IsPathRooted(referenceFullPath), \"Method does not treat path normalization cases\");\n+\n+            if (shouldSkipStaticGraphIsolationOnReference == null)\n+            {\n+                shouldSkipStaticGraphIsolationOnReference = GetReferenceFilter();\n+            }\n+\n+            return shouldSkipStaticGraphIsolationOnReference(referenceFullPath);\n+\n+            Func<string, bool> GetReferenceFilter()\n+            {\n+                lock (_syncLock)\n+                {\n+                    if (shouldSkipStaticGraphIsolationOnReference != null)\n+                    {\n+                        return shouldSkipStaticGraphIsolationOnReference;\n+                    }\n+\n+                    var items = Project.GetItems(ItemTypeNames.ReferencesToSkipGraphIsolationConstraintsOn);\n+\n+                    if (items.Count == 0 || items.All(i => string.IsNullOrWhiteSpace(i.EvaluatedInclude)))\n+                    {\n+                        return _ => false;\n+                    }\n+\n+                    var fragments = items.SelectMany(i => ExpressionShredder.SplitSemiColonSeparatedList(i.EvaluatedInclude));\n+                    var glob = new CompositeGlob(\n+                        fragments\n+                            .Select(s => MSBuildGlob.Parse(Project.Directory, s)));",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@danmosemsft \r\nCopied from https://github.com/microsoft/msbuild/pull/4407#pullrequestreview-243428925\r\n> I think the other messages put \" around paths.\r\n\r\n",
              "createdAt": "2019-05-30T17:43:03Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1763,13 +1763,19 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} is a file path\n     </comment>\n   </data>\n+  <data name=\"SkippedConstraintsOnRequest\" UESanitized=\"false\" Visibility=\"Public\">\n+    <value>MSB4260: Project {0} skipped graph isolation constraints on referenced project {1}</value>",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: should these have distinct strings?",
              "createdAt": "2019-06-05T22:27:12Z",
              "path": "src/Build.UnitTests/Graph/IsolateProjects_Tests.cs",
              "diffHunk": "@@ -54,17 +58,67 @@ public class IsolateProjectsTests\n \n                     <Target Name='SelfTarget'>\n                     </Target>\n+\n+                    <UsingTask TaskName='CustomMSBuild' TaskFactory='RoslynCodeTaskFactory' AssemblyFile='$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll'>\n+                        <ParameterGroup>\n+                          <Projects ParameterType='Microsoft.Build.Framework.ITaskItem[]' Required='true' />\n+                          <Targets ParameterType='Microsoft.Build.Framework.ITaskItem[]' Required='true' />\n+                        </ParameterGroup>\n+                        <Task>\n+                          <Code Type='Fragment' Language='cs'>\n+                    <![CDATA[\n+\n+var projects = new string[Projects.Length];\n+var globalProperties = new IDictionary[Projects.Length];\n+var toolsVersions = new string[Projects.Length];\n+\n+for (var i = 0; i < Projects.Length; i++)\n+{{\n+  projects[i] = Projects[i].ItemSpec;\n+  globalProperties[i] = new Dictionary<string, string>();\n+  toolsVersions[i] = \"\"Current\"\";\n+}}\n+\n+var targets = new string[Targets.Length];\n+for (var i = 0; i < Targets.Length; i++)\n+{{\n+  targets[i] = Targets[i].ItemSpec;\n+}}\n+\n+BuildEngine5.BuildProjectFilesInParallel(\n+  projects,\n+  targets,\n+  globalProperties,\n+  null,\n+  toolsVersions,\n+  false,\n+  false\n+  );\n+]]>\n+                          </Code>\n+                        </Task>\n+                    </UsingTask>\n+\n+                    <Target Name='BuildDeclaredReferenceViaTask'>\n+                        <CustomMSBuild Projects='{1}' Targets='DeclaredReferenceTarget'/>\n+                    </Target>\n+\n+                    <Target Name='BuildUndeclaredReferenceViaTask'>\n+                        <CustomMSBuild Projects='{2}' Targets='UndeclaredReferenceTarget'/>\n+                    </Target>\n                 </Project>\";\n \n         private readonly string _declaredReference = @\"\n                 <Project>\n                     <Target Name='DeclaredReferenceTarget'>\n+                        <Message Text='Message from reference' Importance='High' />\n                     </Target>\n                 </Project>\";\n \n         private readonly string _undeclaredReference = @\"\n                 <Project>\n                     <Target Name='UndeclaredReferenceTarget'>\n+                        <Message Text='Message from reference' Importance='High' />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "ah, I see below that they must not",
              "createdAt": "2019-06-05T22:27:44Z",
              "path": "src/Build.UnitTests/Graph/IsolateProjects_Tests.cs",
              "diffHunk": "@@ -54,17 +58,67 @@ public class IsolateProjectsTests\n \n                     <Target Name='SelfTarget'>\n                     </Target>\n+\n+                    <UsingTask TaskName='CustomMSBuild' TaskFactory='RoslynCodeTaskFactory' AssemblyFile='$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll'>\n+                        <ParameterGroup>\n+                          <Projects ParameterType='Microsoft.Build.Framework.ITaskItem[]' Required='true' />\n+                          <Targets ParameterType='Microsoft.Build.Framework.ITaskItem[]' Required='true' />\n+                        </ParameterGroup>\n+                        <Task>\n+                          <Code Type='Fragment' Language='cs'>\n+                    <![CDATA[\n+\n+var projects = new string[Projects.Length];\n+var globalProperties = new IDictionary[Projects.Length];\n+var toolsVersions = new string[Projects.Length];\n+\n+for (var i = 0; i < Projects.Length; i++)\n+{{\n+  projects[i] = Projects[i].ItemSpec;\n+  globalProperties[i] = new Dictionary<string, string>();\n+  toolsVersions[i] = \"\"Current\"\";\n+}}\n+\n+var targets = new string[Targets.Length];\n+for (var i = 0; i < Targets.Length; i++)\n+{{\n+  targets[i] = Targets[i].ItemSpec;\n+}}\n+\n+BuildEngine5.BuildProjectFilesInParallel(\n+  projects,\n+  targets,\n+  globalProperties,\n+  null,\n+  toolsVersions,\n+  false,\n+  false\n+  );\n+]]>\n+                          </Code>\n+                        </Task>\n+                    </UsingTask>\n+\n+                    <Target Name='BuildDeclaredReferenceViaTask'>\n+                        <CustomMSBuild Projects='{1}' Targets='DeclaredReferenceTarget'/>\n+                    </Target>\n+\n+                    <Target Name='BuildUndeclaredReferenceViaTask'>\n+                        <CustomMSBuild Projects='{2}' Targets='UndeclaredReferenceTarget'/>\n+                    </Target>\n                 </Project>\";\n \n         private readonly string _declaredReference = @\"\n                 <Project>\n                     <Target Name='DeclaredReferenceTarget'>\n+                        <Message Text='Message from reference' Importance='High' />\n                     </Target>\n                 </Project>\";\n \n         private readonly string _undeclaredReference = @\"\n                 <Project>\n                     <Target Name='UndeclaredReferenceTarget'>\n+                        <Message Text='Message from reference' Importance='High' />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why checked in but commented out?",
              "createdAt": "2019-06-05T22:28:25Z",
              "path": "src/Build.UnitTests/Graph/IsolateProjects_Tests.cs",
              "diffHunk": "@@ -143,11 +246,13 @@ public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences()\n         }\n \n         [Theory]\n-        [InlineData(false)]\n-        [InlineData(true)]\n-        public void TaskEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError)\n+        [InlineData(false, \"BuildUndeclaredReference\")]\n+//        [InlineData(false, \"BuildUndeclaredReferenceViaTask\")]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "They fail due to #4385, and I don't know how to skip an InlineData. Should I just remove them?",
              "createdAt": "2019-06-06T20:41:33Z",
              "path": "src/Build.UnitTests/Graph/IsolateProjects_Tests.cs",
              "diffHunk": "@@ -143,11 +246,13 @@ public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences()\n         }\n \n         [Theory]\n-        [InlineData(false)]\n-        [InlineData(true)]\n-        public void TaskEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError)\n+        [InlineData(false, \"BuildUndeclaredReference\")]\n+//        [InlineData(false, \"BuildUndeclaredReferenceViaTask\")]",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Ah, gotcha. Just add a comment with that bug.",
              "createdAt": "2019-06-06T20:43:11Z",
              "path": "src/Build.UnitTests/Graph/IsolateProjects_Tests.cs",
              "diffHunk": "@@ -143,11 +246,13 @@ public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences()\n         }\n \n         [Theory]\n-        [InlineData(false)]\n-        [InlineData(true)]\n-        public void TaskEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError)\n+        [InlineData(false, \"BuildUndeclaredReference\")]\n+//        [InlineData(false, \"BuildUndeclaredReferenceViaTask\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why `1`?",
              "createdAt": "2019-06-06T14:26:18Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1786,72 +1788,95 @@ private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildReq\n             return null;\n         }\n \n-        private bool CheckIfCacheMissesAreAllowed(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses)\n+        /// <returns>True if caches misses are allowed, false otherwise</returns>\n+        private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses, out Action<ILoggingService> emitNonErrorLogs)\n         {\n+            emitNonErrorLogs = _ => { };\n+\n             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;\n+            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n \n             // do not check root requests as nothing depends on them\n-            if (!request.IsRootRequest && isIsolatedBuild)\n+            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)\n             {\n-                var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n-                var requestConfig = configCache[request.ConfigurationId];\n-\n-                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n-                if (parentRequest == null)\n+                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)\n                 {\n-                    // the parent might still be in executing requests because the scheduler might not have had a chance to mark it as blocked yet\n-                    parentRequest = _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+                    // retrieving the configs is not quite free, so avoid computing them eagerly\n+                    var configs = GetConfigurations();\n+\n+                    emitNonErrorLogs = ls => ls.LogComment(\n+                            NewBuildEventContext(),\n+                            MessageImportance.Normal,\n+                            \"SkippedConstraintsOnRequest\",\n+                            configs.parentConfig.ProjectFullPath,\n+                            configs.requestConfig.ProjectFullPath);\n                 }\n \n-                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n-                ErrorUtilities.VerifyThrow(\n-                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n-                    \"All non root requests should have a parent with a loaded configuration\");\n+                return true;\n+            }\n \n-                var parentConfig = configCache[parentRequest.BuildRequest.ConfigurationId];\n+            var (requestConfig, parentConfig) = GetConfigurations();\n \n-                // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n-                if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n-                {\n-                    return true;\n-                }\n+            // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n+            if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return true;\n+            }\n \n-                var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n-                    \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n-                    parentConfig.ProjectFullPath,\n-                    requestConfig.ProjectFullPath,\n-                    request.Targets.Count == 0\n-                        ? \"default\"\n-                        : string.Join(\";\", request.Targets));\n+            var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n+                \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n+                parentConfig.ProjectFullPath,\n+                requestConfig.ProjectFullPath,\n+                request.Targets.Count == 0\n+                    ? \"default\"\n+                    : string.Join(\";\", request.Targets));\n \n-                // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n-                BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n-                result.SetOverallResult(false);\n+            // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n+            BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n+            result.SetOverallResult(false);\n \n-                var response = GetResponseForResult(nodeForResults, request, result);\n-                responses.Add(response);\n+            var response = GetResponseForResult(nodeForResults, request, result);\n+            responses.Add(response);\n \n-                // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n-                // todo Search if there's a way to have the error automagically logged in response to the failed build result\n-                _componentHost.LoggingService.LogErrorFromText(\n-                    new BuildEventContext(\n-                        request.SubmissionId,\n-                        1,\n-                        BuildEventContext.InvalidProjectInstanceId,\n-                        BuildEventContext.InvalidProjectContextId,\n-                        BuildEventContext.InvalidTargetId,\n-                        BuildEventContext.InvalidTaskId),\n-                    null,\n-                    null,\n-                    null,\n-                    new BuildEventFileInfo(requestConfig.ProjectFullPath),\n-                    errorMessage);\n+            // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n+            // todo Search if there's a way to have the error automagically logged in response to the failed build result\n+            _componentHost.LoggingService.LogErrorFromText(\n+                NewBuildEventContext(),\n+                null,\n+                null,\n+                null,\n+                new BuildEventFileInfo(requestConfig.ProjectFullPath),\n+                errorMessage);\n \n-                return false;\n+            return false;\n+\n+            BuildEventContext NewBuildEventContext()\n+            {\n+                return new BuildEventContext(\n+                    request.SubmissionId,\n+                    1,\n+                    BuildEventContext.InvalidProjectInstanceId,\n+                    BuildEventContext.InvalidProjectContextId,\n+                    BuildEventContext.InvalidTargetId,\n+                    BuildEventContext.InvalidTaskId);\n             }\n \n-            return true;\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()\n+            {\n+                var buildRequestConfiguration = configCache[request.ConfigurationId];\n+\n+                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n+                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)\n+                                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+\n+                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n+                ErrorUtilities.VerifyThrow(\n+                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n+                    \"All non root requests should have a parent with a loaded configuration\");\n+\n+                var parentConfig1 = configCache[parentRequest.BuildRequest.ConfigurationId];",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oops, refactoring artifact.",
              "createdAt": "2019-06-06T20:43:32Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1786,72 +1788,95 @@ private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildReq\n             return null;\n         }\n \n-        private bool CheckIfCacheMissesAreAllowed(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses)\n+        /// <returns>True if caches misses are allowed, false otherwise</returns>\n+        private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses, out Action<ILoggingService> emitNonErrorLogs)\n         {\n+            emitNonErrorLogs = _ => { };\n+\n             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;\n+            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n \n             // do not check root requests as nothing depends on them\n-            if (!request.IsRootRequest && isIsolatedBuild)\n+            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)\n             {\n-                var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n-                var requestConfig = configCache[request.ConfigurationId];\n-\n-                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n-                if (parentRequest == null)\n+                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)\n                 {\n-                    // the parent might still be in executing requests because the scheduler might not have had a chance to mark it as blocked yet\n-                    parentRequest = _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+                    // retrieving the configs is not quite free, so avoid computing them eagerly\n+                    var configs = GetConfigurations();\n+\n+                    emitNonErrorLogs = ls => ls.LogComment(\n+                            NewBuildEventContext(),\n+                            MessageImportance.Normal,\n+                            \"SkippedConstraintsOnRequest\",\n+                            configs.parentConfig.ProjectFullPath,\n+                            configs.requestConfig.ProjectFullPath);\n                 }\n \n-                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n-                ErrorUtilities.VerifyThrow(\n-                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n-                    \"All non root requests should have a parent with a loaded configuration\");\n+                return true;\n+            }\n \n-                var parentConfig = configCache[parentRequest.BuildRequest.ConfigurationId];\n+            var (requestConfig, parentConfig) = GetConfigurations();\n \n-                // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n-                if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n-                {\n-                    return true;\n-                }\n+            // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n+            if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return true;\n+            }\n \n-                var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n-                    \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n-                    parentConfig.ProjectFullPath,\n-                    requestConfig.ProjectFullPath,\n-                    request.Targets.Count == 0\n-                        ? \"default\"\n-                        : string.Join(\";\", request.Targets));\n+            var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n+                \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n+                parentConfig.ProjectFullPath,\n+                requestConfig.ProjectFullPath,\n+                request.Targets.Count == 0\n+                    ? \"default\"\n+                    : string.Join(\";\", request.Targets));\n \n-                // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n-                BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n-                result.SetOverallResult(false);\n+            // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n+            BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n+            result.SetOverallResult(false);\n \n-                var response = GetResponseForResult(nodeForResults, request, result);\n-                responses.Add(response);\n+            var response = GetResponseForResult(nodeForResults, request, result);\n+            responses.Add(response);\n \n-                // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n-                // todo Search if there's a way to have the error automagically logged in response to the failed build result\n-                _componentHost.LoggingService.LogErrorFromText(\n-                    new BuildEventContext(\n-                        request.SubmissionId,\n-                        1,\n-                        BuildEventContext.InvalidProjectInstanceId,\n-                        BuildEventContext.InvalidProjectContextId,\n-                        BuildEventContext.InvalidTargetId,\n-                        BuildEventContext.InvalidTaskId),\n-                    null,\n-                    null,\n-                    null,\n-                    new BuildEventFileInfo(requestConfig.ProjectFullPath),\n-                    errorMessage);\n+            // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n+            // todo Search if there's a way to have the error automagically logged in response to the failed build result\n+            _componentHost.LoggingService.LogErrorFromText(\n+                NewBuildEventContext(),\n+                null,\n+                null,\n+                null,\n+                new BuildEventFileInfo(requestConfig.ProjectFullPath),\n+                errorMessage);\n \n-                return false;\n+            return false;\n+\n+            BuildEventContext NewBuildEventContext()\n+            {\n+                return new BuildEventContext(\n+                    request.SubmissionId,\n+                    1,\n+                    BuildEventContext.InvalidProjectInstanceId,\n+                    BuildEventContext.InvalidProjectContextId,\n+                    BuildEventContext.InvalidTargetId,\n+                    BuildEventContext.InvalidTaskId);\n             }\n \n-            return true;\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()\n+            {\n+                var buildRequestConfiguration = configCache[request.ConfigurationId];\n+\n+                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n+                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)\n+                                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+\n+                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n+                ErrorUtilities.VerifyThrow(\n+                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n+                    \"All non root requests should have a parent with a loaded configuration\");\n+\n+                var parentConfig1 = configCache[parentRequest.BuildRequest.ConfigurationId];",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is populated, so get creative\r\n```\r\n\r\n? Also, if it's \"sometimes\" should there be an optimistic check?",
              "createdAt": "2019-06-06T14:28:19Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1786,72 +1788,95 @@ private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildReq\n             return null;\n         }\n \n-        private bool CheckIfCacheMissesAreAllowed(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses)\n+        /// <returns>True if caches misses are allowed, false otherwise</returns>\n+        private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses, out Action<ILoggingService> emitNonErrorLogs)\n         {\n+            emitNonErrorLogs = _ => { };\n+\n             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;\n+            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n \n             // do not check root requests as nothing depends on them\n-            if (!request.IsRootRequest && isIsolatedBuild)\n+            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)\n             {\n-                var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n-                var requestConfig = configCache[request.ConfigurationId];\n-\n-                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n-                if (parentRequest == null)\n+                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)\n                 {\n-                    // the parent might still be in executing requests because the scheduler might not have had a chance to mark it as blocked yet\n-                    parentRequest = _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+                    // retrieving the configs is not quite free, so avoid computing them eagerly\n+                    var configs = GetConfigurations();\n+\n+                    emitNonErrorLogs = ls => ls.LogComment(\n+                            NewBuildEventContext(),\n+                            MessageImportance.Normal,\n+                            \"SkippedConstraintsOnRequest\",\n+                            configs.parentConfig.ProjectFullPath,\n+                            configs.requestConfig.ProjectFullPath);\n                 }\n \n-                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n-                ErrorUtilities.VerifyThrow(\n-                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n-                    \"All non root requests should have a parent with a loaded configuration\");\n+                return true;\n+            }\n \n-                var parentConfig = configCache[parentRequest.BuildRequest.ConfigurationId];\n+            var (requestConfig, parentConfig) = GetConfigurations();\n \n-                // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n-                if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n-                {\n-                    return true;\n-                }\n+            // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n+            if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return true;\n+            }\n \n-                var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n-                    \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n-                    parentConfig.ProjectFullPath,\n-                    requestConfig.ProjectFullPath,\n-                    request.Targets.Count == 0\n-                        ? \"default\"\n-                        : string.Join(\";\", request.Targets));\n+            var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n+                \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n+                parentConfig.ProjectFullPath,\n+                requestConfig.ProjectFullPath,\n+                request.Targets.Count == 0\n+                    ? \"default\"\n+                    : string.Join(\";\", request.Targets));\n \n-                // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n-                BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n-                result.SetOverallResult(false);\n+            // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n+            BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n+            result.SetOverallResult(false);\n \n-                var response = GetResponseForResult(nodeForResults, request, result);\n-                responses.Add(response);\n+            var response = GetResponseForResult(nodeForResults, request, result);\n+            responses.Add(response);\n \n-                // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n-                // todo Search if there's a way to have the error automagically logged in response to the failed build result\n-                _componentHost.LoggingService.LogErrorFromText(\n-                    new BuildEventContext(\n-                        request.SubmissionId,\n-                        1,\n-                        BuildEventContext.InvalidProjectInstanceId,\n-                        BuildEventContext.InvalidProjectContextId,\n-                        BuildEventContext.InvalidTargetId,\n-                        BuildEventContext.InvalidTaskId),\n-                    null,\n-                    null,\n-                    null,\n-                    new BuildEventFileInfo(requestConfig.ProjectFullPath),\n-                    errorMessage);\n+            // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n+            // todo Search if there's a way to have the error automagically logged in response to the failed build result\n+            _componentHost.LoggingService.LogErrorFromText(\n+                NewBuildEventContext(),\n+                null,\n+                null,\n+                null,\n+                new BuildEventFileInfo(requestConfig.ProjectFullPath),\n+                errorMessage);\n \n-                return false;\n+            return false;\n+\n+            BuildEventContext NewBuildEventContext()\n+            {\n+                return new BuildEventContext(\n+                    request.SubmissionId,\n+                    1,\n+                    BuildEventContext.InvalidProjectInstanceId,\n+                    BuildEventContext.InvalidProjectContextId,\n+                    BuildEventContext.InvalidTargetId,\n+                    BuildEventContext.InvalidTaskId);\n             }\n \n-            return true;\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()\n+            {\n+                var buildRequestConfiguration = configCache[request.ConfigurationId];\n+\n+                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "What's an optimistic check?\r\n\r\nI check in two places because I don't quite understand if it would be safe enough to just check in one of them. From what I've noticed, a request migrates back and forth between BlockedRequests and ExecutingRequests, and it seems that the parent could be in either when the cache miss constraint is checked.",
              "createdAt": "2019-06-06T21:21:40Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1786,72 +1788,95 @@ private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildReq\n             return null;\n         }\n \n-        private bool CheckIfCacheMissesAreAllowed(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses)\n+        /// <returns>True if caches misses are allowed, false otherwise</returns>\n+        private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses, out Action<ILoggingService> emitNonErrorLogs)\n         {\n+            emitNonErrorLogs = _ => { };\n+\n             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;\n+            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n \n             // do not check root requests as nothing depends on them\n-            if (!request.IsRootRequest && isIsolatedBuild)\n+            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)\n             {\n-                var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n-                var requestConfig = configCache[request.ConfigurationId];\n-\n-                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n-                if (parentRequest == null)\n+                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)\n                 {\n-                    // the parent might still be in executing requests because the scheduler might not have had a chance to mark it as blocked yet\n-                    parentRequest = _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+                    // retrieving the configs is not quite free, so avoid computing them eagerly\n+                    var configs = GetConfigurations();\n+\n+                    emitNonErrorLogs = ls => ls.LogComment(\n+                            NewBuildEventContext(),\n+                            MessageImportance.Normal,\n+                            \"SkippedConstraintsOnRequest\",\n+                            configs.parentConfig.ProjectFullPath,\n+                            configs.requestConfig.ProjectFullPath);\n                 }\n \n-                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n-                ErrorUtilities.VerifyThrow(\n-                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n-                    \"All non root requests should have a parent with a loaded configuration\");\n+                return true;\n+            }\n \n-                var parentConfig = configCache[parentRequest.BuildRequest.ConfigurationId];\n+            var (requestConfig, parentConfig) = GetConfigurations();\n \n-                // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n-                if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n-                {\n-                    return true;\n-                }\n+            // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n+            if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return true;\n+            }\n \n-                var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n-                    \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n-                    parentConfig.ProjectFullPath,\n-                    requestConfig.ProjectFullPath,\n-                    request.Targets.Count == 0\n-                        ? \"default\"\n-                        : string.Join(\";\", request.Targets));\n+            var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n+                \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n+                parentConfig.ProjectFullPath,\n+                requestConfig.ProjectFullPath,\n+                request.Targets.Count == 0\n+                    ? \"default\"\n+                    : string.Join(\";\", request.Targets));\n \n-                // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n-                BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n-                result.SetOverallResult(false);\n+            // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n+            BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n+            result.SetOverallResult(false);\n \n-                var response = GetResponseForResult(nodeForResults, request, result);\n-                responses.Add(response);\n+            var response = GetResponseForResult(nodeForResults, request, result);\n+            responses.Add(response);\n \n-                // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n-                // todo Search if there's a way to have the error automagically logged in response to the failed build result\n-                _componentHost.LoggingService.LogErrorFromText(\n-                    new BuildEventContext(\n-                        request.SubmissionId,\n-                        1,\n-                        BuildEventContext.InvalidProjectInstanceId,\n-                        BuildEventContext.InvalidProjectContextId,\n-                        BuildEventContext.InvalidTargetId,\n-                        BuildEventContext.InvalidTaskId),\n-                    null,\n-                    null,\n-                    null,\n-                    new BuildEventFileInfo(requestConfig.ProjectFullPath),\n-                    errorMessage);\n+            // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n+            // todo Search if there's a way to have the error automagically logged in response to the failed build result\n+            _componentHost.LoggingService.LogErrorFromText(\n+                NewBuildEventContext(),\n+                null,\n+                null,\n+                null,\n+                new BuildEventFileInfo(requestConfig.ProjectFullPath),\n+                errorMessage);\n \n-                return false;\n+            return false;\n+\n+            BuildEventContext NewBuildEventContext()\n+            {\n+                return new BuildEventContext(\n+                    request.SubmissionId,\n+                    1,\n+                    BuildEventContext.InvalidProjectInstanceId,\n+                    BuildEventContext.InvalidProjectContextId,\n+                    BuildEventContext.InvalidTargetId,\n+                    BuildEventContext.InvalidTaskId);\n             }\n \n-            return true;\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()\n+            {\n+                var buildRequestConfiguration = configCache[request.ConfigurationId];\n+\n+                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Ah, I see. Let's try a small rewrite:\r\n\r\n```suggestion\r\n                // Need the parent request. It might be blocked or executing; check both\r\n```\r\n\r\n?",
              "createdAt": "2019-06-07T20:19:18Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1786,72 +1788,95 @@ private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildReq\n             return null;\n         }\n \n-        private bool CheckIfCacheMissesAreAllowed(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses)\n+        /// <returns>True if caches misses are allowed, false otherwise</returns>\n+        private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses, out Action<ILoggingService> emitNonErrorLogs)\n         {\n+            emitNonErrorLogs = _ => { };\n+\n             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;\n+            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n \n             // do not check root requests as nothing depends on them\n-            if (!request.IsRootRequest && isIsolatedBuild)\n+            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)\n             {\n-                var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);\n-                var requestConfig = configCache[request.ConfigurationId];\n-\n-                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative\n-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n-                if (parentRequest == null)\n+                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)\n                 {\n-                    // the parent might still be in executing requests because the scheduler might not have had a chance to mark it as blocked yet\n-                    parentRequest = _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);\n+                    // retrieving the configs is not quite free, so avoid computing them eagerly\n+                    var configs = GetConfigurations();\n+\n+                    emitNonErrorLogs = ls => ls.LogComment(\n+                            NewBuildEventContext(),\n+                            MessageImportance.Normal,\n+                            \"SkippedConstraintsOnRequest\",\n+                            configs.parentConfig.ProjectFullPath,\n+                            configs.requestConfig.ProjectFullPath);\n                 }\n \n-                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));\n-                ErrorUtilities.VerifyThrow(\n-                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),\n-                    \"All non root requests should have a parent with a loaded configuration\");\n+                return true;\n+            }\n \n-                var parentConfig = configCache[parentRequest.BuildRequest.ConfigurationId];\n+            var (requestConfig, parentConfig) = GetConfigurations();\n \n-                // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n-                if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n-                {\n-                    return true;\n-                }\n+            // allow self references (project calling the msbuild task on itself, potentially with different global properties)\n+            if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return true;\n+            }\n \n-                var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n-                    \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n-                    parentConfig.ProjectFullPath,\n-                    requestConfig.ProjectFullPath,\n-                    request.Targets.Count == 0\n-                        ? \"default\"\n-                        : string.Join(\";\", request.Targets));\n+            var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\n+                \"CacheMissesNotAllowedInIsolatedGraphBuilds\",\n+                parentConfig.ProjectFullPath,\n+                requestConfig.ProjectFullPath,\n+                request.Targets.Count == 0\n+                    ? \"default\"\n+                    : string.Join(\";\", request.Targets));\n \n-                // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n-                BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n-                result.SetOverallResult(false);\n+            // Issue a failed build result to have the msbuild task marked as failed and thus stop the build\n+            BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));\n+            result.SetOverallResult(false);\n \n-                var response = GetResponseForResult(nodeForResults, request, result);\n-                responses.Add(response);\n+            var response = GetResponseForResult(nodeForResults, request, result);\n+            responses.Add(response);\n \n-                // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n-                // todo Search if there's a way to have the error automagically logged in response to the failed build result\n-                _componentHost.LoggingService.LogErrorFromText(\n-                    new BuildEventContext(\n-                        request.SubmissionId,\n-                        1,\n-                        BuildEventContext.InvalidProjectInstanceId,\n-                        BuildEventContext.InvalidProjectContextId,\n-                        BuildEventContext.InvalidTargetId,\n-                        BuildEventContext.InvalidTaskId),\n-                    null,\n-                    null,\n-                    null,\n-                    new BuildEventFileInfo(requestConfig.ProjectFullPath),\n-                    errorMessage);\n+            // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors\n+            // todo Search if there's a way to have the error automagically logged in response to the failed build result\n+            _componentHost.LoggingService.LogErrorFromText(\n+                NewBuildEventContext(),\n+                null,\n+                null,\n+                null,\n+                new BuildEventFileInfo(requestConfig.ProjectFullPath),\n+                errorMessage);\n \n-                return false;\n+            return false;\n+\n+            BuildEventContext NewBuildEventContext()\n+            {\n+                return new BuildEventContext(\n+                    request.SubmissionId,\n+                    1,\n+                    BuildEventContext.InvalidProjectInstanceId,\n+                    BuildEventContext.InvalidProjectContextId,\n+                    BuildEventContext.InvalidTargetId,\n+                    BuildEventContext.InvalidTaskId);\n             }\n \n-            return true;\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()\n+            {\n+                var buildRequestConfiguration = configCache[request.ConfigurationId];\n+\n+                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I feel like there's a better name hiding here, but I don't have a great suggestion.\r\n\r\n```\r\nAllowedReference\r\nIgnoredGraphIsolationReference\r\n```\r\n\r\n? I can live with this name if we can't find something clearly nicer.",
              "createdAt": "2019-06-06T14:34:02Z",
              "path": "src/Tasks/Microsoft.Managed.targets",
              "diffHunk": "@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <DisableTransitiveProjectReferences Condition=\"'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''\">true</DisableTransitiveProjectReferences>\n    </PropertyGroup>\n \n+   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.\n+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.\n+           Escape the item to avoid eager evaluation of the wildcards.\n+      -->\n+      <ReferencesToSkipGraphIsolationConstraintsOn",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Alternatives\r\n`ReferencesExemptFromGraphIsolation`\r\n`GraphIsolationExemptions`\r\n`ReferencesExcludedFromGraphIsolation`",
              "createdAt": "2019-06-06T21:25:57Z",
              "path": "src/Tasks/Microsoft.Managed.targets",
              "diffHunk": "@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <DisableTransitiveProjectReferences Condition=\"'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''\">true</DisableTransitiveProjectReferences>\n    </PropertyGroup>\n \n+   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.\n+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.\n+           Escape the item to avoid eager evaluation of the wildcards.\n+      -->\n+      <ReferencesToSkipGraphIsolationConstraintsOn",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "`GraphIsolationExemptReference`?",
              "createdAt": "2019-06-07T20:25:04Z",
              "path": "src/Tasks/Microsoft.Managed.targets",
              "diffHunk": "@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <DisableTransitiveProjectReferences Condition=\"'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''\">true</DisableTransitiveProjectReferences>\n    </PropertyGroup>\n \n+   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.\n+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.\n+           Escape the item to avoid eager evaluation of the wildcards.\n+      -->\n+      <ReferencesToSkipGraphIsolationConstraintsOn",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you confirm that this works on a `dotnet new wpf` and a template framework XAML-using project?",
              "createdAt": "2019-06-06T14:34:48Z",
              "path": "src/Tasks/Microsoft.Managed.targets",
              "diffHunk": "@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <DisableTransitiveProjectReferences Condition=\"'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''\">true</DisableTransitiveProjectReferences>\n    </PropertyGroup>\n \n+   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.\n+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I have both of them in https://github.com/microsoft/MSBuildStaticGraphTester. The msbuild repo does not have a tradition of storing test projects, so I didn't even consider adding them. I could actually add them to the sdk repo, but I have to wait until this change makes it to the sdk.",
              "createdAt": "2019-06-06T21:28:44Z",
              "path": "src/Tasks/Microsoft.Managed.targets",
              "diffHunk": "@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <DisableTransitiveProjectReferences Condition=\"'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''\">true</DisableTransitiveProjectReferences>\n    </PropertyGroup>\n \n+   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.\n+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "That's all I wanted, no need to add the test here (as part of this; more tests always welcome!)",
              "createdAt": "2019-06-07T20:12:10Z",
              "path": "src/Tasks/Microsoft.Managed.targets",
              "diffHunk": "@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <DisableTransitiveProjectReferences Condition=\"'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''\">true</DisableTransitiveProjectReferences>\n    </PropertyGroup>\n \n+   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.\n+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}