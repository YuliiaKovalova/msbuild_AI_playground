{
  "number": 6094,
  "title": "On disk cache serialization ",
  "body": "### Context\r\nBinaryFormater serialization of on-disk RAR cache is slow and unsecure. \r\nRelated issue: #6057\r\n\r\n### Changes Made\r\nSerialization changed to use custom binary format by using existing `ITranslatable` \r\n\r\n### Testing\r\nUnit testing\r\nManual testing\r\n- Roslyn repo rebuild + incremental build\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2021-01-27T22:20:37Z",
  "updatedAt": "2021-04-01T13:37:31Z",
  "closedAt": "2021-02-25T16:50:58Z",
  "mergedAt": "2021-02-25T16:50:58Z",
  "additions": 888,
  "deletions": 73,
  "changedFiles": 14,
  "headRefName": "rokonec/6057-on-disk-cache-serialization",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rokonec"
      }
    ]
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "7e75c0d3dae897defcc0bf68460f70370b38d2a9",
          "message": "Initial code changes - not verified yet",
          "committedDate": "2021-01-25T19:32:54Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a1f100133a47c8d583ed03400ee399186443ff1e",
          "message": "Unit tests part 1",
          "committedDate": "2021-01-27T22:14:49Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "292e88541c99663e5867e8d55d40d43339a228b2",
          "message": "Intermediate version with BinaryFormatter still in and special  unit tests.",
          "committedDate": "2021-02-02T08:41:01Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "44e685ed63b1f87d7f4acf786a5cb7df9c8367f6",
          "message": "Cleaning old serialization code. Additional unit tests.",
          "committedDate": "2021-02-02T22:44:43Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ab488fc594dcc20854e3fc18552129ccf6b21c4",
          "message": "Review comments #1",
          "committedDate": "2021-02-04T13:33:22Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "944c4e7de87891cb4defb5385e659e045556c1f1",
          "message": "Attempt to get more info why unit tests fails.",
          "committedDate": "2021-02-04T13:56:19Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "501db6e722335165ad8c50af12851cc86cb68530",
          "message": "Fix unit test by embedded resources approach",
          "committedDate": "2021-02-04T15:34:48Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "02cb3fb44aac693d4efd7cfea6a30b50237b6f19",
          "message": "Add ignored file :-(",
          "committedDate": "2021-02-04T16:11:47Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Looks roughly good to me, and as I said over Teams\u2014don't worry about the mono failures.",
        "createdAt": "2021-01-28T01:08:57Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Very curious to see what the time differences are between this and master. Please post numbers once you have them :)",
        "createdAt": "2021-02-04T02:13:47Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "Are there any unit tests that assert a correct serialize / deserialize roundtrip for SystemState? If not, maybe worth adding at least one big smoke test.\r\n\r\nLater edit: woops, didn't see the one you added.",
        "createdAt": "2021-02-04T02:36:36Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "@cdmihai \r\n> General approach looks good. Curios to see perf data comparisons.\r\n\r\nPerf data:\r\n- On rotational DISK incremental build of Roslyn is about 8% shorter at RAR wall clock time.\r\n- On SSD incremental build of OrchardCore is about 2% shorter at RAR wall clock time.\r\n- RAR cache on-disk size is about 5x smaller (20% of original size).\r\n- Memory allocated by RAR in incremental Roslyn build is about 15% smaller.",
        "createdAt": "2021-02-08T14:23:55Z",
        "author": {
          "login": "rokonec"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you explain how this Translator works? It seems like you just say Translate on a basic type, and it serializes it, then stores it somewhere magical where it comes out again when you ask for it?",
              "createdAt": "2021-02-03T00:06:16Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ah, sleeping always helps.\r\n\r\nSeems like you pass in a file stream in the real version, so the Translate method (on a basic type) presumably does some simple translation and puts it in the stream or vice versa if it's reading. Thanks!",
              "createdAt": "2021-02-03T15:07:40Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this be added as an extra InlineData in the previous test?",
              "createdAt": "2021-02-03T00:07:17Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Although both of these test repeat quite a few lines, null vs various valid states are distinct use cases. One validate that all kinds of object state will be serialized properly, other that object can be serialized as null. \r\nI'd rather keep those separated.",
              "createdAt": "2021-02-04T09:18:27Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n            TranslationHelpers.GetReadTranslator().TranslateHashSet(ref deserializedValue, BaseClass.FactoryForDeserialization, capacity => new());\r\n```",
              "createdAt": "2021-02-03T00:08:40Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()\n+        {\n+            CultureInfo value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);\n+        }\n+\n+        [Theory]\n+        [InlineData(\"1.2\")]\n+        [InlineData(\"1.2.3\")]\n+        [InlineData(\"1.2.3.4\")]\n+        public void Version(string version)\n+        {\n+            Version value = new Version(version);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            Version deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void VersionAsNull()\n+        {\n+            Version value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            Version deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void HashSetOfT()\n+        {\n+            HashSet<BaseClass> value = new()\n+            {\n+                new BaseClass(1),\n+                new BaseClass(2),\n+                null\n+            };\n+            TranslationHelpers.GetWriteTranslator().TranslateHashSet(ref value, BaseClass.FactoryForDeserialization, capacity => new ());\n+\n+            HashSet<BaseClass> deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().TranslateHashSet(ref deserializedValue, BaseClass.FactoryForDeserialization, capacity => new ());",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-02-04T09:13:09Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()\n+        {\n+            CultureInfo value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);\n+        }\n+\n+        [Theory]\n+        [InlineData(\"1.2\")]\n+        [InlineData(\"1.2.3\")]\n+        [InlineData(\"1.2.3.4\")]\n+        public void Version(string version)\n+        {\n+            Version value = new Version(version);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            Version deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void VersionAsNull()\n+        {\n+            Version value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            Version deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void HashSetOfT()\n+        {\n+            HashSet<BaseClass> value = new()\n+            {\n+                new BaseClass(1),\n+                new BaseClass(2),\n+                null\n+            };\n+            TranslationHelpers.GetWriteTranslator().TranslateHashSet(ref value, BaseClass.FactoryForDeserialization, capacity => new ());\n+\n+            HashSet<BaseClass> deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().TranslateHashSet(ref deserializedValue, BaseClass.FactoryForDeserialization, capacity => new ());",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would you mind using Shouldly for all the asserts?",
              "createdAt": "2021-02-03T00:09:04Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()\n+        {\n+            CultureInfo value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "When I was choosing assertion library, based on https://blog.safnet.com/archive/2018/12/03/assertion-comparisons/, i liked FluentAssertion better. Mostly for documentation part. Situation in 2021 could be different and I understand that there is some inertia with using Shouldly and I don't think we will or shall change it. Just saying.\r\nSo is there consensus in team to use Shouldly from now on? I have seen it used in few places but was not sure about the strategy here, so I have decided to fall back to g'old xunit asserts, although, personally, I like to have assertion library isolated from unit test runner and I love fluent assertions regardless it is shouldly or FluentAssetions.",
              "createdAt": "2021-02-03T15:41:53Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()\n+        {\n+            CultureInfo value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "That, at least, was the previous consensus. We can bring it up again if you'd like\u2014I don't care too much about documentation because once I've figured something out, I can just copy it rather than looking at docs again. I also appreciate fewer characters in the code.",
              "createdAt": "2021-02-03T15:54:38Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()\n+        {\n+            CultureInfo value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-02-04T12:41:13Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -431,6 +434,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()\n             Assert.Equal(value, deserializedValue);\n         }\n \n+        [Theory]\n+        [InlineData(\"en\")]\n+        [InlineData(\"en-US\")]\n+        [InlineData(\"en-CA\")]\n+        [InlineData(\"zh-HK\")]\n+        [InlineData(\"sr-Cyrl-CS\")]\n+        public void CultureInfo(string name)\n+        {\n+            CultureInfo value = new CultureInfo(name);\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Equal(value, deserializedValue);\n+        }\n+\n+        [Fact]\n+        public void CultureInfoAsNull()\n+        {\n+            CultureInfo value = null;\n+            TranslationHelpers.GetWriteTranslator().Translate(ref value);\n+\n+            CultureInfo deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);\n+\n+            Assert.Null(deserializedValue);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do you need the parameter?",
              "createdAt": "2021-02-03T02:45:47Z",
              "path": "src/Shared/TranslatorHelpers.cs",
              "diffHunk": "@@ -102,5 +107,168 @@ void Translate(ITranslator translator, ref T objectToTranslate)\n         {\n             translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);\n         }\n+\n+        public static void TranslateHashSet<T>(\n+            this ITranslator translator,\n+            ref HashSet<T> hashSet,\n+            NodePacketValueFactory<T> valueFactory,\n+            NodePacketCollectionCreator<HashSet<T>> collectionFactory) where T : class, ITranslatable\n+        {\n+            if (!translator.TranslateNullable(hashSet))\n+                return;\n+\n+            int count = default;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                count = hashSet.Count;\n+            }\n+            translator.Translate(ref count);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                hashSet = collectionFactory(count);\n+                for (int i = 0; i < count; i++)\n+                {\n+                    T value = default(T);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We don't. Changed",
              "createdAt": "2021-02-04T09:19:35Z",
              "path": "src/Shared/TranslatorHelpers.cs",
              "diffHunk": "@@ -102,5 +107,168 @@ void Translate(ITranslator translator, ref T objectToTranslate)\n         {\n             translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);\n         }\n+\n+        public static void TranslateHashSet<T>(\n+            this ITranslator translator,\n+            ref HashSet<T> hashSet,\n+            NodePacketValueFactory<T> valueFactory,\n+            NodePacketCollectionCreator<HashSet<T>> collectionFactory) where T : class, ITranslatable\n+        {\n+            if (!translator.TranslateNullable(hashSet))\n+                return;\n+\n+            int count = default;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                count = hashSet.Count;\n+            }\n+            translator.Translate(ref count);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                hashSet = collectionFactory(count);\n+                for (int i = 0; i < count; i++)\n+                {\n+                    T value = default(T);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there any reason you can't just delete this and the corresponding line, then? I noticed that you omitted a lot of other properties that weren't used in RAR either.\r\n\r\nOn the other hand, I'm wondering for this sort of thing whether it's better to translate everything, including things we don't need. Perf and simplicity vs. future developer coming by and wondering why translation is \"broken\" for AssemblyNames...",
              "createdAt": "2021-02-03T02:51:03Z",
              "path": "src/Shared/TranslatorHelpers.cs",
              "diffHunk": "@@ -102,5 +107,168 @@ void Translate(ITranslator translator, ref T objectToTranslate)\n         {\n             translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);\n         }\n+\n+        public static void TranslateHashSet<T>(\n+            this ITranslator translator,\n+            ref HashSet<T> hashSet,\n+            NodePacketValueFactory<T> valueFactory,\n+            NodePacketCollectionCreator<HashSet<T>> collectionFactory) where T : class, ITranslatable\n+        {\n+            if (!translator.TranslateNullable(hashSet))\n+                return;\n+\n+            int count = default;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                count = hashSet.Count;\n+            }\n+            translator.Translate(ref count);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                hashSet = collectionFactory(count);\n+                for (int i = 0; i < count; i++)\n+                {\n+                    T value = default(T);\n+                    translator.Translate(ref value, valueFactory);\n+                    hashSet.Add(value);\n+                }\n+            }\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                foreach (T item in hashSet)\n+                {\n+                    T value = item;\n+                    translator.Translate(ref value, valueFactory);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref CultureInfo cultureInfo)\n+        {\n+            if (!translator.TranslateNullable(cultureInfo))\n+                return;\n+\n+            int lcid = default;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                lcid = cultureInfo.LCID;\n+            }\n+\n+            translator.Translate(ref lcid);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                cultureInfo = new CultureInfo(lcid);\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Version version)\n+        {\n+            if (!translator.TranslateNullable(version))\n+                return;\n+\n+            int major = 0;\n+            int minor = 0;\n+            int build = 0;\n+            int revision = 0;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                major = version.Major;\n+                minor = version.Minor;\n+                build = version.Build;\n+                revision = version.Revision;\n+            }\n+\n+            translator.Translate(ref major);\n+            translator.Translate(ref minor);\n+            translator.Translate(ref build);\n+            translator.Translate(ref revision);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                if (build < 0)\n+                {\n+                    version = new Version(major, minor);\n+                }\n+                else if (revision < 0)\n+                {\n+                    version = new Version(major, minor, build);\n+                }\n+                else\n+                {\n+                    version = new Version(major, minor, build, revision);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref AssemblyName assemblyName)\n+        {\n+            if (!translator.TranslateNullable(assemblyName))\n+                return;\n+\n+            string name = null;\n+            Version version = null;\n+            AssemblyNameFlags flags = default;\n+            ProcessorArchitecture processorArchitecture = default;\n+            CultureInfo cultureInfo = null;\n+            AssemblyHashAlgorithm hashAlgorithm = default;\n+            AssemblyVersionCompatibility versionCompatibility = default;\n+            string codeBase = null;\n+\n+            byte[] publicKey = null;\n+            byte[] publicKeyToken = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                name = assemblyName.Name;\n+                version = assemblyName.Version;\n+                flags = assemblyName.Flags;\n+                processorArchitecture = assemblyName.ProcessorArchitecture;\n+                cultureInfo = assemblyName.CultureInfo;\n+                hashAlgorithm = assemblyName.HashAlgorithm;\n+                versionCompatibility = assemblyName.VersionCompatibility;\n+                codeBase = assemblyName.CodeBase;\n+\n+                publicKey = assemblyName.GetPublicKey(); // TODO: no need to serialize, public key is not used anywhere in context of RAR, only public key token",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The extend of serialized properties was reverse engineered. In order to not change too much in one PR, I was trying to mimic current binary formatter serialization.\r\nIf we decide to optimize it or make it more generic, i recommend to do so in different PR.",
              "createdAt": "2021-02-04T09:24:11Z",
              "path": "src/Shared/TranslatorHelpers.cs",
              "diffHunk": "@@ -102,5 +107,168 @@ void Translate(ITranslator translator, ref T objectToTranslate)\n         {\n             translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);\n         }\n+\n+        public static void TranslateHashSet<T>(\n+            this ITranslator translator,\n+            ref HashSet<T> hashSet,\n+            NodePacketValueFactory<T> valueFactory,\n+            NodePacketCollectionCreator<HashSet<T>> collectionFactory) where T : class, ITranslatable\n+        {\n+            if (!translator.TranslateNullable(hashSet))\n+                return;\n+\n+            int count = default;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                count = hashSet.Count;\n+            }\n+            translator.Translate(ref count);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                hashSet = collectionFactory(count);\n+                for (int i = 0; i < count; i++)\n+                {\n+                    T value = default(T);\n+                    translator.Translate(ref value, valueFactory);\n+                    hashSet.Add(value);\n+                }\n+            }\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                foreach (T item in hashSet)\n+                {\n+                    T value = item;\n+                    translator.Translate(ref value, valueFactory);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref CultureInfo cultureInfo)\n+        {\n+            if (!translator.TranslateNullable(cultureInfo))\n+                return;\n+\n+            int lcid = default;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                lcid = cultureInfo.LCID;\n+            }\n+\n+            translator.Translate(ref lcid);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                cultureInfo = new CultureInfo(lcid);\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Version version)\n+        {\n+            if (!translator.TranslateNullable(version))\n+                return;\n+\n+            int major = 0;\n+            int minor = 0;\n+            int build = 0;\n+            int revision = 0;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                major = version.Major;\n+                minor = version.Minor;\n+                build = version.Build;\n+                revision = version.Revision;\n+            }\n+\n+            translator.Translate(ref major);\n+            translator.Translate(ref minor);\n+            translator.Translate(ref build);\n+            translator.Translate(ref revision);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                if (build < 0)\n+                {\n+                    version = new Version(major, minor);\n+                }\n+                else if (revision < 0)\n+                {\n+                    version = new Version(major, minor, build);\n+                }\n+                else\n+                {\n+                    version = new Version(major, minor, build, revision);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref AssemblyName assemblyName)\n+        {\n+            if (!translator.TranslateNullable(assemblyName))\n+                return;\n+\n+            string name = null;\n+            Version version = null;\n+            AssemblyNameFlags flags = default;\n+            ProcessorArchitecture processorArchitecture = default;\n+            CultureInfo cultureInfo = null;\n+            AssemblyHashAlgorithm hashAlgorithm = default;\n+            AssemblyVersionCompatibility versionCompatibility = default;\n+            string codeBase = null;\n+\n+            byte[] publicKey = null;\n+            byte[] publicKeyToken = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                name = assemblyName.Name;\n+                version = assemblyName.Version;\n+                flags = assemblyName.Flags;\n+                processorArchitecture = assemblyName.ProcessorArchitecture;\n+                cultureInfo = assemblyName.CultureInfo;\n+                hashAlgorithm = assemblyName.HashAlgorithm;\n+                versionCompatibility = assemblyName.VersionCompatibility;\n+                codeBase = assemblyName.CodeBase;\n+\n+                publicKey = assemblyName.GetPublicKey(); // TODO: no need to serialize, public key is not used anywhere in context of RAR, only public key token",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doesn't this mean it just serializes/deserializes an assemblyname rather than an assemblynameextension?",
              "createdAt": "2021-02-03T03:00:39Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -149,47 +153,28 @@ internal FileState(DateTime lastModified)\n             }\n \n             /// <summary>\n-            /// Deserializing constuctor.\n+            /// Ctor for translator deserialization\n             /// </summary>\n-            internal FileState(SerializationInfo info, StreamingContext context)\n+            internal FileState(ITranslator translator)\n             {\n-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-                lastModified = new DateTime(info.GetInt64(\"mod\"), (DateTimeKind)info.GetInt32(\"modk\"));\n-                assemblyName = (AssemblyNameExtension)info.GetValue(\"an\", typeof(AssemblyNameExtension));\n-                dependencies = (AssemblyNameExtension[])info.GetValue(\"deps\", typeof(AssemblyNameExtension[]));\n-                scatterFiles = (string[])info.GetValue(\"sfiles\", typeof(string[]));\n-                runtimeVersion = (string)info.GetValue(\"rtver\", typeof(string));\n-                if (info.GetBoolean(\"fn\"))\n-                {\n-                    var frameworkNameVersion = (Version) info.GetValue(\"fnVer\", typeof(Version));\n-                    var frameworkIdentifier = info.GetString(\"fnId\");\n-                    var frameworkProfile = info.GetString(\"fmProf\");\n-                    frameworkName = new FrameworkName(frameworkIdentifier, frameworkNameVersion, frameworkProfile);\n-                }\n+                Translate(translator);\n             }\n \n             /// <summary>\n-            /// Serialize the contents of the class.\n+            /// Reads/writes this class\n             /// </summary>\n-            [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]\n-            public void GetObjectData(SerializationInfo info, StreamingContext context)\n+            public void Translate(ITranslator translator)\n             {\n-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-                info.AddValue(\"mod\", lastModified.Ticks);\n-                info.AddValue(\"modk\", (int)lastModified.Kind);\n-                info.AddValue(\"an\", assemblyName);\n-                info.AddValue(\"deps\", dependencies);\n-                info.AddValue(\"sfiles\", scatterFiles);\n-                info.AddValue(\"rtver\", runtimeVersion);\n-                info.AddValue(\"fn\", frameworkName != null);\n-                if (frameworkName != null)\n-                {\n-                    info.AddValue(\"fnVer\", frameworkName.Version);\n-                    info.AddValue(\"fnId\", frameworkName.Identifier);\n-                    info.AddValue(\"fmProf\", frameworkName.Profile);\n-                }\n+                ErrorUtilities.VerifyThrowArgumentNull(translator, nameof(translator));\n+\n+                translator.Translate(ref lastModified);\n+                translator.Translate(ref assemblyName,\n+                    (ITranslator t) => new AssemblyNameExtension(t));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I am not sure I understand your question. `asemblyName` is declared as `private AssemblyNameExtension assemblyName;`\r\n`AssemblyNameExtension` implements ITranslatable but does not have `new()`. Above override using `(ITranslator t) => {...}` was designed to handle such case.",
              "createdAt": "2021-02-04T09:30:02Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -149,47 +153,28 @@ internal FileState(DateTime lastModified)\n             }\n \n             /// <summary>\n-            /// Deserializing constuctor.\n+            /// Ctor for translator deserialization\n             /// </summary>\n-            internal FileState(SerializationInfo info, StreamingContext context)\n+            internal FileState(ITranslator translator)\n             {\n-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-                lastModified = new DateTime(info.GetInt64(\"mod\"), (DateTimeKind)info.GetInt32(\"modk\"));\n-                assemblyName = (AssemblyNameExtension)info.GetValue(\"an\", typeof(AssemblyNameExtension));\n-                dependencies = (AssemblyNameExtension[])info.GetValue(\"deps\", typeof(AssemblyNameExtension[]));\n-                scatterFiles = (string[])info.GetValue(\"sfiles\", typeof(string[]));\n-                runtimeVersion = (string)info.GetValue(\"rtver\", typeof(string));\n-                if (info.GetBoolean(\"fn\"))\n-                {\n-                    var frameworkNameVersion = (Version) info.GetValue(\"fnVer\", typeof(Version));\n-                    var frameworkIdentifier = info.GetString(\"fnId\");\n-                    var frameworkProfile = info.GetString(\"fmProf\");\n-                    frameworkName = new FrameworkName(frameworkIdentifier, frameworkNameVersion, frameworkProfile);\n-                }\n+                Translate(translator);\n             }\n \n             /// <summary>\n-            /// Serialize the contents of the class.\n+            /// Reads/writes this class\n             /// </summary>\n-            [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]\n-            public void GetObjectData(SerializationInfo info, StreamingContext context)\n+            public void Translate(ITranslator translator)\n             {\n-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-                info.AddValue(\"mod\", lastModified.Ticks);\n-                info.AddValue(\"modk\", (int)lastModified.Kind);\n-                info.AddValue(\"an\", assemblyName);\n-                info.AddValue(\"deps\", dependencies);\n-                info.AddValue(\"sfiles\", scatterFiles);\n-                info.AddValue(\"rtver\", runtimeVersion);\n-                info.AddValue(\"fn\", frameworkName != null);\n-                if (frameworkName != null)\n-                {\n-                    info.AddValue(\"fnVer\", frameworkName.Version);\n-                    info.AddValue(\"fnId\", frameworkName.Identifier);\n-                    info.AddValue(\"fmProf\", frameworkName.Profile);\n-                }\n+                ErrorUtilities.VerifyThrowArgumentNull(translator, nameof(translator));\n+\n+                translator.Translate(ref lastModified);\n+                translator.Translate(ref assemblyName,\n+                    (ITranslator t) => new AssemblyNameExtension(t));",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I may not properly understand this code, but I understood it to create an AssemblyName, then essentially cast it into an AssemblyNameExtension. Since the original that was serialized was an AssemblyNameExtension, that seemed like it would lose information\u2014anything in the extension.",
              "createdAt": "2021-02-04T15:58:08Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -149,47 +153,28 @@ internal FileState(DateTime lastModified)\n             }\n \n             /// <summary>\n-            /// Deserializing constuctor.\n+            /// Ctor for translator deserialization\n             /// </summary>\n-            internal FileState(SerializationInfo info, StreamingContext context)\n+            internal FileState(ITranslator translator)\n             {\n-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-                lastModified = new DateTime(info.GetInt64(\"mod\"), (DateTimeKind)info.GetInt32(\"modk\"));\n-                assemblyName = (AssemblyNameExtension)info.GetValue(\"an\", typeof(AssemblyNameExtension));\n-                dependencies = (AssemblyNameExtension[])info.GetValue(\"deps\", typeof(AssemblyNameExtension[]));\n-                scatterFiles = (string[])info.GetValue(\"sfiles\", typeof(string[]));\n-                runtimeVersion = (string)info.GetValue(\"rtver\", typeof(string));\n-                if (info.GetBoolean(\"fn\"))\n-                {\n-                    var frameworkNameVersion = (Version) info.GetValue(\"fnVer\", typeof(Version));\n-                    var frameworkIdentifier = info.GetString(\"fnId\");\n-                    var frameworkProfile = info.GetString(\"fmProf\");\n-                    frameworkName = new FrameworkName(frameworkIdentifier, frameworkNameVersion, frameworkProfile);\n-                }\n+                Translate(translator);\n             }\n \n             /// <summary>\n-            /// Serialize the contents of the class.\n+            /// Reads/writes this class\n             /// </summary>\n-            [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]\n-            public void GetObjectData(SerializationInfo info, StreamingContext context)\n+            public void Translate(ITranslator translator)\n             {\n-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-                info.AddValue(\"mod\", lastModified.Ticks);\n-                info.AddValue(\"modk\", (int)lastModified.Kind);\n-                info.AddValue(\"an\", assemblyName);\n-                info.AddValue(\"deps\", dependencies);\n-                info.AddValue(\"sfiles\", scatterFiles);\n-                info.AddValue(\"rtver\", runtimeVersion);\n-                info.AddValue(\"fn\", frameworkName != null);\n-                if (frameworkName != null)\n-                {\n-                    info.AddValue(\"fnVer\", frameworkName.Version);\n-                    info.AddValue(\"fnId\", frameworkName.Identifier);\n-                    info.AddValue(\"fmProf\", frameworkName.Profile);\n-                }\n+                ErrorUtilities.VerifyThrowArgumentNull(translator, nameof(translator));\n+\n+                translator.Translate(ref lastModified);\n+                translator.Translate(ref assemblyName,\n+                    (ITranslator t) => new AssemblyNameExtension(t));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            \r\n            // If there was a problem writing the file (like it's read-only or locked on disk, for\r\n            // example), then eat the exception and log a warning.  Otherwise, rethrow.\r\n            catch (Exception e) when (!ExceptionHandling.NotExpectedSerializationException(e))\r\n            {\r\n```",
              "createdAt": "2021-02-03T03:04:23Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Also maybe combine comments, since they're similar.",
              "createdAt": "2021-02-03T03:08:06Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done ",
              "createdAt": "2021-02-04T09:31:20Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        /// TODO: once all classes derived from StateFileBase adopt the new serialization, we should consider moving this into the base class\r\n```",
              "createdAt": "2021-02-03T03:05:49Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;\n+\n+                // Not being able to serialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotWriteStateFile\", stateFile, e.Message);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Read the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-02-04T09:33:38Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;\n+\n+                // Not being able to serialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotWriteStateFile\", stateFile, e.Message);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Read the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            // First, we read the cache from disk if one exists; otherwise, we create one.\r\n```",
              "createdAt": "2021-02-03T03:06:34Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;\n+\n+                // Not being able to serialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotWriteStateFile\", stateFile, e.Message);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Read the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            // First, we read the cache from disk if one exists, or if one does not exist\n+            // then we create one.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))\r\n            {\r\n```",
              "createdAt": "2021-02-03T03:09:43Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;\n+\n+                // Not being able to serialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotWriteStateFile\", stateFile, e.Message);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Read the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            // First, we read the cache from disk if one exists, or if one does not exist\n+            // then we create one.\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))\n+                {\n+                    using FileStream s = new FileStream(stateFile, FileMode.Open);\n+                    var translator = BinaryTranslator.GetReadTranslator(s, buffer:null); // TODO: shared buffering?\n+\n+                    // verify file signature\n+                    var contractSignature = translator.Reader.ReadBytes(TranslateContractSignature.Length);\n+                    var contractVersion = translator.Reader.ReadByte();\n+\n+                    if (!contractSignature.SequenceEqual(TranslateContractSignature) || contractVersion != TranslateContractVersion)\n+                    {\n+                        log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n+                        return null;\n+                    }\n+\n+                    SystemState systemState = new SystemState();\n+                    systemState.Translate(translator);\n+                    systemState.isDirty = false;\n+\n+                    return systemState;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                if (ExceptionHandling.IsCriticalException(e))\n+                {\n+                    throw;\n+                }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-02-04T09:34:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;\n+\n+                // Not being able to serialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotWriteStateFile\", stateFile, e.Message);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Read the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            // First, we read the cache from disk if one exists, or if one does not exist\n+            // then we create one.\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))\n+                {\n+                    using FileStream s = new FileStream(stateFile, FileMode.Open);\n+                    var translator = BinaryTranslator.GetReadTranslator(s, buffer:null); // TODO: shared buffering?\n+\n+                    // verify file signature\n+                    var contractSignature = translator.Reader.ReadBytes(TranslateContractSignature.Length);\n+                    var contractVersion = translator.Reader.ReadByte();\n+\n+                    if (!contractSignature.SequenceEqual(TranslateContractSignature) || contractVersion != TranslateContractVersion)\n+                    {\n+                        log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n+                        return null;\n+                    }\n+\n+                    SystemState systemState = new SystemState();\n+                    systemState.Translate(translator);\n+                    systemState.isDirty = false;\n+\n+                    return systemState;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                if (ExceptionHandling.IsCriticalException(e))\n+                {\n+                    throw;\n+                }",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can just delete this.",
              "createdAt": "2021-02-03T03:10:14Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))\n+                {\n+                    if (FileSystems.Default.FileExists(stateFile))\n+                    {\n+                        File.Delete(stateFile);\n+                    }\n+\n+                    using var s = new FileStream(stateFile, FileMode.CreateNew);\n+                    var translator = BinaryTranslator.GetWriteTranslator(s);\n+\n+                    // write file signature\n+                    translator.Writer.Write(TranslateContractSignature);\n+                    translator.Writer.Write(TranslateContractVersion);\n+\n+                    Translate(translator);\n+                    isDirty = false;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                // If there was a problem writing the file (like it's read-only or locked on disk, for\n+                // example), then eat the exception and log a warning.  Otherwise, rethrow.\n+                if (ExceptionHandling.NotExpectedSerializationException(e))\n+                    throw;\n+\n+                // Not being able to serialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotWriteStateFile\", stateFile, e.Message);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Read the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            // First, we read the cache from disk if one exists, or if one does not exist\n+            // then we create one.\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))\n+                {\n+                    using FileStream s = new FileStream(stateFile, FileMode.Open);\n+                    var translator = BinaryTranslator.GetReadTranslator(s, buffer:null); // TODO: shared buffering?\n+\n+                    // verify file signature\n+                    var contractSignature = translator.Reader.ReadBytes(TranslateContractSignature.Length);\n+                    var contractVersion = translator.Reader.ReadByte();\n+\n+                    if (!contractSignature.SequenceEqual(TranslateContractSignature) || contractVersion != TranslateContractVersion)\n+                    {\n+                        log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n+                        return null;\n+                    }\n+\n+                    SystemState systemState = new SystemState();\n+                    systemState.Translate(translator);\n+                    systemState.isDirty = false;\n+\n+                    return systemState;\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                if (ExceptionHandling.IsCriticalException(e))\n+                {\n+                    throw;\n+                }\n+\n+                // The deserialization process seems like it can throw just about \n+                // any exception imaginable.  Catch them all here.\n+                // Not being able to deserialize the cache is not an error, but we let the user know anyway.\n+                // Don't want to hold up processing just because we couldn't read the file.\n+                log.LogWarningWithCodeFromResources(\"General.CouldNotReadStateFile\", stateFile, e.Message);\n+                return null;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Copywrite header",
              "createdAt": "2021-02-03T03:11:40Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -0,0 +1,35 @@\n+using System;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In theory there could be infinite loop caused by cycle in `remappedFrom' resulting in stack overflow, out of memory or out of disk space exception (whatever will happen 1st).\r\nWhen I was looking at the code remapped from shall not cause recursive cycle as this would require to have cyclic dependencies between assemblies.\r\nShall we implement some kind of protection against it as part of this PR? Or having specific issue for it.",
              "createdAt": "2021-02-03T14:29:07Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1010,23 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+        /// <summary>\n+        /// Reads/writes this class\n+        /// </summary>\n+        /// <param name=\"translator\"></param>\n+        public void Translate(ITranslator translator)\n+        {\n+            translator.Translate(ref asAssemblyName);\n+            translator.Translate(ref asString);\n+            translator.Translate(ref isSimpleName);\n+            translator.Translate(ref hasProcessorArchitectureInFusionName);\n+            translator.Translate(ref immutable);\n+            \n+            // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I don't think there can be (currently) because the only places we add to the remapped assembly list, we add a clone instead, and the method is internal, so the only risk is if we add the possibility of creating a cyclic dependency. Additionally, the method currently disallows adding non-immutable ANEs, so we would have to either change that or ignore immutability and then permit the creation of a cycle for that to happen. I don't think giving it a nice error message is worth the cycles.",
              "createdAt": "2021-02-03T15:00:33Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1010,23 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+        /// <summary>\n+        /// Reads/writes this class\n+        /// </summary>\n+        /// <param name=\"translator\"></param>\n+        public void Translate(ITranslator translator)\n+        {\n+            translator.Translate(ref asAssemblyName);\n+            translator.Translate(ref asString);\n+            translator.Translate(ref isSimpleName);\n+            translator.Translate(ref hasProcessorArchitectureInFusionName);\n+            translator.Translate(ref immutable);\n+            \n+            // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Unfortunately it is shallow Clone  and do not clone `remappedFrom` ",
              "createdAt": "2021-02-03T15:49:06Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1010,23 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+        /// <summary>\n+        /// Reads/writes this class\n+        /// </summary>\n+        /// <param name=\"translator\"></param>\n+        public void Translate(ITranslator translator)\n+        {\n+            translator.Translate(ref asAssemblyName);\n+            translator.Translate(ref asString);\n+            translator.Translate(ref isSimpleName);\n+            translator.Translate(ref hasProcessorArchitectureInFusionName);\n+            translator.Translate(ref immutable);\n+            \n+            // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't it be better to assert stateFile cannot be null via ErrorUtilities.Verify...NotNull instead of letting the method silently ignore it? Same for deserialization.",
              "createdAt": "2021-02-04T02:27:52Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "It is consistent with current behavior, see former: https://github.com/dotnet/msbuild/blob/4b9f6122dfc8397ee0d939d7932df9cd5818c90c/src/Tasks/StateFileBase.cs#L37\r\nI believe `stateFile` is optionable parameter of RAR and its omision results in no cache persistence.",
              "createdAt": "2021-02-04T09:45:52Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Okay, I guess it's a dubious precedent, but a precedent nonetheless :)",
              "createdAt": "2021-02-04T17:48:31Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,14 +239,107 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n         }\n \n         /// <summary>\n-        /// Serialize the contents of the class.\n+        /// Writes the contents of this object out to the specified file.\n+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class\n+        /// </summary>\n+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            try\n+            {\n+                if (!string.IsNullOrEmpty(stateFile))",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      }
    ]
  }
}