{
  "number": 9748,
  "title": "Do not import project extensions during restore",
  "body": "Fixes #9512\r\n\r\n### Context\r\nDuring restore, MSBuild needs to evaluate the entry project and during this evaluation if any of the project extension files that NuGet generates (`project.nuget.g.props` and `project.nuget.g.targets`) they are used during the next restore.  Another side effect is the files that exist on disk at the beginning of restore are embedded in the binary log and not the ones that are generated by NuGet.\r\n\r\n### Changes Made\r\nIntroduced a new property `MSBuildIsRestoring` which is set during an implicit restore (`/restore`) or an explicit restore (`/Target:restore`) so that we don't need to take a dependency on `MSBuildRestoreSessionId`.  This is now a property users can key off of to detect if a command-line based restore is running.  \r\n\r\nDefault `ImportProjectExtensionProps` and `ImportProjectExtensionTargets` to `false` if `MSBuildIsRestoring` is `true` unless a users has explicitly set `ImportProjectExtensionProps` or `ImportProjectExtensionTargets` to `true`.  This allows users to bring back the old behavior if desired.\r\n\r\nI also added `MSBuildRestoreSessionId` and `MSBuildIsRestoring` to `MSBuildConstants` so their names can be defined in a single place.\r\n\r\n### Testing\r\nAdded to existing unit tests to verify\r\n1. `ImportProjectExtensionProps` and `ImportProjectExtensionTargets` default to `false` if `MSBuildIsRestoring` is `true`\r\n2. When `ImportProjectExtensionProps` and `ImportProjectExtensionTargets` are set to `true`, their values are not set even if `MSBuildIsRestoring` is `true`\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2024-02-15T18:18:51Z",
  "updatedAt": "2024-03-07T23:18:51Z",
  "closedAt": "2024-02-28T10:29:02Z",
  "mergedAt": "2024-02-28T10:29:02Z",
  "additions": 91,
  "deletions": 3,
  "changedFiles": 6,
  "headRefName": "msbuild-is-restoring",
  "isDraft": false,
  "author": {
    "login": "jeffkl"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "jeffkl"
      }
    ]
  },
  "labels": [
    "Area: Debuggability"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3b86aa3eb57b5878976c021c39f5dbfb888d21ea",
          "message": "Do not import project extensions during restore\n\nFixes https://github.com/dotnet/msbuild/issues/9512",
          "committedDate": "2024-02-15T18:10:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c2597226b3768ae09ed6abbea6da3036a7a69521",
          "message": "Update src/Shared/Constants.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2024-02-15T19:18:48Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5303c161ac80f07297396a591fe17e0b8aecb65",
          "message": "Add ChangeWave condition",
          "committedDate": "2024-02-15T19:51:03Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "677b98735bc51268be9c546c90fec90ede605f28",
          "message": "Fix wording",
          "committedDate": "2024-02-15T22:28:01Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "FYI @KirillOsenkov ",
        "createdAt": "2024-02-15T18:19:03Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "> Looks great. I guess adding more special-case handling of the `restore` target should boost the priority of #9553.\r\n\r\n100% agree on we should add mechanism flagging that issue.\r\nThough it seems it won't be able to benefit from this change - as the Restore in this case is 'marked' only if it's the only executed target of the build and explicitly specified. If multiple targets are explicitly given (e.g. `/t:'Build;Execute'`), or if the Restore is added in the script (e.g. `InitialTragets=\"Restore\"` or `<BuildDependsOn>$(BuildDependsOn);Restore</BuildDependsOn>`) then it's not marked.\r\nSo we'll probably need to infer the situation from the build execution (e.g. TargetStartedEvent args with the Restore or Pack target and as well as with the Build target are encountered with the same ProjectContextId)",
        "createdAt": "2024-02-16T15:22:37Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I wonder if in this case we could get away with adding a high-importance message right to `XMake.cs` (as opposed to building an analyzer).",
        "createdAt": "2024-02-16T15:33:02Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> I wonder if in this case we could get away with adding a high-importance message right to `XMake.cs` (as opposed to building an analyzer).\r\n\r\nI support that!\r\n\r\nIt wouldn't catch the case of restore run requested via dependencies definition - but I'd hope it's rather esoteric. And even if it wouldn't be esoteric - check in XMake is cheap and we can have it quickly...  - do you want to shoot a PR? :-)",
        "createdAt": "2024-02-16T16:46:39Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Wait, I don't think I understand what the message is for? Is it \"you're running Restore and something else in the same invocation\"?",
        "createdAt": "2024-02-16T16:50:59Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Yes, it would basically warn against `/t:Restore;SomethingElse`. Because it looks like it's broken enough to maybe warrant this.",
        "createdAt": "2024-02-16T16:58:39Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I fear that's the same kind of \"breaking change\" we've had to back out before. I think the analyzer-related \"have a way to opt into new warnings\" would have to be in place first.",
        "createdAt": "2024-02-16T17:05:19Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Question for everyone:\r\n\r\nShould this pull request also set `EmbedProjectAssetsFile` to `false` or should I update the .NET SDK to default `EmbedProjectAssetsFile` to `false` when `MSBuildIsRestoring` is `true`?\r\n\r\nhttps://github.com/dotnet/sdk/blob/7b872bf735f7d86b6c20281ab9f7a55d9c712a91/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.PackageDependencyResolution.targets#L69",
        "createdAt": "2024-02-16T17:37:09Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "I'd leave that definition in the SDK I think.",
        "createdAt": "2024-02-16T19:17:18Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Hi @jeffkl,\r\n\r\nThese changes backfired in an unusual way for the tests in sdk (e.g. https://github.com/dotnet/sdk/pull/39093)\r\nYou can see the attached binlogs here\r\n[sdk_test_binlogs.zip](https://github.com/dotnet/msbuild/files/14513235/sdk_test_binlogs.zip)\r\n\r\nIn the [test](https://github.com/dotnet/sdk/blob/0a2a432e980a143c6f7a9827d3ce015b39564427/test/Microsoft.NET.Publish.Tests/GivenThatWeWantToRunILLink.cs#L100), publish and restore are run on the same project separately, and on restore execution PublishTrimmed switch is passed in a special way\r\nhttps://github.com/dotnet/sdk/blob/0a2a432e980a143c6f7a9827d3ce015b39564427/test/Microsoft.NET.Publish.Tests/GivenThatWeWantToRunILLink.cs#L2252  (hopefully @MiYanni has some story behind this, please let us know!)\r\n In fact it writes a new property to *.g.targets and expects from msbuild to react to it!\r\n<img width=\"353\" alt=\"image\" src=\"https://github.com/dotnet/msbuild/assets/95473390/e6c455ba-6e31-4180-b313-9a9d52e2eea0\">\r\n\r\nSince restore happens after publish, project is considered as up to date and this stage is skipped:\r\n![image](https://github.com/dotnet/msbuild/assets/95473390/953d33d1-d14d-41b8-8dd7-d4b8a2050ddf)\r\n\r\nAs a possible strategies we can suggest:\r\n1. Make changes on MSBuild side and check *.g.targets for up to date state;\r\n2. Revert the changes if it can be considered as a real world scenario;\r\n3. Probably something can be adapted on the Nuget's side (?).\r\n\r\nPlease share you opinion on that! \r\nThank you.\r\n",
        "createdAt": "2024-03-06T17:20:50Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "also adding @Forgind for his insights",
        "createdAt": "2024-03-06T18:58:29Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "If my understanding is correct, we should update the tests to account for the new behavior. \r\n\r\nI've filed an issue here and added some details:\r\nhttps://github.com/dotnet/sdk/issues/39266",
        "createdAt": "2024-03-06T19:17:36Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "jeffkl and I investigated this yesterday in the SDK insertion PR and found the same root cause as YuliiaKovalova. We also decided it's probably best to just update the tests. We're still talking a bit (with dsplaisted) about how big of a breaking change it likely is and what we should do about it. Thanks for the parallel investigation!",
        "createdAt": "2024-03-06T20:15:49Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> If my understanding is correct, we should update the tests to account for the new behavior.\r\n> \r\n> I've filed an issue here and added some details: [dotnet/sdk#39266](https://github.com/dotnet/sdk/issues/39266)\r\n\r\nEven switching to inline argument will help!\r\n<img width=\"827\" alt=\"image\" src=\"https://github.com/dotnet/msbuild/assets/95473390/1cc8ff1d-a1d2-4626-93f0-66ce167b87c1\">\r\n\r\nBut I though it was intentionally passed this way for checking some specific scenario which I am not aware of.\r\n",
        "createdAt": "2024-03-07T09:43:46Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "@YuliiaKovalova\r\n\r\nI was trying to understand how I'm related to this since I don't even know what this is. Took me a second as I looked at the blame on the file, and I'm *not* in the blame. However, I'm in the commit history for the file because I moved *every test in the repo* in [this PR](https://github.com/dotnet/sdk/pull/37200). So, I'd just recommend looking at the blame history over the commit history since it usually gives you a more accurate gauge of the people involved.",
        "createdAt": "2024-03-07T23:18:50Z",
        "author": {
          "login": "MiYanni"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        /// A property set during an implicit restore (/restore) or explicit restore (/t:restore) to indicate that a restore is executing.\r\n```",
              "createdAt": "2024-02-15T18:52:54Z",
              "path": "src/Shared/Constants.cs",
              "diffHunk": "@@ -69,6 +69,17 @@ internal static class MSBuildConstants\n \n         internal const string MSBuildDummyGlobalPropertyHeader = \"MSBuildProjectInstance\";\n \n+        /// <summary>\n+        /// A property set during a in implicit restore (/restore) or explicit restore (/t:restore) to ensure that the evaluations are not re-used during build\n+        /// </summary>\n+        internal const string MSBuildRestoreSessionId = nameof(MSBuildRestoreSessionId);\n+\n+        /// <summary>\n+        /// A property set during a in implicit restore (/restore) or explicit restore (/t:restore) to indicate that a restore is executing.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you put these behind changewave 17.10 please? I _hope_ no one is depending on importing these things when they shouldn't be, but you know how these things are.",
              "createdAt": "2024-02-15T18:56:32Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -227,6 +227,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     build.\n   -->\n   <PropertyGroup>\n+    <!--\n+        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed\n+        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other\n+        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionTargets\n+    -->\n+    <ImportProjectExtensionTargets Condition=\"'$(ImportProjectExtensionTargets)' == '' And '$(MSBuildIsRestoring)' == 'true'\">false</ImportProjectExtensionTargets>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Should I put the `MSBuildIsRestoring` property behind a change wave to accomplish this?  Or is there a change wave property/mechanism for props/targets?",
              "createdAt": "2024-02-15T19:18:45Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -227,6 +227,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     build.\n   -->\n   <PropertyGroup>\n+    <!--\n+        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed\n+        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other\n+        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionTargets\n+    -->\n+    <ImportProjectExtensionTargets Condition=\"'$(ImportProjectExtensionTargets)' == '' And '$(MSBuildIsRestoring)' == 'true'\">false</ImportProjectExtensionTargets>",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "There is a property function (`$([MSBuild]::AreFeaturesEnabled('17.10'))`) and I think I'd rather use that since _adding_ the property should be innocuous. But if you've got a reason to go the other way I'd be fine with that too.\r\n\r\n",
              "createdAt": "2024-02-15T19:41:56Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -227,6 +227,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     build.\n   -->\n   <PropertyGroup>\n+    <!--\n+        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed\n+        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other\n+        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionTargets\n+    -->\n+    <ImportProjectExtensionTargets Condition=\"'$(ImportProjectExtensionTargets)' == '' And '$(MSBuildIsRestoring)' == 'true'\">false</ImportProjectExtensionTargets>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}