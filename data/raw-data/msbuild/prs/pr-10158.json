{
  "number": 10158,
  "title": "Document MSBuild Logging",
  "body": "### Context\r\n\r\nCaptures internal workings and design of MSBuild logging\r\n\r\nCouple comments within code adjusted/clarified as well\r\n",
  "state": "MERGED",
  "createdAt": "2024-05-20T12:11:47Z",
  "updatedAt": "2024-06-09T19:13:50Z",
  "closedAt": "2024-06-09T19:13:46Z",
  "mergedAt": "2024-06-09T19:13:46Z",
  "additions": 159,
  "deletions": 7,
  "changedFiles": 12,
  "headRefName": "doc/logging",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c11283bfc7d88d3dca4c3c079bcbe49fbee313e8",
          "message": "Document MSBuild Logging",
          "committedDate": "2024-05-20T12:10:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59cc4e2dcda2df8fc7a1c95976155a5c24943e5a",
          "message": "Adjust whitespaces format",
          "committedDate": "2024-05-20T12:16:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6bafc7df879d2f50ad21dff66833c0472d0eee40",
          "message": "Update based on review",
          "committedDate": "2024-05-23T12:22:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "00a71c3a72d1c65c9265c22b2b992839d77d9f7b",
          "message": "Apply suggestions from code review\n\nCo-authored-by: AR-May <67507805+AR-May@users.noreply.github.com>\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2024-05-31T13:40:26Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e82cff8cb2995e1cc853775c15ff6ffb990131c6",
          "message": "Reflecting PR review comments",
          "committedDate": "2024-05-31T14:16:52Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "On the sentence about Central Loggers. I'm not sure the wording is great. I'm a bit confused about the use of \"transparent\". Are those central loggers able to see the multiprocessor execution node?",
              "createdAt": "2024-05-20T14:11:34Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "reworded to\r\n\r\n```\r\n(...) or they can operate in a mode where the distributed execution is not visible to them\r\n```\r\n\r\nNot sure if that reads better?",
              "createdAt": "2024-05-23T12:14:05Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "That reads better. thank you.",
              "createdAt": "2024-05-23T12:31:39Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is OOP? Could you write it in the format: \"Abbreviation Meaning (AM)\"?",
              "createdAt": "2024-05-20T14:19:09Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "I just saw that it is defined later. Maybe we can bring that bullet point up so we have that context here.",
              "createdAt": "2024-05-20T14:22:29Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "Reordered",
              "createdAt": "2024-05-23T12:16:38Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "None of the images are loading properly. I think you need to add the relative path for them to load.",
              "createdAt": "2024-05-20T14:21:08Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "It is a deficiency of the PR viewing. For the actual appearance (and working links) you'd need to view it in the source branch: https://github.com/JanKrivanek/msbuild/blob/doc/logging/documentation/wiki/Logging-Internals.md",
              "createdAt": "2024-05-23T12:21:22Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I had to google what \"demultiplexes\" means, could we use an easier word?",
              "createdAt": "2024-05-20T14:29:39Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which demultiplexes separate design time and build time invocation build events into a single registered logger)",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "Good point - replaced with 'combines'",
              "createdAt": "2024-05-23T12:19:12Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which demultiplexes separate design time and build time invocation build events into a single registered logger)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "typo: properteis -> properties",
              "createdAt": "2024-05-20T14:45:30Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which demultiplexes separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properteis in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a difference betwwe SinkId and LoggerID? Or is it just different names for the same thing?",
              "createdAt": "2024-05-20T15:46:08Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which demultiplexes separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properteis in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "It is the same thing. But different components in code refer to it via those 2 different terms - so I wanted to make it explicit here that it's the same thing",
              "createdAt": "2024-05-23T12:22:36Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,141 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where that fact is completely transparent to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which demultiplexes separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properteis in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\nMSBuild allows plugging in inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred to as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\r\n```",
              "createdAt": "2024-05-27T08:38:37Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\nIn this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So, this document is mainly targeted to MSBuild project developer or a curious user.\r\n```",
              "createdAt": "2024-05-27T08:42:33Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n* **Distributed Logger** - It is a pair of a Central Logger and a Forwarding Logger.\r\n```",
              "createdAt": "2024-05-27T08:52:08Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred to as sinkId) and sending them through node -> node communication\r\n```",
              "createdAt": "2024-05-27T09:45:22Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n ### Delivery of events in a single-node build\r\n```",
              "createdAt": "2024-05-28T16:27:18Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n* Each forwarder process the trace stream and may choose to forward to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\r\n```",
              "createdAt": "2024-05-28T16:30:47Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n* Each forwarder processes the trace stream and optionally forwards each event to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\r\n```",
              "createdAt": "2024-05-28T16:33:09Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "IMO this should be \r\n```suggestion\r\n #### Scheduler Node\r\n```\r\n\r\nthat it is generally the entrypoint isn't the interesting part.",
              "createdAt": "2024-05-28T16:34:08Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).\n+* `BuildEventArgTransportSink` bundles the tracing data (instance of `BuildEventArgs`) together with the SinkId and passes it down the pipeline that enqueues data for remoting to the Entrypoint Node.\n+\n+Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![OOP Node Logging](OOPNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![OOP Node Logging - stack](OOPLoggingStack.png)\n+\n+ #### Entrypoint Node",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good point - if there is a 'thin client' in the future - this would became confusing (or even wrong). I'm replacing the term in the whole doc.",
              "createdAt": "2024-05-31T13:40:19Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).\n+* `BuildEventArgTransportSink` bundles the tracing data (instance of `BuildEventArgs`) together with the SinkId and passes it down the pipeline that enqueues data for remoting to the Entrypoint Node.\n+\n+Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![OOP Node Logging](OOPNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![OOP Node Logging - stack](OOPLoggingStack.png)\n+\n+ #### Entrypoint Node",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "> This behavior is of course only in the current state - it can be subject to change.\r\n\r\nCould it? I don't think violating sequential delivery ever makes sense.",
              "createdAt": "2024-05-28T16:35:29Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).\n+* `BuildEventArgTransportSink` bundles the tracing data (instance of `BuildEventArgs`) together with the SinkId and passes it down the pipeline that enqueues data for remoting to the Entrypoint Node.\n+\n+Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![OOP Node Logging](OOPNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![OOP Node Logging - stack](OOPLoggingStack.png)\n+\n+ #### Entrypoint Node\n+\n+ * `LoggingService` recives the remoted data - the instance of `BuildEventArgs` bundled with the SinkId.\n+ * Based on the SinkId the `LoggingService` routes the received data to the registered `EventSourceSink` (one per registered forwarder).\n+ * `EventSourceSink` distributes the events to the subscribed Loggers (again - up to single subscribed logger in case of [distributed loggers registrations](#RegisterDistributedLogger), possible multiple loggers in case of [central loggers registrations](#RegisterLogger))\n+\n+ Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![EntryPoint Node Logging](EntryPointNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![EntryPoint Node Logging - stack](RemotedLoggingStack.png)\n+\n+### Synchronous and Asynchronous events processing\n+\n+As was mentioned in the [`ProcessLoggingEvent`](#ProcessLoggingEvent) description - the `LoggingService` can deliver the logging events either in a synchronous or asynchronous mode.\n+\n+The logging mode is dictated by the `LoggerMode` that is injected into the `LoggingService` as such:\n+ * In the Out Of Proc node the mode is always **asynchronous**.\n+ * In the Entrypoint node the mode is by default **synchronous**, unless the `MSBUILDLOGASYNC` environment variable is set to `\"1\"`\n+ * For `ProjectCollection` the mode depends on the construction argument `useAsynchronousLogging`. In signatures that do not ask this argument - it defaults to **synchronous**.\n+\n+Regardless of the mode used - sequential and isolated delivery of events is always guaranteed (single logger will not receive next event before returning from the previous, any logger will not receive an event while it's being processed by a different logger). This behavior is of course only in the current state - it can be subject to change.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This was refering to the '`any logger will not receive an event while it's being processed by a different logger`' part - I'll rephrase",
              "createdAt": "2024-05-31T13:52:06Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).\n+* `BuildEventArgTransportSink` bundles the tracing data (instance of `BuildEventArgs`) together with the SinkId and passes it down the pipeline that enqueues data for remoting to the Entrypoint Node.\n+\n+Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![OOP Node Logging](OOPNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![OOP Node Logging - stack](OOPLoggingStack.png)\n+\n+ #### Entrypoint Node\n+\n+ * `LoggingService` recives the remoted data - the instance of `BuildEventArgs` bundled with the SinkId.\n+ * Based on the SinkId the `LoggingService` routes the received data to the registered `EventSourceSink` (one per registered forwarder).\n+ * `EventSourceSink` distributes the events to the subscribed Loggers (again - up to single subscribed logger in case of [distributed loggers registrations](#RegisterDistributedLogger), possible multiple loggers in case of [central loggers registrations](#RegisterLogger))\n+\n+ Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![EntryPoint Node Logging](EntryPointNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![EntryPoint Node Logging - stack](RemotedLoggingStack.png)\n+\n+### Synchronous and Asynchronous events processing\n+\n+As was mentioned in the [`ProcessLoggingEvent`](#ProcessLoggingEvent) description - the `LoggingService` can deliver the logging events either in a synchronous or asynchronous mode.\n+\n+The logging mode is dictated by the `LoggerMode` that is injected into the `LoggingService` as such:\n+ * In the Out Of Proc node the mode is always **asynchronous**.\n+ * In the Entrypoint node the mode is by default **synchronous**, unless the `MSBUILDLOGASYNC` environment variable is set to `\"1\"`\n+ * For `ProjectCollection` the mode depends on the construction argument `useAsynchronousLogging`. In signatures that do not ask this argument - it defaults to **synchronous**.\n+\n+Regardless of the mode used - sequential and isolated delivery of events is always guaranteed (single logger will not receive next event before returning from the previous, any logger will not receive an event while it's being processed by a different logger). This behavior is of course only in the current state - it can be subject to change.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "?",
              "createdAt": "2024-05-28T16:35:59Z",
              "path": "src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs",
              "diffHunk": "@@ -1849,7 +1849,7 @@ public static IBuildComponent CreateLoggingService(LoggerMode mode, int nodeId,\n             /// Override the method to log which event was processed so it can be verified in a test\n             /// </summary>\n             /// <param name=\"buildEvent\">Build event which was asked to be processed</param>\n-            internal override void ProcessLoggingEvent(object buildEvent)\n+            protected override void ProcessLoggingEvent(object buildEvent)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "fixed to `protected internal`",
              "createdAt": "2024-05-31T14:16:33Z",
              "path": "src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs",
              "diffHunk": "@@ -1849,7 +1849,7 @@ public static IBuildComponent CreateLoggingService(LoggerMode mode, int nodeId,\n             /// Override the method to log which event was processed so it can be verified in a test\n             /// </summary>\n             /// <param name=\"buildEvent\">Build event which was asked to be processed</param>\n-            internal override void ProcessLoggingEvent(object buildEvent)\n+            protected override void ProcessLoggingEvent(object buildEvent)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels like too much info for the summary. Move to remarks?",
              "createdAt": "2024-05-28T16:37:15Z",
              "path": "src/Framework/INodeLogger.cs",
              "diffHunk": "@@ -8,9 +8,11 @@\n namespace Microsoft.Build.Framework\n {\n     /// <summary>\n-    /// This interface defines a \"parallel aware logger\" in the build system. A parallel aware logger\n-    /// will accept a cpu count and be aware that any cpu count greater than 1 means the events will\n-    /// be received from the logger from each cpu as the events are logged.\n+    /// This interface defines a logger that will receive information about number of logical execution\n+    /// nodes that will be executing the build requests and producing the build events.\n+    /// Implementing loggers (same as loggers implementing ILogger) will be registered as so called 'central logger',\n+    /// which means that they will be receiving all events in the serialized order (either via locking or via delivery via single thread).\n+    /// This means that the implementation doesn't need to be thread safe.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't make sense to me. Can you elaborate? I thought we'd forward an event if any of the distributed loggers asked for that and then on the central side pass any received event to all registered loggers. Is that not true? If not what happens if two loggers forward an event, is it serialized multiple times?",
              "createdAt": "2024-05-28T16:39:07Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).\n+* `BuildEventArgTransportSink` bundles the tracing data (instance of `BuildEventArgs`) together with the SinkId and passes it down the pipeline that enqueues data for remoting to the Entrypoint Node.\n+\n+Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![OOP Node Logging](OOPNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![OOP Node Logging - stack](OOPLoggingStack.png)\n+\n+ #### Entrypoint Node\n+\n+ * `LoggingService` recives the remoted data - the instance of `BuildEventArgs` bundled with the SinkId.\n+ * Based on the SinkId the `LoggingService` routes the received data to the registered `EventSourceSink` (one per registered forwarder).",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If multiple distributed loggers are registered and they all request forwarding of a particular event, then it is being serialized and sent multiple times:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/49afd897383524da3d6e342b8254dfa8486a3400/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs#L135-L151",
              "createdAt": "2024-05-31T13:29:09Z",
              "path": "documentation/wiki/Logging-Internals.md",
              "diffHunk": "@@ -0,0 +1,142 @@\n+# Logging Internals\n+\n+MSBuild allows to plug inbox and custom loggers - those can be registered via the API or CLI and will be receiving rich tracing information during the build process (here as well referred as `BuildEventArgs`). Detailed article from user point of view can be found on Microsoft Learn: [Build Loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-loggers)\n+\n+\n+Logging architecture allows usage in distributed execution nature of MSBuild (as [MSBuild has multi-process execution modes](Nodes-Orchestration.md#need-for-multiple-processes)) while pluggable logger might decide to be aware of the situation (then we speak about so called '*Distributed Loggers*') or they can operate in a mode where the distributed execution is not visible to them (they can be referred to as '*Central Loggers*'). Detailed article from user point of view can be found on Microsoft Learn: [Write multi-processor-aware loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/writing-multi-processor-aware-loggers) and [Create forwarding loggers](https://learn.microsoft.com/en-us/visualstudio/msbuild/creating-forwarding-loggers)\n+\n+In this document we'll be describing mainly the internal design and implementation of the Logging infrastructure. We won't be going into actual implementation of individual loggers or a way to author custom one. So this is mainly targeted to MSBuild project developer or a curious user.\n+\n+## Terminology\n+\n+* **Entrypoint node** - build process that was created to serve the build request (either from CLI, API or from Visual Studio via API).\n+* **In-Proc node** - the build executing unit that is running in the 'Entrypoint node'\n+* **Out-Of-Proc node** / **OOP node** - the build executing unit that is running in the separate process.\n+* **Logger** - an implementor of `ILogger` (or `INodeLogger`) interface. Such a component then can be registered to receive detailed tracing info from the build process and process the info further. The most common use-case is logging the information into the console, file etc. - hence the name 'Logger', but it can be processed for other purposes (e.g. the [ParallelBuildDebuggingLogger](https://github.com/rainersigwald/parallelbuilddebugginglogger) for debugging purposes, or the BuildCheck for diagnostics).\n+* **Central Logger** - a logger that runs in the Central node - as well here referred to as the 'Entrypoint Node'. It receives the information from the whole build regardless of if it's executed within single or multiple processes.\n+* **Forwarding Logger** - a logger that has a single instance in each logical executing node and is capable of filtering and/or alter the tracing stream formed of the `BuildEventArg`s before it undergoes serialization and remoting into the Entrypoint node. Main built-in implementations are: `CentralForwardingLogger` and `ConfigurableForwardingLogger`.\n+* **Distributed Logger** - It is a pair of Central Logger and a 'Forwarding Logger'\n+* <a name=\"LoggerDescription\"></a>**LoggerDescription** - Serializable information describing the Forwarding Logger - so that the forwarding logger can be constructed in the OOP node. It also holds the 'LoggerId' (AKA 'SinkId') - so that the remote data can be properly routed to the Central Logger. Other notable datapoints are `Verbosity` and `LoggerSwitchParameters` - which both serves for proper initialization of the forwarder after it's constructed in OOP node.\n+\n+  ![Distributed Logger](distnode.png)\n+* **EventSource** - source of the tracing events - either from the life build process or replayed post-hoc from the stored source.\n+* **Sink** - Consumer of the tracing data that exposes and fires them as events - serving as a 'EventSource' for the consuming Logger\n+\n+## LoggingService\n+\n+`LoggingService` is the backbone of the Logging Infrastructure - it serves as the consumer of the logging from the build process and as a dispatcher to the individual distributed and central loggers (and internally as well as x-process transmission channel for the tracing in OOP nodes).\n+\n+There is a single instance in the Entrypoint node, single instance within each out-of-proc node and one in ProjectCollection (for standalone API driven evaluation). So, we can technically treat `LoggingService` as a singleton.\n+\n+### Methods overview\n+\n+<a name=\"RegisterLogger\"></a>**`RegisterLogger(ILogger logger)`**\n+\n+* Registers logger as distributed with a single CentralForwardingLogger (regardless of number of calls to the method - just single forwarder)\n+* Called by BuildManager when starting the build (on the entrypoint node)\n+* Called by ProjectCollection to register loggers for operations through OM/API. ProjectCollection registers the loggers wrapped by `ReusableLogger` (which combines separate design time and build time invocation build events into a single registered logger)\n+\n+\n+<a name=\"RegisterDistributedLogger\"></a>**`RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)`**\n+\n+* The central logger runs in the Entrypoint node and the forwarding logger in the out-of-proc worker node\n+* It creates (1 for each distributed logger) `EventSourceSink` (to be run on the EntrypointNode, where it serves as the `IEventSource` for the registered central loggers (pumping events into them). `LoggingService` in the EntrypointNode multiplexes the build events to the appropriate `EventSourceSink` based on source forwarding logger the event went through in the OOP node)\n+* It creates (1 for each distributed logger) `EventRedirectorToSink` (to be run on OOP node and to wrap the BuildEvent with the proper LoggerId - so that it can then be multiplexed by the `LoggingService` in the EntrypointNode to the proper `EventSourceSink` and by extension to the proper logger)\n+* It maintains incrementing counter of registered distributed loggers, and each additional logger is assigned next id - to be used as identification for sinks (`EventSourceSink` and `EventRedirectorToSink`) and it adds the id into passed `LoggerDescription` - so that this can be remoted to the OOP node and proper forwarding is initialized.\n+* It creates a single `EventSourceSink` in the LoggingService - this is used by all the forwarders as a source of events.\n+\t\n+\n+<a name=\"InitializeNodeLoggers\"></a>**`InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId)`**\n+* Called from OutOfProcNode.HandleNodeConfiguration - which handles NodeConfiguration 'packet' from the node -> node communiction. (This is as well when the environment and various build-wide configurations - like including evaluated properties in EvaluationFinished events - are received and applied, and as well when LoggingService in OOP node is created)\n+* `BuildEventArgTransportSink` is passed to the LoggingService - it is attached to each forwarding logger together with the central logger id, within a `EventRedirectorToSink`\n+* `BuildEventArgTransportSink` takes care about bundling the build events together with the target logger id (in some contexts referred as sinkId) and sending them through node -> node communication\n+\t\n+<a name=\"ProcessLoggingEvent\"></a>**`ProcessLoggingEvent(object buildEvent)`**\n+* Ingestion point of build events\n+* Can be called either to consume an event logged through the internal API (from LogBuildEvent or Log<XXX> [e.g. `LogBuildStarted`, `LogError` etc.])\n+* Or is called from the node -> node remoting (via PacketReceived)\n+* Ensures isolated delivery - as in synchronous mode it locks, in asynchronous mode it enqueues and delivers from the queue via single thread\n+* The isolated delivery however means that a single slow logger can block all others and that the event consuming time is a sum of all loggers consuming times.\n+ \n+ \n+ ### Delivery of events in a single node build\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder process the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+* `EventRedirectorToSink` forwards to `EventSourceSink` (the instance of `EventSourceSink` was passed to `EventRedirectorToSink` during its construction). There is 1 `EventSourceSink` per each `EventRedirectorToSink`\n+* `EventSourceSink` distributes events to registered Loggers. There can be multiple registered Loggers to the single `EventSourceSink` (this is the case when Logger was registered as 'Central Logger' via [`RegisterLogger`](#RegisterLogger)).\n+\n+\n+![In node logging](InNodeLoggingFlow.png)\n+\n+The above diagram is simplified (it doesn't capture the calls within a single component), the current state of calls (that is subject to changes) is illustrated by the following stack trace capture:\n+\n+![In node logging - stack](InProcLoggingStack.png)\n+\n+ ### Delivery of events in a distributed build\n+\n+ In case of distributed execution of build, NodeManager is requesting execution of additional Out Of Process (OOP) Nodes. Logging events from those nodes are transferred to the Entrypoint node, where they are eventually consumed by the Central Loggers. In addition to the OOP Nodes, build can have a single 'In Proc Node' - an execution node sharing the same process with the Entrypoint Node. For this reason the described process and diagram for the [Delivery of events in a single node build](#delivery-of-events-in-a-single-node-build) can apply fully for the distributed build as well (in addition to the following).\n+\n+ #### OOP Node \n+\n+The initial part of the workflow of logging is identical to the in-proc delivery:\n+\n+* There is 1 instance of LoggingService per build.\n+* It holds 1 instance of EventSourceSink pumping events to forwarders.\n+* There can be multiple forwarders (one shared for all central loggers registered via [`RegisterLogger`](#RegisterLogger) and one per each distributed logger registered via [`RegisterDistributedLogger`](#RegisterDistributedLogger)).\n+Example of forwarders:\n+  * `CentralForwardingLogger`\n+  * `ConfigurableForwardingLogger`\n+* Each forwarder processes the trace stream and forwards to an `EventRedirectorToSink` (1 redirector per 1 forwarder)\n+\n+Processing from `EventRedirectorToSink` differs. This is given by injection of a single sink `BuildEventArgTransportSink` (injected via [`InitializeNodeLoggers`](#InitializeNodeLoggers)) as a consumer of `EventRedirectorToSink` data:\n+\n+* There is single `BuildEventArgTransportSink` per build, that consumes data from all `EventRedirectorToSink`. The data are enriched with the SinkId (AKA LoggerId) - the Id was created during the Logger registration and remoted to the OOP node together with the [`LoggerDescription`](#LoggerDescription).\n+* `BuildEventArgTransportSink` bundles the tracing data (instance of `BuildEventArgs`) together with the SinkId and passes it down the pipeline that enqueues data for remoting to the Entrypoint Node.\n+\n+Simplified diagram of the flow (calls within the single component are omitted):\n+\n+![OOP Node Logging](OOPNodeLoggingFlow.png)\n+\n+Illustrative stack of the sequence of the calls:\n+\n+![OOP Node Logging - stack](OOPLoggingStack.png)\n+\n+ #### Entrypoint Node\n+\n+ * `LoggingService` recives the remoted data - the instance of `BuildEventArgs` bundled with the SinkId.\n+ * Based on the SinkId the `LoggingService` routes the received data to the registered `EventSourceSink` (one per registered forwarder).",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}