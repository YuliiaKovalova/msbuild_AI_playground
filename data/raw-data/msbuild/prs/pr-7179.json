{
  "number": 7179,
  "title": "CA1810 Initialize reference type static fields inline",
  "body": "Relates to #7174",
  "state": "MERGED",
  "createdAt": "2021-12-30T01:00:33Z",
  "updatedAt": "2022-01-31T20:41:30Z",
  "closedAt": "2022-01-31T16:45:32Z",
  "mergedAt": "2022-01-31T16:45:32Z",
  "additions": 64,
  "deletions": 151,
  "changedFiles": 12,
  "headRefName": "CA1810",
  "isDraft": false,
  "author": {
    "login": "elachlan"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "ee41eb2303c70b7baa388bd89adc20ec081056f7",
          "message": "CA1810 Initialize reference type static fields inline",
          "committedDate": "2021-12-30T00:59:48Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "25a0ad0d9ab4128f1a4911d341bb33dd2d892c3a",
          "message": "Update src/Build/Evaluation/ProjectRootElementCache.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-12-30T22:06:03Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb9912197c679492036dce216f4061d31dcfb6aa",
          "message": "unindent region",
          "committedDate": "2021-12-30T22:11:04Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ebabaaa69d77efd5cf91034267d9d0a961a09478",
          "message": "Revert CodeAnalysis.ruleset",
          "committedDate": "2022-01-08T00:22:32Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f4123a5b6d18f785170180b6f9251eae8dbb1e60",
          "message": "merge master",
          "committedDate": "2022-01-08T00:22:46Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "97bab175f78ad026891760d41b13da846a6155c8",
          "message": "enable warning on CA1810",
          "committedDate": "2022-01-08T00:23:06Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "60126c50272cc1b7ada0b79437cd761d21af288b",
          "message": "Fix remaining occurrences of CA1810 violations",
          "committedDate": "2022-01-08T01:40:36Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9c7e8a160ddede79e020c1d9ab36f43bafd4cdc",
          "message": "handle null value after cast",
          "committedDate": "2022-01-08T01:58:17Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7ad2b518107cd277e807b827e9e67e1f3bdd381b",
          "message": "Merge branch 'main' into CA1810",
          "committedDate": "2022-01-10T22:42:04Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4140c8f568209fa0e128f0e47a22055bd5a3d2cd",
          "message": "Remove static constructors",
          "committedDate": "2022-01-18T23:30:22Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c0dfd4f0777e711f28a1a40babbd112b78b964a",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2022-01-18T23:49:38Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4bdda5bd1e70d2398badb79b92d20d27b840eaab",
          "message": "refactor from code review",
          "committedDate": "2022-01-18T23:51:20Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb3ca9f91758ad7b4c3dbae7722d7d72a8fd4b7b",
          "message": "Change from review",
          "committedDate": "2022-01-25T22:14:36Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "158e42946c7a3d0d82bb149a8b0592493786ba3a",
          "message": "Lazy initialization of Spec Dictionaries",
          "committedDate": "2022-01-26T23:17:08Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19b78aec9c9da34aec6dcad4db1de4e2c3b5c4d5",
          "message": "Merge branch 'main' into CA1810",
          "committedDate": "2022-01-26T23:21:09Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6342047711d360d09d4f2e9ae67d31296c61914c",
          "message": "Merge branch 'main' into CA1810",
          "committedDate": "2022-01-26T23:27:35Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a36f0844a6593a6bcd7e074641253b1f9713845b",
          "message": "Changes from review plus a few other fixes",
          "committedDate": "2022-01-27T10:39:58Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "There are still 3 occurrences that I believe are false positives. I can add a suppression, but I think if this takes a while to merge it might be fixed in the analyzer by then.",
        "createdAt": "2022-01-08T02:03:00Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "> Looks good! I'm assuming the false positive problem isn't about to be resolved, though we also shouldn't be merging right now because our last insertion failed for some reason, so we have a little time.\r\n\r\nThere is only one false positive and it has a suppression now. The other two were me not fully reading the analyzer article and understanding what it wanted me to do. Hence the fixes I just submitted.",
        "createdAt": "2022-01-18T23:53:14Z",
        "author": {
          "login": "elachlan"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does it think this is problematic?",
              "createdAt": "2021-12-30T04:57:35Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -41,7 +41,9 @@ internal static class ItemGroupLoggingHelper\n         /// to materialize the Message as that's a declaration assembly. We inject the logic\n         /// here.\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think it is a false positive. Since the variables that it is assigning to are not members of the class. But are static members of other static classes.\r\n\r\nMoving those inline would change the logic.",
              "createdAt": "2021-12-30T22:33:35Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -41,7 +41,9 @@ internal static class ItemGroupLoggingHelper\n         /// to materialize the Message as that's a declaration assembly. We inject the logic\n         /// here.\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Gotcha. Sounds good.",
              "createdAt": "2021-12-30T22:38:04Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -41,7 +41,9 @@ internal static class ItemGroupLoggingHelper\n         /// to materialize the Message as that's a declaration assembly. We inject the logic\n         /// here.\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@elachlan can you please file an issue on https://github.com/dotnet/roslyn-analyzers about this false positive?",
              "createdAt": "2022-01-04T22:39:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -41,7 +41,9 @@ internal static class ItemGroupLoggingHelper\n         /// to materialize the Message as that's a declaration assembly. We inject the logic\n         /// here.\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "jmarolf"
              }
            },
            {
              "body": "It may be a false positive given the semantics of this analyzer but it is indeed a weird construct. I'd say it's good that it was flagged. According to the comment this static ctor exists to work around a layering limitation. And it's actually triggered rather explicitly:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/fb700f90493a0bf47623511edf28b1d6c114e4fa/src/Build/BackEnd/Components/Logging/LoggingService.cs#L302-L304\r\n\r\nI suspect the right fix would be to refactor it into an ordinary method, possibly not on this type, and make sure it runs on relevant initialization paths. In a separate PR.",
              "createdAt": "2022-01-19T07:55:15Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -41,7 +41,9 @@ internal static class ItemGroupLoggingHelper\n         /// to materialize the Message as that's a declaration assembly. We inject the logic\n         /// here.\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm tempted to propose:\r\n```suggestion\r\n        private static readonly int s_maximumStrongCacheSize = !string.IsNullOrEmpty((string s = Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\"))) ?\r\n            Convert.ToInt32(s, NumberFormatInfo.InvariantInfo) : 200;\r\n```\r\n\r\nHonestly not sure which I like better. I like inlining most of these, but this one is messy.",
              "createdAt": "2021-12-30T21:07:17Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -69,20 +69,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-        private static readonly int s_maximumStrongCacheSize = 200;\n+        private static readonly int s_maximumStrongCacheSize = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\")) ?\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\"), NumberFormatInfo.InvariantInfo)  : 200;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Actually, Environment.GetEnvironmentVariable returns null if it isn't defined; how about:\r\n```suggestion\r\n        private static readonly int s_maximumStrongCacheSize =\r\n            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\") ?? \"200\", NumberFormatInfo.InvariantInfo);\r\n```\r\n?",
              "createdAt": "2021-12-30T21:08:47Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -69,20 +69,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-        private static readonly int s_maximumStrongCacheSize = 200;\n+        private static readonly int s_maximumStrongCacheSize = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\")) ?\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\"), NumberFormatInfo.InvariantInfo)  : 200;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I also thought that, but what if the environment variable is an empty string value?",
              "createdAt": "2021-12-30T21:43:35Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -69,20 +69,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-        private static readonly int s_maximumStrongCacheSize = 200;\n+        private static readonly int s_maximumStrongCacheSize = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\")) ?\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\"), NumberFormatInfo.InvariantInfo)  : 200;",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "On Windows, empty strings are undefined for environment variables, so that shouldn't be an issue. Linux does differentiate between unset environment variables and empty ones, but ultimately, it shouldn't matter. This is for debugging/testing only and isn't published anywhere. Anyone who relies on this _and_ misuses it deserves to have a broken build.\r\n\r\n(That's also why we don't verify that it's really an integer before we try to coerce it into one.)",
              "createdAt": "2021-12-30T21:58:17Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -69,20 +69,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-        private static readonly int s_maximumStrongCacheSize = 200;\n+        private static readonly int s_maximumStrongCacheSize = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\")) ?\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\"), NumberFormatInfo.InvariantInfo)  : 200;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this one problematic?",
              "createdAt": "2021-12-30T21:09:32Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -124,7 +124,9 @@ public enum ExitType\n         /// <summary>\n         /// Static constructor\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It is initializing static fields here. But there is a big block comment:\r\n```\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Only initialize static fields here, not inline!                           //\r\n//  This forces the type to initialize in this static constructor and thus    //\r\n//  any configuration file exceptions can be caught here.                     //\r\n////////////////////////////////////////////////////////////////////////////////\r\n```\r\nSo I put a suppression in.",
              "createdAt": "2021-12-30T22:30:12Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -124,7 +124,9 @@ public enum ExitType\n         /// <summary>\n         /// Static constructor\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "I'd missed your comment of 2 minutes ago. Are these constructors ever even called? I don't see an explicit call in the code, but are they automatically invoked when you start a build?",
              "createdAt": "2021-12-30T22:31:55Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -124,7 +124,9 @@ public enum ExitType\n         /// <summary>\n         /// Static constructor\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Static ctors are invoked automatically by the runtime, yes. `MSBuildApp` is the entry point so it's not clear why we wouldn't want to do this work at the top of `Main` instead. It should be equivalent unless someone directly calls into other `MSBuildApp` methods (unlikely).",
              "createdAt": "2022-01-19T08:12:55Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -124,7 +124,9 @@ public enum ExitType\n         /// <summary>\n         /// Static constructor\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nunindent?",
              "createdAt": "2021-12-30T21:09:57Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -374,16 +374,10 @@ internal static class FrameworkLocationHelper\n        };\n #endif // FEATURE_WIN32_REGISTRY\n \n-        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;\n-        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict;\n+        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n+        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);\n \n-#endregion // Static member variables\n-\n-        static FrameworkLocationHelper()\n-        {\n-            s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n-            s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);\n-        }\n+        #endregion // Static member variables",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                return HardcodedCultureNames;\r\n```\r\n\r\nAnd move this to the top of the function?",
              "createdAt": "2022-01-18T23:37:38Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -19,35 +19,36 @@ namespace Microsoft.Build.Tasks\n     /// </summary>\n     internal static class CultureInfoCache\n     {\n-        private static readonly HashSet<string> ValidCultureNames;\n+        private static readonly HashSet<string> ValidCultureNames = InitializeValidCultureNames();\n \n-        static CultureInfoCache()\n+        static HashSet<string> InitializeValidCultureNames()\n         {\n-            ValidCultureNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n-\n+            HashSet<string> validCultureNames = new(StringComparer.OrdinalIgnoreCase);\n #if !FEATURE_CULTUREINFO_GETCULTURES\n             if (!AssemblyUtilities.CultureInfoHasGetCultures())\n             {\n-                ValidCultureNames = HardcodedCultureNames;\n-                return;\n+                validCultureNames = HardcodedCultureNames;\n+                return validCultureNames;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        private static readonly bool AllowMOTW = !NativeMethodsShared.IsWindows || (Registry.GetValue(@\"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\.NETFramework\\SDK\", \"AllowProcessOfUntrustedResourceFiles\", null) is string allowUntrustedFiles && allowUntrustedFiles.Equals(\"true\", StringComparison.OrdinalIgnoreCase));\r\n```\r\n?",
              "createdAt": "2022-01-18T23:40:15Z",
              "path": "src/Tasks/GenerateResource.cs",
              "diffHunk": "@@ -923,7 +900,7 @@ public override bool Execute()\n         }\n \n #if FEATURE_COM_INTEROP\n-        private static bool allowMOTW;\n+        private static readonly bool AllowMOTW = !NativeMethodsShared.IsWindows || (Registry.GetValue(@\"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\.NETFramework\\SDK\", \"AllowProcessOfUntrustedResourceFiles\", null) as string ?? string.Empty).Equals(\"true\", StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n        private static readonly Lazy<string> s_version451Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version451));\r\n```",
              "createdAt": "2022-01-18T23:41:52Z",
              "path": "src/Tasks/GetFrameworkPath.cs",
              "diffHunk": "@@ -52,23 +32,22 @@ public override bool Execute()\n         // it still seems to give an advantage perhaps because there is one less string copy.\n         // In a large build, this adds up.\n         // PERF NOTE: We also only find paths we are actually asked for (via <Output> tags)\n-\n-        private static readonly Lazy<string> s_path;\n-        private static readonly Lazy<string> s_version11Path;\n-        private static readonly Lazy<string> s_version20Path;\n-        private static readonly Lazy<string> s_version30Path;\n-        private static readonly Lazy<string> s_version35Path;\n-        private static readonly Lazy<string> s_version40Path;\n-        private static readonly Lazy<string> s_version45Path;\n-        private static readonly Lazy<string> s_version451Path;\n-        private static readonly Lazy<string> s_version452Path;\n-        private static readonly Lazy<string> s_version46Path;\n-        private static readonly Lazy<string> s_version461Path;\n-        private static readonly Lazy<string> s_version462Path;\n-        private static readonly Lazy<string> s_version47Path;\n-        private static readonly Lazy<string> s_version471Path;\n-        private static readonly Lazy<string> s_version472Path;\n-        private static readonly Lazy<string> s_version48Path;\n+        private static readonly Lazy<string> s_path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Latest));\n+        private static readonly Lazy<string> s_version11Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version11));\n+        private static readonly Lazy<string> s_version20Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20));\n+        private static readonly Lazy<string> s_version30Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version30));\n+        private static readonly Lazy<string> s_version35Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35));\n+        private static readonly Lazy<string> s_version40Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version40));\n+        private static readonly Lazy<string> s_version45Path = new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version45));\n+        private static readonly Lazy<string> s_version451Path=new Lazy<string>(() => ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version451));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please add a new private static method and:\r\n\r\n```suggestion\r\n        private static readonly int s_maximumStrongCacheSize = InitializeMaximumStrongCacheSize();\r\n```\r\n\r\nThe initialization expression you wrote makes us parse the string `\"200\"` which is suboptimal.",
              "createdAt": "2022-01-19T08:02:17Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -71,22 +71,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-#pragma warning disable CA1802 // Use literals where appropriate\n-        private static readonly int s_maximumStrongCacheSize = 200;\n-#pragma warning restore CA1802 // Use literals where appropriate\n+        private static readonly int s_maximumStrongCacheSize =\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\") ?? \"200\", NumberFormatInfo.InvariantInfo);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I think this was from my suggestion, since this was pretty clean.\r\n\r\nHow about:\r\n`Int32.TryParse(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\"), out int cacheSize) ? cacheSize : 200`? I don't particularly mind losing the NumberFormatInfo.InvariantInfo, since people shouldn't be relying on that anyway. The static method should also work, and that's easier to make \"clean.\"",
              "createdAt": "2022-01-19T16:32:33Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -71,22 +71,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-#pragma warning disable CA1802 // Use literals where appropriate\n-        private static readonly int s_maximumStrongCacheSize = 200;\n-#pragma warning restore CA1802 // Use literals where appropriate\n+        private static readonly int s_maximumStrongCacheSize =\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\") ?? \"200\", NumberFormatInfo.InvariantInfo);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That works too!",
              "createdAt": "2022-01-19T16:37:55Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -71,22 +71,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-#pragma warning disable CA1802 // Use literals where appropriate\n-        private static readonly int s_maximumStrongCacheSize = 200;\n-#pragma warning restore CA1802 // Use literals where appropriate\n+        private static readonly int s_maximumStrongCacheSize =\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\") ?? \"200\", NumberFormatInfo.InvariantInfo);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2022-01-25T22:30:07Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -71,22 +71,21 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase\n         /// If this number is increased much higher, the datastructure may\n         /// need to be changed from a linked list, since it's currently O(n).\n         /// </remarks>\n-#pragma warning disable CA1802 // Use literals where appropriate\n-        private static readonly int s_maximumStrongCacheSize = 200;\n-#pragma warning restore CA1802 // Use literals where appropriate\n+        private static readonly int s_maximumStrongCacheSize =\n+            Convert.ToInt32(Environment.GetEnvironmentVariable(\"MSBUILDPROJECTROOTELEMENTCACHESIZE\") ?? \"200\", NumberFormatInfo.InvariantInfo);",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This change may be counter-productive. Presumably the debug dump path is needed only if there actually was an exception. With this change we may be initializing it eagerly which is wasted work when no exception is thrown. We can afford to pay the small cost of precise (i.e. non-`beforefieldinit`) initialization on error paths.\r\n\r\nCan you please perform a simple test to see if `GetDebugDumpPath` runs without your changes when the build succeeds?",
              "createdAt": "2022-01-19T08:19:32Z",
              "path": "src/Shared/ExceptionHandling.cs",
              "diffHunk": "@@ -34,12 +34,7 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal static class ExceptionHandling\n     {\n-        private static readonly string s_debugDumpPath;\n-\n-        static ExceptionHandling()\n-        {\n-            s_debugDumpPath = GetDebugDumpPath();\n-        }\n+        private static readonly string s_debugDumpPath = GetDebugDumpPath();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I feel like you teach me something new about C# every week \ud83d\ude01\r\n\r\nWhen would static field be initialized without the static constructor being called? [\"If static field variable initializers are present in the class of the static constructor, they're executed in the textual order in which they appear in the class declaration. The initializers run immediately prior to the execution of the static constructor.\"](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/static-constructors) made it sound like they always happen together.",
              "createdAt": "2022-01-19T16:48:53Z",
              "path": "src/Shared/ExceptionHandling.cs",
              "diffHunk": "@@ -34,12 +34,7 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal static class ExceptionHandling\n     {\n-        private static readonly string s_debugDumpPath;\n-\n-        static ExceptionHandling()\n-        {\n-            s_debugDumpPath = GetDebugDumpPath();\n-        }\n+        private static readonly string s_debugDumpPath = GetDebugDumpPath();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "They do happen together. Field initializers become part of the static ctor at IL level. It's just that depending on whether the class does or doesn't have a static ctor declared in C#, the code may run a different time. Let me link an older article explaining the difference: https://csharpindepth.com/articles/BeforeFieldInit",
              "createdAt": "2022-01-19T17:01:34Z",
              "path": "src/Shared/ExceptionHandling.cs",
              "diffHunk": "@@ -34,12 +34,7 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal static class ExceptionHandling\n     {\n-        private static readonly string s_debugDumpPath;\n-\n-        static ExceptionHandling()\n-        {\n-            s_debugDumpPath = GetDebugDumpPath();\n-        }\n+        private static readonly string s_debugDumpPath = GetDebugDumpPath();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "@ladipro I tested with a small .net framework project. It didn't hit `GetDebugDumpPath` when when the build succeeds before or after the change.",
              "createdAt": "2022-01-25T23:44:21Z",
              "path": "src/Shared/ExceptionHandling.cs",
              "diffHunk": "@@ -34,12 +34,7 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal static class ExceptionHandling\n     {\n-        private static readonly string s_debugDumpPath;\n-\n-        static ExceptionHandling()\n-        {\n-            s_debugDumpPath = GetDebugDumpPath();\n-        }\n+        private static readonly string s_debugDumpPath = GetDebugDumpPath();",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Thank you! Let's go with the change then. There's still a possibility that we will initialize more eagerly - depending on the runtime and the exact code path - plus the initialization has a side-effect of creating a directory (see the `DebugUtils` static ctor) but it's under a debug switch so no biggie.",
              "createdAt": "2022-01-26T10:31:48Z",
              "path": "src/Shared/ExceptionHandling.cs",
              "diffHunk": "@@ -34,12 +34,7 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal static class ExceptionHandling\n     {\n-        private static readonly string s_debugDumpPath;\n-\n-        static ExceptionHandling()\n-        {\n-            s_debugDumpPath = GetDebugDumpPath();\n-        }\n+        private static readonly string s_debugDumpPath = GetDebugDumpPath();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like expensive work. Making it run with the `beforefieldinit` semantics would be OK only if we're sure it's needed everywhere the type `FrameworkLocationHelper` is mentioned (not necessarily actually used). ",
              "createdAt": "2022-01-19T08:22:11Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -376,17 +376,11 @@ internal static class FrameworkLocationHelper\n        };\n #endif // FEATURE_WIN32_REGISTRY\n \n-        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;\n-        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict;\n+        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n+        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Apologies for the inconsistent use of the word \"use\".\r\n- \"Mention\" here means the runtime sees the type because it is for example compiling a method referencing it. Making a method call in the code being compiled, accessing a field, a type check, ..., all these count.\r\n- \"Use\" means an instance is actually created, a static method is called, or a static field is accessed. Actually as in at run-time.",
              "createdAt": "2022-01-19T08:42:27Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -376,17 +376,11 @@ internal static class FrameworkLocationHelper\n        };\n #endif // FEATURE_WIN32_REGISTRY\n \n-        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;\n-        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict;\n+        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n+        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I can say with certainty that not all usages of `FrameworkLocationHelper` depend on `s_dotNetFrameworkSpecDict` or `s_visualStudioSpecDict`. \r\nExample:\r\nhttps://github.com/dotnet/msbuild/blob/4bdda5bd1e70d2398badb79b92d20d27b840eaab/src/Shared/FrameworkLocationHelper.cs#L135\r\n\r\nDoes that mean `s_dotNetFrameworkSpecDict` and `s_visualStudioSpecDict` should keep their initialisation in the static constructor?",
              "createdAt": "2022-01-25T22:13:49Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -376,17 +376,11 @@ internal static class FrameworkLocationHelper\n        };\n #endif // FEATURE_WIN32_REGISTRY\n \n-        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;\n-        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict;\n+        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n+        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Confirming that there are scenarios where we run static initialization but end up not needing `s_dotNetFrameworkSpecDict` or `s_visualStudioSpecDict`. Due to the non-trivial cost of initializing static fields on this class I would discourage making the change in this PR to not risk regressions. Instead, please consider switching to an explicit lazy initialization of this data.\r\n\r\nI see the static ctor run at this callstack, for example:\r\n\r\n```\r\n004fe734 04dcb6b8 Microsoft.Build.Shared.FrameworkLocationHelper..cctor()\r\n004ff0ac 04dc823e Microsoft.Build.Internal.Utilities.GetEnvironmentProperties()\r\n004ff0f0 04dc7c64 Microsoft.Build.Evaluation.ProjectCollection.get_EnvironmentProperties()\r\n004ff124 04dc7bd0 Microsoft.Build.Evaluation.ProjectCollection.InitializeToolsetCollection(Microsoft.Build.Evaluation.ToolsetRegistryReader, Microsoft.Build.Evaluation.ToolsetConfigurationReader)\r\n004ff13c 0248e676 Microsoft.Build.Evaluation.ProjectCollection..ctor(System.Collections.Generic.IDictionary`2, System.Collections.Generic.IEnumerable`1, System.Collections.Generic.IEnumerable`1, Microsoft.Build.Evaluation.ToolsetDefinitionLocations, Int32, Boolean, Boolean)\r\n004ff190 0248cb74 Microsoft.Build.CommandLine.MSBuildApp.BuildProject(System.String, System.String[], System.String, System.Collections.Generic.Dictionary`2, System.Collections.Generic.Dictionary`2, Microsoft.Build.Framework.ILogger[], Microsoft.Build.Framework.LoggerVerbosity, Microsoft.Build.CommandLine.DistributedLoggerRecord[], Boolean, System.String, Int32, Boolean, System.IO.TextWriter, System.IO.TextWriter, Boolean, System.Collections.Generic.ISet`1, System.Collections.Generic.ISet`1, Boolean, Microsoft.Build.Logging.ProfilerLogger, Boolean, Boolean, Boolean, Microsoft.Build.Graph.GraphBuildOptions, Boolean, System.String[], System.String)\r\n004ff2e0 02481e9f Microsoft.Build.CommandLine.MSBuildApp.Execute(System.String)\r\n004ff3a4 024810e3 Microsoft.Build.CommandLine.MSBuildApp.Main()\r\n```\r\n\r\nwhere `GetEnvironmentProperties` accesses only the `programFiles32` and `programFiles64` fields.\r\n\r\nThis is further exacerbated by compiling `FrameworkLocationHelper` into multiple assemblies so in a typical build the static initialization runs twice per process, once for the copy in `Microsoft.Build`, once for the copy in `Microsoft.Build.Utilities.Core`.\r\n\r\nIn summary, this code is in need of larger refactoring. In this PR I would err on the safer side and leave it alone.",
              "createdAt": "2022-01-26T10:16:51Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -376,17 +376,11 @@ internal static class FrameworkLocationHelper\n        };\n #endif // FEATURE_WIN32_REGISTRY\n \n-        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;\n-        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict;\n+        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n+        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I've changed it to be lazily initialized.",
              "createdAt": "2022-01-26T23:35:33Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -376,17 +376,11 @@ internal static class FrameworkLocationHelper\n        };\n #endif // FEATURE_WIN32_REGISTRY\n \n-        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;\n-        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict;\n+        private static readonly IReadOnlyDictionary<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict = s_dotNetFrameworkSpecs.ToDictionary(spec => spec.Version);\n+        private static readonly IReadOnlyDictionary<Version, VisualStudioSpec> s_visualStudioSpecDict = s_visualStudioSpecs.ToDictionary(spec => spec.Version);",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`We need a static constructor` did I overlook this? Is the static constructor needed to avoid issues on IA64?",
              "createdAt": "2022-01-25T23:50:18Z",
              "path": "src/Shared/MSBuildNameIgnoreCaseComparer.cs",
              "diffHunk": "@@ -22,16 +22,7 @@ internal class MSBuildNameIgnoreCaseComparer : IConstrainedEqualityComparer<stri\n         /// <summary>\n         /// The processor architecture on which we are running, but default it will be x86\n         /// </summary>\n-        private static readonly NativeMethodsShared.ProcessorArchitectures s_runningProcessorArchitecture;\n-\n-        /// <summary>\n-        /// We need a static constructor to retrieve the running ProcessorArchitecture that way we can",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "I don't think the comment was specifically about needing an explicit static ctor. Switching to inline initialization should be fine.",
              "createdAt": "2022-01-26T09:46:18Z",
              "path": "src/Shared/MSBuildNameIgnoreCaseComparer.cs",
              "diffHunk": "@@ -22,16 +22,7 @@ internal class MSBuildNameIgnoreCaseComparer : IConstrainedEqualityComparer<stri\n         /// <summary>\n         /// The processor architecture on which we are running, but default it will be x86\n         /// </summary>\n-        private static readonly NativeMethodsShared.ProcessorArchitectures s_runningProcessorArchitecture;\n-\n-        /// <summary>\n-        /// We need a static constructor to retrieve the running ProcessorArchitecture that way we can",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please make this one and `VisualStudioSpecs` lazy as well? Likely by just refactoring them into private static methods instead of fields. The methods would be called from the `Lazy` lambdas you have added.",
              "createdAt": "2022-01-27T08:45:42Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -145,7 +145,7 @@ internal static class FrameworkLocationHelper\n         /// <summary>\n         /// List the supported .net versions.\n         /// </summary>\n-        private static readonly DotNetFrameworkSpec[] s_dotNetFrameworkSpecs =\n+        private static readonly DotNetFrameworkSpec[] DotNetFrameworkSpecs =",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This code relies on the VisualStudioSpecs being an array so it can find the previous version by index. So VisualStudioSpecs can't be refactored into a static method. But it can be lazily loaded.\r\nhttps://github.com/dotnet/msbuild/blob/daa103ebba42cb56ba18caefa74399a848905d3d/src/Shared/FrameworkLocationHelper.cs#L1472-L1484",
              "createdAt": "2022-01-27T10:33:19Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -145,7 +145,7 @@ internal static class FrameworkLocationHelper\n         /// <summary>\n         /// List the supported .net versions.\n         /// </summary>\n-        private static readonly DotNetFrameworkSpec[] s_dotNetFrameworkSpecs =\n+        private static readonly DotNetFrameworkSpec[] DotNetFrameworkSpecs =",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nice catch!",
              "createdAt": "2022-01-27T11:05:25Z",
              "path": "src/Shared/FrameworkLocationHelper.cs",
              "diffHunk": "@@ -72,7 +72,7 @@ internal static class FrameworkLocationHelper\n         internal static readonly Version visualStudioVersion170 = new Version(17, 0);\n \n         // keep this up-to-date; always point to the latest visual studio version.\n-        internal static readonly Version visualStudioVersionLatest = visualStudioVersion160;\n+        internal static readonly Version visualStudioVersionLatest = visualStudioVersion170;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I think I'd slightly prefer putting the restore below the end of this function, but I don't care too much.",
              "createdAt": "2022-01-27T19:18:53Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -127,7 +127,9 @@ public enum ExitType\n         /// <summary>\n         /// Static constructor\n         /// </summary>\n+#pragma warning disable CA1810 // Initialize reference type static fields inline\n         static MSBuildApp()\n+#pragma warning restore CA1810 // Initialize reference type static fields inline",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}