{
  "number": 11481,
  "title": "Integrate the initial node metrics",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/11480\r\n\r\n### Context\r\nConnects the exposed data into the telemetry collector, converts them into json format.\r\n\r\n### Testing\r\n**TBD**\r\n\r\nAlso - we need to test the resulting output on Orchard to have an idea on volume/size of resulting data - we may need to aggregate/filter targets a bit?\r\n\r\n### Notes\r\n\r\nSample of resulting data:\r\n\r\n```\r\n\"Tasks\":\r\n\r\n[\r\n  \"TaskA\": {\r\n    \"ExecTimeMs\": 2000,\r\n    \"ExecCnt\": 5,\r\n    \"MemKBs\": 0.5322265625,\r\n    \"IsCustom\": false,\r\n    \"IsFromNuget\": true\r\n  },\r\n  \"75745449d67e47c3288fa8db4bf6961b455bdf65f6597a4e1c897e1740ebdc1a\": {\r\n    \"ExecTimeMs\": 254548000,\r\n    \"ExecCnt\": 6,\r\n    \"MemKBs\": 53267.0419921875,\r\n    \"IsCustom\": true,\r\n    \"IsFromNuget\": false\r\n  }\r\n]\r\n\r\n\r\n\r\n\"Targets\":\r\n\r\n[\r\n  \"TargetA\": {\r\n    \"WasExecuted\": false,\r\n    \"IsCustom\": false,\r\n    \"IsFromNuget\": true,\r\n    \"IsMetaproj\": false\r\n  },\r\n  \"ce5582cb3fdd2433a022932a42185f9bd62696888bc8102d0bad33363c43aa96\": {\r\n    \"WasExecuted\": false,\r\n    \"IsCustom\": true,\r\n    \"IsFromNuget\": true,\r\n    \"IsMetaproj\": false\r\n  },\r\n  \"TargetB\": {\r\n    \"WasExecuted\": false,\r\n    \"IsCustom\": false,\r\n    \"IsFromNuget\": false,\r\n    \"IsMetaproj\": true\r\n  }\r\n]\r\n\r\n\r\n\"TargetsSummary\":\r\n\r\n\"Loaded\": {\r\n  \"Total\": 3,\r\n  \"Microsoft\": {\r\n    \"Total\": 1,\r\n    \"FromNuget\": 1,\r\n    \"FromMetaproj\": 0\r\n  },\r\n  \"Custom\": {\r\n    \"Total\": 2,\r\n    \"FromNuget\": 1,\r\n    \"FromMetaproj\": 1\r\n  }\r\n},\r\n\"Executed\": {\r\n  \"Total\": 0\r\n}\r\n\r\n\r\n\"TasksSummary\":\r\n\r\n\"Microsoft\": {\r\n  \"Total\": {\r\n    \"TotalExecutionsCount\": 5,\r\n    \"CumulativeExecutionTimeMs\": 2000,\r\n    \"CumulativeConsumedMemoryKB\": 0.5322265625\r\n  },\r\n  \"FromNuget\": {\r\n    \"TotalExecutionsCount\": 5,\r\n    \"CumulativeExecutionTimeMs\": 2000,\r\n    \"CumulativeConsumedMemoryKB\": 0.5322265625\r\n  }\r\n},\r\n\"Custom\": {\r\n  \"Total\": {\r\n    \"TotalExecutionsCount\": 6,\r\n    \"CumulativeExecutionTimeMs\": 254548000,\r\n    \"CumulativeConsumedMemoryKB\": 53267.0419921875\r\n  }\r\n}\r\n```",
  "state": "MERGED",
  "createdAt": "2025-02-21T17:40:42Z",
  "updatedAt": "2025-03-04T15:56:31Z",
  "closedAt": "2025-02-26T12:47:34Z",
  "mergedAt": "2025-02-26T12:47:34Z",
  "additions": 432,
  "deletions": 17,
  "changedFiles": 12,
  "headRefName": "telemetry/integrate",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "JanProvaznik"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "85ac838b4df74f2ca406020feb3c22011bc2d3b0",
          "message": "Integrate the initial node metrics",
          "committedDate": "2025-02-21T17:35:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e852270d8bd946bb188d204a2167abf03a27d514",
          "message": "Add node telemetry data summarization",
          "committedDate": "2025-02-24T14:33:39Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c74c63f25065f4c9efa10f3232661490ecd94e23",
          "message": "fix flushing node data to json",
          "committedDate": "2025-02-24T16:38:47Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4fb8a4a29ade93cc3e35175f0c5deaa5c06ff3cf",
          "message": "Refactor telemetry task details exclusion logic in BuildManager and Traits",
          "committedDate": "2025-02-24T16:48:16Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed558963d606231bc2944e25c678e037c1af9e0d",
          "message": "syntax",
          "committedDate": "2025-02-24T17:02:16Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c91c4e9d8211d57be782d78166b39b9f4102832",
          "message": "fix",
          "committedDate": "2025-02-25T12:37:10Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce212c4d3bc1a6b4144ae7e56fc3b8e4384edc15",
          "message": "Merge branch 'main' into telemetry/integrate",
          "committedDate": "2025-02-25T12:38:16Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed45e8ae564e6dab56fa462265f1a67007c0e890",
          "message": "fix schema for summaries",
          "committedDate": "2025-02-25T17:17:36Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c3cea1944275a1e35833c4e60224c5214de6bb5c",
          "message": "more wrapping objects",
          "committedDate": "2025-02-25T17:44:38Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "51aaf20b890476bef3a2426555ac3ffde68efa75",
          "message": "Fix failing tests",
          "committedDate": "2025-02-26T11:47:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa2d584808bf9ae6ee75e52dce48b8839c872570",
          "message": "Remove indentation",
          "committedDate": "2025-02-26T11:49:15Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "As discussed offline - left for @JanProvaznik to handle:\r\n * VS perf integration tests when opted in\r\n * unit/e2e tests - since this is opt-in feature - it's fine to do manual verifications now, and handle unit or/and e2e tests in followup items\r\n * verifications that the 'tags' appended to main activity (the \"Tasks\", \"Targets\", \"TargetsSummary\", \"TasksSummary\") will appear as json subtags - not json encoded strings, that then would be hassle to query out\r\n * dump the sample data on OrchardCore or MSBuild or similar mid-size repo, to get the idea of size collected and verify with VS data platform folks that it's fine to send such sample size for sampled-in runs",
        "createdAt": "2025-02-24T14:42:15Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "ran `$env:MSBUILDNODETELEMETRYFILENAME=\"telemetry.txt\"; $env:MSBUILD_TELEMETRY_SAMPLE_RATE=\"1.0\"; $env:MSBUILD_TELEMETRY_OPTIN=\"1\" $env:MSBUILDOUTPUTNODESTELEMETRY=\"1\"; .\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\MSBuild.exe ..\\OrchardCore\\`\r\non restored orchardcore, \r\n\r\ncan't find the telemetry.txt\r\n\r\n1668 targets (half metaproj)\r\n266 tasks\r\nthe console flush seems to be same ballpark as the json, this results in 200kb of data\r\n\r\n\r\nwe might want to aggregate metaproj targets, if they're hashed then it's not very useful to have their details",
        "createdAt": "2025-02-24T15:20:34Z",
        "author": {
          "login": "JanProvaznik"
        }
      },
      {
        "body": "maybe the csv serialization will be needed after all\ud83e\udd14 ",
        "createdAt": "2025-02-24T15:22:28Z",
        "author": {
          "login": "JanProvaznik"
        }
      },
      {
        "body": "> it breaks VS C++ scenarios, needs more testing. https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=11074124&view=ms.vss-test-web.build-test-results-tab&runId=122902221&resultId=100000&paneView=debug\r\n\r\nThis was a recent change of 'ExecutionsCount' type change from short to int, that wasn't reflected on the receiving side (it was caught by the failing `WorkerNodeTelemetryEventArgs_Tests` unit test, that is green now)",
        "createdAt": "2025-02-26T11:50:52Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "strategy to get this in 17.14p2:\r\n- experimental insertion + always on override\r\n- meanwhile merge and run real insertion\r\n- completereal insert if both suceed\r\n- if no, revert from main :( and reopen\r\n- address all comments and issues in followup pr",
        "createdAt": "2025-02-26T12:17:15Z",
        "author": {
          "login": "JanProvaznik"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "you mentioned hashing metaproj tasks/targets, is that missing here?",
              "createdAt": "2025-02-24T11:10:24Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,138 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(2);\n+\n+            telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                WriteIndented = true,\n+                Converters =\n+                {\n+                    new TargetDataConverter(),\n+                    new TaskDataConverter(),\n+                },\n+                // TypeInfoResolver = new PrivateConstructorContractResolver()\n+            };\n+\n+            return opt;\n+        }\n+\n+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "yes - was missing - added now",
              "createdAt": "2025-02-24T14:34:30Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,138 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(2);\n+\n+            telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                WriteIndented = true,\n+                Converters =\n+                {\n+                    new TargetDataConverter(),\n+                    new TaskDataConverter(),\n+                },\n+                // TypeInfoResolver = new PrivateConstructorContractResolver()\n+            };\n+\n+            return opt;\n+        }\n+\n+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "so this test is supposed to validate the serialization and you left it as a follow-up to me? did you have other tests in mind?",
              "createdAt": "2025-02-24T11:14:40Z",
              "path": "src/Build.UnitTests/TelemetryTests.cs",
              "diffHunk": "@@ -165,5 +166,30 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()\n \n             workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsFromNugetCache);\n         }\n+\n+        [Fact]\n+        public void Foo()\n+        {\n+            WorkerNodeTelemetryData wd = new WorkerNodeTelemetryData(\n+                new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>()\n+                {\n+                    {\n+                        new TaskOrTargetTelemetryKey(\"TaskA\", false, true),\n+                        new TaskExecutionStats(TimeSpan.FromSeconds(2), 5, 545)\n+                    },\n+                    {\n+                        new TaskOrTargetTelemetryKey(\"TaskA\", true, false),\n+                        new TaskExecutionStats(TimeSpan.FromSeconds(254548), 6, 54545451)\n+                    },\n+                },\n+                new Dictionary<TaskOrTargetTelemetryKey, bool>()\n+                {\n+                    { new TaskOrTargetTelemetryKey(\"TargetA\", false, true, false), false },\n+                    { new TaskOrTargetTelemetryKey(\"TargetA\", true, true, false), false },\n+                    { new TaskOrTargetTelemetryKey(\"TargetB\", false, false, true), false }\n+                });\n+\n+            var holder = TelemetryDataUtils.AsActivityDataHolder(wd);\n+        }",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "That's correct - tests are completely TBD",
              "createdAt": "2025-02-24T14:34:51Z",
              "path": "src/Build.UnitTests/TelemetryTests.cs",
              "diffHunk": "@@ -165,5 +166,30 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()\n \n             workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsFromNugetCache);\n         }\n+\n+        [Fact]\n+        public void Foo()\n+        {\n+            WorkerNodeTelemetryData wd = new WorkerNodeTelemetryData(\n+                new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>()\n+                {\n+                    {\n+                        new TaskOrTargetTelemetryKey(\"TaskA\", false, true),\n+                        new TaskExecutionStats(TimeSpan.FromSeconds(2), 5, 545)\n+                    },\n+                    {\n+                        new TaskOrTargetTelemetryKey(\"TaskA\", true, false),\n+                        new TaskExecutionStats(TimeSpan.FromSeconds(254548), 6, 54545451)\n+                    },\n+                },\n+                new Dictionary<TaskOrTargetTelemetryKey, bool>()\n+                {\n+                    { new TaskOrTargetTelemetryKey(\"TargetA\", false, true, false), false },\n+                    { new TaskOrTargetTelemetryKey(\"TargetA\", true, true, false), false },\n+                    { new TaskOrTargetTelemetryKey(\"TargetB\", false, false, true), false }\n+                });\n+\n+            var holder = TelemetryDataUtils.AsActivityDataHolder(wd);\n+        }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "opened a ticket for this",
              "createdAt": "2025-02-24T16:56:35Z",
              "path": "src/Build.UnitTests/TelemetryTests.cs",
              "diffHunk": "@@ -165,5 +166,30 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()\n \n             workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsFromNugetCache);\n         }\n+\n+        [Fact]\n+        public void Foo()\n+        {\n+            WorkerNodeTelemetryData wd = new WorkerNodeTelemetryData(\n+                new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>()\n+                {\n+                    {\n+                        new TaskOrTargetTelemetryKey(\"TaskA\", false, true),\n+                        new TaskExecutionStats(TimeSpan.FromSeconds(2), 5, 545)\n+                    },\n+                    {\n+                        new TaskOrTargetTelemetryKey(\"TaskA\", true, false),\n+                        new TaskExecutionStats(TimeSpan.FromSeconds(254548), 6, 54545451)\n+                    },\n+                },\n+                new Dictionary<TaskOrTargetTelemetryKey, bool>()\n+                {\n+                    { new TaskOrTargetTelemetryKey(\"TargetA\", false, true, false), false },\n+                    { new TaskOrTargetTelemetryKey(\"TargetA\", true, true, false), false },\n+                    { new TaskOrTargetTelemetryKey(\"TargetB\", false, false, true), false }\n+                });\n+\n+            var holder = TelemetryDataUtils.AsActivityDataHolder(wd);\n+        }",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "originally I did not intend for tasks/targets to be the same event as the basic info, but it seems fine this way too",
              "createdAt": "2025-02-24T11:17:09Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1134,7 +1139,8 @@ private void EndBuildTelemetry()\n         {\n             OpenTelemetryManager.Instance.DefaultActivitySource?\n                 .StartActivity(\"Build\")?\n-                .WithTags(_buildTelemetry!)\n+                .WithTags(_buildTelemetry)\n+                .WithTags(_telemetryConsumingLogger?.WorkerNodeTelemetryData.AsActivityDataHolder())",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is tha place where we ensure that the nodes will collect the node telemetry if needed",
              "createdAt": "2025-02-24T14:42:49Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -563,6 +569,7 @@ public void BeginBuild(BuildParameters parameters)\n                 // Initialize components.\n                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;\n \n+                _buildParameters.IsTelemetryEnabled = OpenTelemetryManager.Instance.IsActive();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should probably be removed. (was there for easier review of data during testing)",
              "createdAt": "2025-02-26T06:22:05Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,319 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(4);\n+\n+            if (includeTasksDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            }\n+\n+            if (includeTargetDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+            }\n+\n+            TargetsSummary targetsSummary = new();\n+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TargetsSummary\",\n+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));\n+\n+            TasksSummary tasksSummary = new();\n+            tasksSummary.Initialize(telemetryData.TasksExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TasksSummary\",\n+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                WriteIndented = true,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: naming is a bit strange, could you be more specific and add short documentation?",
              "createdAt": "2025-02-26T12:04:13Z",
              "path": "src/Framework/Telemetry/TaskExecutionStats.cs",
              "diffHunk": "@@ -5,11 +5,36 @@\n \n namespace Microsoft.Build.Framework;\n \n-internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumption)\n+internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, int executionsCount, long totalMemoryConsumption)\n {\n+    private TaskExecutionStats()\n+        : this(TimeSpan.Zero, 0, 0)\n+    { }\n+\n+    internal static TaskExecutionStats CreateEmpty()\n+        => new();\n+\n+    /// <summary>\n+    /// Total execution time of the task in all nodes for all projects.\n+    /// </summary>\n     public TimeSpan CumulativeExecutionTime { get; set; } = cumulativeExecutionTime;\n+\n+    /// <summary>\n+    /// Total memory consumption (across all executions) in bytes.\n+    /// </summary>\n     public long TotalMemoryConsumption { get; set; } = totalMemoryConsumption;\n-    public short ExecutionsCount { get; set; } = executionsCount;\n+\n+    /// <summary>\n+    /// Total number of execution of the tasks in all nodes for all projects.\n+    /// </summary>\n+    public int ExecutionsCount { get; set; } = executionsCount;\n+\n+    internal void AddAnother(TaskExecutionStats another)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can it be 'Initialize'? \r\nThe naming a bit unusual :) ",
              "createdAt": "2025-02-26T12:06:01Z",
              "path": "src/Framework/Telemetry/TaskExecutionStats.cs",
              "diffHunk": "@@ -5,11 +5,36 @@\n \n namespace Microsoft.Build.Framework;\n \n-internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumption)\n+internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, int executionsCount, long totalMemoryConsumption)\n {\n+    private TaskExecutionStats()\n+        : this(TimeSpan.Zero, 0, 0)\n+    { }\n+\n+    internal static TaskExecutionStats CreateEmpty()",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I think this is good naming. Initialize would imply: we first create and then initialize. This is a static factory method that returns an instance of stats that is empty. Adding a doc comment there",
              "createdAt": "2025-03-03T13:02:49Z",
              "path": "src/Framework/Telemetry/TaskExecutionStats.cs",
              "diffHunk": "@@ -5,11 +5,36 @@\n \n namespace Microsoft.Build.Framework;\n \n-internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumption)\n+internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, int executionsCount, long totalMemoryConsumption)\n {\n+    private TaskExecutionStats()\n+        : this(TimeSpan.Zero, 0, 0)\n+    { }\n+\n+    internal static TaskExecutionStats CreateEmpty()",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can we use consistent naming for the variables and json keys, so it can be nameof(prop), instead on the hardcoded strings?",
              "createdAt": "2025-02-26T12:10:55Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,320 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(4);\n+\n+            if (includeTasksDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            }\n+\n+            if (includeTargetDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+            }\n+\n+            TargetsSummary targetsSummary = new();\n+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TargetsSummary\",\n+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));\n+\n+            TasksSummary tasksSummary = new();\n+            tasksSummary.Initialize(telemetryData.TasksExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TasksSummary\",\n+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                // Add following if user-friendly indentation would be needed\n+                // WriteIndented = true,\n+                Converters =\n+                {\n+                    new TargetDataConverter(),\n+                    new TaskDataConverter(),\n+                    new TargetsSummary(),\n+                    new TasksSummary(),\n+                },\n+            };\n+\n+            return opt;\n+        }\n+\n+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom || valuePair.Key.IsFromMetaProject ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    writer.WriteBoolean(\"WasExecuted\", valuePair.Value);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteBoolean(\"IsMetaproj\", valuePair.Key.IsFromMetaProject);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TaskDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"ExecTimeMs\", valuePair.Value.CumulativeExecutionTime.TotalMilliseconds / 1);\n+                    writer.WriteNumber(\"ExecCnt\", valuePair.Value.ExecutionsCount);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"MemKBs\", valuePair.Value.TotalMemoryConsumption / 1024);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TargetsSummary : JsonConverter<TargetsSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)\n+            {\n+                foreach (var targetInfo in targetsExecutionData)\n+                {\n+                    UpdateStatistics(LoadedBuiltinTargetInfo, LoadedCustomTargetInfo, targetInfo.Key);\n+                    if (targetInfo.Value)\n+                    {\n+                        UpdateStatistics(ExecutedBuiltinTargetInfo, ExecutedCustomTargetInfo, targetInfo.Key);\n+                    }\n+                }\n+\n+                void UpdateStatistics(\n+                    TargetInfo builtinTargetInfo,\n+                    TargetInfo customTargetInfo,\n+                    TaskOrTargetTelemetryKey key)\n+                {\n+                    UpdateSingleStatistics(key.IsCustom ? customTargetInfo : builtinTargetInfo, key);\n+\n+                    void UpdateSingleStatistics(TargetInfo targetInfo, TaskOrTargetTelemetryKey kkey)\n+                    {\n+                        targetInfo.Total++;\n+                        if (kkey.IsFromNugetCache)\n+                        {\n+                            targetInfo.FromNuget++;\n+                        }\n+                        if (kkey.IsFromMetaProject)\n+                        {\n+                            targetInfo.FromMetaproj++;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private TargetInfo LoadedBuiltinTargetInfo { get; } = new();\n+            private TargetInfo LoadedCustomTargetInfo { get; } = new();\n+            private TargetInfo ExecutedBuiltinTargetInfo { get; } = new();\n+            private TargetInfo ExecutedCustomTargetInfo { get; } = new();\n+\n+            private class TargetInfo\n+            {\n+                public int Total { get; internal set; }\n+                public int FromNuget { get; internal set; }\n+                public int FromMetaproj { get; internal set; }\n+            }\n+\n+            public override TargetsSummary? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options) =>\n+            throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                TargetsSummary value,\n+                JsonSerializerOptions options)\n+            {\n+                writer.WriteStartObject();\n+                writer.WriteStartObject(\"Loaded\");\n+                WriteStat(writer, value.LoadedBuiltinTargetInfo, value.LoadedCustomTargetInfo);\n+                writer.WriteEndObject();\n+                writer.WriteStartObject(\"Executed\");\n+                WriteStat(writer, value.ExecutedBuiltinTargetInfo, value.ExecutedCustomTargetInfo);\n+                writer.WriteEndObject();\n+                writer.WriteEndObject();\n+\n+\n+                void WriteStat(Utf8JsonWriter writer, TargetInfo customTargetsInfo, TargetInfo builtinTargetsInfo)\n+                {\n+                    writer.WriteNumber(\"Total\", builtinTargetsInfo.Total + customTargetsInfo.Total);\n+                    WriteSingleStat(writer, builtinTargetsInfo, \"Microsoft\");\n+                    WriteSingleStat(writer, customTargetsInfo, \"Custom\");\n+                }\n+\n+                void WriteSingleStat(Utf8JsonWriter writer, TargetInfo targetInfo, string name)\n+                {\n+                    if (targetInfo.Total > 0)\n+                    {\n+                        writer.WriteStartObject(name);\n+                        writer.WriteNumber(\"Total\", targetInfo.Total);\n+                        writer.WriteNumber(\"FromNuget\", targetInfo.FromNuget);\n+                        writer.WriteNumber(\"FromMetaproj\", targetInfo.FromMetaproj);\n+                        writer.WriteEndObject();\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        private class TasksSummary : JsonConverter<TasksSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData)\n+            {\n+                foreach (var taskInfo in tasksExecutionData)\n+                {\n+                    UpdateStatistics(BuiltinTasksInfo, CustomTasksInfo, taskInfo.Key, taskInfo.Value);\n+                }\n+\n+                void UpdateStatistics(\n+                    TasksInfo builtinTaskInfo,\n+                    TasksInfo customTaskInfo,\n+                    TaskOrTargetTelemetryKey key,\n+                    TaskExecutionStats taskExecutionStats)\n+                {\n+                    UpdateSingleStatistics(key.IsCustom ? customTaskInfo : builtinTaskInfo, taskExecutionStats, key);\n+\n+                    void UpdateSingleStatistics(TasksInfo summarizedTaskInfo, TaskExecutionStats infoToAdd, TaskOrTargetTelemetryKey kkey)\n+                    {\n+                        summarizedTaskInfo.Total.AddAnother(infoToAdd);\n+                        if (kkey.IsFromNugetCache)\n+                        {\n+                            summarizedTaskInfo.FromNuget.AddAnother(infoToAdd);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private TasksInfo BuiltinTasksInfo { get; } = new TasksInfo();\n+            private TasksInfo CustomTasksInfo { get; } = new TasksInfo();\n+\n+            private class TasksInfo\n+            {\n+                public TaskExecutionStats Total { get; } = TaskExecutionStats.CreateEmpty();\n+                public TaskExecutionStats FromNuget { get; } = TaskExecutionStats.CreateEmpty();\n+            }\n+\n+            public override TasksSummary? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options) =>\n+            throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                TasksSummary value,\n+                JsonSerializerOptions options)\n+            {\n+                writer.WriteStartObject();\n+                WriteStat(writer, value.BuiltinTasksInfo, \"Microsoft\");\n+                WriteStat(writer, value.CustomTasksInfo, \"Custom\");\n+                writer.WriteEndObject();\n+\n+                void WriteStat(Utf8JsonWriter writer, TasksInfo tasksInfo, string name)\n+                {\n+                    writer.WriteStartObject(name);\n+                    WriteSingleStat(writer, tasksInfo.Total, \"Total\", true);\n+                    WriteSingleStat(writer, tasksInfo.FromNuget, \"FromNuget\", false);\n+                    writer.WriteEndObject();\n+                }\n+\n+                void WriteSingleStat(Utf8JsonWriter writer, TaskExecutionStats stats, string name, bool writeIfEmpty)\n+                {\n+                    if (stats.ExecutionsCount > 0)\n+                    {\n+                        writer.WriteStartObject(name);\n+                        writer.WriteNumber(\"TotalExecutionsCount\", stats.ExecutionsCount);\n+                        // We do not want decimals\n+                        writer.WriteNumber(\"CumulativeExecutionTimeMs\", (long)stats.CumulativeExecutionTime.TotalMilliseconds);\n+                        // We do not want decimals\n+                        writer.WriteNumber(\"CumulativeConsumedMemoryKB\", stats.TotalMemoryConsumption / 1024);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`kkey ` - typo?",
              "createdAt": "2025-02-26T12:11:42Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,320 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(4);\n+\n+            if (includeTasksDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            }\n+\n+            if (includeTargetDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+            }\n+\n+            TargetsSummary targetsSummary = new();\n+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TargetsSummary\",\n+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));\n+\n+            TasksSummary tasksSummary = new();\n+            tasksSummary.Initialize(telemetryData.TasksExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TasksSummary\",\n+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                // Add following if user-friendly indentation would be needed\n+                // WriteIndented = true,\n+                Converters =\n+                {\n+                    new TargetDataConverter(),\n+                    new TaskDataConverter(),\n+                    new TargetsSummary(),\n+                    new TasksSummary(),\n+                },\n+            };\n+\n+            return opt;\n+        }\n+\n+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom || valuePair.Key.IsFromMetaProject ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    writer.WriteBoolean(\"WasExecuted\", valuePair.Value);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteBoolean(\"IsMetaproj\", valuePair.Key.IsFromMetaProject);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TaskDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"ExecTimeMs\", valuePair.Value.CumulativeExecutionTime.TotalMilliseconds / 1);\n+                    writer.WriteNumber(\"ExecCnt\", valuePair.Value.ExecutionsCount);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"MemKBs\", valuePair.Value.TotalMemoryConsumption / 1024);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TargetsSummary : JsonConverter<TargetsSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)\n+            {\n+                foreach (var targetInfo in targetsExecutionData)\n+                {\n+                    UpdateStatistics(LoadedBuiltinTargetInfo, LoadedCustomTargetInfo, targetInfo.Key);\n+                    if (targetInfo.Value)\n+                    {\n+                        UpdateStatistics(ExecutedBuiltinTargetInfo, ExecutedCustomTargetInfo, targetInfo.Key);\n+                    }\n+                }\n+\n+                void UpdateStatistics(\n+                    TargetInfo builtinTargetInfo,\n+                    TargetInfo customTargetInfo,\n+                    TaskOrTargetTelemetryKey key)\n+                {\n+                    UpdateSingleStatistics(key.IsCustom ? customTargetInfo : builtinTargetInfo, key);\n+\n+                    void UpdateSingleStatistics(TargetInfo targetInfo, TaskOrTargetTelemetryKey kkey)\n+                    {\n+                        targetInfo.Total++;\n+                        if (kkey.IsFromNugetCache)\n+                        {\n+                            targetInfo.FromNuget++;\n+                        }\n+                        if (kkey.IsFromMetaProject)\n+                        {\n+                            targetInfo.FromMetaproj++;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private TargetInfo LoadedBuiltinTargetInfo { get; } = new();\n+            private TargetInfo LoadedCustomTargetInfo { get; } = new();\n+            private TargetInfo ExecutedBuiltinTargetInfo { get; } = new();\n+            private TargetInfo ExecutedCustomTargetInfo { get; } = new();\n+\n+            private class TargetInfo\n+            {\n+                public int Total { get; internal set; }\n+                public int FromNuget { get; internal set; }\n+                public int FromMetaproj { get; internal set; }\n+            }\n+\n+            public override TargetsSummary? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options) =>\n+            throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                TargetsSummary value,\n+                JsonSerializerOptions options)\n+            {\n+                writer.WriteStartObject();\n+                writer.WriteStartObject(\"Loaded\");\n+                WriteStat(writer, value.LoadedBuiltinTargetInfo, value.LoadedCustomTargetInfo);\n+                writer.WriteEndObject();\n+                writer.WriteStartObject(\"Executed\");\n+                WriteStat(writer, value.ExecutedBuiltinTargetInfo, value.ExecutedCustomTargetInfo);\n+                writer.WriteEndObject();\n+                writer.WriteEndObject();\n+\n+\n+                void WriteStat(Utf8JsonWriter writer, TargetInfo customTargetsInfo, TargetInfo builtinTargetsInfo)\n+                {\n+                    writer.WriteNumber(\"Total\", builtinTargetsInfo.Total + customTargetsInfo.Total);\n+                    WriteSingleStat(writer, builtinTargetsInfo, \"Microsoft\");\n+                    WriteSingleStat(writer, customTargetsInfo, \"Custom\");\n+                }\n+\n+                void WriteSingleStat(Utf8JsonWriter writer, TargetInfo targetInfo, string name)\n+                {\n+                    if (targetInfo.Total > 0)\n+                    {\n+                        writer.WriteStartObject(name);\n+                        writer.WriteNumber(\"Total\", targetInfo.Total);\n+                        writer.WriteNumber(\"FromNuget\", targetInfo.FromNuget);\n+                        writer.WriteNumber(\"FromMetaproj\", targetInfo.FromMetaproj);\n+                        writer.WriteEndObject();\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        private class TasksSummary : JsonConverter<TasksSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData)\n+            {\n+                foreach (var taskInfo in tasksExecutionData)\n+                {\n+                    UpdateStatistics(BuiltinTasksInfo, CustomTasksInfo, taskInfo.Key, taskInfo.Value);\n+                }\n+\n+                void UpdateStatistics(\n+                    TasksInfo builtinTaskInfo,\n+                    TasksInfo customTaskInfo,\n+                    TaskOrTargetTelemetryKey key,\n+                    TaskExecutionStats taskExecutionStats)\n+                {\n+                    UpdateSingleStatistics(key.IsCustom ? customTaskInfo : builtinTaskInfo, taskExecutionStats, key);\n+\n+                    void UpdateSingleStatistics(TasksInfo summarizedTaskInfo, TaskExecutionStats infoToAdd, TaskOrTargetTelemetryKey kkey)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is it dupe of line 222?",
              "createdAt": "2025-02-26T12:12:48Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,320 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(4);\n+\n+            if (includeTasksDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            }\n+\n+            if (includeTargetDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+            }\n+\n+            TargetsSummary targetsSummary = new();\n+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TargetsSummary\",\n+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));\n+\n+            TasksSummary tasksSummary = new();\n+            tasksSummary.Initialize(telemetryData.TasksExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TasksSummary\",\n+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                // Add following if user-friendly indentation would be needed\n+                // WriteIndented = true,\n+                Converters =\n+                {\n+                    new TargetDataConverter(),\n+                    new TaskDataConverter(),\n+                    new TargetsSummary(),\n+                    new TasksSummary(),\n+                },\n+            };\n+\n+            return opt;\n+        }\n+\n+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom || valuePair.Key.IsFromMetaProject ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    writer.WriteBoolean(\"WasExecuted\", valuePair.Value);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteBoolean(\"IsMetaproj\", valuePair.Key.IsFromMetaProject);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TaskDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"ExecTimeMs\", valuePair.Value.CumulativeExecutionTime.TotalMilliseconds / 1);\n+                    writer.WriteNumber(\"ExecCnt\", valuePair.Value.ExecutionsCount);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"MemKBs\", valuePair.Value.TotalMemoryConsumption / 1024);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TargetsSummary : JsonConverter<TargetsSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)\n+            {\n+                foreach (var targetInfo in targetsExecutionData)\n+                {\n+                    UpdateStatistics(LoadedBuiltinTargetInfo, LoadedCustomTargetInfo, targetInfo.Key);\n+                    if (targetInfo.Value)\n+                    {\n+                        UpdateStatistics(ExecutedBuiltinTargetInfo, ExecutedCustomTargetInfo, targetInfo.Key);\n+                    }\n+                }\n+\n+                void UpdateStatistics(\n+                    TargetInfo builtinTargetInfo,\n+                    TargetInfo customTargetInfo,\n+                    TaskOrTargetTelemetryKey key)\n+                {\n+                    UpdateSingleStatistics(key.IsCustom ? customTargetInfo : builtinTargetInfo, key);\n+\n+                    void UpdateSingleStatistics(TargetInfo targetInfo, TaskOrTargetTelemetryKey kkey)\n+                    {\n+                        targetInfo.Total++;\n+                        if (kkey.IsFromNugetCache)\n+                        {\n+                            targetInfo.FromNuget++;\n+                        }\n+                        if (kkey.IsFromMetaProject)\n+                        {\n+                            targetInfo.FromMetaproj++;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private TargetInfo LoadedBuiltinTargetInfo { get; } = new();\n+            private TargetInfo LoadedCustomTargetInfo { get; } = new();\n+            private TargetInfo ExecutedBuiltinTargetInfo { get; } = new();\n+            private TargetInfo ExecutedCustomTargetInfo { get; } = new();\n+\n+            private class TargetInfo\n+            {\n+                public int Total { get; internal set; }\n+                public int FromNuget { get; internal set; }\n+                public int FromMetaproj { get; internal set; }\n+            }\n+\n+            public override TargetsSummary? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options) =>\n+            throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                TargetsSummary value,\n+                JsonSerializerOptions options)\n+            {\n+                writer.WriteStartObject();\n+                writer.WriteStartObject(\"Loaded\");\n+                WriteStat(writer, value.LoadedBuiltinTargetInfo, value.LoadedCustomTargetInfo);\n+                writer.WriteEndObject();\n+                writer.WriteStartObject(\"Executed\");\n+                WriteStat(writer, value.ExecutedBuiltinTargetInfo, value.ExecutedCustomTargetInfo);\n+                writer.WriteEndObject();\n+                writer.WriteEndObject();\n+\n+\n+                void WriteStat(Utf8JsonWriter writer, TargetInfo customTargetsInfo, TargetInfo builtinTargetsInfo)\n+                {\n+                    writer.WriteNumber(\"Total\", builtinTargetsInfo.Total + customTargetsInfo.Total);\n+                    WriteSingleStat(writer, builtinTargetsInfo, \"Microsoft\");\n+                    WriteSingleStat(writer, customTargetsInfo, \"Custom\");\n+                }\n+\n+                void WriteSingleStat(Utf8JsonWriter writer, TargetInfo targetInfo, string name)\n+                {\n+                    if (targetInfo.Total > 0)\n+                    {\n+                        writer.WriteStartObject(name);\n+                        writer.WriteNumber(\"Total\", targetInfo.Total);\n+                        writer.WriteNumber(\"FromNuget\", targetInfo.FromNuget);\n+                        writer.WriteNumber(\"FromMetaproj\", targetInfo.FromMetaproj);\n+                        writer.WriteEndObject();\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        private class TasksSummary : JsonConverter<TasksSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData)\n+            {\n+                foreach (var taskInfo in tasksExecutionData)\n+                {\n+                    UpdateStatistics(BuiltinTasksInfo, CustomTasksInfo, taskInfo.Key, taskInfo.Value);\n+                }\n+\n+                void UpdateStatistics(\n+                    TasksInfo builtinTaskInfo,\n+                    TasksInfo customTaskInfo,\n+                    TaskOrTargetTelemetryKey key,\n+                    TaskExecutionStats taskExecutionStats)\n+                {\n+                    UpdateSingleStatistics(key.IsCustom ? customTaskInfo : builtinTaskInfo, taskExecutionStats, key);\n+\n+                    void UpdateSingleStatistics(TasksInfo summarizedTaskInfo, TaskExecutionStats infoToAdd, TaskOrTargetTelemetryKey kkey)\n+                    {\n+                        summarizedTaskInfo.Total.AddAnother(infoToAdd);\n+                        if (kkey.IsFromNugetCache)\n+                        {\n+                            summarizedTaskInfo.FromNuget.AddAnother(infoToAdd);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private TasksInfo BuiltinTasksInfo { get; } = new TasksInfo();\n+            private TasksInfo CustomTasksInfo { get; } = new TasksInfo();\n+\n+            private class TasksInfo\n+            {\n+                public TaskExecutionStats Total { get; } = TaskExecutionStats.CreateEmpty();\n+                public TaskExecutionStats FromNuget { get; } = TaskExecutionStats.CreateEmpty();\n+            }\n+\n+            public override TasksSummary? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options) =>\n+            throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                TasksSummary value,\n+                JsonSerializerOptions options)\n+            {\n+                writer.WriteStartObject();\n+                WriteStat(writer, value.BuiltinTasksInfo, \"Microsoft\");\n+                WriteStat(writer, value.CustomTasksInfo, \"Custom\");\n+                writer.WriteEndObject();\n+\n+                void WriteStat(Utf8JsonWriter writer, TasksInfo tasksInfo, string name)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please add short description for the method ",
              "createdAt": "2025-02-26T12:13:49Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,320 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(4);\n+\n+            if (includeTasksDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            }\n+\n+            if (includeTargetDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+            }\n+\n+            TargetsSummary targetsSummary = new();\n+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TargetsSummary\",\n+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));\n+\n+            TasksSummary tasksSummary = new();\n+            tasksSummary.Initialize(telemetryData.TasksExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TasksSummary\",\n+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()\n+        {\n+            var opt = new JsonSerializerOptions\n+            {\n+                // Add following if user-friendly indentation would be needed\n+                // WriteIndented = true,\n+                Converters =\n+                {\n+                    new TargetDataConverter(),\n+                    new TaskDataConverter(),\n+                    new TargetsSummary(),\n+                    new TasksSummary(),\n+                },\n+            };\n+\n+            return opt;\n+        }\n+\n+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom || valuePair.Key.IsFromMetaProject ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    writer.WriteBoolean(\"WasExecuted\", valuePair.Value);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteBoolean(\"IsMetaproj\", valuePair.Key.IsFromMetaProject);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TaskDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>\n+        {\n+            public override Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? Read(\n+                ref Utf8JsonReader reader,\n+                Type typeToConvert,\n+                JsonSerializerOptions options)\n+                =>\n+                    throw new NotImplementedException(\"Reading is not supported\");\n+\n+            public override void Write(\n+                Utf8JsonWriter writer,\n+                Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? value,\n+                JsonSerializerOptions options)\n+            {\n+                if (value == null)\n+                {\n+                    throw new NotSupportedException(\"TaskOrTargetTelemetryKey cannot be null in telemetry data\");\n+                }\n+\n+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types\n+\n+                writer.WriteStartArray();\n+\n+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> valuePair in value)\n+                {\n+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"ExecTimeMs\", valuePair.Value.CumulativeExecutionTime.TotalMilliseconds / 1);\n+                    writer.WriteNumber(\"ExecCnt\", valuePair.Value.ExecutionsCount);\n+                    // We do not want decimals\n+                    writer.WriteNumber(\"MemKBs\", valuePair.Value.TotalMemoryConsumption / 1024);\n+                    writer.WriteBoolean(\"IsCustom\", valuePair.Key.IsCustom);\n+                    writer.WriteBoolean(\"IsFromNuget\", valuePair.Key.IsFromNugetCache);\n+                    writer.WriteEndObject();\n+                }\n+\n+                writer.WriteEndArray();\n+            }\n+        }\n+\n+        private class TargetsSummary : JsonConverter<TargetsSummary>\n+        {\n+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)\n+            {\n+                foreach (var targetInfo in targetsExecutionData)\n+                {\n+                    UpdateStatistics(LoadedBuiltinTargetInfo, LoadedCustomTargetInfo, targetInfo.Key);\n+                    if (targetInfo.Value)\n+                    {\n+                        UpdateStatistics(ExecutedBuiltinTargetInfo, ExecutedCustomTargetInfo, targetInfo.Key);\n+                    }\n+                }\n+\n+                void UpdateStatistics(",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why we can't make it as a static property without a separation ? ",
              "createdAt": "2025-02-26T12:16:29Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,320 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)\n+        {\n+            if (telemetryData == null)\n+            {\n+                return null;\n+            }\n+\n+            List<TelemetryItem> telemetryItems = new(4);\n+\n+            if (includeTasksDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Tasks\",\n+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));\n+            }\n+\n+            if (includeTargetDetails)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"Targets\",\n+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));\n+            }\n+\n+            TargetsSummary targetsSummary = new();\n+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TargetsSummary\",\n+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));\n+\n+            TasksSummary tasksSummary = new();\n+            tasksSummary.Initialize(telemetryData.TasksExecutionData);\n+            telemetryItems.Add(new TelemetryItem(\"TasksSummary\",\n+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));\n+\n+            return new NodeTelemetry(telemetryItems);\n+        }\n+\n+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();\n+\n+        private static JsonSerializerOptions CreateSerializerOptions()",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do we need to check `Traits.Instance.ExcludeTasksDetailsFromTelemetry` here?\r\ncould you also use param names? it's easier to read",
              "createdAt": "2025-02-26T12:19:15Z",
              "path": "src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs",
              "diffHunk": "@@ -75,6 +82,22 @@ private void FlushDataIntoConsoleIfRequested()\n         Console.WriteLine(\"==========================================\");\n     }\n \n+    private void FlushDataIntoJsonFileIfRequested()\n+    {\n+        const string jsonFileNameVariable = \"MSBUILDNODETELEMETRYFILENAME\";\n+        var jsonFilePath = Environment.GetEnvironmentVariable(jsonFileNameVariable);\n+        if (string.IsNullOrEmpty(jsonFilePath))\n+        {\n+            return;\n+        }\n+\n+        var telemetryTags = _workerNodeTelemetryData.AsActivityDataHolder(true, true)?.GetActivityProperties();",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "if you specify `WriteIndented` do you need to do the same in custom deserializers? ",
              "createdAt": "2025-02-26T12:20:16Z",
              "path": "src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs",
              "diffHunk": "@@ -75,6 +82,22 @@ private void FlushDataIntoConsoleIfRequested()\n         Console.WriteLine(\"==========================================\");\n     }\n \n+    private void FlushDataIntoJsonFileIfRequested()\n+    {\n+        const string jsonFileNameVariable = \"MSBUILDNODETELEMETRYFILENAME\";\n+        var jsonFilePath = Environment.GetEnvironmentVariable(jsonFileNameVariable);\n+        if (string.IsNullOrEmpty(jsonFilePath))\n+        {\n+            return;\n+        }\n+\n+        var telemetryTags = _workerNodeTelemetryData.AsActivityDataHolder(true, true)?.GetActivityProperties();\n+\n+        using var stream = File.OpenWrite(jsonFilePath);\n+        stream.SetLength(0);\n+        JsonSerializer.Serialize(stream, telemetryTags, new JsonSerializerOptions() { WriteIndented = true });",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "no, it has no effect on deserialization",
              "createdAt": "2025-03-04T15:56:31Z",
              "path": "src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs",
              "diffHunk": "@@ -75,6 +82,22 @@ private void FlushDataIntoConsoleIfRequested()\n         Console.WriteLine(\"==========================================\");\n     }\n \n+    private void FlushDataIntoJsonFileIfRequested()\n+    {\n+        const string jsonFileNameVariable = \"MSBUILDNODETELEMETRYFILENAME\";\n+        var jsonFilePath = Environment.GetEnvironmentVariable(jsonFileNameVariable);\n+        if (string.IsNullOrEmpty(jsonFilePath))\n+        {\n+            return;\n+        }\n+\n+        var telemetryTags = _workerNodeTelemetryData.AsActivityDataHolder(true, true)?.GetActivityProperties();\n+\n+        using var stream = File.OpenWrite(jsonFilePath);\n+        stream.SetLength(0);\n+        JsonSerializer.Serialize(stream, telemetryTags, new JsonSerializerOptions() { WriteIndented = true });",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do you need to read this var all the time on method run? can it be moved to a global var?",
              "createdAt": "2025-02-26T12:21:02Z",
              "path": "src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs",
              "diffHunk": "@@ -75,6 +82,22 @@ private void FlushDataIntoConsoleIfRequested()\n         Console.WriteLine(\"==========================================\");\n     }\n \n+    private void FlushDataIntoJsonFileIfRequested()\n+    {\n+        const string jsonFileNameVariable = \"MSBUILDNODETELEMETRYFILENAME\";",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do you need to check if path is relevant or normalize it?",
              "createdAt": "2025-02-26T12:21:39Z",
              "path": "src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs",
              "diffHunk": "@@ -75,6 +82,22 @@ private void FlushDataIntoConsoleIfRequested()\n         Console.WriteLine(\"==========================================\");\n     }\n \n+    private void FlushDataIntoJsonFileIfRequested()\n+    {\n+        const string jsonFileNameVariable = \"MSBUILDNODETELEMETRYFILENAME\";\n+        var jsonFilePath = Environment.GetEnvironmentVariable(jsonFileNameVariable);\n+        if (string.IsNullOrEmpty(jsonFilePath))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please check if it regresses on vs insertion ",
              "createdAt": "2025-02-26T12:25:32Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -23,7 +23,7 @@\n     <PackageReference Include=\"System.Runtime.CompilerServices.Unsafe\" />\n     <PackageReference Include=\"Microsoft.VisualStudio.Setup.Configuration.Interop\" PrivateAssets=\"all\" />\n     <Reference Include=\"System.Xaml\" />\n-\n+    <PackageReference Include=\"System.Text.Json\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please document this method",
              "createdAt": "2025-02-26T12:26:22Z",
              "path": "src/Build/TelemetryInfra/TelemetryDataUtils.cs",
              "diffHunk": "@@ -0,0 +1,320 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Serialization;\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    internal static class TelemetryDataUtils\n+    {\n+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      }
    ]
  }
}