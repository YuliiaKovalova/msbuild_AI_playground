{
  "number": 7162,
  "title": "Remove unnecessary allocations in Hash task.",
  "body": "Fixes #7086\r\n\r\n### Context\r\n`Hash.Execute()` allocates a string which gets to the large object heap. This could be avoided without changing the resulting hash function.\r\n\r\n### Changes Made\r\nHash function is rewritten.\r\n\r\n### Testing\r\nUnit tests & manual testing\r\n",
  "state": "MERGED",
  "createdAt": "2021-12-20T19:20:37Z",
  "updatedAt": "2022-01-21T08:30:09Z",
  "closedAt": "2022-01-21T08:30:09Z",
  "mergedAt": "2022-01-21T08:30:09Z",
  "additions": 155,
  "deletions": 26,
  "changedFiles": 2,
  "headRefName": "new-hash-function-2",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "7be7de1c29a01505b89b84b624578ebb210fcbf9",
          "message": "Fix the hash function: remove unnecessary allocations.",
          "committedDate": "2021-12-20T19:15:26Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21e03ac254cfb0f45800aee77bd49736dc0fa455",
          "message": "Addressing review comments.",
          "committedDate": "2021-12-22T20:17:55Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01d37cfc3a9c547278db7fbb46ed1af3041a9329",
          "message": "Fix bug.",
          "committedDate": "2022-01-01T16:37:20Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "affd674f40a49c358d6868667c752bd99a26b3a8",
          "message": "Addressing review comments.",
          "committedDate": "2022-01-03T16:25:45Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd1939ddb8f597edd5bbb9622b79afe8d253f0d0",
          "message": "Addressing review comments - 2.",
          "committedDate": "2022-01-03T16:37:46Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "15850f0ec467550601342379a352a04b6776b730",
          "message": "Addressing review comments - 3.",
          "committedDate": "2022-01-12T11:41:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f086dba400a5476470972618be56af230cead02f",
          "message": "Add unit tests.",
          "committedDate": "2022-01-12T13:15:26Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19c60f4854fbcdc239d14ed237fdccdb90c4c95b",
          "message": "Fix build error.",
          "committedDate": "2022-01-12T13:15:26Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "67b0a901ad69fead6762ed8d1e554f7ba825e810",
          "message": "Addressing review comments - 4.",
          "committedDate": "2022-01-12T16:19:40Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1fac1821bca1b050db49ee0e27a8d58dc14ef840",
          "message": "Update unit tests.",
          "committedDate": "2022-01-13T14:20:05Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e38f7b9fe059366a8f94012d6f885642bce5d523",
          "message": "Small fixes: codestyle and etc.",
          "committedDate": "2022-01-13T15:00:12Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Benchmark results\r\n|   Method | itemsN |       Mean |     Error |    StdDev |    Gen 0 |    Gen 1 |    Gen 2 | Allocated | Code Size |\r\n|--------- |------------ |-----------:|----------:|----------:|---------:|---------:|---------:|----------:|----------:|\r\n| Hash_old |           1 |   4.160 us | 0.0135 us | 0.0113 us |   0.3815 |        - |        - |   1.58 KB |   0.05 KB |\r\n| Hash_new |           1 |   3.909 us | 0.0201 us | 0.0168 us |   0.5188 |        - |        - |   2.13 KB |   0.05 KB |\r\n| Hash_old |          50 |  21.633 us | 0.4320 us | 0.4802 us |   4.6997 |        - |        - |  19.36 KB |   0.05 KB |\r\n| Hash_new |          50 |  19.812 us | 0.2839 us | 0.2370 us |   0.5188 |        - |        - |   2.22 KB |   0.05 KB |\r\n| Hash_old |         100 |  38.248 us | 0.2357 us | 0.1841 us |   9.0332 |        - |        - |   37.3 KB |   0.05 KB |\r\n| Hash_new |         100 |  35.920 us | 0.3721 us | 0.3299 us |   0.5493 |        - |        - |   2.38 KB |   0.05 KB |\r\n| Hash_old |         200 |  74.621 us | 1.3318 us | 1.2458 us |  17.9443 |   1.9531 |        - |  73.71 KB |   0.05 KB |\r\n| Hash_new |         200 |  68.415 us | 0.4927 us | 0.4608 us |   0.4883 |        - |        - |    2.3 KB |   0.05 KB |\r\n| Hash_old |         500 | 175.176 us | 1.9376 us | 1.7177 us |  43.9453 |   9.7656 |        - | 182.67 KB |   0.05 KB |\r\n| Hash_new |         500 | 165.182 us | 1.3158 us | 1.0273 us |   0.4883 |        - |        - |   2.07 KB |   0.05 KB |\r\n| Hash_old |        1000 | 457.556 us | 3.5648 us | 2.7831 us |  90.8203 |  90.8203 |  90.8203 | 364.31 KB |   0.05 KB |\r\n| Hash_new |        1000 | 323.996 us | 2.5561 us | 2.2659 us |   0.4883 |        - |        - |   2.18 KB |   0.05 KB |\r\n| Hash_old |        2000 | 805.439 us | 6.8509 us | 6.0732 us | 230.4688 | 230.4688 | 230.4688 | 732.84 KB |   0.05 KB |\r\n| Hash_new |        2000 | 656.162 us | 7.2575 us | 6.4336 us |        - |        - |        - |   2.38 KB |   0.05 KB |",
        "createdAt": "2021-12-21T16:48:31Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "> They'd have to JIT something extra if they hadn't already...it looks like we use System.Buffers in InterningBinaryReader.cs and System.Buffers.Binary in NodeProviderOutOfProcBase.cs. I'm not sure if System.Buffers.Binary is a separate assembly, but if it is, maybe not?\r\n\r\nWon't the BCL already use arraypool, hence it'd be jitted already?",
        "createdAt": "2021-12-21T21:06:24Z",
        "author": {
          "login": "Therzok"
        }
      },
      {
        "body": "> Won't the BCL already use arraypool, hence it'd be jitted already?\r\n\r\nI am not sure about that. Do you know anybody who we could ask and figure this out?",
        "createdAt": "2021-12-22T16:23:15Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "> > Won't the BCL already use arraypool, hence it'd be jitted already?\r\n> \r\n> I am not sure about that. Do you know anybody who we could ask and figure this out?\r\n\r\n@danmoseley maybe?",
        "createdAt": "2021-12-23T04:26:26Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> > > Won't the BCL already use arraypool, hence it'd be jitted already?\r\n> > \r\n> > \r\n> > I am not sure about that. Do you know anybody who we could ask and figure this out?\r\n> \r\n> @danmoseley maybe?\r\n\r\nYes the core libraries use `System.Buffers.ArrayPool<T>.Shared` extensively, for byte and char. I would not expect MSBuild to add more jitting by using it for those.\r\n\r\nEventually I expect MSBuild could make use of `ValueStringBuilder` instead of `StringBuilder` in many places, and thus avoid pooling/allocating the `StringBuilder` as well. That's internal right now for safety reasons but there's [discussion ](https://github.com/dotnet/runtime/issues/25587) about making it public.",
        "createdAt": "2021-12-23T19:45:41Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "> Presumably `sha1.TransformBlock` has a constant cost which led to introducing the intermediate buffer. Do you have numbers on the perf characteristics of `TransformBlock` to back it up?\r\n> \r\n> In other words, I am wondering how the code would perform without `sha1Buffer`, so if you called `TransformBlock` always, regardless of how small the incoming buffer is.\r\n\r\nI definitely tried to write this without additional buffer in the first place, but it works longer in this case and makes me think about how to trade CPU for memory improvements.  Adding this buffer I found a way not to think of it too much: both CPU and memory improves in this PR. I would need more time to repeat these measurements to show you numbers, but maybe you could check [comments ](https://github.com/dotnet/msbuild/pull/5560#issuecomment-666419183) under previous PR about Hash function. There are such measurements too and they coincide with what I got. Their `Hash1` is my `Hash_old` and `Hash2` is the version with `TransformBlock` without any buffer. I suppose those measurements would be enough to get an insight how the code would perform.",
        "createdAt": "2022-01-03T15:52:11Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "> 1. Would wrapping `sha1Buffer` with a `MemoryStream` simplify the code or would it make it worse?\r\n> 2. Do existing unit tests cover all code paths?\r\n\r\n1. Hm, it might make the code more readable right, but i am do not have time for it right now - I would need to run it through benchmark too, I suppose. I can make a follow up pr for that later. I suppose current version is readable enough.\r\n2. They do go through all the code paths, but not good enough, as for me. I suppose I can make some improvements there when I have more time, as a follow up. There is no long strings in the tests. Also, see the commit \"Fix bug.\". It could be a bug if the constants were different but worked correctly with current constants. This code path could not be hit in a wrong way when chunk size is less then sha1 buffer size. I caught it in my additional manual tests when I modified the sizes of the buffer and checked for random strings that output for old and new hash coincides. I suppose I might add constants modification to the tests for more coverage.  ",
        "createdAt": "2022-01-03T18:08:48Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "I ran the tests again: the failure was not related to my changes. Now the tests pass.",
        "createdAt": "2022-01-03T18:10:37Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "> > 1. Would wrapping `sha1Buffer` with a `MemoryStream` simplify the code or would it make it worse?\r\n> > 2. Do existing unit tests cover all code paths?\r\n> \r\n> 1. Hm, it might make the code more readable right, but i am do not have time for it right now - I would need to run it through benchmark too, I suppose. I can make a follow up pr for that later. I suppose current version is readable enough.\r\n> 2. They do go through all the code paths, but not good enough, as for me. I suppose I can make some improvements there when I have more time, as a follow up. There is no long strings in the tests. Also, see the commit \"Fix bug.\". It could be a bug if the constants were different but worked correctly with current constants. This code path could not be hit in a wrong way when chunk size is less then sha1 buffer size. I caught it in my additional manual tests when I modified the sizes of the buffer and checked for random strings that output for old and new hash coincides. I suppose I might add constants modification to the tests for more coverage.\r\n\r\nAre you planning to incorporate any of these changes into this PR, or do you want it merged as-is and perhaps tackle some in a follow-up? (If follow-up, maybe make an issue for that?)",
        "createdAt": "2022-01-03T18:28:12Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Here I am not completely sure that it is a good idea to rent a buffer from a pool. \r\nWe might just use allocations instead here and it will not be much worse.\r\nWhat do you think of using `System.Buffers` in a task?  Could it lead to any problems? For example, for users who would like to use this task somehow?",
              "createdAt": "2021-12-21T17:07:44Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "They'd have to JIT something extra if they hadn't already...it looks like we use System.Buffers in InterningBinaryReader.cs and System.Buffers.Binary in NodeProviderOutOfProcBase.cs. I'm not sure if System.Buffers.Binary is a separate assembly, but if it is, maybe not?",
              "createdAt": "2021-12-21T20:16:08Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If System.Buffers is present (net6+), the BCL already uses it in many places, so I guess it's JITted already ",
              "createdAt": "2021-12-21T21:07:52Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);",
              "author": {
                "login": "Therzok"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why static vs. constant? Aren't these all used the same way?",
              "createdAt": "2021-12-21T20:10:29Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I wanted to allocate and compute this byte array only once, so I opted for `static readonly` instead of `const`. Two other static variables are the ones the byte array depends on. There is no reason though for two other variables not being static too, as far as I see.",
              "createdAt": "2021-12-22T08:55:14Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it really helpful to be so precise? maxInputChunkLength isn't huge, and you're walking through (potentially) a large number of strings to get a number that may be more precise but probably won't be a power of 2, which just means you're likely to end up at 128 or 256 anyway. Also makes the code a bit more complicated.",
              "createdAt": "2021-12-21T20:13:04Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Well, 256 is a string size, the byte array size would be a bit bigger. But I see your point, I suppose it could be good idea. Initially having `maxInputChunkLength` was just a safe measure for preventing to allocate too big byte array and I did not expect to hit this code path too often. ",
              "createdAt": "2021-12-22T09:03:46Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Possible benefit of char-by-char copying and capitalizing?",
              "createdAt": "2021-12-21T20:16:28Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Here I do not yet have a good idea how I can make an efficient char-by-char in place capitalization, without extra allocations and in a way that code is short and clear. I am not sure this question is worth looking further, because when msbuild is using this task, these `itemSpec` are just file paths and not huge strings. ",
              "createdAt": "2021-12-22T09:12:04Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe unnecessary?",
              "createdAt": "2021-12-21T20:20:36Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We certainly need some separator because otherwise I can easily create two sets of filenames, for example, which would give the same hash. That doesn't work for us. ",
              "createdAt": "2021-12-22T09:17:56Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "It's easy to construct, but I imagine it's very hard in practice. If you have full paths on windows, the `:` can only be the second character. If you have relative paths, you would need, at minimum, something like `a.txt`, `b.txt`, and `a.txtb.txt`, where that last seems unlikely.",
              "createdAt": "2021-12-22T14:47:32Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "For the file paths and file names with extension I do agree. But this is a task, who knows how it would be used. Better to be safe. \"Seems unlikely\" are not chances I would like to take if there is possibility of breaking the build silently. \r\nThe second point is that previous implementation used the same approach. Therefore, If I want not to change the result, I need this line.",
              "createdAt": "2021-12-22T16:11:05Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you ever use this?",
              "createdAt": "2021-12-21T20:22:22Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));\n                         }\n-\n                         HashResult = stringBuilder.ToString();\n                     }\n                 }\n             }\n-\n             return true;\n         }\n \n-        private int ComputeStringSize(ITaskItem[] itemsToHash)\n+        /// <summary>\n+        /// Add bytes to the sha1 buffer. Once the limit size is reached, sha1.TransformBlock is called and the buffer is flushed.\n+        /// </summary>\n+        /// <param name=\"sha1\">Hashing algorithm sha1.</param>\n+        /// <param name=\"sha1Buffer\">The sha1 buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>\n+        /// <param name=\"sha1BufferLength\">Number of used bytes of the sha1 buffer.</param>\n+        /// <param name=\"sha1BufferSize\">The size of sha1 buffer.</param>\n+        /// <param name=\"bytesBuffer\">Bytes buffer which contains bytes to be written to sha1 buffer.</param>\n+        /// <param name=\"bytesNumber\">Amount of bytes that are to be added to sha1 buffer.</param>\n+        /// <returns></returns>\n+        private bool AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, ref int sha1BufferLength, int sha1BufferSize, byte[] bytesBuffer, int bytesNumber)\n         {\n-            if (itemsToHash.Length == 0)\n+            int bytesProcessedNumber = 0;\n+            while (sha1BufferLength + bytesNumber >= sha1BufferSize)\n             {\n-                return 0;\n+                int sha1BufferFreeSpace = sha1BufferSize - sha1BufferLength;\n+\n+                if (sha1BufferLength == 0)\n+                {\n+                    // If sha1 buffer is empty and bytes number is big enough there is no need to copy bytes to sha1 buffer.\n+                    // Pass the bytes to TransformBlock right away.\n+                    sha1.TransformBlock(bytesBuffer, 0, sha1BufferSize, null, 0);\n+                }\n+                else\n+                {\n+                    Array.Copy(bytesBuffer, bytesProcessedNumber, sha1Buffer, sha1BufferLength, sha1BufferFreeSpace);\n+                    sha1.TransformBlock(sha1Buffer, 0, sha1BufferSize, null, 0);\n+                    sha1BufferLength = 0;\n+                }\n+\n+                bytesProcessedNumber += sha1BufferFreeSpace;\n+                bytesNumber -= sha1BufferFreeSpace;\n             }\n \n-            var totalItemSize = 0;\n+            Array.Copy(bytesBuffer, bytesProcessedNumber, sha1Buffer, sha1BufferLength, bytesNumber);\n+            sha1BufferLength += bytesNumber;\n \n+            return true;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Right, forgot to remove the return value. I will make it void.",
              "createdAt": "2021-12-22T09:21:20Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));\n                         }\n-\n                         HashResult = stringBuilder.ToString();\n                     }\n                 }\n             }\n-\n             return true;\n         }\n \n-        private int ComputeStringSize(ITaskItem[] itemsToHash)\n+        /// <summary>\n+        /// Add bytes to the sha1 buffer. Once the limit size is reached, sha1.TransformBlock is called and the buffer is flushed.\n+        /// </summary>\n+        /// <param name=\"sha1\">Hashing algorithm sha1.</param>\n+        /// <param name=\"sha1Buffer\">The sha1 buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>\n+        /// <param name=\"sha1BufferLength\">Number of used bytes of the sha1 buffer.</param>\n+        /// <param name=\"sha1BufferSize\">The size of sha1 buffer.</param>\n+        /// <param name=\"bytesBuffer\">Bytes buffer which contains bytes to be written to sha1 buffer.</param>\n+        /// <param name=\"bytesNumber\">Amount of bytes that are to be added to sha1 buffer.</param>\n+        /// <returns></returns>\n+        private bool AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, ref int sha1BufferLength, int sha1BufferSize, byte[] bytesBuffer, int bytesNumber)\n         {\n-            if (itemsToHash.Length == 0)\n+            int bytesProcessedNumber = 0;\n+            while (sha1BufferLength + bytesNumber >= sha1BufferSize)\n             {\n-                return 0;\n+                int sha1BufferFreeSpace = sha1BufferSize - sha1BufferLength;\n+\n+                if (sha1BufferLength == 0)\n+                {\n+                    // If sha1 buffer is empty and bytes number is big enough there is no need to copy bytes to sha1 buffer.\n+                    // Pass the bytes to TransformBlock right away.\n+                    sha1.TransformBlock(bytesBuffer, 0, sha1BufferSize, null, 0);\n+                }\n+                else\n+                {\n+                    Array.Copy(bytesBuffer, bytesProcessedNumber, sha1Buffer, sha1BufferLength, sha1BufferFreeSpace);\n+                    sha1.TransformBlock(sha1Buffer, 0, sha1BufferSize, null, 0);\n+                    sha1BufferLength = 0;\n+                }\n+\n+                bytesProcessedNumber += sha1BufferFreeSpace;\n+                bytesNumber -= sha1BufferFreeSpace;\n             }\n \n-            var totalItemSize = 0;\n+            Array.Copy(bytesBuffer, bytesProcessedNumber, sha1Buffer, sha1BufferLength, bytesNumber);\n+            sha1BufferLength += bytesNumber;\n \n+            return true;",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can AppendFormat with something like \"{0:x2}\" be used instead? Not sure.",
              "createdAt": "2021-12-21T20:45:48Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "What's the difference?",
              "createdAt": "2021-12-21T21:12:37Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Avoids intermediate ToString allocation and uses writes directly to the internal stringbuilder buffer.",
              "createdAt": "2021-12-21T23:08:05Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "current: value.ToString(fmt) -> Append(string)\r\nproposed: AppendFormat(fmt, value)\r\n\r\nThe only downside is that you probably box the int, so allocation still occurs, but smaller than original.",
              "createdAt": "2021-12-21T23:09:03Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "yeah, I suppose we can use it here. I will try it.",
              "createdAt": "2021-12-22T09:23:25Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "hmm, I suppose I will not switch to `AppendFormat`: there is no function `AppendFormat` in ReuseableStringBuilder at the moment and I do not see improvement when I tried to switch in benchmark results. I do not think it is worth additional work here.",
              "createdAt": "2021-12-22T18:52:22Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,120 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    int maxItemStringSize = encoding.GetMaxByteCount(Math.Min(ComputeMaxItemSpecLength(ItemsToHash), maxInputChunkLength));\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(maxItemStringSize);\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Isn't this equivalent to the existing condition `ItemsToHash?.Length > 0` ?",
              "createdAt": "2022-01-03T13:41:07Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It is the same condition, obviously. \r\nThis append because I was rewriting the whole code of the function, I removed the old function completely and wrote it in the other way myself.  ",
              "createdAt": "2022-01-03T15:26:15Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Typo `reachs`.",
              "createdAt": "2022-01-03T13:41:29Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Inconsistent field naming. This one is all lower-case while the other two statics are CamelCase. Also, shouldn't they all start with `s_`?",
              "createdAt": "2022-01-03T13:45:30Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Slightly different names that would let me understand the code faster (subjective, feel free to ignore):\r\n`sha1BufferLength` -> `sha1BufferPosition`\r\n`bytesNumber` -> `byteCount`",
              "createdAt": "2022-01-03T14:58:16Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(encoding.GetMaxByteCount(maxInputChunkLength));\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n+                            int charsToProcess = Math.Min(itemSpecLength, maxInputChunkLength);\n+                            int bytesNumber = encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, bytesBuffer, 0);\n+                            itemSpecPosition += charsToProcess;\n+                            itemSpecLength -= charsToProcess;\n+\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, bytesBuffer, bytesNumber);\n                         }\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                        AddBytesToSha1Buffer(sha1, sha1Buffer, ref bufferLength, sha1BufferSize, ItemSeparatorCharacterBytes, ItemSeparatorCharacterBytes.Length);\n+                    }\n \n-                        stringBuilder.Clear();\n+                    sha1.TransformFinalBlock(sha1Buffer, 0, bufferLength);\n \n-                        foreach (var b in hash)\n+                    using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                    {\n+                        foreach (var b in sha1.Hash)\n                         {\n                             stringBuilder.Append(b.ToString(\"x2\"));\n                         }\n-\n                         HashResult = stringBuilder.ToString();\n                     }\n                 }\n             }\n-\n             return true;\n         }\n \n-        private int ComputeStringSize(ITaskItem[] itemsToHash)\n+        /// <summary>\n+        /// Add bytes to the sha1 buffer. Once the limit size is reached, sha1.TransformBlock is called and the buffer is flushed.\n+        /// </summary>\n+        /// <param name=\"sha1\">Hashing algorithm sha1.</param>\n+        /// <param name=\"sha1Buffer\">The sha1 buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>\n+        /// <param name=\"sha1BufferLength\">Number of used bytes of the sha1 buffer.</param>\n+        /// <param name=\"sha1BufferSize\">The size of sha1 buffer.</param>\n+        /// <param name=\"bytesBuffer\">Bytes buffer which contains bytes to be written to sha1 buffer.</param>\n+        /// <param name=\"bytesNumber\">Amount of bytes that are to be added to sha1 buffer.</param>\n+        private void AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, ref int sha1BufferLength, int sha1BufferSize, byte[] bytesBuffer, int bytesNumber)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                        for (int itemSpecPosition = 0; itemSpecPosition < itemSpec.Length; itemSpecPosition += maxInputChunkLength)\r\n```\r\n\r\nwhich lets you remove the `itemSpecPosition += ...` and `itemSpecLength += ...` below.",
              "createdAt": "2022-01-03T15:00:54Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });\n+\n+        private const int sha1BufferSize = 512;\n+\n+        private const int maxInputChunkLength = 256;\n+\n         /// <summary>\n         /// Execute the task.\n         /// </summary>\n         public override bool Execute()\n         {\n-            if (ItemsToHash?.Length > 0)\n+            if (ItemsToHash != null && ItemsToHash.Length > 0)\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reachs the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    byte[] bytesBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(encoding.GetMaxByteCount(maxInputChunkLength));\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    int bufferLength = 0;\n+                    for (int i = 0; i < ItemsToHash.Length; i++)\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n+\n+                        // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                        int itemSpecLength = itemSpec.Length;\n+                        int itemSpecPosition = 0;\n+                        while (itemSpecLength > 0)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please either use const and rename to `itemSeparatorCharacter` or rename it to `s_itemSeparatorCharacter` to follow naming rules for private statics and private const.",
              "createdAt": "2022-01-03T15:46:40Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please rename it to `s_ItemSeparatorCharacterBytes` to follow naming rules for private statics.",
              "createdAt": "2022-01-03T15:47:18Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -37,61 +35,102 @@ public class Hash : TaskExtension\n         [Output]\n         public string HashResult { get; set; }\n \n+        private static readonly char ItemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] ItemSeparatorCharacterBytes = encoding.GetBytes(new char[] { ItemSeparatorCharacter });",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These buffers should be returned back to the pool using the [Return](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1.return) method.",
              "createdAt": "2022-01-04T10:19:08Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -46,52 +54,79 @@ public override bool Execute()\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reaches the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n \n-                    var hashStringSize = sha1.HashSize;\n+                    byte[] byteBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(s_encoding.GetMaxByteCount(maxInputChunkLength));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public void HashTaskLargeInputCountTest()\r\n```",
              "createdAt": "2022-01-12T12:59:45Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public void HashTaskLargeInputSizeTest()\r\n```",
              "createdAt": "2022-01-12T12:59:55Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is 1_000_000 iterations, is it? What is usual duration if this unit test?",
              "createdAt": "2022-01-12T13:04:02Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "It's 1 sec. It is less than the HashTaskDifferentImputSizesTest takes.",
              "createdAt": "2022-01-12T13:57:51Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "The duration of these tests worries me though.",
              "createdAt": "2022-01-12T13:58:24Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "1 sec is too much, IMHO, can we get it under 100ms?",
              "createdAt": "2022-01-12T16:13:15Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This one is most unnecessary test of all. Maybe drop it at all?",
              "createdAt": "2022-01-12T16:42:08Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "However, I would like to save the test with different sizes of input (`HashTaskDifferentInputSizesTest`) despite it takes 3 sec, cause it tests a dangerous place where one can easily make a mistake.",
              "createdAt": "2022-01-12T16:45:04Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "+1 on trying to make the tests fast. I'd say 3 seconds is too much.",
              "createdAt": "2022-01-13T13:01:05Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Ok, got it. I will remove this test as not very necessary one and I will improve `HashTaskDifferentInputSizesTest`. So far I got ~0.5 sec on my machine instead of 3. ",
              "createdAt": "2022-01-13T14:55:48Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public void HashTaskLargeInputCountAndSizeTest()\r\n```",
              "createdAt": "2022-01-12T13:06:05Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public void HashTaskDifferentInputSizesTest()\r\n```",
              "createdAt": "2022-01-12T13:06:15Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";\n+                }\n+            }\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[inputSize];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem(string.Join(\"\", array[i]));\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+#pragma warning disable CA5350\n+        [Fact]\n+        public void HashTaskDifferentImputSizesTest()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If I understand it correctly the intent of this task is to verify that hash computes is correct for various numbers of characters so we catch frequent edge of the buffer use cases regardless on the size of the buffer. \r\nCan you please consider to state intent of this unit test in comments?",
              "createdAt": "2022-01-12T13:13:22Z",
              "path": "src/Tasks.UnitTests/Hash_Tests.cs",
              "diffHunk": "@@ -43,6 +43,100 @@ public void HashTaskEmptyInputTest()\n             Assert.Null(zeroLengthItemsHash);\n         }\n \n+        [Fact]\n+        public void HashTaskLargeImputCountTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"8a996bbcb5e481981c2fba7ac408e20d0b4360a5\";\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[1000];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem($\"Item{i}\");\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"0509142dd3d3a733f30a52a0eec37cd727d46122\";\n+\n+            string[] array = new string[1000];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = $\"Item{i}\";\n+            }\n+            ITaskItem[] itemsToHash = new ITaskItem[] { new TaskItem(string.Join(\"\", array)) };\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+        [Fact]\n+        public void HashTaskLargeImputCountAndSizeTest()\n+        {\n+            // This hash was pre-computed. If the implementation changes it may need to be adjusted.\n+            var expectedHash = \"be23ae7b09f1e14fa5a17de87ddae2c3ec62f967\";\n+\n+            int inputSize = 1000;\n+            string[][] array = new string[inputSize][];\n+            for (int i = 0; i < array.Length; i++)\n+            {\n+                array[i] = new string[inputSize];\n+                for (int j = 0; j < array[i].Length; j++)\n+                {\n+                    array[i][j] = $\"Item{i}{j}\";\n+                }\n+            }\n+\n+            ITaskItem[] itemsToHash = new ITaskItem[inputSize];\n+            for (int i = 0; i < itemsToHash.Length; i++)\n+            {\n+                itemsToHash[i] = new TaskItem(string.Join(\"\", array[i]));\n+            }\n+\n+            var actualHash = ExecuteHashTask(itemsToHash);\n+\n+            Assert.Equal(expectedHash, actualHash);\n+        }\n+\n+#pragma warning disable CA5350\n+        [Fact]\n+        public void HashTaskDifferentImputSizesTest()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Although MSBuild is not 100% consistent in this in vast majority we tend to use PascalCasing for constants.",
              "createdAt": "2022-01-12T13:15:51Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -18,7 +18,19 @@ namespace Microsoft.Build.Tasks\n     /// </remarks>\n     public class Hash : TaskExtension\n     {\n-        private const char ItemSeparatorCharacter = '\\u2028';\n+        private const char s_itemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding s_encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { s_itemSeparatorCharacter });\n+\n+        // Size of buffer where bytes of the strings are stored until sha1.TransformBlock is be run on them.\n+        // It is needed to get a balance between amount of costly sha1.TransformBlock calls and amount of allocated memory.\n+        private const int sha1BufferSize = 512;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please use PascalCasing",
              "createdAt": "2022-01-12T13:16:05Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -18,7 +18,19 @@ namespace Microsoft.Build.Tasks\n     /// </remarks>\n     public class Hash : TaskExtension\n     {\n-        private const char ItemSeparatorCharacter = '\\u2028';\n+        private const char s_itemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding s_encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { s_itemSeparatorCharacter });\n+\n+        // Size of buffer where bytes of the strings are stored until sha1.TransformBlock is be run on them.\n+        // It is needed to get a balance between amount of costly sha1.TransformBlock calls and amount of allocated memory.\n+        private const int sha1BufferSize = 512;\n+\n+        // Size of chunks in which ItemSpecs would be cut.\n+        // String of size 169 gives no more than ~512 bytes in utf8 encoding.\n+        private const int maxInputChunkLength = 169;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: Please consider to include further clarification, something like: `We have chosen this length so byteBuffer rented from ArrayPool will be close but not bigger than 512.\"",
              "createdAt": "2022-01-12T13:25:20Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -18,7 +18,19 @@ namespace Microsoft.Build.Tasks\n     /// </remarks>\n     public class Hash : TaskExtension\n     {\n-        private const char ItemSeparatorCharacter = '\\u2028';\n+        private const char s_itemSeparatorCharacter = '\\u2028';\n+\n+        private static readonly Encoding s_encoding = Encoding.UTF8;\n+\n+        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { s_itemSeparatorCharacter });\n+\n+        // Size of buffer where bytes of the strings are stored until sha1.TransformBlock is be run on them.\n+        // It is needed to get a balance between amount of costly sha1.TransformBlock calls and amount of allocated memory.\n+        private const int sha1BufferSize = 512;\n+\n+        // Size of chunks in which ItemSpecs would be cut.\n+        // String of size 169 gives no more than ~512 bytes in utf8 encoding.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: `byteBuffer` is little too generic. Please consider to rename to something like `itemSpecChunkByteBuffer`",
              "createdAt": "2022-01-12T13:29:48Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -46,52 +58,97 @@ public override bool Execute()\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reaches the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = null;\n \n-                    var hashStringSize = sha1.HashSize;\n+                    // Buffer in which bytes of items' ItemSpec are to be stored.\n+                    byte[] byteBuffer = null;\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    try\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n+                        byteBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(s_encoding.GetMaxByteCount(maxInputChunkLength));",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: please consider to change method signature to:\r\n`private int AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, int sha1BufferPosition, int sha1BufferSize, byte[] byteBuffer, int byteCount)` so this method returns new sha1BufferPosition.\r\nReasoning: using ref argument prohibit compiler to use registry for sha1BufferPosition with resulting of degraded performance.",
              "createdAt": "2022-01-12T13:49:41Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -46,52 +58,97 @@ public override bool Execute()\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reaches the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = null;\n \n-                    var hashStringSize = sha1.HashSize;\n+                    // Buffer in which bytes of items' ItemSpec are to be stored.\n+                    byte[] byteBuffer = null;\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    try\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n+                        byteBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(s_encoding.GetMaxByteCount(maxInputChunkLength));\n+\n+                        int sha1BufferPosition = 0;\n+                        for (int i = 0; i < ItemsToHash.Length; i++)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n-                        }\n+                            string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                            // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                            for (int itemSpecPosition = 0; itemSpecPosition < itemSpec.Length; itemSpecPosition += maxInputChunkLength)\n+                            {\n+                                int charsToProcess = Math.Min(itemSpec.Length - itemSpecPosition, maxInputChunkLength);\n+                                int byteCount = s_encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, byteBuffer, 0);\n \n-                        stringBuilder.Clear();\n+                                AddBytesToSha1Buffer(sha1, sha1Buffer, ref sha1BufferPosition, sha1BufferSize, byteBuffer, byteCount);\n+                            }\n \n-                        foreach (var b in hash)\n-                        {\n-                            stringBuilder.Append(b.ToString(\"x2\"));\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref sha1BufferPosition, sha1BufferSize, s_itemSeparatorCharacterBytes, s_itemSeparatorCharacterBytes.Length);\n                         }\n \n-                        HashResult = stringBuilder.ToString();\n+                        sha1.TransformFinalBlock(sha1Buffer, 0, sha1BufferPosition);\n+\n+                        using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                        {\n+                            foreach (var b in sha1.Hash)\n+                            {\n+                                stringBuilder.Append(b.ToString(\"x2\"));\n+                            }\n+                            HashResult = stringBuilder.ToString();\n+                        }\n+                    }\n+                    finally\n+                    {\n+                        if (sha1Buffer != null)\n+                        {\n+                            System.Buffers.ArrayPool<byte>.Shared.Return(sha1Buffer);\n+                        }\n+                        if (byteBuffer != null)\n+                        {\n+                            System.Buffers.ArrayPool<byte>.Shared.Return(byteBuffer);\n+                        }\n                     }\n                 }\n             }\n-\n             return true;\n         }\n \n-        private int ComputeStringSize(ITaskItem[] itemsToHash)\n+        /// <summary>\n+        /// Add bytes to the sha1 buffer. Once the limit size is reached, sha1.TransformBlock is called and the buffer is flushed.\n+        /// </summary>\n+        /// <param name=\"sha1\">Hashing algorithm sha1.</param>\n+        /// <param name=\"sha1Buffer\">The sha1 buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>\n+        /// <param name=\"sha1BufferPosition\">Number of used bytes of the sha1 buffer.</param>\n+        /// <param name=\"sha1BufferSize\">The size of sha1 buffer.</param>\n+        /// <param name=\"byteBuffer\">Bytes buffer which contains bytes to be written to sha1 buffer.</param>\n+        /// <param name=\"byteCount\">Amount of bytes that are to be added to sha1 buffer.</param>\n+        private void AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, ref int sha1BufferPosition, int sha1BufferSize, byte[] byteBuffer, int byteCount)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: I think `bytesProcessed` is sufficient",
              "createdAt": "2022-01-12T13:52:42Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -46,52 +58,97 @@ public override bool Execute()\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reaches the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.\n+                    byte[] sha1Buffer = null;\n \n-                    var hashStringSize = sha1.HashSize;\n+                    // Buffer in which bytes of items' ItemSpec are to be stored.\n+                    byte[] byteBuffer = null;\n \n-                    using (var stringBuilder = new ReuseableStringBuilder(Math.Max(concatenatedItemStringSize, hashStringSize)))\n+                    try\n                     {\n-                        foreach (var item in ItemsToHash)\n+                        sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(sha1BufferSize);\n+                        byteBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(s_encoding.GetMaxByteCount(maxInputChunkLength));\n+\n+                        int sha1BufferPosition = 0;\n+                        for (int i = 0; i < ItemsToHash.Length; i++)\n                         {\n-                            string itemSpec = item.ItemSpec;\n-                            stringBuilder.Append(IgnoreCase ? itemSpec.ToUpperInvariant() : itemSpec);\n-                            stringBuilder.Append(ItemSeparatorCharacter);\n-                        }\n+                            string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;\n \n-                        var hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(stringBuilder.ToString()));\n+                            // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.\n+                            for (int itemSpecPosition = 0; itemSpecPosition < itemSpec.Length; itemSpecPosition += maxInputChunkLength)\n+                            {\n+                                int charsToProcess = Math.Min(itemSpec.Length - itemSpecPosition, maxInputChunkLength);\n+                                int byteCount = s_encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, byteBuffer, 0);\n \n-                        stringBuilder.Clear();\n+                                AddBytesToSha1Buffer(sha1, sha1Buffer, ref sha1BufferPosition, sha1BufferSize, byteBuffer, byteCount);\n+                            }\n \n-                        foreach (var b in hash)\n-                        {\n-                            stringBuilder.Append(b.ToString(\"x2\"));\n+                            AddBytesToSha1Buffer(sha1, sha1Buffer, ref sha1BufferPosition, sha1BufferSize, s_itemSeparatorCharacterBytes, s_itemSeparatorCharacterBytes.Length);\n                         }\n \n-                        HashResult = stringBuilder.ToString();\n+                        sha1.TransformFinalBlock(sha1Buffer, 0, sha1BufferPosition);\n+\n+                        using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))\n+                        {\n+                            foreach (var b in sha1.Hash)\n+                            {\n+                                stringBuilder.Append(b.ToString(\"x2\"));\n+                            }\n+                            HashResult = stringBuilder.ToString();\n+                        }\n+                    }\n+                    finally\n+                    {\n+                        if (sha1Buffer != null)\n+                        {\n+                            System.Buffers.ArrayPool<byte>.Shared.Return(sha1Buffer);\n+                        }\n+                        if (byteBuffer != null)\n+                        {\n+                            System.Buffers.ArrayPool<byte>.Shared.Return(byteBuffer);\n+                        }\n                     }\n                 }\n             }\n-\n             return true;\n         }\n \n-        private int ComputeStringSize(ITaskItem[] itemsToHash)\n+        /// <summary>\n+        /// Add bytes to the sha1 buffer. Once the limit size is reached, sha1.TransformBlock is called and the buffer is flushed.\n+        /// </summary>\n+        /// <param name=\"sha1\">Hashing algorithm sha1.</param>\n+        /// <param name=\"sha1Buffer\">The sha1 buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>\n+        /// <param name=\"sha1BufferPosition\">Number of used bytes of the sha1 buffer.</param>\n+        /// <param name=\"sha1BufferSize\">The size of sha1 buffer.</param>\n+        /// <param name=\"byteBuffer\">Bytes buffer which contains bytes to be written to sha1 buffer.</param>\n+        /// <param name=\"byteCount\">Amount of bytes that are to be added to sha1 buffer.</param>\n+        private void AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, ref int sha1BufferPosition, int sha1BufferSize, byte[] byteBuffer, int byteCount)\n         {\n-            if (itemsToHash.Length == 0)\n+            int bytesProcessedNumber = 0;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo \"is be run\".",
              "createdAt": "2022-01-13T12:55:34Z",
              "path": "src/Tasks/Hash.cs",
              "diffHunk": "@@ -46,52 +55,100 @@ public override bool Execute()\n             {\n                 using (var sha1 = SHA1.Create())\n                 {\n-                    var concatenatedItemStringSize = ComputeStringSize(ItemsToHash);\n+                    // Buffer in which bytes of the strings are to be stored until their number reaches the limit size.\n+                    // Once the limit is reached, the sha1.TransformBlock is be run on all the bytes of this buffer.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}