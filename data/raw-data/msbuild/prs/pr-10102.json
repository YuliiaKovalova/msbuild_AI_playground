{
  "number": 10102,
  "title": "Expander refactoring [property tracking analyzers prerequisity]",
  "body": "Contributes to #9883 (spinoff from #10009 - focusing on parts not related to BuildCheck)\r\n\r\n### Note\r\n\r\nThere is no new functionality in this PR - just refactoring and code moving. It is required for the followup PR(s) for property tracking analyzers\r\n\r\n### Context\r\nExpander is using `LoggingContext` in some of the execution paths, but in it usually has a default value of `null` - so we end up with literaly hundrets of calling paths where we cannot be sure whether `LoggingContext` is available or not. The `LoggingContext` is appealing for a data pub-sub, so let's make sure it's available throughout the `Expander` calls, while at the same let's simplify the code a bit\r\n\r\n\r\n### Changes Made\r\n * Added constructors to `Expander` to pass `LoggingContext` wherever possible (the only exception is the Expander usages from the ToolsetReader - where we do not know the build context yet).\r\n * Removed explicit LoggingContext arg from the Expander methods\r\n  Reason: Went through all the methods in Expander and all the possible caller chains (there were many hunderts of them) - and found out there is just a single case where LoggingContext passed to expander calls differ from the LoggingContext used to construct the Expander\r\n * Added `ItemBucket.UpdateLoggingContext` \r\n    Reason:  The single differing case was in `TargetEntry.ExecuteTarget` where `ProjectLoggingContext` was used to construct the `Expander`, but then `TargetLogginContext` was used to transitively call the methods. So the updating of the context was used to bridge this case\r\n * Moved the conditioning of `PropertyTrackingEvaluatorDataWrapper` into the type - so that in the folowup PR we can use the type to feed data to analyzers even if proprty tracking logging is not requested\r\n * Renamed `UsedUninitializedProperties` -> `PropertiesUsageTracker`\r\n * Added more info to calls of `PropertiesUsageTracker`\r\n   * Info about context in which the property was expanded\r\n   * Moved the code to make this class responsible for deciding about uninitialized reads\r\n\r\n\r\n### Testing\r\n Refactored and resued existing tests (as there is no new functionality)",
  "state": "MERGED",
  "createdAt": "2024-05-03T22:13:51Z",
  "updatedAt": "2024-05-20T15:25:08Z",
  "closedAt": "2024-05-20T15:25:07Z",
  "mergedAt": "2024-05-20T15:25:07Z",
  "additions": 805,
  "deletions": 578,
  "changedFiles": 50,
  "headRefName": "exp/expander-refactor",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "acff41ef454beb72dbb4e8e32d414d81331093d1",
          "message": "Refactor expander - logging context and property tracking",
          "committedDate": "2024-05-03T22:07:41Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4f61d9eabf28ced8e14ebfcb06af2fe6be99669d",
          "message": "Fix env vars tracking",
          "committedDate": "2024-05-04T07:00:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "db29aaae10a162e712e629a1e93bc187ae486ef5",
          "message": "Merge branch 'main' into exp/expander-refactor",
          "committedDate": "2024-05-10T07:01:11Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e9d8e65d8c952cbddb880c7abd88089196eee9c4",
          "message": "Fix after merge",
          "committedDate": "2024-05-10T07:06:21Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e51d0ce86f014d09c93546499af26f47519ec146",
          "message": "reflect PR comments",
          "committedDate": "2024-05-10T07:50:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ac40929e9361a00150cd6cead05126523667ff64",
          "message": "Initialize ItemBucket expander only once LoggingContext is known",
          "committedDate": "2024-05-10T12:45:24Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bcbbb4d9f90dcced967a82776473d6dfb3f50e59",
          "message": "Join conditions",
          "committedDate": "2024-05-13T11:03:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fde62739bea4b250668a72c7484bd06797a5a974",
          "message": "Reflect PR comments",
          "committedDate": "2024-05-14T12:29:54Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Extra empty line.",
              "createdAt": "2024-05-07T09:25:57Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -78,14 +77,21 @@ internal override void ExecuteTask(Lookup lookup)\n                                 \"CannotModifyReservedProperty\",\n                                 property.Name);\n \n+                            bucket.Expander.PropertiesUsageTracker.CurrentlyEvaluatingPropertyElementName = property.Name;\n+                            bucket.Expander.PropertiesUsageTracker.PropertyReadContext =\n+                                PropertyReadContext.PropertyEvaluation;\n+",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Assuming this is undoing the initialization of `PropertiesUsageTracker` above, shouldn't it be in a finally block?",
              "createdAt": "2024-05-07T09:28:26Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -78,14 +77,21 @@ internal override void ExecuteTask(Lookup lookup)\n                                 \"CannotModifyReservedProperty\",\n                                 property.Name);\n \n+                            bucket.Expander.PropertiesUsageTracker.CurrentlyEvaluatingPropertyElementName = property.Name;\n+                            bucket.Expander.PropertiesUsageTracker.PropertyReadContext =\n+                                PropertyReadContext.PropertyEvaluation;\n+\n+\n                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);\n+                            bucket.Expander.PropertiesUsageTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);\n \n                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)\n                             {\n                                 LoggingContext.LogComment(MessageImportance.Low, \"PropertyGroupLogMessage\", property.Name, evaluatedValue);\n                             }\n \n                             bucket.Lookup.SetProperty(ProjectPropertyInstance.Create(property.Name, evaluatedValue, property.Location, Project.IsImmutable));\n+                            bucket.Expander.PropertiesUsageTracker.ResetPropertyReadContext(false);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Wrap in a `finally`?",
              "createdAt": "2024-05-07T09:46:50Z",
              "path": "src/Build/Evaluation/ConditionEvaluator.cs",
              "diffHunk": "@@ -301,6 +295,8 @@ public ConcurrentStack<GenericExpressionNode> GetOrAdd(string condition, Func<st\n                 }\n             }\n \n+            expander.PropertiesUsageTracker.ResetPropertyReadContext();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Some implementations of `GetUnexpandedValue` allocate strings. Since this is a fairly perf critical path, I think it would be worth adding a new method specifically for this purpose. Something like `bool IsEmptyUnexpanded(...)` maybe?",
              "createdAt": "2024-05-07T09:56:00Z",
              "path": "src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs",
              "diffHunk": "@@ -51,8 +51,16 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState\n             // and we know which do, then we already have enough information to evaluate this expression.\n             // That means we don't have to fully expand a condition like \" '@(X)' == '' \"\n             // which is a performance advantage if @(X) is a huge item list.\n-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);\n-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);\n+\n+            // this is the possible case of '$(a)' == ''\n+            if (string.IsNullOrEmpty(LeftChild.GetUnexpandedValue(state)) ||\n+                string.IsNullOrEmpty(RightChild.GetUnexpandedValue(state)))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is unfortunate. Not a big deal and not a blocking comment but it does reduce the cleanliness, IMO. Do instances of this class really use the logging context they are constructed with, before it's replaced here? If the answer is no, can we delay creation of these objects until the final logging context is known?",
              "createdAt": "2024-05-09T14:56:37Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -95,11 +98,20 @@ private ItemBucket()\n             }\n \n             _metadata = metadata;\n-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);\n+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default, loggingContext);\n \n             _bucketSequenceNumber = bucketSequenceNumber;\n         }\n \n+        /// <summary>\n+        /// Updates the logging context that this bucket is going to use.\n+        /// </summary>\n+        /// <param name=\"loggingContext\"></param>\n+        internal void UpdateLoggingContext(LoggingContext loggingContext)\n+        {\n+            _expander = _expander.WithLoggingContext(loggingContext);\n+        }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Unfortunately if we batch targets - then buckets are prepared prior the target logging context is created (as that creation logs info about starting run of a target)",
              "createdAt": "2024-05-10T07:49:44Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -95,11 +98,20 @@ private ItemBucket()\n             }\n \n             _metadata = metadata;\n-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);\n+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default, loggingContext);\n \n             _bucketSequenceNumber = bucketSequenceNumber;\n         }\n \n+        /// <summary>\n+        /// Updates the logging context that this bucket is going to use.\n+        /// </summary>\n+        /// <param name=\"loggingContext\"></param>\n+        internal void UpdateLoggingContext(LoggingContext loggingContext)\n+        {\n+            _expander = _expander.WithLoggingContext(loggingContext);\n+        }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Gotcha. I took a quick look and I am still wondering if there is an easy way to make it more elegant (and a bit more performant). Currently:\r\n\r\n1. `ItemBucket` is created, internally it creates a new `Expander` with the original logging context.\r\n2. (The original logging context is not used, the expander is not used.)\r\n3. `UpdateLoggingContext` is called to replace the expander with a newly created one.\r\n\r\nWhat if, instead, `ItemBucket` construction was split into the real constructor and an `Initialize` method. Only the latter would create the expander with the right logging context. This way there would be no throw-away expander, and the pattern of ctor+Initialize would look slightly more conventional.",
              "createdAt": "2024-05-10T08:41:34Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -95,11 +98,20 @@ private ItemBucket()\n             }\n \n             _metadata = metadata;\n-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);\n+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default, loggingContext);\n \n             _bucketSequenceNumber = bucketSequenceNumber;\n         }\n \n+        /// <summary>\n+        /// Updates the logging context that this bucket is going to use.\n+        /// </summary>\n+        /// <param name=\"loggingContext\"></param>\n+        internal void UpdateLoggingContext(LoggingContext loggingContext)\n+        {\n+            _expander = _expander.WithLoggingContext(loggingContext);\n+        }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Looks better then re-creation pattern - thx! - will try that out",
              "createdAt": "2024-05-10T10:30:02Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -95,11 +98,20 @@ private ItemBucket()\n             }\n \n             _metadata = metadata;\n-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);\n+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default, loggingContext);\n \n             _bucketSequenceNumber = bucketSequenceNumber;\n         }\n \n+        /// <summary>\n+        /// Updates the logging context that this bucket is going to use.\n+        /// </summary>\n+        /// <param name=\"loggingContext\"></param>\n+        internal void UpdateLoggingContext(LoggingContext loggingContext)\n+        {\n+            _expander = _expander.WithLoggingContext(loggingContext);\n+        }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the unconditional wrapping expected to have negligible perf impact?",
              "createdAt": "2024-05-09T14:58:37Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -223,12 +224,8 @@ internal class Evaluator<P, I, M, D>\n                 buildEventContext,\n                 string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? \"(null)\" : projectRootElement.ProjectFileLocation.File);\n \n-            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.\n-            if (Traits.Instance.LogPropertyTracking > 0)\n-            {\n-                // Wrap the IEvaluatorData<> object passed in.\n-                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);\n-            }\n+            // Wrap the IEvaluatorData<> object passed in.\n+            data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Let's test with PerfStart (branch for testing: https://github.com/dotnet/msbuild/tree/perf/expander-refactor)",
              "createdAt": "2024-05-10T07:48:39Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -223,12 +224,8 @@ internal class Evaluator<P, I, M, D>\n                 buildEventContext,\n                 string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? \"(null)\" : projectRootElement.ProjectFileLocation.File);\n \n-            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.\n-            if (Traits.Instance.LogPropertyTracking > 0)\n-            {\n-                // Wrap the IEvaluatorData<> object passed in.\n-                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);\n-            }\n+            // Wrap the IEvaluatorData<> object passed in.\n+            data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "PerfStar is currently down with unclear timelines. So I run a manual perf tests- numbers included here:\r\n\r\nhttps://github.com/dotnet/msbuild/pull/10125\r\n\r\ntl;dr;: Basic measurement did not reveal measurable difference",
              "createdAt": "2024-05-14T16:27:41Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -223,12 +224,8 @@ internal class Evaluator<P, I, M, D>\n                 buildEventContext,\n                 string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? \"(null)\" : projectRootElement.ProjectFileLocation.File);\n \n-            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.\n-            if (Traits.Instance.LogPropertyTracking > 0)\n-            {\n-                // Wrap the IEvaluatorData<> object passed in.\n-                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);\n-            }\n+            // Wrap the IEvaluatorData<> object passed in.\n+            data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This feels slightly unusual. Why not make the call only `if (isUninitialized && !isArtificial)` ?",
              "createdAt": "2024-05-10T14:23:18Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5493,13 +5502,57 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n     /// <summary>\n     /// This class wraps information about properties which have been used before they are initialized.\n     /// </summary>\n-    internal sealed class UsedUninitializedProperties\n+    internal sealed class PropertiesUsageTracker\n     {\n+        internal LoggingContext LoggingContext { get; init; }\n+\n+        public PropertiesUsageTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;\n+\n+        /// <summary>\n+        /// Whether to warn when we set a property for the first time, after it was previously used.\n+        /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.\n+        /// </summary>\n+        // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.\n+        private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;\n+\n         /// <summary>\n         /// Lazily allocated collection of properties and the element which used them.\n         /// </summary>\n         private Dictionary<string, IElementLocation>? _properties;\n \n+        internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)\n+        {\n+            if (isArtificial)\n+            {\n+                return;\n+            }\n+\n+            if (!isUninitialized)\n+            {\n+                return;\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This is a relict of extracting the refactoring only changes from the Property Read Analyzer PR - where there was a BuildCheck pumping code in between (https://github.com/dotnet/msbuild/pull/10009/files#diff-e6b332d6a62d7e070dc0b1621e77b7d0146e52a8eba9c2bec2a7cdd3fdb5739fR5530-R5553)\r\n\r\nJoining the if-s now",
              "createdAt": "2024-05-13T10:58:17Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5493,13 +5502,57 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n     /// <summary>\n     /// This class wraps information about properties which have been used before they are initialized.\n     /// </summary>\n-    internal sealed class UsedUninitializedProperties\n+    internal sealed class PropertiesUsageTracker\n     {\n+        internal LoggingContext LoggingContext { get; init; }\n+\n+        public PropertiesUsageTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;\n+\n+        /// <summary>\n+        /// Whether to warn when we set a property for the first time, after it was previously used.\n+        /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.\n+        /// </summary>\n+        // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.\n+        private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;\n+\n         /// <summary>\n         /// Lazily allocated collection of properties and the element which used them.\n         /// </summary>\n         private Dictionary<string, IElementLocation>? _properties;\n \n+        internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)\n+        {\n+            if (isArtificial)\n+            {\n+                return;\n+            }\n+\n+            if (!isUninitialized)\n+            {\n+                return;\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Pre-existing issue: this is just a heuristic. Do we eventually want to fix it to really detect only built-in properties using something like `ReservedPropertyNames.IsReservedProperty()` ?",
              "createdAt": "2024-05-10T14:27:00Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1517,21 +1540,26 @@ internal static string ConvertToString(object valueToConvert)\n             /// <summary>\n             /// Look up a simple property reference by the name of the property, e.g. \"Foo\" when expanding $(Foo).\n             /// </summary>\n-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)\n             {\n-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, usedUninitializedProperties);\n+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUsageTracker);\n             }\n \n             /// <summary>\n             /// Look up a simple property reference by the name of the property, e.g. \"Foo\" when expanding $(Foo).\n             /// </summary>\n-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)\n+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n \n                 object propertyValue;\n \n-                if (property == null && ((endIndex - startIndex) >= 7) && MSBuildNameIgnoreCaseComparer.Default.Equals(\"MSBuild\", propertyName, startIndex, 7))\n+                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&\n+                                   MSBuildNameIgnoreCaseComparer.Default.Equals(\"MSBuild\", propertyName, startIndex, 7);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "What happens if someone defines 'MSBuildXXX' property today? Is that allowed?\r\nIt feels we should rather prevent users from doing that (rather then controlling just the subset we use today).\r\n\r\nWe might actually want to include it in scope of https://github.com/dotnet/msbuild/issues/9891",
              "createdAt": "2024-05-13T11:02:52Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1517,21 +1540,26 @@ internal static string ConvertToString(object valueToConvert)\n             /// <summary>\n             /// Look up a simple property reference by the name of the property, e.g. \"Foo\" when expanding $(Foo).\n             /// </summary>\n-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)\n             {\n-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, usedUninitializedProperties);\n+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUsageTracker);\n             }\n \n             /// <summary>\n             /// Look up a simple property reference by the name of the property, e.g. \"Foo\" when expanding $(Foo).\n             /// </summary>\n-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)\n+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n \n                 object propertyValue;\n \n-                if (property == null && ((endIndex - startIndex) >= 7) && MSBuildNameIgnoreCaseComparer.Default.Equals(\"MSBuild\", propertyName, startIndex, 7))\n+                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&\n+                                   MSBuildNameIgnoreCaseComparer.Default.Equals(\"MSBuild\", propertyName, startIndex, 7);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yep, too bad the prefix isn't reserved from the beginning. There is nothing preventing anyone from defining their own `MSBuild*` properties.",
              "createdAt": "2024-05-13T11:11:39Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1517,21 +1540,26 @@ internal static string ConvertToString(object valueToConvert)\n             /// <summary>\n             /// Look up a simple property reference by the name of the property, e.g. \"Foo\" when expanding $(Foo).\n             /// </summary>\n-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)\n             {\n-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, usedUninitializedProperties);\n+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUsageTracker);\n             }\n \n             /// <summary>\n             /// Look up a simple property reference by the name of the property, e.g. \"Foo\" when expanding $(Foo).\n             /// </summary>\n-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)\n+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n \n                 object propertyValue;\n \n-                if (property == null && ((endIndex - startIndex) >= 7) && MSBuildNameIgnoreCaseComparer.Default.Equals(\"MSBuild\", propertyName, startIndex, 7))\n+                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&\n+                                   MSBuildNameIgnoreCaseComparer.Default.Equals(\"MSBuild\", propertyName, startIndex, 7);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This comment no longer applies--but I think it should?",
              "createdAt": "2024-05-13T15:38:38Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -58,8 +60,9 @@ internal sealed class ItemBucket : IComparable\n         /// <summary>\n         /// Private default constructor disallows parameterless instantiation.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Adjusted the comment.\r\n(There is yet another parametrized ctor - so parameterless construction is not possible regardless of the signature of this one. It's actually used just to create dummy item for binary searching).",
              "createdAt": "2024-05-14T12:06:27Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -58,8 +60,9 @@ internal sealed class ItemBucket : IComparable\n         /// <summary>\n         /// Private default constructor disallows parameterless instantiation.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand this one. Elaborate?",
              "createdAt": "2024-05-13T15:47:13Z",
              "path": "src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs",
              "diffHunk": "@@ -51,8 +51,16 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState\n             // and we know which do, then we already have enough information to evaluate this expression.\n             // That means we don't have to fully expand a condition like \" '@(X)' == '' \"\n             // which is a performance advantage if @(X) is a huge item list.\n-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);\n-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);\n+\n+            // this is the possible case of '$(a)' == ''\n+            if (LeftChild.IsUnexpandedValueEmpty(state) ||\n+                RightChild.IsUnexpandedValueEmpty(state))\n+            {\n+                state.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Updated the comment to:\r\n\r\n```\r\n            // This is the possible case of an expression similar to '$(a)' == '', where a usage of uninitialized\r\n            //  property is reasonable and should not be flagged by uninitialized reads detection.\r\n            // So if at least one side is empty, we know to signal to PropertiesUseTracker to not flag in this scope.\r\n            // The other side might not be property at all - that's fine, as then PropertiesUseTracker won't be even called.\r\n```\r\n\r\nPlease let me know if it makes sense.",
              "createdAt": "2024-05-14T12:11:51Z",
              "path": "src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs",
              "diffHunk": "@@ -51,8 +51,16 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState\n             // and we know which do, then we already have enough information to evaluate this expression.\n             // That means we don't have to fully expand a condition like \" '@(X)' == '' \"\n             // which is a performance advantage if @(X) is a huge item list.\n-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);\n-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);\n+\n+            // this is the possible case of '$(a)' == ''\n+            if (LeftChild.IsUnexpandedValueEmpty(state) ||\n+                RightChild.IsUnexpandedValueEmpty(state))\n+            {\n+                state.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What makes this combination of things an \"Element\"?\r\n\r\nMaybe just needs an explanatory comment.",
              "createdAt": "2024-05-13T16:01:23Z",
              "path": "src/Build/Instance/IElementWithLocation.cs",
              "diffHunk": "@@ -0,0 +1,14 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Construction;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal interface IElementWithLocation",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Renamed to `IPropertyElementWithLocation` and xml commented",
              "createdAt": "2024-05-14T11:40:35Z",
              "path": "src/Build/Instance/IElementWithLocation.cs",
              "diffHunk": "@@ -0,0 +1,14 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Construction;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal interface IElementWithLocation",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is fine but it feels like we shouldn't ever construct a numeric expression with a null or empty value. Do we?",
              "createdAt": "2024-05-13T16:02:17Z",
              "path": "src/Build/Evaluation/Conditionals/NumericExpressionNode.cs",
              "diffHunk": "@@ -23,22 +23,26 @@ internal NumericExpressionNode(string value)\n             _value = value;\n         }\n \n-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)\n+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)\n         {\n             result = default;\n             return false;\n         }\n \n-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)\n+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)\n         {\n             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);\n         }\n \n-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)\n+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)\n         {\n             return Version.TryParse(_value, out result);\n         }\n \n+        /// <inheritdoc cref=\"GenericExpressionNode\"/>\n+        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state)\n+            => string.IsNullOrEmpty(_value);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "You're right - the only places creating Numeric tokens:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/Evaluation/Conditionals/Scanner.cs#L726\r\n\r\nand\r\n\r\nhttps://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/Evaluation/Conditionals/Scanner.cs#L753\r\n\r\nBoth verifying there is actually some string left.\r\n\r\n\r\nSo I applied nullable checks and runtime check on not emptiness during constructions - and the method in question is now constant `false`",
              "createdAt": "2024-05-14T11:58:18Z",
              "path": "src/Build/Evaluation/Conditionals/NumericExpressionNode.cs",
              "diffHunk": "@@ -23,22 +23,26 @@ internal NumericExpressionNode(string value)\n             _value = value;\n         }\n \n-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)\n+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)\n         {\n             result = default;\n             return false;\n         }\n \n-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)\n+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)\n         {\n             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);\n         }\n \n-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)\n+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)\n         {\n             return Version.TryParse(_value, out result);\n         }\n \n+        /// <inheritdoc cref=\"GenericExpressionNode\"/>\n+        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state)\n+            => string.IsNullOrEmpty(_value);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems to be required. Should we add some `Debug.Assert(initialized == true)` type calls elsewhere?",
              "createdAt": "2024-05-13T16:20:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -95,11 +98,19 @@ private ItemBucket()\n             }\n \n             _metadata = metadata;\n-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);\n \n             _bucketSequenceNumber = bucketSequenceNumber;\n         }\n \n+        /// <summary>\n+        /// Updates the logging context that this bucket is going to use.\n+        /// </summary>\n+        /// <param name=\"loggingContext\"></param>\n+        internal void Initialize(LoggingContext loggingContext)\n+        {\n+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(_metadata), FileSystems.Default, loggingContext);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "There is luckily just single accessing property - added check there",
              "createdAt": "2024-05-14T12:03:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs",
              "diffHunk": "@@ -95,11 +98,19 @@ private ItemBucket()\n             }\n \n             _metadata = metadata;\n-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);\n \n             _bucketSequenceNumber = bucketSequenceNumber;\n         }\n \n+        /// <summary>\n+        /// Updates the logging context that this bucket is going to use.\n+        /// </summary>\n+        /// <param name=\"loggingContext\"></param>\n+        internal void Initialize(LoggingContext loggingContext)\n+        {\n+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(_metadata), FileSystems.Default, loggingContext);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is big enough now that I'd move it to its own file soon.",
              "createdAt": "2024-05-13T17:02:42Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5493,13 +5502,52 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n     /// <summary>\n     /// This class wraps information about properties which have been used before they are initialized.\n     /// </summary>\n-    internal sealed class UsedUninitializedProperties\n+    internal sealed class PropertiesUsageTracker",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Also I'd personally name it `PropertyUseTracker`.",
              "createdAt": "2024-05-14T01:15:43Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5493,13 +5502,52 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n     /// <summary>\n     /// This class wraps information about properties which have been used before they are initialized.\n     /// </summary>\n-    internal sealed class UsedUninitializedProperties\n+    internal sealed class PropertiesUsageTracker",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\ud83d\udc4d to both suggestions! - done :-) ",
              "createdAt": "2024-05-14T12:17:59Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5493,13 +5502,52 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n     /// <summary>\n     /// This class wraps information about properties which have been used before they are initialized.\n     /// </summary>\n-    internal sealed class UsedUninitializedProperties\n+    internal sealed class PropertiesUsageTracker",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Update please",
              "createdAt": "2024-05-13T17:02:50Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5493,13 +5502,52 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n     /// <summary>\n     /// This class wraps information about properties which have been used before they are initialized.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not pop?\r\n\r\n```suggestion\r\n                            bucket.Expander.PropertiesUsageTracker.ResetPropertyReadContext(popPrevious: false);\r\n```",
              "createdAt": "2024-05-13T17:04:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -97,6 +101,7 @@ internal override void ExecuteTask(Lookup lookup)\n                         foreach (ItemBucket bucket in buckets)\n                         {\n                             bucket.LeaveScope();\n+                            bucket.Expander.PropertiesUsageTracker.ResetPropertyReadContext(false);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Added clarifying comment.\r\n\r\n```\r\n// We are now done processing this property - so no need to pop its previous context.\r\n```",
              "createdAt": "2024-05-14T12:23:21Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -97,6 +101,7 @@ internal override void ExecuteTask(Lookup lookup)\n                         foreach (ItemBucket bucket in buckets)\n                         {\n                             bucket.LeaveScope();\n+                            bucket.Expander.PropertiesUsageTracker.ResetPropertyReadContext(false);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this makes intuitive sense to me.",
              "createdAt": "2024-05-13T18:10:08Z",
              "path": "src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs",
              "diffHunk": "@@ -37,11 +38,15 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio\n         /// Value after any item and property expressions are expanded\n         /// </summary>\n         /// <returns></returns>\n-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)\n+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)\n         {\n             return null;\n         }\n \n+        /// <inheritdoc cref=\"GenericExpressionNode\"/>\n+        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state)\n+            => true;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good catch! This is a weird leftover.\r\n\r\nFixed to\r\n\r\n```\r\n=> LeftChild.IsUnexpandedValueEmpty() && RightChild.IsUnexpandedValueEmpty();\r\n```",
              "createdAt": "2024-05-14T12:29:28Z",
              "path": "src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs",
              "diffHunk": "@@ -37,11 +38,15 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio\n         /// Value after any item and property expressions are expanded\n         /// </summary>\n         /// <returns></returns>\n-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)\n+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)\n         {\n             return null;\n         }\n \n+        /// <inheritdoc cref=\"GenericExpressionNode\"/>\n+        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state)\n+            => true;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}