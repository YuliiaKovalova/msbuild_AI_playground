{
  "number": 6738,
  "title": "Propagate solution configuration information to project cache plugins",
  "body": "### Context\r\nVisual Studio has solution configurations and project configurations. A configuration is a (Configuration, Platform) tuple.\r\nA solution configuration defines a specific project configuration for each project in the solution. It's like a mapping  from a solution configuration to a list of project configurations for each project.\r\nAt any moment a single solution configuration is active in VS.\r\nWhen doing a real build in VS, the active solution configuration is propagated as global properties on each build request.\r\n\r\nUp until now I didn't have a clear understanding of this, therefore the project cache setup has a bug when building under VS: it does not propagate the solution configuration information to the plugin instance.\r\nThis means that if the user selects a non-default solution configuration (or if the solution is more complicated and the default project configuration assignment is not straightforward), there will be a mismatch between the build requests issued by VS (reflecting the non-default solution configuration) and the state of the plugin (reflecting the default solution configuration).\r\nThe mismatches end up as build failures because the plugin is unable to match an incoming build request to an existing quickbuild build node (build node graph is created from MSBuild's static graph)\r\n\r\n### Changes Made\r\n\r\nUnfortunately MSBuild does not know what the active VS solution configuration is. So in this PR we parse the project configuration for each project from an XML that VS sets on each build request as a global property (however horrible the idea of that global property is, without it we could not have enabled the build-under-VS scenario). Previously, msbuild used the .sln file as the single entry-point to the plugin. Starting with this PR it creates one entry point for each project in the parsed XML, with its particular project configuration set as global properties.\r\nThis makes the static graph inside the plugin instance match the solution configuration.\r\nThese changes are in the VS workaround part of the code. Ideally, if VS passed in the project cache graph descriptor, it would have enough information to just use a single .sln based entrypoint and set the solution configuration on it. Maybe, one day ...\r\n\r\nThe PR also removes TargetFramework from the entry points. VS sets an empty `TargetFramework=\"\"` global properties on outerbuilds (because why not). If we don't remove it it leaks into the graph entry-points, which propagates TF=\"\" to all nodes in the graph, messing them up.\r\n\r\n### Testing\r\nUnit tests and manual testing.\r\n\r\n### Notes\r\nThe meat of the implementation is here: https://github.com/dotnet/msbuild/pull/6738/files#diff-ac47163cf1a4ff2fbd79d56e0cf79ce9636b6a8331dfa89dae3fe8d3547f7fb3R345",
  "state": "MERGED",
  "createdAt": "2021-08-05T21:27:59Z",
  "updatedAt": "2021-08-23T20:20:32Z",
  "closedAt": "2021-08-23T20:20:32Z",
  "mergedAt": "2021-08-23T20:20:31Z",
  "additions": 369,
  "deletions": 58,
  "changedFiles": 9,
  "headRefName": "parseSolutionEntrypoints_on_main",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "497760a47c72b769dfee72b3c3dfe0bf4639240b",
          "message": "Add failing test",
          "committedDate": "2021-08-05T21:02:09Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3da2f5e03a62738dfd2e0b075fc646723fa70d4d",
          "message": "Add helper method for asserting build result",
          "committedDate": "2021-08-05T21:07:28Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c4b24f8244e85d01de6114d177896ab8d18bcf0",
          "message": "Extract configuration name parsing",
          "committedDate": "2021-08-05T21:07:31Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c46332aea20b25852aa005a061f6d2c2110ae8fa",
          "message": "Use projects with solution project configurations as graph entry points for the plugin",
          "committedDate": "2021-08-05T21:07:31Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63723059af7ea933ec27c6bd0b4f728209d74e73",
          "message": "Remove TargetFramework from the plugin graph entry point",
          "committedDate": "2021-08-05T21:07:31Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1d90c5a2f919214c6cfd6e44ae2df252ef00012",
          "message": "Remove project specific properties only once",
          "committedDate": "2021-08-05T23:43:30Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "058b92cfd79eed4524734b40479c0110f8c0930c",
          "message": "Extract test method which builds a graph via the VS workaround",
          "committedDate": "2021-08-11T22:45:55Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "339719d9050bb8d3b9a0f6617a42946f10015077",
          "message": "Account for ProjectDependency and BuildProjectInSolution",
          "committedDate": "2021-08-12T00:38:17Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "06195caa865a5802ed7bffced896091821f857cf",
          "message": "Mark code clones with issue link",
          "committedDate": "2021-08-12T02:31:51Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "655da74b93f95a144704992cf1dc42bdd3f705e8",
          "message": "Do not check project existence. VS should have done it already.",
          "committedDate": "2021-08-12T23:20:48Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a12f15ea3cebfd12afe362ee5f2fa080c215d3b9",
          "message": "Include name for second param",
          "committedDate": "2021-08-12T23:36:33Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9b0b5ffe86d554a1e76ffc73ef0facff52fd46a4",
          "message": "Add more project specific properties",
          "committedDate": "2021-08-13T00:46:06Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5adac0c7cdf1cf62445bfa8b120db11f7f8ade78",
          "message": "Update src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-08-16T17:35:56Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d514d7f6f1e9350c6c1aa74dcba9b29e6e3bb73a",
          "message": "Update src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-08-16T17:36:57Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Here's a screenshot with the global properties that VS sets on build requests when `ctrl+shift+B`ing in VS (captured by setting MSBuildDebugEngine and looking at the real build binlog).\r\n\r\nIt shows that:\r\n- VS does not set the solution configuration in any global property, it only sets that big xml containing all the project configurations for the currently selected solution configuration\r\n- The Configuation / Platform global properties set on each build request represent the project configuration for that particular project, not the solution configuration. For this, I manually edited `MSBuild.sln` to make Microsoft.Build.csproj always build Release. This causes VS to set Configuration=Release for Microsoft.Build, even though the solution configuration is Debug\r\n\r\n![image](https://user-images.githubusercontent.com/2255729/128747172-13eddcb5-6791-4310-96b2-b308847a6700.png)\r\n",
        "createdAt": "2021-08-09T17:20:13Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "> Any luck merging GenerateGraphEntryPointsFromSolutionConfigurationXml with the task we talked about in PR reviews?\r\n\r\n@Forgind reducing the code clones turns out to be a bit complicated. I opened https://github.com/dotnet/msbuild/issues/6751 with more details. Since it gets complicated, I propose that we treat it as a separate issue and consider it a non-issue for this PR. I did mark the relevant code clones in the code and linked them to the issue.",
        "createdAt": "2021-08-12T02:35:26Z",
        "author": {
          "login": "cdmihai"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't this have been checked already? This isn't a trivially cheap check.",
              "createdAt": "2021-08-11T15:31:43Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,94 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+                    ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(projectPath), \"Expected the projects in the solution to exist.\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "True, this code only runs within VS and I assume VS checked this already..",
              "createdAt": "2021-08-12T23:17:52Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,94 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+                    ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(projectPath), \"Expected the projects in the solution to exist.\");",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    if (globalProperties.ContainsKey(innerBuildPropertyName))\r\n```\r\n\r\nShould be able to skip the first check, since it's captured by the second.",
              "createdAt": "2021-08-11T15:35:24Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,94 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+                    ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(projectPath), \"Expected the projects in the solution to exist.\");\n+\n+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);\n+\n+                    // Take the defining project global properties and override the configuration and platform.\n+                    // It's sufficient to only set Configuration and Platform.\n+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.\n+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)\n+                    {\n+                        [\"Configuration\"] = configuration,\n+                        [\"Platform\"] = platform\n+                    };\n+\n+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));\n+                }\n+\n+                return graphEntryPoints;\n+\n+                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\n+                {\n+                    // Remove the inner build property from the graph entry point global properties.\n+                    // If the inner build property is set (TargetFramework), it will propagate down the project graph and force all nodes to that innerbuild value, which is incorrect.\n+                    var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);\n+\n+                    if (!string.IsNullOrWhiteSpace(innerBuildPropertyName) && globalProperties.ContainsKey(innerBuildPropertyName))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "ContainsKey throws if the key is null, so I'd have to do a sanity check beforehand (via ErrorUtilities) that the key is not null before calling ContainsKey. Not technically necessary, but for peace of mind :). I think the sanity check + the direct access is not as clean as how it looks now.",
              "createdAt": "2021-08-12T23:28:24Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,94 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+                    ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(projectPath), \"Expected the projects in the solution to exist.\");\n+\n+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);\n+\n+                    // Take the defining project global properties and override the configuration and platform.\n+                    // It's sufficient to only set Configuration and Platform.\n+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.\n+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)\n+                    {\n+                        [\"Configuration\"] = configuration,\n+                        [\"Platform\"] = platform\n+                    };\n+\n+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));\n+                }\n+\n+                return graphEntryPoints;\n+\n+                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\n+                {\n+                    // Remove the inner build property from the graph entry point global properties.\n+                    // If the inner build property is set (TargetFramework), it will propagate down the project graph and force all nodes to that innerbuild value, which is incorrect.\n+                    var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);\n+\n+                    if (!string.IsNullOrWhiteSpace(innerBuildPropertyName) && globalProperties.ContainsKey(innerBuildPropertyName))",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is TargetFramework really the only project-specific global property of relevance? Others I thought might be relevant include TargetPlatform, Configuration, and OutputType.",
              "createdAt": "2021-08-11T15:38:44Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,94 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+                    ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(projectPath), \"Expected the projects in the solution to exist.\");\n+\n+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);\n+\n+                    // Take the defining project global properties and override the configuration and platform.\n+                    // It's sufficient to only set Configuration and Platform.\n+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.\n+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)\n+                    {\n+                        [\"Configuration\"] = configuration,\n+                        [\"Platform\"] = platform\n+                    };\n+\n+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));\n+                }\n+\n+                return graphEntryPoints;\n+\n+                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\n+                {\n+                    // Remove the inner build property from the graph entry point global properties.\n+                    // If the inner build property is set (TargetFramework), it will propagate down the project graph and force all nodes to that innerbuild value, which is incorrect.\n+                    var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Very good point. I removed only the TF because it actually lead to real crashes, but I see how the ones you mentioned could be problematic as well. I'll add the ones you mentioned and take another look through the binlogs for other suspicious properties.",
              "createdAt": "2021-08-12T23:32:07Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,94 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+                    ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(projectPath), \"Expected the projects in the solution to exist.\");\n+\n+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);\n+\n+                    // Take the defining project global properties and override the configuration and platform.\n+                    // It's sufficient to only set Configuration and Platform.\n+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.\n+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)\n+                    {\n+                        [\"Configuration\"] = configuration,\n+                        [\"Platform\"] = platform\n+                    };\n+\n+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));\n+                }\n+\n+                return graphEntryPoints;\n+\n+                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\n+                {\n+                    // Remove the inner build property from the graph entry point global properties.\n+                    // If the inner build property is set (TargetFramework), it will propagate down the project graph and force all nodes to that innerbuild value, which is incorrect.\n+                    var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the second half of this about an exception? If it succeeded, shouldn't there be no exception?",
              "createdAt": "2021-08-11T15:44:30Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -155,6 +155,36 @@ internal static void AssertItemEvaluationFromGenericItemEvaluator(Func<string, P\n             }\n         }\n \n+        internal static void ShouldHaveSucceeded(this BuildResult result)\n+        {\n+            result.OverallResult.ShouldBe(BuildResultCode.Success, result.Exception is not null ? result.Exception.ToString() : string.Empty);\n+        }\n+\n+        internal static void ShouldHaveSucceeded(this GraphBuildResult result)\n+        {\n+            result.OverallResult.ShouldBe(BuildResultCode.Success, result.Exception is not null ? result.Exception.ToString() : string.Empty);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The second argument is an info message that Shouldly prints out if the assertion fails. In this case, if the BuildResultCode is failure AND there's an exception, then I print the exception to make debugging easier. But if there's no exception there's no helpful message to write. I'll add the parameter name to make it self documenting.",
              "createdAt": "2021-08-12T23:34:43Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -155,6 +155,36 @@ internal static void AssertItemEvaluationFromGenericItemEvaluator(Func<string, P\n             }\n         }\n \n+        internal static void ShouldHaveSucceeded(this BuildResult result)\n+        {\n+            result.OverallResult.ShouldBe(BuildResultCode.Success, result.Exception is not null ? result.Exception.ToString() : string.Empty);\n+        }\n+\n+        internal static void ShouldHaveSucceeded(this GraphBuildResult result)\n+        {\n+            result.OverallResult.ShouldBe(BuildResultCode.Success, result.Exception is not null ? result.Exception.ToString() : string.Empty);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Ah, makes sense, thanks!",
              "createdAt": "2021-08-12T23:43:31Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -155,6 +155,36 @@ internal static void AssertItemEvaluationFromGenericItemEvaluator(Func<string, P\n             }\n         }\n \n+        internal static void ShouldHaveSucceeded(this BuildResult result)\n+        {\n+            result.OverallResult.ShouldBe(BuildResultCode.Success, result.Exception is not null ? result.Exception.ToString() : string.Empty);\n+        }\n+\n+        internal static void ShouldHaveSucceeded(this GraphBuildResult result)\n+        {\n+            result.OverallResult.ShouldBe(BuildResultCode.Success, result.Exception is not null ? result.Exception.ToString() : string.Empty);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    // InnerBuildPropertyName is TargetFramework for the managed sdk.\r\n```\r\n?",
              "createdAt": "2021-08-13T14:01:15Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,113 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var buildProjectInSolution = node.Attributes![\"BuildProjectInSolution\"];\n+                    if (buildProjectInSolution is not null &&\n+                        string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&\n+                        bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&\n+                        buildProject is false)\n+                    {\n+                        continue;\n+                    }\n+\n+                    ErrorUtilities.VerifyThrow(\n+                        node.ChildNodes.OfType<XmlElement>().FirstOrDefault(e => e.Name == \"ProjectDependency\") is null,\n+                        \"Project cache service does not support solution only dependencies when running under Visual Studio.\");\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+\n+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);\n+\n+                    // Take the defining project global properties and override the configuration and platform.\n+                    // It's sufficient to only set Configuration and Platform.\n+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.\n+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)\n+                    {\n+                        [\"Configuration\"] = configuration,\n+                        [\"Platform\"] = platform\n+                    };\n+\n+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));\n+                }\n+\n+                return graphEntryPoints;\n+\n+                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\n+                {\n+                    // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.\n+\n+                    // TargetFramework for the managed sdk.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.\r\n                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\r\n                {\r\n```",
              "createdAt": "2021-08-13T14:02:34Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -337,19 +341,113 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)\n                     FileSystems.Default.FileExists(solutionPath),\n                     $\"Solution file does not exist: {solutionPath}\");\n \n+                ErrorUtilities.VerifyThrow(\n+                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,\n+                    \"Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.\");\n+\n+                // A solution supports multiple solution configurations (different values for Configuration and Platform).\n+                // Each solution configuration generates a different static graph.\n+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the\n+                // currently solution configuration used by VS.\n+                //\n+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property\n+                // named \"CurrentSolutionConfigurationContents\" that VS sets on each built project. It does not contain the solution configuration itself, but\n+                // instead it contains information on how the solution configuration maps to each project's configuration.\n+                //\n+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project\n+                // mentioned in the \"CurrentSolutionConfigurationContents\" global property.\n+                //\n+                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as\n+                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.\n+                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                    solutionConfigurationXml,\n+                    configuration.Project);\n+\n                 await BeginBuildAsync(\n                     ProjectCacheDescriptor.FromAssemblyPath(\n                         _projectCacheDescriptor.PluginAssemblyPath!,\n-                        new[]\n-                        {\n-                            new ProjectGraphEntryPoint(\n-                                solutionPath,\n-                                configuration.Project.GlobalProperties)\n-                        },\n+                        graphEntryPointsFromSolutionConfig,\n                         projectGraph: null,\n                         _projectCacheDescriptor.PluginSettings));\n             }\n \n+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(\n+                string solutionConfigurationXml,\n+                ProjectInstance project\n+            )\n+            {\n+                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751\n+                var doc = new XmlDocument();\n+                doc.LoadXml(solutionConfigurationXml);\n+\n+                var root = doc.DocumentElement!;\n+                var projectConfigurationNodes = root.GetElementsByTagName(\"ProjectConfiguration\");\n+\n+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, \"Expected at least one project in solution\");\n+\n+                var definingProjectPath = project.FullPath;\n+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);\n+\n+                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);\n+                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);\n+\n+                foreach (XmlNode node in projectConfigurationNodes)\n+                {\n+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));\n+\n+                    var buildProjectInSolution = node.Attributes![\"BuildProjectInSolution\"];\n+                    if (buildProjectInSolution is not null &&\n+                        string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&\n+                        bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&\n+                        buildProject is false)\n+                    {\n+                        continue;\n+                    }\n+\n+                    ErrorUtilities.VerifyThrow(\n+                        node.ChildNodes.OfType<XmlElement>().FirstOrDefault(e => e.Name == \"ProjectDependency\") is null,\n+                        \"Project cache service does not support solution only dependencies when running under Visual Studio.\");\n+\n+                    var projectPathAttribute = node.Attributes![\"AbsolutePath\"];\n+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, \"Expected VS to set the project path on each ProjectConfiguration element.\");\n+\n+                    var projectPath = projectPathAttribute!.Value;\n+\n+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);\n+\n+                    // Take the defining project global properties and override the configuration and platform.\n+                    // It's sufficient to only set Configuration and Platform.\n+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.\n+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)\n+                    {\n+                        [\"Configuration\"] = configuration,\n+                        [\"Platform\"] = platform\n+                    };\n+\n+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));\n+                }\n+\n+                return graphEntryPoints;\n+\n+                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)\n+                {\n+                    // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.\n+",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}