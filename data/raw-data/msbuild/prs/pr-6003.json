{
  "number": 6003,
  "title": "Add support for aliased cultures",
  "body": "Fixes #3897",
  "state": "CLOSED",
  "createdAt": "2021-01-04T15:13:46Z",
  "updatedAt": "2021-04-26T15:31:30Z",
  "closedAt": "2021-04-26T15:31:29Z",
  "mergedAt": null,
  "additions": 151,
  "deletions": 964,
  "changedFiles": 6,
  "headRefName": "aliased_cultures",
  "isDraft": false,
  "author": {
    "login": "0xced"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "03c72cee3c08dede36af616ca75d2a57877b0dc4",
          "message": "Add support for aliased cultures\n\nFixes #3897",
          "committedDate": "2021-01-04T20:15:34Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c96d156f2a848d44bd6828be04d5ab5f87dbbded",
          "message": "Add braces\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2021-01-04T20:15:34Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5f58802d0a32ab8f4ed2ead4ec37709b09679b1",
          "message": "Rename InvalidCultureNames to KnownInvalidCultureNames for better clarity\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2021-01-04T20:15:34Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0749c06790d31fd2c267f14364674d9ae68cac7e",
          "message": "Catch CultureNotFoundException instead of Exception",
          "committedDate": "2021-01-04T20:15:34Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "52f3cbb2067b1ceb9a168f34a48268de72284b76",
          "message": "Simplify CultureInfoCache.IsValidCultureString\n\nRemove anything \"smart\" and only rely on `CultureInfo.GetCultureInfo` not throwing `CultureNotFoundException` to deem a culture name valid.\n\nSince CultureInfo.GetCultureInfo() returns a cached CultureInfo there should be no performance issue.",
          "committedDate": "2021-01-04T20:15:34Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "55f8feebe52e4c7a152ad59d4f8dcac967fe2ae6",
          "message": "Cleanup FEATURE_CULTUREINFO_GETCULTURE* related code\n\nThis was needed in the .NET Core 1.0 era but CultureInfo.GetCultures and CultureInfo.GetCultureInfo are now available in .NET Core (since version 2.0).",
          "committedDate": "2021-01-04T20:40:01Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4bdca75d9191276fab4a1824ad75212cfc87b609",
          "message": "Only deem aliased cultures as valid, not _all_ cultures",
          "committedDate": "2021-01-06T13:08:28Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d68fe2a18bada75893d18eb5738b63ff181b2a09",
          "message": "Check for ThreeLetterISOLanguageName length to be 3 instead of > 0\n\nOn .NET Framework, ThreeLetterISOLanguageName has two letters for unknown cultures such as \"xx\".",
          "committedDate": "2021-01-06T14:00:25Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9102445d081b99ef330604c0f408d926cbb0c37e",
          "message": "Skip aliased cultures that are not available on .NET Framework",
          "committedDate": "2021-01-06T14:04:12Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4388369ab1c666c37a6625b320a743e5f5ff8701",
          "message": "Skip aliased cultures that are not available on Mono",
          "committedDate": "2021-01-06T14:08:01Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80bc0f0e65c8b1b447062b96f3eda1ac2dd5e7c4",
          "message": "Fix handling of invalid cultures with three letters name on .NET Framework",
          "committedDate": "2021-01-06T14:22:54Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c02b28a1fd77cfac9d00de0d38f095722b03abdc",
          "message": "Skip Najdi Arabic (ars) culture on both Mono and .NET Framework",
          "committedDate": "2021-01-06T14:59:17Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cdb730cc7c4c86ab53b2e6b070c2d9b1238d16a0",
          "message": "Improve code readability",
          "committedDate": "2021-01-06T15:07:29Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a10a85685300fea3c5bb8414e2b4f30840f0f05d",
          "message": "Fix tests when running under NLS",
          "committedDate": "2021-01-06T16:23:34Z",
          "author": {
            "name": "C\u00e9dric Luthi",
            "email": "cedric.luthi@gmail.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I believe we should get rid of the whole cache and just use CultureInfo.GetCultureInfo API. are we not using this API for any perf reason?\r\n\r\nNote that on Windows 10 (on on Linux using ICU), all cultures with the well formed name is considered a valid culture even if the system doesn't have a data for. why we are trying to create a cache at all? CultureInfo.GetCultureInfo already maintaining internal cache  for all previously created cultures.",
        "createdAt": "2021-01-04T17:32:08Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "> I believe we should get rid of the whole cache and just use CultureInfo.GetCultureInfo API. are we not using this API for any perf reason?\r\n\r\nThe .NET Core version of this was introduced in https://github.com/dotnet/msbuild/pull/213, but that was a patch over `CultureInfo.GetCultures` not existing in .NET Core 1.0. The Framework code that relies on the enumeration and caching dates back to `2003-11-09 18:07:58` in a commit that has an _entirely_ useless message but also has this change:\r\n\r\n```diff\r\n-                try\r\n-                {\r\n-                    // Construct a CultureInfo just to see if its possible.\r\n-                    new CultureInfo(cultureName);\r\n-                    validCulture = true;\r\n-                }\r\n-                catch (ArgumentException)\r\n-                {\r\n-                    // Just eat the exception, but now we know the culture isn't valid. \r\n-                }\r\n+                validCulture = CultureStringUtilities.IsValidCultureString(cultureName);\r\n```\r\n\r\nSo maybe there was a perf issue 18 years ago? I certainly like the simplicity of your proposal.",
        "createdAt": "2021-01-04T17:48:14Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald we should give it a try. I think the perf hit would be in invalid cases only which I think is not common. Also, on Windows 10, most of the time will not encounter any invalid cases too.",
        "createdAt": "2021-01-04T17:56:19Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "I am not familiar with this issue. I will pass it to @tarekgh :)",
        "createdAt": "2021-01-04T18:08:36Z",
        "author": {
          "login": "wli3"
        }
      },
      {
        "body": "> @rainersigwald Rainer Sigwald FTE we should give it a try. I think the perf hit would be in invalid cases only which I think is not common. Also, on Windows 10, most of the time will not encounter any invalid cases too.\r\n\r\nOk. @0xced would you be willing to make that change?",
        "createdAt": "2021-01-04T18:17:24Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Sure. I force-pushed and simplified to the maximum! (+77 / -901) The `IsValidCultureString` method is now just a few lines, anything \"smart\" has been removed.\r\n\r\n```csharp\r\ninternal static bool IsValidCultureString(string name)\r\n{\r\n    try\r\n    {\r\n        _ = CultureInfo.GetCultureInfo(name);\r\n        return true;\r\n    }\r\n    catch (CultureNotFoundException)\r\n    {\r\n        return false;\r\n    }\r\n}\r\n```",
        "createdAt": "2021-01-04T19:45:05Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "@0xced thanks a lot for your help here. the changes looks good. could you please try to clean the usage of `FEATURE_CULTUREINFO_GETCULTURES` from the cs project and also if there is dead code (maybe something like `AssemblyUtilities.CultureInfoHasGetCultures()`). \r\n\r\n@rainersigwald do we have any perf test can be used to ensure we are not regressing the perf with that? ",
        "createdAt": "2021-01-04T20:25:37Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "> @rainersigwald do we have any perf test can be used to ensure we are not regressing the perf with that?\r\n\r\ncc @ladipro and @Forgind but not really. We have VS RPS tests but they exercise very small projects and I don't know if they touch this codepath at all.",
        "createdAt": "2021-01-04T20:41:44Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I did some cleanup on `FEATURE_CULTUREINFO_GETCULTURES` and `FEATURE_CULTUREINFO_GETCULTUREINFO` in 55f8feebe52e4c7a152ad59d4f8dcac967fe2ae6.\r\n\r\nWhen doing this cleanup I noticed this comment:\r\n> // Assembly.Location is only available in .netstandard1.5, but MSBuild needs to target 1.3.\r\n> // use reflection to access the property\r\n\r\nIs it still true that MSBuild needs to target .NET Standard 1.3?",
        "createdAt": "2021-01-04T20:47:42Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "> Is it still true that MSBuild needs to target .NET Standard 1.3?\r\n\r\nNope! Please feel free to remove that :)",
        "createdAt": "2021-01-04T20:56:16Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "It looks like at some point they decided to throw an error when it hadn't been initialized properly? Not sure why:\r\nhttps://github.com/dotnet/msbuild/blob/c70d520b5b8df990f651f0d00cd186a68cb277c6/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs#L934-L982\r\n\r\nIt goes back to the original commit:\r\nhttps://github.com/dotnet/msbuild/commit/82177a50da735cc0443ac10fa490d69368403d71#diff-0ef03e858b5dafafd31e725cf2f7be2c22aaa57214afc6bee56d639652b3a9d5R1066-R1082",
        "createdAt": "2021-01-04T21:07:49Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I'm a bit lost as to why the `InvalidToolsVersionErrors` test is now failing and how it relates to the change introduced in this pull request. I noticed that the tests fail only when run with `eng/cibuild_bootstrapped_msbuild.sh` (which is using `stage1/bin/bootstrap/netcoreapp2.1/MSBuild/MSBuild.dll`) but I'm not sure what this means. All tests are passing when I run `./build.sh --test --ci` (which is using `.dotnet/sdk/3.1.100/MSBuild.dll`).\r\n\r\nCan someone with more MSBuild experience help me to diagnose this issue?",
        "createdAt": "2021-01-05T09:24:23Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "I wonder if the `netcoreapp2.1` `MSBuild.dll` referenced is using an older version of whatever assembly `CultureInfo.GetCultureInfo` comes from, and that older version doesn't include aliased cultures? I'll dig into this a bit and report any findings.\r\n\r\nedit: I'm constantly running into an issue with eng\\cibuild_bootstrapped_msbuild.sh not running the second build because of a permission issue so I can't get a local repro.",
        "createdAt": "2021-01-06T00:37:20Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Here's why the tests were failing: MSBuild itself uses `Strings.shared.resx` as resource name. When accepting `shared` as a valid culture, `Microsoft.Build.Strings.shared.resources` would **not** end up in the embedded resources of `artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.dll` leading to the `MissingManifestResourceException` that was the cause of the failing tests.\r\n\r\nMSBuild itself is a good example as to why we should be conservative and accept only aliased cultures in order not to break projects using `Name.something.resx` where `something` is not a locale.\r\n\r\nI have improved this in 4bdca75 to only deem aliased cultures as valid, not _all_ cultures.",
        "createdAt": "2021-01-06T13:22:26Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "Thinking more about it, maybe we hit another bug because if `shared` was assigned as a culture then it should have ended as `Microsoft.Build.Strings.shared.resources` in the embedded resources of `artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.dll`. \ud83e\udd14",
        "createdAt": "2021-01-06T13:30:51Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "So, I think I finally found a way to identify predefined cultures, under both ICU and NLS.\r\n\r\nTo deem a culture valid it must either:\r\n* Have a LCID != 4096 (LOCALE_CUSTOM_UNSPECIFIED)\r\nor\r\n* Have a `ThreeLetterISOLanguageName` and have a `NativeName` which does not start with \"Unknown Language\"\r\n\r\nA better solution would be to use [`CultureInfo.GetCultureInfo(name, predefinedOnly: true)`][1] but unfortunately it is only available since .NET 5.\r\n\r\nI also tweaked the test so that they pass on all supported platforms. Supported cultures vary a lot across different platforms!\r\n\r\n[1]: https://github.com/dotnet/runtime/blob/v5.0.1/src/libraries/System.Private.CoreLib/src/System/Globalization/CultureInfo.cs#L1162-L1177",
        "createdAt": "2021-01-07T21:51:44Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "> Have a ThreeLetterISOLanguageName and have a NativeName which does not start with \"Unknown Language\"\r\n\r\nPlease don't use this. Windows is not promising this will work. That is why we have exposed the other GetCultureInfo overload. \r\n\r\n> Have a LCID != 4096 (LOCALE_CUSTOM_UNSPECIFIED)\r\n\r\nIf you use this, please check LOCALE_CUSTOM_DEFAULT too.\r\n```\r\nLOCALE_CUSTOM_DEFAULT       = 0x0c00;\r\n```\r\n\r\nAlso to clarify, checking LOCALE_CUSTOM_UNSPECIFIED would exclude some legitimate Windows cultures. I didn't follow closely here but would be nice if someone clarify why we care filtering out these cultures?",
        "createdAt": "2021-01-07T21:59:23Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "> Please don't use this. Windows is not promising this will work. That is why we have exposed the other GetCultureInfo overload.\r\n\r\nHmmm, but [`CultureInfo.GetCultureInfo(name, predefinedOnly: true)`][1] is only available since .NET 5 and I don't think MSBuild is ready to switch to .NET 5, right? Is there another way without using a .NET 5-only API?\r\n\r\n> Also to clarify, checking LOCALE_CUSTOM_UNSPECIFIED would exclude some legitimate Windows cultures.\r\n\r\nDo you have an example of such a culture so that I can add it to the tests and make sure it's considered a valid culture?\r\n\r\n> I didn't follow closely here but would be nice if someone clarify why we care filtering out these cultures?\r\n\r\nJust to be conservative and to not accidentally break too much existing projects. MSBuild itself breaks when using `shared` as a *culture* name, see my previous comments: https://github.com/dotnet/msbuild/pull/6003#issuecomment-755296020\r\n\r\n[1]: https://github.com/dotnet/runtime/blob/v5.0.1/src/libraries/System.Private.CoreLib/src/System/Globalization/CultureInfo.cs#L1162-L1177",
        "createdAt": "2021-01-20T19:58:25Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "> Hmmm, but CultureInfo.GetCultureInfo(name, predefinedOnly: true) is only available since .NET 5 and I don't think MSBuild is ready to switch to .NET 5, right? Is there another way without using a .NET 5-only API?\r\n\r\nI assume we are talking when running on Windows. If so, you may call the OS directly for that. something like the call https://source.dot.net/#System.Private.CoreLib/CultureInfo.Nls.cs,14\r\nIf we need that on Linux, that will be more complicated to do as we depend on ICU to get the info.\r\n\r\n> Do you have an example of such a culture so that I can add it to the tests and make sure it's considered a valid culture?\r\n\r\nplease run the following code and it will give you such list.\r\n\r\n```C#\r\n            foreach (CultureInfo ci in CultureInfo.GetCultures(CultureTypes.AllCultures))\r\n            {\r\n                if (ci.LCID == 0x1000)\r\n                {\r\n                    Console.WriteLine(ci.Name);\r\n                }\r\n            }\r\n```\r\n\r\n> Just to be conservative and to not accidentally break too much existing projects. MSBuild itself breaks when using shared as a culture name, see my previous comments: #6003 (comment)\r\n\r\nIs there any other way to include the shared resources without considering it as a culture? I mean can the resource file be renamed to something else (like String_shared.resx for instance)? or we don't have control over that?",
        "createdAt": "2021-01-20T20:24:03Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "Any recent updates on this?",
        "createdAt": "2021-03-31T17:05:42Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Team triage: closing for inactivity. Happy to reopen if we can work through its issues.",
        "createdAt": "2021-04-26T15:31:29Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please expand on this a bit? It's not immediately obvious to me from the link why non-system locales should be fully rejected here.",
              "createdAt": "2021-01-04T16:56:24Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -55,7 +57,35 @@ static CultureInfoCache()\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            var isValid = ValidCultureNames.Contains(name);\n+            if (isValid)\n+                return true;\n+\n+            var isInvalid = InvalidCultureNames.Contains(name);\n+            if (isInvalid)\n+                return false;\n+\n+            CultureInfo culture;\n+            try\n+            {\n+                culture = new CultureInfo(name);\n+            }\n+            catch (Exception)\n+            {\n+                InvalidCultureNames.Add(name);\n+                return false;\n+            }\n+\n+            // See https://docs.microsoft.com/en-us/dotnet/api/System.Globalization.CultureInfo.LCID#remarks\n+            const int LOCALE_CUSTOM_UNSPECIFIED = 0x1000;\n+            if (culture.LCID == LOCALE_CUSTOM_UNSPECIFIED)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Actually, this could be further discussed. What do we want? Accept *any* valid culture or accept *known* (by the operating system) cultures? If we accept *any* valid culture then we can get rid of this check altogether.",
              "createdAt": "2021-01-04T17:18:28Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -55,7 +57,35 @@ static CultureInfoCache()\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            var isValid = ValidCultureNames.Contains(name);\n+            if (isValid)\n+                return true;\n+\n+            var isInvalid = InvalidCultureNames.Contains(name);\n+            if (isInvalid)\n+                return false;\n+\n+            CultureInfo culture;\n+            try\n+            {\n+                culture = new CultureInfo(name);\n+            }\n+            catch (Exception)\n+            {\n+                InvalidCultureNames.Add(name);\n+                return false;\n+            }\n+\n+            // See https://docs.microsoft.com/en-us/dotnet/api/System.Globalization.CultureInfo.LCID#remarks\n+            const int LOCALE_CUSTOM_UNSPECIFIED = 0x1000;\n+            if (culture.LCID == LOCALE_CUSTOM_UNSPECIFIED)",
              "author": {
                "login": "0xced"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please brace even one-line blocks\r\n\r\n```suggestion\r\n            {\r\n                return true;\r\n            }\r\n```",
              "createdAt": "2021-01-04T16:57:47Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -55,7 +57,35 @@ static CultureInfoCache()\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            var isValid = ValidCultureNames.Contains(name);\n+            if (isValid)\n+                return true;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            {\r\n                return false;\r\n            }\r\n```",
              "createdAt": "2021-01-04T16:58:15Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -55,7 +57,35 @@ static CultureInfoCache()\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            var isValid = ValidCultureNames.Contains(name);\n+            if (isValid)\n+                return true;\n+\n+            var isInvalid = InvalidCultureNames.Contains(name);\n+            if (isInvalid)\n+                return false;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        private static readonly HashSet<string> KnownInvalidCultureNames;\r\n```\r\n\r\n? I was initially a bit confused since this isn't an exhaustive list.",
              "createdAt": "2021-01-04T17:02:31Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -18,10 +18,12 @@ namespace Microsoft.Build.Tasks\n     internal static class CultureInfoCache\n     {\n         private static readonly HashSet<string> ValidCultureNames;\n+        private static readonly HashSet<string> InvalidCultureNames;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since this `catch` is super broad, please comment with an explanation of what it's doing, maybe something like\r\n\r\n```suggestion\r\n            catch (Exception)\r\n            {\r\n                // Treat any failure of CultureInfo construction as information that\r\n                // the name is invalid.\r\n                InvalidCultureNames.Add(name);\r\n```",
              "createdAt": "2021-01-04T17:04:29Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -55,7 +57,35 @@ static CultureInfoCache()\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            var isValid = ValidCultureNames.Contains(name);\n+            if (isValid)\n+                return true;\n+\n+            var isInvalid = InvalidCultureNames.Contains(name);\n+            if (isInvalid)\n+                return false;\n+\n+            CultureInfo culture;\n+            try\n+            {\n+                culture = new CultureInfo(name);\n+            }\n+            catch (Exception)\n+            {\n+                InvalidCultureNames.Add(name);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Right, I changed to catch `CultureNotFoundException` instead of `Exception` in 19c9e110a6cedb063c6eb7d6555d6d2dad1df022",
              "createdAt": "2021-01-04T17:21:59Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -55,7 +57,35 @@ static CultureInfoCache()\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            var isValid = ValidCultureNames.Contains(name);\n+            if (isValid)\n+                return true;\n+\n+            var isInvalid = InvalidCultureNames.Contains(name);\n+            if (isInvalid)\n+                return false;\n+\n+            CultureInfo culture;\n+            try\n+            {\n+                culture = new CultureInfo(name);\n+            }\n+            catch (Exception)\n+            {\n+                InvalidCultureNames.Add(name);",
              "author": {
                "login": "0xced"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is the critical difference between this test and the above, right? Can you call it out with a comment?",
              "createdAt": "2021-01-04T17:06:15Z",
              "path": "src/Tasks.UnitTests/AssignCulture_Tests.cs",
              "diffHunk": "@@ -216,6 +216,56 @@ public void PseudoLocalization(string culture)\n             Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n             Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n         }\n+\n+        /*\n+        * Method:   AliasedCulture\n+        *\n+        * Test that an aliased culture (e.g. zh-CN or zh-TW) which is _not_ returned by CultureInfo.GetCultures(CultureTypes.AllCultures)\n+        * on Unix-based systems is still considered valid.\n+        * See also https://github.com/dotnet/msbuild/issues/3897 (Cultures aliased by ICU cannot be used for resource localization on non-Windows environments)\n+        */\n+        [Theory]\n+        [InlineData(\"zh-CN\")]\n+        [InlineData(\"zh-TW\")]\n+        public void AliasedCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);\n+            Assert.Single(t.CultureNeutralAssignedFiles);\n+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata(\"Culture\"));\n+            Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n+            Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n+        }\n+\n+        /*\n+        * Method:   InvalidCulture\n+        *\n+        * Test for invalid culture (i.e. throwing an exception when using new CultureInfo())\n+        * and unknown culture (i.e. a culture not known by the operating system but which can be created with new CultureInfo())\n+        */\n+        [Theory]\n+        [InlineData(\"\\U0001F4A5\")]\n+        [InlineData(\"xx\")]\n+        public void InvalidCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);\n+            Assert.Single(t.CultureNeutralAssignedFiles);\n+            Assert.Equal(String.Empty, t.AssignedFiles[0].GetMetadata(\"Culture\"));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Do you mean that the `Culture` metadata is empty?",
              "createdAt": "2021-01-04T17:28:57Z",
              "path": "src/Tasks.UnitTests/AssignCulture_Tests.cs",
              "diffHunk": "@@ -216,6 +216,56 @@ public void PseudoLocalization(string culture)\n             Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n             Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n         }\n+\n+        /*\n+        * Method:   AliasedCulture\n+        *\n+        * Test that an aliased culture (e.g. zh-CN or zh-TW) which is _not_ returned by CultureInfo.GetCultures(CultureTypes.AllCultures)\n+        * on Unix-based systems is still considered valid.\n+        * See also https://github.com/dotnet/msbuild/issues/3897 (Cultures aliased by ICU cannot be used for resource localization on non-Windows environments)\n+        */\n+        [Theory]\n+        [InlineData(\"zh-CN\")]\n+        [InlineData(\"zh-TW\")]\n+        public void AliasedCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);\n+            Assert.Single(t.CultureNeutralAssignedFiles);\n+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata(\"Culture\"));\n+            Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n+            Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n+        }\n+\n+        /*\n+        * Method:   InvalidCulture\n+        *\n+        * Test for invalid culture (i.e. throwing an exception when using new CultureInfo())\n+        * and unknown culture (i.e. a culture not known by the operating system but which can be created with new CultureInfo())\n+        */\n+        [Theory]\n+        [InlineData(\"\\U0001F4A5\")]\n+        [InlineData(\"xx\")]\n+        public void InvalidCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);\n+            Assert.Single(t.CultureNeutralAssignedFiles);\n+            Assert.Equal(String.Empty, t.AssignedFiles[0].GetMetadata(\"Culture\"));",
              "author": {
                "login": "0xced"
              }
            },
            {
              "body": "In general I just mean \"Please call out the parts of this test that are different\". Here I guess it's not just that Culture is empty but also that the culture-neutral part doesn't get assigned.",
              "createdAt": "2021-01-04T17:31:36Z",
              "path": "src/Tasks.UnitTests/AssignCulture_Tests.cs",
              "diffHunk": "@@ -216,6 +216,56 @@ public void PseudoLocalization(string culture)\n             Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n             Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n         }\n+\n+        /*\n+        * Method:   AliasedCulture\n+        *\n+        * Test that an aliased culture (e.g. zh-CN or zh-TW) which is _not_ returned by CultureInfo.GetCultures(CultureTypes.AllCultures)\n+        * on Unix-based systems is still considered valid.\n+        * See also https://github.com/dotnet/msbuild/issues/3897 (Cultures aliased by ICU cannot be used for resource localization on non-Windows environments)\n+        */\n+        [Theory]\n+        [InlineData(\"zh-CN\")]\n+        [InlineData(\"zh-TW\")]\n+        public void AliasedCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);\n+            Assert.Single(t.CultureNeutralAssignedFiles);\n+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata(\"Culture\"));\n+            Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n+            Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n+        }\n+\n+        /*\n+        * Method:   InvalidCulture\n+        *\n+        * Test for invalid culture (i.e. throwing an exception when using new CultureInfo())\n+        * and unknown culture (i.e. a culture not known by the operating system but which can be created with new CultureInfo())\n+        */\n+        [Theory]\n+        [InlineData(\"\\U0001F4A5\")]\n+        [InlineData(\"xx\")]\n+        public void InvalidCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);\n+            Assert.Single(t.CultureNeutralAssignedFiles);\n+            Assert.Equal(String.Empty, t.AssignedFiles[0].GetMetadata(\"Culture\"));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We're going from a hashset lookup to try-catching a function call. This will run for every resource in a project, what's the perf impact here?",
              "createdAt": "2021-01-05T01:03:38Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -17,907 +14,22 @@ namespace Microsoft.Build.Tasks\n     /// </summary>\n     internal static class CultureInfoCache\n     {\n-        private static readonly HashSet<string> ValidCultureNames;\n-\n-        static CultureInfoCache()\n-        {\n-            ValidCultureNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n-\n-#if !FEATURE_CULTUREINFO_GETCULTURES\n-            if (!AssemblyUtilities.CultureInfoHasGetCultures())\n-            {\n-                ValidCultureNames = HardcodedCultureNames;\n-                return;\n-            }\n-#endif\n-\n-            foreach (CultureInfo cultureName in AssemblyUtilities.GetAllCultures())\n-            {\n-                ValidCultureNames.Add(cultureName.Name);\n-            }\n-\n-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing\n-            // These pseudo-locales are available in versions of Windows from Vista and later.\n-            // However, from Windows 10, version 1803, they are not returned when enumerating the\n-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.\n-            var pseudoLocales = new[] { \"qps-ploc\", \"qps-ploca\", \"qps-plocm\", \"qps-Latn-x-sh\" };\n-\n-            foreach (string pseudoLocale in pseudoLocales)\n-            {\n-                ValidCultureNames.Add(pseudoLocale);\n-            }\n-        }\n-\n         /// <summary>\n         /// Determine if a culture string represents a valid <see cref=\"CultureInfo\"/> instance.\n         /// </summary>\n         /// <param name=\"name\">The culture name.</param>\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            try\n+            {\n+                _ = CultureInfo.GetCultureInfo(name);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Looks like it does a `TryGetValue` on a dictionary behind the scenes. https://source.dot.net/#System.Private.CoreLib/CultureInfo.cs,fec605b3b773ab26",
              "createdAt": "2021-01-05T01:04:30Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -17,907 +14,22 @@ namespace Microsoft.Build.Tasks\n     /// </summary>\n     internal static class CultureInfoCache\n     {\n-        private static readonly HashSet<string> ValidCultureNames;\n-\n-        static CultureInfoCache()\n-        {\n-            ValidCultureNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n-\n-#if !FEATURE_CULTUREINFO_GETCULTURES\n-            if (!AssemblyUtilities.CultureInfoHasGetCultures())\n-            {\n-                ValidCultureNames = HardcodedCultureNames;\n-                return;\n-            }\n-#endif\n-\n-            foreach (CultureInfo cultureName in AssemblyUtilities.GetAllCultures())\n-            {\n-                ValidCultureNames.Add(cultureName.Name);\n-            }\n-\n-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing\n-            // These pseudo-locales are available in versions of Windows from Vista and later.\n-            // However, from Windows 10, version 1803, they are not returned when enumerating the\n-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.\n-            var pseudoLocales = new[] { \"qps-ploc\", \"qps-ploca\", \"qps-plocm\", \"qps-Latn-x-sh\" };\n-\n-            foreach (string pseudoLocale in pseudoLocales)\n-            {\n-                ValidCultureNames.Add(pseudoLocale);\n-            }\n-        }\n-\n         /// <summary>\n         /// Determine if a culture string represents a valid <see cref=\"CultureInfo\"/> instance.\n         /// </summary>\n         /// <param name=\"name\">The culture name.</param>\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            try\n+            {\n+                _ = CultureInfo.GetCultureInfo(name);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I didn't notice the discussion before, it looks like we're okay with this change so long as RPS doesn't catch this.\r\n\r\nI also didn't realize that the previous valid cultures are calculated on each run. This seems fine to me.",
              "createdAt": "2021-01-05T01:08:00Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -17,907 +14,22 @@ namespace Microsoft.Build.Tasks\n     /// </summary>\n     internal static class CultureInfoCache\n     {\n-        private static readonly HashSet<string> ValidCultureNames;\n-\n-        static CultureInfoCache()\n-        {\n-            ValidCultureNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n-\n-#if !FEATURE_CULTUREINFO_GETCULTURES\n-            if (!AssemblyUtilities.CultureInfoHasGetCultures())\n-            {\n-                ValidCultureNames = HardcodedCultureNames;\n-                return;\n-            }\n-#endif\n-\n-            foreach (CultureInfo cultureName in AssemblyUtilities.GetAllCultures())\n-            {\n-                ValidCultureNames.Add(cultureName.Name);\n-            }\n-\n-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing\n-            // These pseudo-locales are available in versions of Windows from Vista and later.\n-            // However, from Windows 10, version 1803, they are not returned when enumerating the\n-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.\n-            var pseudoLocales = new[] { \"qps-ploc\", \"qps-ploca\", \"qps-plocm\", \"qps-Latn-x-sh\" };\n-\n-            foreach (string pseudoLocale in pseudoLocales)\n-            {\n-                ValidCultureNames.Add(pseudoLocale);\n-            }\n-        }\n-\n         /// <summary>\n         /// Determine if a culture string represents a valid <see cref=\"CultureInfo\"/> instance.\n         /// </summary>\n         /// <param name=\"name\">The culture name.</param>\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            try\n+            {\n+                _ = CultureInfo.GetCultureInfo(name);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Try itself is fast as long as it doesn't hit the catch ([StackOverflow](https://stackoverflow.com/questions/1308432/do-try-catch-blocks-hurt-performance-when-exceptions-are-not-thrown)), and I imagine the cache is small enough that the dictionary lookup will be faster than looking through a list of valid cultures. My biggest worry would be if calling into the runtime causes us to load an assembly we otherwise didn't repeatedly. Not sure about that.",
              "createdAt": "2021-01-05T01:30:27Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -17,907 +14,22 @@ namespace Microsoft.Build.Tasks\n     /// </summary>\n     internal static class CultureInfoCache\n     {\n-        private static readonly HashSet<string> ValidCultureNames;\n-\n-        static CultureInfoCache()\n-        {\n-            ValidCultureNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n-\n-#if !FEATURE_CULTUREINFO_GETCULTURES\n-            if (!AssemblyUtilities.CultureInfoHasGetCultures())\n-            {\n-                ValidCultureNames = HardcodedCultureNames;\n-                return;\n-            }\n-#endif\n-\n-            foreach (CultureInfo cultureName in AssemblyUtilities.GetAllCultures())\n-            {\n-                ValidCultureNames.Add(cultureName.Name);\n-            }\n-\n-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing\n-            // These pseudo-locales are available in versions of Windows from Vista and later.\n-            // However, from Windows 10, version 1803, they are not returned when enumerating the\n-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.\n-            var pseudoLocales = new[] { \"qps-ploc\", \"qps-ploca\", \"qps-plocm\", \"qps-Latn-x-sh\" };\n-\n-            foreach (string pseudoLocale in pseudoLocales)\n-            {\n-                ValidCultureNames.Add(pseudoLocale);\n-            }\n-        }\n-\n         /// <summary>\n         /// Determine if a culture string represents a valid <see cref=\"CultureInfo\"/> instance.\n         /// </summary>\n         /// <param name=\"name\">The culture name.</param>\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            try\n+            {\n+                _ = CultureInfo.GetCultureInfo(name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> My biggest worry would be if calling into the runtime causes us to load an assembly we otherwise didn't repeatedly. Not sure about that.\r\n\r\nThe Globalization code residing inside the core library. so this change wouldn't make any difference. Or are you referring to something else?\r\n",
              "createdAt": "2021-01-05T01:49:01Z",
              "path": "src/Tasks/CultureInfoCache.cs",
              "diffHunk": "@@ -17,907 +14,22 @@ namespace Microsoft.Build.Tasks\n     /// </summary>\n     internal static class CultureInfoCache\n     {\n-        private static readonly HashSet<string> ValidCultureNames;\n-\n-        static CultureInfoCache()\n-        {\n-            ValidCultureNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n-\n-#if !FEATURE_CULTUREINFO_GETCULTURES\n-            if (!AssemblyUtilities.CultureInfoHasGetCultures())\n-            {\n-                ValidCultureNames = HardcodedCultureNames;\n-                return;\n-            }\n-#endif\n-\n-            foreach (CultureInfo cultureName in AssemblyUtilities.GetAllCultures())\n-            {\n-                ValidCultureNames.Add(cultureName.Name);\n-            }\n-\n-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing\n-            // These pseudo-locales are available in versions of Windows from Vista and later.\n-            // However, from Windows 10, version 1803, they are not returned when enumerating the\n-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.\n-            var pseudoLocales = new[] { \"qps-ploc\", \"qps-ploca\", \"qps-plocm\", \"qps-Latn-x-sh\" };\n-\n-            foreach (string pseudoLocale in pseudoLocales)\n-            {\n-                ValidCultureNames.Add(pseudoLocale);\n-            }\n-        }\n-\n         /// <summary>\n         /// Determine if a culture string represents a valid <see cref=\"CultureInfo\"/> instance.\n         /// </summary>\n         /// <param name=\"name\">The culture name.</param>\n         /// <returns>True if the culture is determined to be valid.</returns>\n         internal static bool IsValidCultureString(string name)\n         {\n-            return ValidCultureNames.Contains(name);\n+            try\n+            {\n+                _ = CultureInfo.GetCultureInfo(name);",
              "author": {
                "login": "tarekgh"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "While we're here\r\n```suggestion\r\n            result.ShouldBe(new CultureInfo(\"en-US\").ToString());\r\n```",
              "createdAt": "2021-01-06T01:37:05Z",
              "path": "src/Build.UnitTests/Evaluation/Expander_Tests.cs",
              "diffHunk": "@@ -3213,11 +3213,7 @@ public void PropertyFunctionStaticMethodGetCultureInfo()\n \n             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);\n \n-#if FEATURE_CULTUREINFO_GETCULTURES\n             string result = expander.ExpandIntoStringLeaveEscaped(@\"$([System.Globalization.CultureInfo]::GetCultureInfo(`en-US`).ToString())\", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);\n-#else\n-            string result = expander.ExpandIntoStringLeaveEscaped(@\"$([System.Globalization.CultureInfo]::new(`en-US`).ToString())\", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);\n-#endif\n \n             Assert.Equal(new CultureInfo(\"en-US\").ToString(), result);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This applies to the other asserts as well, we _should_ shouldly-ify functions we touch on.\r\n\r\n```suggestion\r\n            t.AssignedFiles[0].ItemSpec.ShouldBe($\"MyResource.{culture}.resx\");\r\n```",
              "createdAt": "2021-01-06T01:38:29Z",
              "path": "src/Tasks.UnitTests/AssignCulture_Tests.cs",
              "diffHunk": "@@ -216,6 +256,30 @@ public void PseudoLocalization(string culture)\n             Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Assert -> Shouldly function calls.",
              "createdAt": "2021-01-06T01:38:42Z",
              "path": "src/Tasks.UnitTests/AssignCulture_Tests.cs",
              "diffHunk": "@@ -216,6 +256,30 @@ public void PseudoLocalization(string culture)\n             Assert.Equal($\"MyResource.{culture}.resx\", t.AssignedFiles[0].ItemSpec);\n             Assert.Equal(\"MyResource.resx\", t.CultureNeutralAssignedFiles[0].ItemSpec);\n         }\n+\n+        /*\n+        * Method:   InvalidCulture\n+        *\n+        * Test for invalid culture (i.e. throwing CultureNotFoundException when using CultureInfo.GetCultureInfo())\n+        */\n+        [Theory]\n+        [InlineData(\"@\")]\n+        [InlineData(\"\\U0001F4A5\")]\n+        public void InvalidCulture(string culture)\n+        {\n+            AssignCulture t = new AssignCulture();\n+            t.BuildEngine = new MockEngine();\n+            ITaskItem i = new TaskItem($\"MyResource.{culture}.resx\");\n+            t.Files = new ITaskItem[] { i };\n+            t.Execute();\n+\n+            Assert.Single(t.AssignedFiles);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      }
    ]
  }
}