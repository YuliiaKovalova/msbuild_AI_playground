{
  "number": 6816,
  "title": "Optimize InternableString.GetHashCode",
  "body": "### Context\r\n\r\nThe current straightforward implementation is slow, especially on 64-bit Framework CLR. It is causing a measurable regression when evaluating large projects.\r\n\r\n### Changes Made\r\n\r\nRewrote the routine using a similar approach as [this BCL method](https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840). Calculating only 2 and not 4 characters at a time, though, to reduce the complexity since our implementation works on a list of spans and not just one string. The additional perf benefit of going 4 at a time would be relatively small.\r\n\r\n### Testing\r\n\r\n- A new unit test to verify correctness.\r\n- Micro-benchmark showing 1.6x boost on x86 and 2x boost on x64.\r\n- Evaluation perf traces showing significant reduction in the time spent in GetHashCode, saving 110 ms (~6%) per evaluation of the Unreal Engine C++ project on 64-bit.",
  "state": "MERGED",
  "createdAt": "2021-09-03T22:27:37Z",
  "updatedAt": "2021-09-14T15:55:53Z",
  "closedAt": "2021-09-14T08:52:18Z",
  "mergedAt": "2021-09-14T08:52:18Z",
  "additions": 91,
  "deletions": 13,
  "changedFiles": 3,
  "headRefName": "optimize-gethashcode",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "961a8605e04c56f7a57473064675bbdf800c3606",
          "message": "Optimize InternableString.GetHashCode (4.5x faster on Framework x64)",
          "committedDate": "2021-09-03T21:55:47Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c0b04d8872665026006d1d3c59d37608e504228",
          "message": "Fix unit tests (hash code values are now different)",
          "committedDate": "2021-09-06T13:47:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "184bf702caaa55a52a976d304f9e4f7f3e021eed",
          "message": "PR feedback: Add MethodImplOptions.AggressiveInlining",
          "committedDate": "2021-09-06T13:50:58Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "60e6082cd74bb20068d54eb3a7b1e640647a3b35",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-09-13T11:00:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68cb95eade7164fae5d8c52068a9ae07ab2e7ea2",
          "message": "Rotate bits, don't just shift",
          "committedDate": "2021-09-13T11:47:54Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4adc629b66f171dc2edde9d611d744a6ff5bcac2",
          "message": "Fix unit tests (hash code values are now different, again)",
          "committedDate": "2021-09-13T12:07:23Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4d660e9a0bc061ddb8526eabb00da3f2e003f687",
          "message": "PR feedback: Update comment",
          "committedDate": "2021-09-13T12:59:21Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> Looks reasonable to me but since hashing is scary just wanted to check on the algo and constants and things.\r\n\r\nIndeed, I have a major bug there because `<<` is a bit shift and I need bit rotation \ud83e\udd26\u200d\u2642\ufe0f \r\n\r\nThe plan:\r\n\r\n- [x] Fix the code to use `BitOperations.RotateLeft`.\r\n- [x] Re-run the benchmark.\r\n- [x] Fix the unit tests which explicitly uses colliding strings.\r\n- [x] Check for collisions on a representative set of strings as a sanity check.\r\n\r\n> I also note in the linked impl that it's \"when collisions aren't a problem\", which . . . seems right for us but have you thought about that in depth?\r\n\r\nThis was discussed when the current implementation was being developed and we convinced ourselves that since you can ask MSBuild to wipe the drive or do anything the current user can do, we don't really worry about DoS'ing it with crafted strings. In other words, strings processed by MSBuild are not considered user input that we should be protecting against because the whole build process has to be trusted by design.",
        "createdAt": "2021-09-07T21:21:59Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "The perf win on my VM is now lower - was 4.5x, now only 2x. I see the same thing without the new commits so it's likely because of the particular physical CPU where my machine is hosted is different. I have updated the description with the new numbers.",
        "createdAt": "2021-09-13T19:58:11Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: worth adding `[MethodImpl(MethodImplOptions.AggressiveInlining)]`?",
              "createdAt": "2021-09-04T00:11:46Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,59 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Sounds like a good idea. Done, thank you!",
              "createdAt": "2021-09-06T13:51:36Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,59 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "slightly off-topic: Wouldn't caching this string's hashcode result in a net improvement?",
              "createdAt": "2021-09-04T03:48:37Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,59 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "`GetHashCode` runs only once for a given string unless the caller calls `SpanBasedStringBuilder.ToString()` multiple times on the same instance without mutating it between the calls. Same as calling `StringBuilder.ToString()` multiple times, it is technically possible but enough of an anti-pattern that the implementation does not cache the result.\r\n\r\nMore on running `GetHashCode` only once: When a string is added to the weak cache, its hash code is used as a key in a dictionary. So it's not calculated on each look-up because the look-up is done based on the hash code and not the string itself. When we're looking for a string in the weak cache, we calculate its hash code once per lookup and, as argued above, there should not be more than one look-up for the same string.",
              "createdAt": "2021-09-06T14:02:19Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,59 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this still djb2?",
              "createdAt": "2021-09-07T15:55:54Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,60 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I will fix to say something like \"djb2-like\" and link to the dotnet/runtime method.",
              "createdAt": "2021-09-07T21:09:54Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,60 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have updated the comment.",
              "createdAt": "2021-09-13T13:02:22Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,60 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n        public void GetHashCodeIsStableRegardlessOfSpanLength(string testString)\r\n```\r\n```suggestion\r\n        public void GetHashCodeIsStableRegadlessOfSpanLengths(string testString)\r\n```",
              "createdAt": "2021-09-10T21:12:48Z",
              "path": "src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs",
              "diffHunk": "@@ -96,6 +96,28 @@ public void ReferenceEqualsReturnsExpectedValue()\n             internableString.ReferenceEquals(str).ShouldBeFalse();\n         }\n \n+        [Theory]\n+        [InlineData(\"012345678\")] // odd number of characters\n+        [InlineData(\"0123456789\")] // even number of characters\n+        public void GetHashCodeIsStableRegadlessOfSpanLengths(string testString)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            // Chop the string into 2-3 parts and verify that the hash code is unchanged.\r\n```\r\n```suggestion\r\n            // Chop up the string to 2-3 parts and verify that the hash code is unchanged.\r\n```",
              "createdAt": "2021-09-10T21:13:24Z",
              "path": "src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs",
              "diffHunk": "@@ -96,6 +96,28 @@ public void ReferenceEqualsReturnsExpectedValue()\n             internableString.ReferenceEquals(str).ShouldBeFalse();\n         }\n \n+        [Theory]\n+        [InlineData(\"012345678\")] // odd number of characters\n+        [InlineData(\"0123456789\")] // even number of characters\n+        public void GetHashCodeIsStableRegadlessOfSpanLengths(string testString)\n+        {\n+            int hashCode = new InternableString(testString).GetHashCode();\n+\n+            // Chop up the string to 2-3 parts and verify that the hash code is unchanged.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How is this hashing two at a time? It looks like it's modifying the hash as I'd expect then xor'ing it with one character. Length goes down by two but index only increases by one? Would that miss the second half of the span?",
              "createdAt": "2021-09-10T22:05:26Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,60 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {\n+            if (hashedOddNumberOfCharacters && length > 0)\n+            {\n+                // If the number of characters hashed so far is odd, the first character of the current block completes\n+                // the calculation done with the last character of the previous block.\n+                hash ^= BitConverter.IsLittleEndian ? ((uint)*charPtr << 16) : *charPtr;\n+                length--;\n+                charPtr++;\n+                hashedOddNumberOfCharacters = false;\n+            }\n+\n+            // The loop hashes two characters at a time.\n+            uint* ptr = (uint*)charPtr;\n+            while (length >= 2)\n+            {\n+                length -= 2;\n+                hash = ((hash << 5) + hash) ^ *ptr;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`ptr` is a `uint*` which is [syntactic sugar for an unsigned 32-bit int](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#:~:text=%20Integral%20numeric%20types%20%28C%23%20reference%29%20%201,C%205%20%20language%20specification.%20%20More%20). `charPtr` though is a `char*` which is [syntactic sugar for a UTF-16 character](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/char). So `length` is a count of 16-bit things and \"index\"/`ptr` is a list of 32-bit things (so half the size if the list is even).",
              "createdAt": "2021-09-10T22:28:22Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -304,28 +304,60 @@ public override string ToString()\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {\n+            if (hashedOddNumberOfCharacters && length > 0)\n+            {\n+                // If the number of characters hashed so far is odd, the first character of the current block completes\n+                // the calculation done with the last character of the previous block.\n+                hash ^= BitConverter.IsLittleEndian ? ((uint)*charPtr << 16) : *charPtr;\n+                length--;\n+                charPtr++;\n+                hashedOddNumberOfCharacters = false;\n+            }\n+\n+            // The loop hashes two characters at a time.\n+            uint* ptr = (uint*)charPtr;\n+            while (length >= 2)\n+            {\n+                length -= 2;\n+                hash = ((hash << 5) + hash) ^ *ptr;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please avoid using `ref` variables in tight loops. JIT cant optimize it into registry.\r\nI recommend to change signature to `private static unsafe uint GetHashCodeHelper(char* charPtr, int length, uint hash, ref bool hashedOddNumberOfCharacters)` and call it `hash = GetHashCodeHelper(charPtr, span.Length, hash, ref hashedOddNumberOfCharacters);`\r\n\r\nIn my micro benchmark, this simple change makes it about 2x faster.",
              "createdAt": "2021-09-14T13:44:47Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Wow, this must be the reason why it got slower after the last update. Confirming your results, it really is more than 2x faster after eliminating the ref parameter.",
              "createdAt": "2021-09-14T14:17:53Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "https://github.com/dotnet/msbuild/pull/6845",
              "createdAt": "2021-09-14T14:31:59Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Would it also be faster using out parameters? Having an input and out parameter that happen to match. Or maybe returning a tuple?",
              "createdAt": "2021-09-14T14:50:31Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind Using non ref local variable as running hash in tight loop and than copy it to out parameter would most probably render about same benefit. However, returning integer value from procedure is something highly optimized by calling conventions. In particular it returns value in registry eax. This is significantly faster than exchanging return values by copying it into stack memory which both value tuple and out variables does. By significant I mean about 1 us slower for modern CPUs, so in practical world it rarely matters.",
              "createdAt": "2021-09-14T15:55:52Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: `hash = (RotateLeft(hash, 5) + hash) ^ *ptr;` would have exactly same outcome because internally in memory every C# string is terminated by `\\u0000`.\r\nHowever, the way it is written it is more obvious that we indeed think about odd lengths. Maybe we can put explanation into comments though....",
              "createdAt": "2021-09-14T13:47:52Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {\n+            if (hashedOddNumberOfCharacters && length > 0)\n+            {\n+                // If the number of characters hashed so far is odd, the first character of the current block completes\n+                // the calculation done with the last character of the previous block.\n+                hash ^= BitConverter.IsLittleEndian ? ((uint)*charPtr << 16) : *charPtr;\n+                length--;\n+                charPtr++;\n+                hashedOddNumberOfCharacters = false;\n+            }\n+\n+            // The loop hashes two characters at a time.\n+            uint* ptr = (uint*)charPtr;\n+            while (length >= 2)\n+            {\n+                length -= 2;\n+                hash = (RotateLeft(hash, 5) + hash) ^ *ptr;\n+                ptr += 1;\n+            }\n+\n+            if (length > 0)\n+            {\n+                hash = (RotateLeft(hash, 5) + hash) ^ (BitConverter.IsLittleEndian ? *((char*)ptr) : ((uint)*((char*)ptr) << 16));",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This would work on strings but the input here is a span so we have to be precise and never overrun the buffer we're given.",
              "createdAt": "2021-09-14T13:58:38Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -299,33 +299,89 @@ public override string ToString()\n         }\n \n         /// <summary>\n-        /// Implements the simple yet very decently performing djb2 hash function (xor version).\n+        /// Implements the simple yet very decently performing djb2-like hash function (xor version) as inspired by\n+        /// https://github.com/dotnet/runtime/blob/6262ae8e6a33abac569ab6086cdccc470c810ea4/src/libraries/System.Private.CoreLib/src/System/String.Comparison.cs#L810-L840\n         /// </summary>\n         /// <returns>A stable hashcode of the string represented by this instance.</returns>\n+        /// <remarks>\n+        /// Unlike the BCL method, this implementation works only on two characters at a time to cut on the complexity with\n+        /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for\n+        /// a given string regardless of how it's split into spans (e.g. { \"AB\" } and { \"A\", \"B\" } have the same hash code).\n+        /// </remarks>\n         public override unsafe int GetHashCode()\n         {\n-            int hashCode = 5381;\n+            uint hash = (5381 << 16) + 5381;\n+            bool hashedOddNumberOfCharacters = false;\n+\n             fixed (char* charPtr = _inlineSpan)\n             {\n-                for (int i = 0; i < _inlineSpan.Length; i++)\n-                {\n-                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                }\n+                GetHashCodeHelper(charPtr, _inlineSpan.Length, ref hash, ref hashedOddNumberOfCharacters);\n             }\n             if (_spans != null)\n             {\n                 foreach (ReadOnlyMemory<char> span in _spans)\n                 {\n                     fixed (char* charPtr = span.Span)\n                     {\n-                        for (int i = 0; i < span.Length; i++)\n-                        {\n-                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);\n-                        }\n+                        GetHashCodeHelper(charPtr, span.Length, ref hash, ref hashedOddNumberOfCharacters);\n                     }\n                 }\n             }\n-            return hashCode;\n+            return (int)(hash);\n+        }\n+\n+        /// <summary>\n+        /// Hashes a memory block specified by a pointer and length.\n+        /// </summary>\n+        /// <param name=\"charPtr\">Pointer to the first character.</param>\n+        /// <param name=\"length\">Number of characters at <paramref name=\"charPtr\"/>.</param>\n+        /// <param name=\"hash\">The running hash code.</param>\n+        /// <param name=\"hashedOddNumberOfCharacters\">True if the incoming <paramref name=\"hash\"/> was calculated from an odd number of characters.</param>\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private static unsafe void GetHashCodeHelper(char* charPtr, int length, ref uint hash, ref bool hashedOddNumberOfCharacters)\n+        {\n+            if (hashedOddNumberOfCharacters && length > 0)\n+            {\n+                // If the number of characters hashed so far is odd, the first character of the current block completes\n+                // the calculation done with the last character of the previous block.\n+                hash ^= BitConverter.IsLittleEndian ? ((uint)*charPtr << 16) : *charPtr;\n+                length--;\n+                charPtr++;\n+                hashedOddNumberOfCharacters = false;\n+            }\n+\n+            // The loop hashes two characters at a time.\n+            uint* ptr = (uint*)charPtr;\n+            while (length >= 2)\n+            {\n+                length -= 2;\n+                hash = (RotateLeft(hash, 5) + hash) ^ *ptr;\n+                ptr += 1;\n+            }\n+\n+            if (length > 0)\n+            {\n+                hash = (RotateLeft(hash, 5) + hash) ^ (BitConverter.IsLittleEndian ? *((char*)ptr) : ((uint)*((char*)ptr) << 16));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}