{
  "number": 7186,
  "title": "CA1838 Avoid 'StringBuilder' parameters for P/Invokes",
  "body": "Relates to #7174\r\nhttps://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1838",
  "state": "MERGED",
  "createdAt": "2021-12-30T03:36:07Z",
  "updatedAt": "2022-02-16T01:11:29Z",
  "closedAt": "2022-02-15T17:57:38Z",
  "mergedAt": "2022-02-15T17:57:38Z",
  "additions": 147,
  "deletions": 89,
  "changedFiles": 8,
  "headRefName": "CA1838",
  "isDraft": false,
  "author": {
    "login": "elachlan"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "994b6969031a9969b40fae9686e76fb0d92cee00",
          "message": "CA1838 Avoid 'StringBuilder' parameters for P/Invokes",
          "committedDate": "2021-12-30T03:35:50Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4b519a9226a4b6261e75bf0415022979872b3b31",
          "message": "revert ruleset change",
          "committedDate": "2022-01-07T23:56:22Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a88ed9ee42e843fc1c31f2964d3c3f63eea6c53",
          "message": "rebase",
          "committedDate": "2022-01-07T23:56:38Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "638775f36fdfc910db341b9c8291a0cf1496454c",
          "message": "Enable warning on CA1838",
          "committedDate": "2022-01-07T23:57:15Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "751fea370a4f1a5852704b0a67bf6952f665df8d",
          "message": "Merge branch 'main' into CA1838",
          "committedDate": "2022-01-11T21:25:24Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "661c2c82cfd53e47ecd63d2b86aee6b42079008a",
          "message": "CA1838 Avoid 'StringBuilder' parameters for P/Invokes. Consider using a character buffer instead.",
          "committedDate": "2022-01-11T22:01:35Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4f0424ca521013696585e33551ba7d02e9f46cdc",
          "message": "trying again",
          "committedDate": "2022-01-12T23:33:41Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e042e6632a89b28abb45b9aa58f4856d8d9826ba",
          "message": "Changes from review",
          "committedDate": "2022-01-27T22:39:27Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4ddf6610e43837e39bf4081b7ca9f9b6c72f7937",
          "message": "GetGacPath changes",
          "committedDate": "2022-01-27T23:05:38Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8f0c31c670f1e6080bd236a7796fc83065b7d697",
          "message": "Making sure we are form strings properly",
          "committedDate": "2022-01-28T02:31:32Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "04e4a1bea5413d75c0e22162c5737155fbc151f1",
          "message": "changes from review",
          "committedDate": "2022-01-28T04:13:50Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "903f35ddc54b9c03d0b99b52de14c7fb4dfdd2ed",
          "message": "Remove unused field",
          "committedDate": "2022-01-28T04:17:50Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "69cf05fce07361bb16957bf909567d19f59185ee",
          "message": "Use ArrayPool in GetRuntimeVersion and fix usage in GetModuleFileName",
          "committedDate": "2022-01-28T05:40:05Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "300179b8b434ffad4f94197160ff03824233b9f9",
          "message": "Refactor GetRuntimeVersion to remove loop and use stackalloc",
          "committedDate": "2022-01-28T23:12:11Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c392277686c3bd07d8e7b1a10bf35817d25b9369",
          "message": "changes from review",
          "committedDate": "2022-01-31T23:14:45Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "de3618c2d86993600f44b5a611af63765c1700da",
          "message": "Fix conflict and xml doc",
          "committedDate": "2022-01-31T23:23:48Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a0178d718ed262e90dbaf9b1a71fb4181d51d606",
          "message": "Merge branch 'main' into CA1838",
          "committedDate": "2022-01-31T23:25:08Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "54878ac32ffdb7d53b1c8551c73631fcdadcf701",
          "message": "Fix possible StackOverflow in GetShortPathName/GetLongPathName by moving back to char array instead of stackalloc\nRemove Explicit zero initialization for RmStartSession",
          "committedDate": "2022-02-01T23:44:59Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "567cc08dbe0bb3a2ef60c1c7d77ab5f752cabba7",
          "message": "Merge branch 'CA1838' of github.com:elachlan/msbuild into CA1838",
          "committedDate": "2022-02-01T23:45:35Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8af24e5df8ac71eae272ac4b84d65683d6cb3986",
          "message": "remove unneeded unsafe from pinvoke definitions",
          "committedDate": "2022-02-01T23:48:14Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "031af514995598c6f7032020f860ea875c863ee7",
          "message": "Added cached GAC Path and changes from review",
          "committedDate": "2022-02-02T21:53:10Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4f6bf7c4a665af4e0c411b560d14a7383d78fef",
          "message": "Add documentation to Pinvoke",
          "committedDate": "2022-02-03T21:39:31Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b5f60db3620d70d687bd1c702b5ffc02763820bb",
          "message": "Changes from review",
          "committedDate": "2022-02-04T09:28:34Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "53d3da4dd84e9cb888ca97fc71892b79a65de75f",
          "message": "Change from review",
          "committedDate": "2022-02-08T21:48:54Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0a97bfd0cad9134a2c25310a43cd119dc7eb8e9c",
          "message": "Add VerifyThrow instead of loop condition",
          "committedDate": "2022-02-08T21:54:06Z",
          "author": {
            "name": "elachlan",
            "email": "2433737+elachlan@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "There are 21 violations of this rule. The fixes seem complex and I don't think I can sort them out.\r\n\r\nHelpful resources:\r\nhttps://github.com/dotnet/runtime/issues/47735\r\nhttps://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1838",
        "createdAt": "2022-01-08T05:26:17Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "> There are 21 violations of this rule. The fixes seem complex and I don't think I can sort them out.\r\n> \r\n> Helpful resources: [dotnet/runtime#47735](https://github.com/dotnet/runtime/issues/47735) https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1838\r\n\r\nDo you want me to mark this up-for-grabs? I'm not sure if someone else will have a chance to sort through it, but I wouldn't have high expectations from maintainers.",
        "createdAt": "2022-01-10T23:42:47Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "As far as I can tell instead of using stringbuilder you are supposed to use a char buffer when making calls via P/Invoke?\r\n\r\nI will give it a go and someone can review it and tell me if I am doing it wrong.",
        "createdAt": "2022-01-10T23:56:19Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "@Forgind in my manic googling to understand how this all works I stumbled into these:\r\n\r\n- https://github.com/microsoft/CsWin32\r\n- https://github.com/dotnet/pinvoke\r\n\r\nThey might be useful in replacing the msbuild maintained pinvokes.",
        "createdAt": "2022-01-12T23:04:17Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "This article suggests that I can use span<char> to avoid the unsafe context.\r\nhttps://vcsjones.dev/stackalloc/\r\n\r\nShould I do this? would the P/Invoke calls work with that?",
        "createdAt": "2022-01-31T22:25:29Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "> This article suggests that I can use span to avoid the unsafe context. https://vcsjones.dev/stackalloc/\r\n> \r\n> Should I do this? would the P/Invoke calls work with that?\r\n\r\nI tested it with Span<Char> and the P/Invoke threw an exception.",
        "createdAt": "2022-01-31T22:55:43Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "> I tested it with Span and the P/Invoke threw an exception.\r\n\r\nYou can't pass a span directly to a DllImport method (you'll be able to with the new GeneratedDllImport support coming in .NET 7 that builds out the marshaling stubs at compile time).  But you can pass either a `ref` or a pointer.  So, for example, if the DllImport signature is:\r\n```C#\r\ninternal static extern int GetLongPathName(string path, ref char fullpath, int length);\r\n```\r\nyou can pass `ref MemoryMarshal.GetReference(span)` as that `fullPath` argument.",
        "createdAt": "2022-02-01T01:35:12Z",
        "author": {
          "login": "stephentoub"
        }
      },
      {
        "body": "[curious] @stephentoub do you think the runtime can at some point introduce zero-copy marshaling of output string buffers? Something like:\r\n\r\n```C#\r\nextern static int GetStringAndYesIKnowTheExactLength([MarshalAs(UnmanagedType.CreateAndPinNewString, LengthIsPassedInParameterNumber=2)] out string s, int length);\r\n```\r\n\r\nWhere the stub would create a new string object of size `length`, pin it, and pass the pointer to unmanaged code. Technically it mutates an existing string object but the object is freshly created so if you squint you could say this is just a fancy string constructor.\r\n\r\n\r\n\r\n",
        "createdAt": "2022-02-02T13:27:29Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "Do you have an example Win32 API that looks like that, where the exact length of the output is known in advance? Typically it's the API that tells the caller how much it wrote to the caller-supplied buffer. (And I say Win32 because on Unix the lingua-franca is UTF8 which couldn't write directly into the string buffer anyway.)\r\n\r\nThat said, you can already do that if you really want to. Just make the call inside of a [string.Create](https://docs.microsoft.com/en-us/dotnet/api/system.string.create?view=net-6.0#system-string-create-1(system-int32-0-system-buffers-spanaction((system-char-0)))) callback and hand the span for the string buffer off to the native call (either pinning it and passing a pointer or using the new source gen marshaling support for spans). ",
        "createdAt": "2022-02-02T14:05:35Z",
        "author": {
          "login": "stephentoub"
        }
      },
      {
        "body": "This very PR has three occurrences of the pattern:\r\n1. Call an API with null buffer to get the length (`kernel32!GetShortPathName`, `kernel32!GetLongPathName`, `fusion!GetCachePath`) or call it with a reasonably sized buffer and hope it will fit (`mscoree!GetFileVersion`).\r\n2. Allocate a buffer of the actual returned length (only if the reasonably sized buffer was not enough in case of `GetFileVersion`).\r\n3. Call the API again passing the allocated buffer to obtain the string.\r\n\r\nThe allocation and copying in steps 2 and 3 could be avoided.\r\n\r\nI didn't know about `string.Create`, that's an awesome API!",
        "createdAt": "2022-02-02T20:38:59Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> Call the API again passing the allocated buffer to obtain the string.\r\n\r\nI don't see how the runtime could depend on that, though.  This pattern involves trusting that the API will succeed in filling the whole space because you gave it what it previously told you was required.",
        "createdAt": "2022-02-02T20:50:17Z",
        "author": {
          "login": "stephentoub"
        }
      },
      {
        "body": "The second call still takes the buffer size so it doesn't overrun, and it returns the actual size so the caller has to make sure that it filled the whole space and the string length is correct. I see how convoluted it is and runtime support is probably not a good idea. Especially now that I know `string.Create` exists.",
        "createdAt": "2022-02-04T08:28:04Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "Thanks @elachlan!",
        "createdAt": "2022-02-15T17:57:49Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "this doesn't have `[out]`, so I think StringBuilder might be valid.",
              "createdAt": "2022-01-11T22:09:46Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -56,8 +56,10 @@ internal enum ApplicationType\n             string[] rgsServiceNames);\n \n         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]\n-        private static extern int RmStartSession(out uint pSessionHandle,\n-            int dwSessionFlags, StringBuilder strSessionKey);\n+        private static extern int RmStartSession(\n+            out uint pSessionHandle,\n+            int dwSessionFlags,\n+            char[] strSessionKey);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "https://docs.microsoft.com/en-us/windows/win32/api/restartmanager/nf-restartmanager-rmstartsession",
              "createdAt": "2022-01-12T23:37:06Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -56,8 +56,10 @@ internal enum ApplicationType\n             string[] rgsServiceNames);\n \n         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]\n-        private static extern int RmStartSession(out uint pSessionHandle,\n-            int dwSessionFlags, StringBuilder strSessionKey);\n+        private static extern int RmStartSession(\n+            out uint pSessionHandle,\n+            int dwSessionFlags,\n+            char[] strSessionKey);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "`[Out] char[]` would be the best way to declare the parameter if it wasn't for the strange behavior of the function not null-terminating the string. Please leave as is (i.e. the default `[In,Out]`).",
              "createdAt": "2022-01-27T13:10:53Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -56,8 +56,10 @@ internal enum ApplicationType\n             string[] rgsServiceNames);\n \n         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]\n-        private static extern int RmStartSession(out uint pSessionHandle,\n-            int dwSessionFlags, StringBuilder strSessionKey);\n+        private static extern int RmStartSession(\n+            out uint pSessionHandle,\n+            int dwSessionFlags,\n+            char[] strSessionKey);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Again, this doesn't have `[out]`, so I think `StringBuilder` might be valid.",
              "createdAt": "2022-01-11T22:10:15Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1051,7 +1051,7 @@ internal static bool AllDrivesMapped()\n         /// to allocate a mutable buffer of characters and pass it around.\n         /// </summary>\n         [DllImport(\"fusion.dll\", CharSet = CharSet.Unicode)]\n-        internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, StringBuilder cachePath, ref int pcchPath);\n+        internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, char[] cachePath, ref int pcchPath);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/fusion/getcachepath-function",
              "createdAt": "2022-01-12T23:35:06Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1051,7 +1051,7 @@ internal static bool AllDrivesMapped()\n         /// to allocate a mutable buffer of characters and pass it around.\n         /// </summary>\n         [DllImport(\"fusion.dll\", CharSet = CharSet.Unicode)]\n-        internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, StringBuilder cachePath, ref int pcchPath);\n+        internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, char[] cachePath, ref int pcchPath);",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Again, this doesn't have `[out]`, so I think `StringBuilder` might be valid.",
              "createdAt": "2022-01-11T22:10:21Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1125,7 +1125,7 @@ internal static bool AllDrivesMapped()\n         /// <param name=\"dwLength\">The size, in bytes, of the returned szBuffer.</param>\n         /// <returns>HResult</returns>\n         [DllImport(MscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]\n-        internal static extern uint GetFileVersion(String szFullPath, StringBuilder szBuffer, int cchBuffer, out uint dwLength);\n+        internal static extern uint GetFileVersion(string szFullPath, char[] szBuffer, int cchBuffer, out uint dwLength);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/getfileversion-function",
              "createdAt": "2022-01-12T23:35:52Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1125,7 +1125,7 @@ internal static bool AllDrivesMapped()\n         /// <param name=\"dwLength\">The size, in bytes, of the returned szBuffer.</param>\n         /// <returns>HResult</returns>\n         [DllImport(MscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]\n-        internal static extern uint GetFileVersion(String szFullPath, StringBuilder szBuffer, int cchBuffer, out uint dwLength);\n+        internal static extern uint GetFileVersion(string szFullPath, char[] szBuffer, int cchBuffer, out uint dwLength);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "@ladipro Could you point me in the right direction on this?",
              "createdAt": "2022-01-27T10:43:24Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1125,7 +1125,7 @@ internal static bool AllDrivesMapped()\n         /// <param name=\"dwLength\">The size, in bytes, of the returned szBuffer.</param>\n         /// <returns>HResult</returns>\n         [DllImport(MscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]\n-        internal static extern uint GetFileVersion(String szFullPath, StringBuilder szBuffer, int cchBuffer, out uint dwLength);\n+        internal static extern uint GetFileVersion(string szFullPath, char[] szBuffer, int cchBuffer, out uint dwLength);",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nits:\r\n- `[In]` on an enum makes no difference, when passed by value it is always \"in\".\r\n- `cachePath` should be `[Out]`; it may not make a difference either if the runtime pins the array but it's a good practice to specify it nonetheless.",
              "createdAt": "2022-01-27T13:02:48Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1050,8 +1050,12 @@ internal static bool AllDrivesMapped()\n         /// and then again to pass the client-allocated character buffer. StringBuilder is the most straightforward way\n         /// to allocate a mutable buffer of characters and pass it around.\n         /// </summary>\n+        /// <param name=\"cacheFlags\">Value that indicates the source of the cached assembly.</param>\n+        /// <param name=\"cachePath\">The returned pointer to the path.</param>\n+        /// <param name=\"pcchPath\">The requested maximum length of CachePath, and upon return, the actual length of CachePath.</param>\n+        /// \n         [DllImport(\"fusion.dll\", CharSet = CharSet.Unicode)]\n-        internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, StringBuilder cachePath, ref int pcchPath);\n+        internal static extern int GetCachePath([In] AssemblyCacheFlags cacheFlags, char[] cachePath, ref int pcchPath);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nits:\r\n- `[MarshalAs(UnmanagedType.LPWStr)]` is the default if `CharSet` is set to `Unicode` although no harm in leaving it in.\r\n- `szBuffer` should be declared as `[Out]` (same comment as in `GetCachePath`).",
              "createdAt": "2022-01-27T13:05:55Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1117,15 +1121,15 @@ internal static bool AllDrivesMapped()\n \n #if FEATURE_MSCOREE\n         /// <summary>\n-        /// Get the runtime version for a given file\n+        /// Get the runtime version for a given file.\n         /// </summary>\n-        /// <param name=\"szFullPath\">The path of the file to be examined</param>\n+        /// <param name=\"szFileName\">The path of the file to be examined.</param>\n         /// <param name=\"szBuffer\">The buffer allocated for the version information that is returned.</param>\n-        /// <param name=\"cchBuffer\">The size, in wide characters, of szBuffer</param>\n+        /// <param name=\"cchBuffer\">The size, in wide characters, of szBuffer.</param>\n         /// <param name=\"dwLength\">The size, in bytes, of the returned szBuffer.</param>\n-        /// <returns>HResult</returns>\n+        /// <returns>HResult.</returns>\n         [DllImport(MscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]\n-        internal static extern uint GetFileVersion(String szFullPath, StringBuilder szBuffer, int cchBuffer, out uint dwLength);\n+        internal static extern uint GetFileVersion([MarshalAs(UnmanagedType.LPWStr)] string szFileName, char[] szBuffer, int cchBuffer, out int dwLength);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please fill the array with all `\\0`'s per the linked blog post.",
              "createdAt": "2022-01-27T13:13:02Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -211,7 +213,8 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             const int maxRetries = 6;\n \n             // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            char[] key = new char[CCH_RM_SESSION_KEY + 1];\n+            key[0] = '\\0';",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Doesn't seem to be indented properly.",
              "createdAt": "2022-01-27T13:14:27Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,27 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n             for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n             {\n-                buffer.EnsureCapacity(bufferSize);\n-\n+                buffer = System.Buffers.ArrayPool<char>.Shared.Rent(bufferSize);\n+                try\n+                {\n                 var handleRef = new System.Runtime.InteropServices.HandleRef(buffer, handle);\n-                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, buffer.Capacity);\n+                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, bufferSize);\n \n-                bool isBufferTooSmall = ((uint)Marshal.GetLastWin32Error() == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n+                bool isBufferTooSmall = (uint)Marshal.GetLastWin32Error() == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER;\n                 success = pathLength != 0 && !isBufferTooSmall;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a bug, we are creating unnecessarily large strings. We should take `pathLength` into account here, otherwise the method returns strings of size `NativeMethodsShared.MAX_PATH` at least.",
              "createdAt": "2022-01-27T13:18:28Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,27 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n             for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n             {\n-                buffer.EnsureCapacity(bufferSize);\n-\n+                buffer = System.Buffers.ArrayPool<char>.Shared.Rent(bufferSize);\n+                try\n+                {\n                 var handleRef = new System.Runtime.InteropServices.HandleRef(buffer, handle);\n-                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, buffer.Capacity);\n+                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, bufferSize);\n \n-                bool isBufferTooSmall = ((uint)Marshal.GetLastWin32Error() == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n+                bool isBufferTooSmall = (uint)Marshal.GetLastWin32Error() == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER;\n                 success = pathLength != 0 && !isBufferTooSmall;\n+                }\n+                finally\n+                {\n+                    System.Buffers.ArrayPool<char>.Shared.Return(buffer);\n+                }\n             }\n \n-            return success ? buffer.ToString() : string.Empty;\n+            return success ? new string(buffer) : string.Empty;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Must either use the `dwLength` parameter of `GetFileVersion` or find the terminating 0 in the char array. Otherwise the string is oversized.",
              "createdAt": "2022-01-27T13:25:47Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,18 +578,19 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n+                    runtimeVersion = new char[bufferLength];\n                     hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n                     bufferLength *= 2;\n-                } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n+                }\n+                while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n \n                 if (hresult == NativeMethodsShared.S_OK)\n                 {\n-                    return runtimeVersion.ToString();\n+                    return new string(runtimeVersion);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't believe you need the `+1`. Please verify before/after that this is returning the same string, i.e. with the same `Length`.",
              "createdAt": "2022-01-27T13:29:15Z",
              "path": "src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs",
              "diffHunk": "@@ -373,10 +373,10 @@ internal static string GetGacPath()\n         {\n             int gacPathLength = 0;\n             NativeMethods.GetCachePath(AssemblyCacheFlags.GAC, null, ref gacPathLength);\n-            StringBuilder gacPath = new StringBuilder(gacPathLength);\n+            char[] gacPath = new char[gacPathLength + 1];",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I ran the tests and debugged it to work it out.",
              "createdAt": "2022-01-28T02:56:46Z",
              "path": "src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs",
              "diffHunk": "@@ -373,10 +373,10 @@ internal static string GetGacPath()\n         {\n             int gacPathLength = 0;\n             NativeMethods.GetCachePath(AssemblyCacheFlags.GAC, null, ref gacPathLength);\n-            StringBuilder gacPath = new StringBuilder(gacPathLength);\n+            char[] gacPath = new char[gacPathLength + 1];",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The `ToString` call on line 968 will return `\"System.Char[]\"`. You'll have to use `new string(...)` instead.",
              "createdAt": "2022-01-27T13:32:40Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -959,7 +959,7 @@ internal static string GetShortFilePath(string path)\n \n             if (length > 0)\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n+                char[] fullPathBuffer = new char[length];",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This method isn't used anywhere and is private. Can we remove it?",
              "createdAt": "2022-01-27T22:49:34Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1478,15 +1478,13 @@ internal static void VerifyThrowWin32Result(int result)\n     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);\n \n     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]\n-    private static extern uint SearchPath\n-    (\n+    private static extern uint SearchPath(",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Dead code can be removed",
              "createdAt": "2022-01-28T03:24:11Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1478,15 +1478,13 @@ internal static void VerifyThrowWin32Result(int result)\n     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);\n \n     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]\n-    private static extern uint SearchPath\n-    (\n+    private static extern uint SearchPath(",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I think the question was whether anyone calls SearchPath via reflection. I have no idea, personally, and I'd be willing to remove it, but I know I'm on the risky edge for most changes.",
              "createdAt": "2022-01-28T17:00:46Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1478,15 +1478,13 @@ internal static void VerifyThrowWin32Result(int result)\n     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);\n \n     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]\n-    private static extern uint SearchPath\n-    (\n+    private static extern uint SearchPath(",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It would be really strange to call it via reflection instead of just implementing their own p/invoke. It would make more sense to write a public method that exposes and then they can use it directly and avoid Reflection.\r\n\r\nI can't find any usages of it via a \"FindAll\"",
              "createdAt": "2022-01-28T22:35:38Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1478,15 +1478,13 @@ internal static void VerifyThrowWin32Result(int result)\n     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);\n \n     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]\n-    private static extern uint SearchPath\n-    (\n+    private static extern uint SearchPath(",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "> just implementing their own p/invoke\r\n\r\nFair enough. I'd been thinking this was a normal method rather than external.",
              "createdAt": "2022-01-28T22:54:48Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1478,15 +1478,13 @@ internal static void VerifyThrowWin32Result(int result)\n     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);\n \n     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]\n-    private static extern uint SearchPath\n-    (\n+    private static extern uint SearchPath(",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks for reviewing, I really appreciate the input! My coding career has taught me I am forever fallible :)",
              "createdAt": "2022-01-28T23:36:29Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1478,15 +1478,13 @@ internal static void VerifyThrowWin32Result(int result)\n     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);\n \n     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]\n-    private static extern uint SearchPath\n-    (\n+    private static extern uint SearchPath(",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "function also not used, can we remove it?",
              "createdAt": "2022-01-27T22:53:11Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1504,10 +1502,10 @@ int[] filePart\n                                             String pConfigurationFile,",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Stackalloc?",
              "createdAt": "2022-01-28T03:23:41Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -959,13 +959,13 @@ internal static string GetShortFilePath(string path)\n \n             if (length > 0)\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n+                char[] fullPathBuffer = new char[length];",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit spaces around operator",
              "createdAt": "2022-01-28T03:24:38Z",
              "path": "src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs",
              "diffHunk": "@@ -367,16 +367,16 @@ bool specificVersion\n         }\n \n         /// <summary>\n-        /// Return the root path of the GAC\n+        /// Return the root path of the GAC.\n         /// </summary>\n         internal static string GetGacPath()\n         {\n             int gacPathLength = 0;\n             NativeMethods.GetCachePath(AssemblyCacheFlags.GAC, null, ref gacPathLength);\n-            StringBuilder gacPath = new StringBuilder(gacPathLength);\n+            char[] gacPath = new char[gacPathLength];\n             NativeMethods.GetCachePath(AssemblyCacheFlags.GAC, gacPath, ref gacPathLength);\n \n-            return gacPath.ToString();\n+            return new string(gacPath, 0, gacPathLength-1);",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Stackalloc for all of these. Generally you should use it where the buffer is not returned, is used synchronously, and you need no more then about 512 bytes as a rule of thumb. Zero allocation",
              "createdAt": "2022-01-28T03:25:48Z",
              "path": "src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs",
              "diffHunk": "@@ -367,16 +367,16 @@ bool specificVersion\n         }\n \n         /// <summary>\n-        /// Return the root path of the GAC\n+        /// Return the root path of the GAC.\n         /// </summary>\n         internal static string GetGacPath()\n         {\n             int gacPathLength = 0;\n             NativeMethods.GetCachePath(AssemblyCacheFlags.GAC, null, ref gacPathLength);\n-            StringBuilder gacPath = new StringBuilder(gacPathLength);\n+            char[] gacPath = new char[gacPathLength];",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This buffer will already be zeroed for you (unless the assembly has disabled zero unit globally)",
              "createdAt": "2022-01-28T03:27:33Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -211,7 +213,11 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             const int maxRetries = 6;\n \n             // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            char[] key = new char[CCH_RM_SESSION_KEY + 1];\n+            for (int i = 0; i < key.Length; i++)",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we use periods on sentence fragments",
              "createdAt": "2022-01-28T03:27:53Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1117,15 +1121,15 @@ internal static bool AllDrivesMapped()\n \n #if FEATURE_MSCOREE\n         /// <summary>\n-        /// Get the runtime version for a given file\n+        /// Get the runtime version for a given file.\n         /// </summary>\n-        /// <param name=\"szFullPath\">The path of the file to be examined</param>\n+        /// <param name=\"szFileName\">The path of the file to be examined.</param>\n         /// <param name=\"szBuffer\">The buffer allocated for the version information that is returned.</param>\n-        /// <param name=\"cchBuffer\">The size, in wide characters, of szBuffer</param>\n+        /// <param name=\"cchBuffer\">The size, in wide characters, of szBuffer.</param>\n         /// <param name=\"dwLength\">The size, in bytes, of the returned szBuffer.</param>\n-        /// <returns>HResult</returns>\n+        /// <returns>HResult.</returns>",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Its one of the analyzers the team has enabled. Maybe I should convert this to a cref as well.",
              "createdAt": "2022-01-28T23:41:26Z",
              "path": "src/Tasks/NativeMethods.cs",
              "diffHunk": "@@ -1117,15 +1121,15 @@ internal static bool AllDrivesMapped()\n \n #if FEATURE_MSCOREE\n         /// <summary>\n-        /// Get the runtime version for a given file\n+        /// Get the runtime version for a given file.\n         /// </summary>\n-        /// <param name=\"szFullPath\">The path of the file to be examined</param>\n+        /// <param name=\"szFileName\">The path of the file to be examined.</param>\n         /// <param name=\"szBuffer\">The buffer allocated for the version information that is returned.</param>\n-        /// <param name=\"cchBuffer\">The size, in wide characters, of szBuffer</param>\n+        /// <param name=\"cchBuffer\">The size, in wide characters, of szBuffer.</param>\n         /// <param name=\"dwLength\">The size, in bytes, of the returned szBuffer.</param>\n-        /// <returns>HResult</returns>\n+        /// <returns>HResult.</returns>",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should I use an array pool here? or is stackalloc okay in a loop here?",
              "createdAt": "2022-01-28T04:15:19Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "~~Stackalloc is fine in a loop~~, but yet problem here is that the size could get too large. You don't want to stackalloc too much as you could blow the stack. We use 512 or 1024 Max in the core libraries.\r\n\r\nIn this case if you may need more you can use array pool. What you sometimes see is code using stackalloc if the length is ok and if not using arraypool.",
              "createdAt": "2022-01-28T04:37:26Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "@stephentoub  am I making correct statements? I now see the docs say to not use it inside a loop. I'm not clear why.",
              "createdAt": "2022-01-28T04:41:31Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "From my reading, if you use it in a loop you can cause a stack overflow if it gets stuck in a loop infinitely. ",
              "createdAt": "2022-01-28T04:44:06Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Right, but that surprises me as when the stackalloc goes out of scope I would expect the codegen to reuse it. But I guess that would be a difficult problem and not always possible in general if there are other locals and the allocation size changes.\n\nI guess you have to follow the pattern suggested in the docs. stackalloc once a reasonable size outside the loop, then if it's too small use array pool.",
              "createdAt": "2022-01-28T04:53:04Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I changed the usage of ArrayPool to make sure we don't access the array after we `Return` it.",
              "createdAt": "2022-01-28T05:41:15Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": ">> Stackalloc is fine in a loop\r\n\r\n> am I making correct statements?\r\n\r\nNo, the allocated stack isn't released until the method returns. Using stackalloc in a loop is rarely correct. ",
              "createdAt": "2022-01-28T11:40:14Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "stephentoub"
              }
            },
            {
              "body": "Makes sense. Just curious (maybe question for @AndyAyersMS ) is any work contemplated to make codegen reuse the stack allocated buffer in some feasible subset of cases? I assume that would be low value as it would be hard to predict whether it would happen so it would remain unwise to use in a loop.",
              "createdAt": "2022-01-28T18:08:54Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "The analysis to reuse a previous iteration's allocation would be tricky, and we don't have plans to do it.\r\n\r\nBest to avoid `stackalloc` in a loop, as others have said.",
              "createdAt": "2022-01-28T19:57:54Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "AndyAyersMS"
              }
            },
            {
              "body": "Thanks, interesting.",
              "createdAt": "2022-01-28T20:29:29Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I rewrote it to remove the loop, which now allows it to use stackalloc.",
              "createdAt": "2022-01-28T23:13:47Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -578,19 +579,13 @@ internal static string GetRuntimeVersion(string path)\n #endif\n                 do\n                 {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n+                    runtimeVersion = new char[bufferLength];",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should I use stackalloc here?",
              "createdAt": "2022-01-28T04:21:35Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,28 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n+            int pathLength = 0;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n             for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n             {\n-                buffer.EnsureCapacity(bufferSize);\n-\n-                var handleRef = new System.Runtime.InteropServices.HandleRef(buffer, handle);\n-                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, buffer.Capacity);\n+                buffer = System.Buffers.ArrayPool<char>.Shared.Rent(bufferSize);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "GetModuleFileName can have a max buffer size of 260. So I think using `ArrayPool` is probably appropriate.",
              "createdAt": "2022-01-28T04:42:15Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,28 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n+            int pathLength = 0;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n             for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n             {\n-                buffer.EnsureCapacity(bufferSize);\n-\n-                var handleRef = new System.Runtime.InteropServices.HandleRef(buffer, handle);\n-                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, buffer.Capacity);\n+                buffer = System.Buffers.ArrayPool<char>.Shared.Rent(bufferSize);",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I couldn't find a function replacement that returns the size of the the buffer. So this is the most efficient way to do it for now. ",
              "createdAt": "2022-01-29T00:14:00Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,32 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n+            string output = string.Empty;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n             for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Please check the `hresult` here. If it's not `ERROR_INSUFFICIENT_BUFFER` `dwLength` may be bogus/undefined and we should not continue.",
              "createdAt": "2022-01-31T10:00:47Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -567,30 +567,20 @@ internal static string GetRuntimeVersion(string path)\n #if FEATURE_MSCOREE\n             if (NativeMethodsShared.IsWindows)\n             {\n-                StringBuilder runtimeVersion;\n-                uint hresult;\n-#if DEBUG\n-                // Just to make sure and exercise the code that doubles the size\n-                // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.\n-                int bufferLength = 1;\n-#else\n-                int bufferLength = 11; // 11 is the length of a runtime version and null terminator v2.0.50727/0\n-#endif\n-                do\n-                {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n-                    bufferLength *= 2;\n-                } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n-\n-                if (hresult == NativeMethodsShared.S_OK)\n+                unsafe\n                 {\n-                    return runtimeVersion.ToString();\n-                }\n-                else\n-                {\n-                    return String.Empty;\n-                }\n+                    // Run the first GetFileVersion to get the required buffer size.\n+                    int bufferLength = 1;\n+                    uint hresult = NativeMethods.GetFileVersion(path, null, bufferLength, out int dwLength);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This means that previously it usually took only one P/Invoke to get the version. The new code always calls twice. I think it should be reasonable to make the first call with the estimate of 11 and only if it fails make another allocation based on the returned length.",
              "createdAt": "2022-01-31T10:05:45Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -567,30 +567,20 @@ internal static string GetRuntimeVersion(string path)\n #if FEATURE_MSCOREE\n             if (NativeMethodsShared.IsWindows)\n             {\n-                StringBuilder runtimeVersion;\n-                uint hresult;\n-#if DEBUG\n-                // Just to make sure and exercise the code that doubles the size\n-                // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.\n-                int bufferLength = 1;\n-#else\n-                int bufferLength = 11; // 11 is the length of a runtime version and null terminator v2.0.50727/0",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I would zero-init the array for the peace of mind. `stackalloc` seems to be finnicky:\r\nhttps://stackoverflow.com/questions/8679052/initialization-of-memory-allocated-with-stackalloc\r\n\r\nThis is used on error paths so perf is not a huge concern.",
              "createdAt": "2022-01-31T10:17:20Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Reading the second answer makes me think we don't need to:\r\nhttps://stackoverflow.com/a/53173980/908889\r\n\r\nThis is because we are using the P/Invoke directly in a method which has lots of local variables. Meaning the buffer will be zero initialized.\r\n\r\nBeing explicit is probably for the best though.",
              "createdAt": "2022-01-31T23:11:59Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "We don't need to _currently_, but if it's officially undefined, that could change without warning. Relying on it means that, in the (admittedly somewhat unlikely) event it changes, we'd suddenly have broken code and no idea why.",
              "createdAt": "2022-01-31T23:14:40Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@stephentoub do we expect more formal definition of expectations here? It seems a little odd to not define whether we zero or not -- might as well not zero at all if we can't 100% rely on it. I could imagine zeroing iff SkipLocalsInit is applied, for example,",
              "createdAt": "2022-01-31T23:41:24Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "[SkipLocalsInit] was added in large part because it would have been a massive breaking change for the C# compiler to stop outputting initlocals in places it already was.  There are one or two corner cases today where the C# compiler doesn't output initlocals, and those are essentially bugs in the compiler, whether or not there's any plan or intention to fix them.  We can rely on initlocals being in place tomorrow everywhere it's in place today.",
              "createdAt": "2022-02-01T01:23:34Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "stephentoub"
              }
            },
            {
              "body": "Thank you @stephentoub! What is the easiest way to check is `[SkipLocalsInit]` is applied?\r\n\r\n",
              "createdAt": "2022-02-01T02:04:12Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "> What is the easiest way to check is [SkipLocalsInit] is applied?\r\n\r\nConsidering a search https://github.com/dotnet/msbuild/search?q=SkipLocalsInit through the whole repo yields 0 hits, it's almost certainly not.  You'd see it applied to something, like the particular method in question, or the type containing it, or the whole module, e.g. `[module: SkipLocalsInit]` in some file.",
              "createdAt": "2022-02-01T02:27:52Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "stephentoub"
              }
            },
            {
              "body": "Thank you. \r\n\r\n@ladipro / @Forgind are you both happy for me to remove the zero initializing code for the buffer since `SkipLocalsInit` isn't used within MSBuild?",
              "createdAt": "2022-02-01T02:41:56Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "@elachlan my question was whether we could rely on zeroing being taken care of if SkipLocalsInit was NOT applied (if it WAS applied, I would certainly expect zeroing to be skipped). It's apparently not being applied. So the question remains do you need to do zeroing.\n\n> We can rely on initlocals being in place tomorrow everywhere it's in place today.\n\nI'm still unclear (sorry) whether this means that in the absence of SkipLocalsEmit the stackalloc buffer will be dependably zeroed. @jaredpar what can we assume about this?",
              "createdAt": "2022-02-01T03:26:59Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "> So the question remains do you need to do zeroing.\r\n\r\nI don't see why zero'ing would be needed here.  This is an out parameter, so the Win32 function being called doesn't care about the contents, and this buffer is ignored by the rest of the method.",
              "createdAt": "2022-02-01T03:30:00Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "stephentoub"
              }
            },
            {
              "body": "@stephentoub I think the answer for `RmStartSession` in particular is documented here:\r\nhttps://devblogs.microsoft.com/oldnewthing/20120217-00/?p=8283\r\n\r\n> The Rm\u00ad\u00adStartSession function doesn\u2019t properly null-terminate the session key, even though the function is documented as returning a null-terminated string. To work around this bug, we pre-fill the buffer with null characters so that whatever ends gets written will have a null terminator (namely, one of the null characters we placed ahead of time).",
              "createdAt": "2022-02-01T03:51:24Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "But `key` is unused after the call on L221 (unless I'm missing where it's used?).  It doesn't matter what data is in it if the code never reads anything from it.  Am I missing something?",
              "createdAt": "2022-02-01T03:53:58Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "stephentoub"
              }
            },
            {
              "body": "You are correct. I think in this particular case it isn't needed. The documentation on the function says \r\n\r\n> A secondary installer can join an existing Restart Manager session by calling the RmJoinSession function with the session handle and **session key** returned from the RmStartSession function call of the primary installer.\r\nhttps://docs.microsoft.com/en-au/windows/win32/api/restartmanager/nf-restartmanager-rmstartsession\r\n\r\nSince we don't use that, we won't need the key as far as I can tell.\r\n",
              "createdAt": "2022-02-01T04:04:52Z",
              "path": "src/Tasks/LockCheck.cs",
              "diffHunk": "@@ -209,11 +211,16 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]\n             }\n \n             const int maxRetries = 6;\n+            uint handle;\n+            int res;\n \n-            // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n-            var key = new StringBuilder(new string('\\0', CCH_RM_SESSION_KEY + 1));\n+            unsafe\n+            {\n+                // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.\n+                char* key = stackalloc char[CCH_RM_SESSION_KEY + 1];",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is potentially dangerous.  If memory serves, length could be up to ~32,000 characters here, so this could end up requesting 32K of stack space.  Depending on what else is going on in the call stack and what OS you're on (some OSes have much smaller stacks by default), this could potentially lead to a stack overflow.  We typically try to keep stackalloc maximums closer to around 256 bytes and generally not more than 1K... I think the max we have somewhere in dotnet/runtime is around 2K.  Typical pattern is something like this:\r\n```C#\r\nSpan<char> fullPathBuffer = length <= 256 ? stackalloc char[length] : new char[length];\r\n```\r\nor if you're in a context that has [SkipLocalsInit], it's generally better to use a const with the stackalloc, e.g.\r\n```C#\r\nSpan<char> fullPathBuffer = length <= 256 ? stackalloc char[256] : new char[length];\r\n```\r\nIf you want a pointer, you can then use `fixed` with the span.",
              "createdAt": "2022-02-01T01:32:38Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -984,25 +986,28 @@ internal static string GetLongFilePath(string path)\n \n         if (path != null)\n         {\n-            int length = GetLongPathName(path, null, 0);\n-            int errorCode = Marshal.GetLastWin32Error();\n-\n-            if (length > 0)\n+            unsafe\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n-                length = GetLongPathName(path, fullPathBuffer, length);\n-                errorCode = Marshal.GetLastWin32Error();\n+                int length = GetLongPathName(path, null, 0);\n+                int errorCode = Marshal.GetLastWin32Error();\n \n                 if (length > 0)\n                 {\n-                    string fullPath = fullPathBuffer.ToString();\n-                    path = fullPath;\n+                    char* fullPathBuffer = stackalloc char[length];",
              "author": {
                "login": "stephentoub"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "MSBuildTaskHost targets NET35. Which means we can't use `Span<char>` or `System.Buffers.ArrayPool<char>`.\r\n\r\nThis means `GetShortFilePath` and `GetLongFilePath` needs to use `Char[]` to avoid the possible stack overflow.",
              "createdAt": "2022-02-01T23:51:08Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -950,13 +949,13 @@ internal static string GetShortFilePath(string path)\n \n             if (length > 0)\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n+                char[] fullPathBuffer = new char[length];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "@ladipro Is there a special reason for NET35 here?",
              "createdAt": "2022-02-02T21:49:22Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -950,13 +949,13 @@ internal static string GetShortFilePath(string path)\n \n             if (length > 0)\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n+                char[] fullPathBuffer = new char[length];",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "`MSBuildTaskHost.exe` exists to support running tasks in a .NET 3.5 process. That's required to support some legacy project types (mostly it's useful for serializing resources for applications targeting 3.5).",
              "createdAt": "2022-02-02T21:56:32Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -950,13 +949,13 @@ internal static string GetShortFilePath(string path)\n \n             if (length > 0)\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n+                char[] fullPathBuffer = new char[length];",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Thank you Rainer. That makes a lot more sense.",
              "createdAt": "2022-02-02T22:46:02Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -950,13 +949,13 @@ internal static string GetShortFilePath(string path)\n \n             if (length > 0)\n             {\n-                StringBuilder fullPathBuffer = new StringBuilder(length);\n+                char[] fullPathBuffer = new char[length];",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: This could be identical to the `return` two lines below if a local was pointing to the right buffer regardless of whether the second call was made or not.\r\n\r\n```C#\r\nchar *runtimeVersion = stackalloc char[bufferLength];\r\nif (...)\r\n{\r\n    // ...\r\n    char *runtimeVersion2 = stackalloc char[dwLength];\r\n    runtimeVersion = runtimeVersion2;\r\n    // ...\r\n}\r\n// ...\r\nreturn hresult == NativeMethodsShared.S_OK ? new string(runtimeVersion, 0, dwLength - 1) : string.Empty;\r\n```",
              "createdAt": "2022-02-02T12:54:25Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -569,30 +569,36 @@ internal static string GetRuntimeVersion(string path)\n #if FEATURE_MSCOREE\n             if (NativeMethodsShared.IsWindows)\n             {\n-                StringBuilder runtimeVersion;\n-                uint hresult;\n #if DEBUG\n-                // Just to make sure and exercise the code that doubles the size\n-                // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.\n+                // Just to make sure and exercise the code that uses dwLength to allocate the buffer\n+                // when GetRequestedRuntimeInfo fails due to insufficient buffer size.\n                 int bufferLength = 1;\n #else\n                 int bufferLength = 11; // 11 is the length of a runtime version and null terminator v2.0.50727/0\n #endif\n-                do\n-                {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n-                    bufferLength *= 2;\n-                } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n \n-                if (hresult == NativeMethodsShared.S_OK)\n-                {\n-                    return runtimeVersion.ToString();\n-                }\n-                else\n+                unsafe\n                 {\n-                    return String.Empty;\n-                }\n+                    // Allocate an initial buffer \n+                    char* runtimeVersionInitial = stackalloc char[bufferLength];\n+\n+                    // Run GetFileVersion, this should succeed using the initial buffer.\n+                    // It also returns the dwLength which is used if there is insufficient buffer.\n+                    uint hresult = NativeMethods.GetFileVersion(path, runtimeVersionInitial, bufferLength, out int dwLength);\n+\n+                    if (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER)\n+                    {\n+                        // Allocate new buffer based on the returned length.\n+                        char* runtimeVersion = stackalloc char[dwLength];\n+\n+                        // Get the RuntimeVersion in this second call.\n+                        bufferLength = dwLength;\n+                        hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out dwLength);\n+                        return hresult == NativeMethodsShared.S_OK ? new string(runtimeVersion, 0, dwLength - 1) : string.Empty;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Unintentional indentation change?",
              "createdAt": "2022-02-02T13:04:28Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -601,14 +607,14 @@ internal static string GetRuntimeVersion(string path)\n #else\n                 return ManagedRuntimeVersionReader.GetRuntimeVersion(path);\n #endif\n-        }\n+                }\n \n \n-        /// <summary>\n-        /// Import assembly dependencies.\n-        /// </summary>\n-        /// <returns>The array of assembly dependencies.</returns>\n-        private AssemblyNameExtension[] ImportAssemblyDependencies()\n+                /// <summary>\n+                /// Import assembly dependencies.\n+                /// </summary>\n+                /// <returns>The array of assembly dependencies.</returns>\n+                private AssemblyNameExtension[] ImportAssemblyDependencies()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit:\r\n\r\n```suggestion\r\n                        return new string(buffer, 0, pathLength);\r\n```\r\n\r\nand `return string.Empty;` at the end of the method.",
              "createdAt": "2022-02-02T13:06:50Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,32 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n+            string output = string.Empty;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n             for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n             {\n-                buffer.EnsureCapacity(bufferSize);\n-\n-                var handleRef = new System.Runtime.InteropServices.HandleRef(buffer, handle);\n-                int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, buffer.Capacity);\n+                buffer = System.Buffers.ArrayPool<char>.Shared.Rent(bufferSize);\n+                try\n+                {\n+                    var handleRef = new System.Runtime.InteropServices.HandleRef(buffer, handle);\n+                    int pathLength = NativeMethodsShared.GetModuleFileName(handleRef, buffer, bufferSize);\n \n-                bool isBufferTooSmall = ((uint)Marshal.GetLastWin32Error() == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n-                success = pathLength != 0 && !isBufferTooSmall;\n+                    bool isBufferTooSmall = (uint)Marshal.GetLastWin32Error() == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER;\n+                    success = pathLength != 0 && !isBufferTooSmall;\n+                    if (success)\n+                    {\n+                        output = new string(buffer, 0, pathLength);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: The `success` local is not needed anymore.",
              "createdAt": "2022-02-04T09:13:54Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,31 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2022-02-04T09:29:04Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -407,21 +407,31 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n         private static string GetModuleFileName(IntPtr handle)\n         {\n             bool success = false;",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there an unstackalloc? And maybe check what dwLength is?\r\n\r\nIf dwLength is big, it would be good not to overrun the stack. I imagine we'd have a little more space if we can un-allocate the first stack before allocating the second.",
              "createdAt": "2022-02-04T16:11:09Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -569,30 +569,36 @@ internal static string GetRuntimeVersion(string path)\n #if FEATURE_MSCOREE\n             if (NativeMethodsShared.IsWindows)\n             {\n-                StringBuilder runtimeVersion;\n-                uint hresult;\n #if DEBUG\n-                // Just to make sure and exercise the code that doubles the size\n-                // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.\n+                // Just to make sure and exercise the code that uses dwLength to allocate the buffer\n+                // when GetRequestedRuntimeInfo fails due to insufficient buffer size.\n                 int bufferLength = 1;\n #else\n                 int bufferLength = 11; // 11 is the length of a runtime version and null terminator v2.0.50727/0\n #endif\n-                do\n-                {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n-                    bufferLength *= 2;\n-                } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n \n-                if (hresult == NativeMethodsShared.S_OK)\n+                unsafe\n                 {\n-                    return runtimeVersion.ToString();\n-                }\n-                else\n-                {\n-                    return String.Empty;\n-                }\n+                    // Allocate an initial buffer \n+                    char* runtimeVersion = stackalloc char[bufferLength];\n+\n+                    // Run GetFileVersion, this should succeed using the initial buffer.\n+                    // It also returns the dwLength which is used if there is insufficient buffer.\n+                    uint hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out int dwLength);\n+\n+                    if (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER)\n+                    {\n+                        // Allocate new buffer based on the returned length.\n+                        char* runtimeVersion2 = stackalloc char[dwLength];",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No Its scoped the the current method.\n\n>  stack allocated memory block created during the method execution is automatically discarded when that method returns. You cannot explicitly free the memory allocated with stackalloc. \n\nhttps://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc",
              "createdAt": "2022-02-04T22:21:31Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -569,30 +569,36 @@ internal static string GetRuntimeVersion(string path)\n #if FEATURE_MSCOREE\n             if (NativeMethodsShared.IsWindows)\n             {\n-                StringBuilder runtimeVersion;\n-                uint hresult;\n #if DEBUG\n-                // Just to make sure and exercise the code that doubles the size\n-                // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.\n+                // Just to make sure and exercise the code that uses dwLength to allocate the buffer\n+                // when GetRequestedRuntimeInfo fails due to insufficient buffer size.\n                 int bufferLength = 1;\n #else\n                 int bufferLength = 11; // 11 is the length of a runtime version and null terminator v2.0.50727/0\n #endif\n-                do\n-                {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);\n-                    bufferLength *= 2;\n-                } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);\n \n-                if (hresult == NativeMethodsShared.S_OK)\n+                unsafe\n                 {\n-                    return runtimeVersion.ToString();\n-                }\n-                else\n-                {\n-                    return String.Empty;\n-                }\n+                    // Allocate an initial buffer \n+                    char* runtimeVersion = stackalloc char[bufferLength];\n+\n+                    // Run GetFileVersion, this should succeed using the initial buffer.\n+                    // It also returns the dwLength which is used if there is insufficient buffer.\n+                    uint hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out int dwLength);\n+\n+                    if (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER)\n+                    {\n+                        // Allocate new buffer based on the returned length.\n+                        char* runtimeVersion2 = stackalloc char[dwLength];",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "That said, I'm not a fan of this code, so I'm glad it's gone \ud83d\ude01",
              "createdAt": "2022-02-04T16:12:05Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -569,30 +569,36 @@ internal static string GetRuntimeVersion(string path)\n #if FEATURE_MSCOREE\n             if (NativeMethodsShared.IsWindows)\n             {\n-                StringBuilder runtimeVersion;\n-                uint hresult;\n #if DEBUG\n-                // Just to make sure and exercise the code that doubles the size\n-                // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.\n+                // Just to make sure and exercise the code that uses dwLength to allocate the buffer\n+                // when GetRequestedRuntimeInfo fails due to insufficient buffer size.\n                 int bufferLength = 1;\n #else\n                 int bufferLength = 11; // 11 is the length of a runtime version and null terminator v2.0.50727/0\n #endif\n-                do\n-                {\n-                    runtimeVersion = new StringBuilder(bufferLength);\n-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it worth making this lazy vs. just leaving it as a static call? It looks like it's only used once per ResolveComReference call, which seems like not very much to me.",
              "createdAt": "2022-02-04T16:17:12Z",
              "path": "src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs",
              "diffHunk": "@@ -31,6 +31,16 @@ internal static class GlobalAssemblyCache\n         /// </summary>\n         internal static readonly GetGacEnumerator gacEnumerator = GetGacNativeEnumerator;\n \n+        /// <summary>\n+        /// Lazy loaded cached root path of the GAC.\n+        /// </summary>\n+        private static readonly Lazy<string> _gacPath = new(() => GetGacPath());",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "My thought process was to hold a cached static value for it so we only have to call once per global run. I am unsure if that is how it works in practice.",
              "createdAt": "2022-02-04T22:23:40Z",
              "path": "src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs",
              "diffHunk": "@@ -31,6 +31,16 @@ internal static class GlobalAssemblyCache\n         /// </summary>\n         internal static readonly GetGacEnumerator gacEnumerator = GetGacNativeEnumerator;\n \n+        /// <summary>\n+        /// Lazy loaded cached root path of the GAC.\n+        /// </summary>\n+        private static readonly Lazy<string> _gacPath = new(() => GetGacPath());",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think it's relevant for this PR, but MaxPath can be as large as int.MaxValue; since that isn't exactly a power of 2, doesn't that mean it could theoretically (if we keep getting ERROR_INSUFFICIENT_BUFFER or pathLength is 0) reach the top, overflow, and throw an exception?",
              "createdAt": "2022-02-04T17:29:30Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -406,22 +406,30 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n \n         private static string GetModuleFileName(IntPtr handle)\n         {\n-            bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n-            for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n+            for (int bufferSize = NativeMethodsShared.MAX_PATH; bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "There are 23 doublings going from MAX_PATH (260) to int.MaxValue. So its not a trivial risk for long path enabled windows. Interestingly NTFS has a 65,535 character limit and The Windows API has many functions that also have Unicode versions to permit an extended-length path for a maximum total path length of 32,767 characters.\r\n\r\nSo I think we would run into file system/WinAPI limitations before hitting overflows.\r\n\r\nI think this would work. \r\n`for (int bufferSize = NativeMethodsShared.MAX_PATH; bufferSize <= NativeMethodsShared.MaxPath && bufferSize <= int.MaxValue/2; bufferSize *= 2)`",
              "createdAt": "2022-02-04T23:01:22Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -406,22 +406,30 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n \n         private static string GetModuleFileName(IntPtr handle)\n         {\n-            bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n-            for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n+            for (int bufferSize = NativeMethodsShared.MAX_PATH; bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "@Forgind let me know if you think the additional check is helpful or not.",
              "createdAt": "2022-02-07T22:26:15Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -406,22 +406,30 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n \n         private static string GetModuleFileName(IntPtr handle)\n         {\n-            bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n-            for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n+            for (int bufferSize = NativeMethodsShared.MAX_PATH; bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "I think that would work. I'd be mildly in favor of adding it, but I don't care too much. It hasn't been an important case up to this point, so I doubt it'll be an important case in the future.\r\n\r\nIt isn't really the point of this PR, but a VerifyThrow at the end of the loop might be a nicer solution? It's almost certainly a bug if we get close to int.MaxValue, and it would be good to make the bug as visible as possible.",
              "createdAt": "2022-02-07T23:15:11Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -406,22 +406,30 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n \n         private static string GetModuleFileName(IntPtr handle)\n         {\n-            bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n-            for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n+            for (int bufferSize = NativeMethodsShared.MAX_PATH; bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Added it.",
              "createdAt": "2022-02-08T21:55:50Z",
              "path": "src/Tasks/ComReference.cs",
              "diffHunk": "@@ -406,22 +406,30 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists\n \n         private static string GetModuleFileName(IntPtr handle)\n         {\n-            bool success = false;\n-            var buffer = new StringBuilder();\n+            char[] buffer = null;\n \n             // Try increased buffer sizes if on longpath-enabled Windows\n-            for (int bufferSize = NativeMethodsShared.MAX_PATH; !success && bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)\n+            for (int bufferSize = NativeMethodsShared.MAX_PATH; bufferSize <= NativeMethodsShared.MaxPath; bufferSize *= 2)",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      }
    ]
  }
}