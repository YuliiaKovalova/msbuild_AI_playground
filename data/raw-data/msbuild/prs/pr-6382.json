{
  "number": 6382,
  "title": "Snapshot Items of TaskParameters from another AppDomain",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/6379\r\n\r\nWe have a situation where we are in a worker node and a task runs in a separate AppDomain and logs a TaskParameterEventArgs. Since logging is asynchronous there's a risk that by the time the node packet translator accesses the TaskParameterEventArgs.Items the AppDomain is already unloaded and we crash when trying to enumerate item metadata.\r\n\r\nDetect that we're in another AppDomain and eagerly take a snapshot of task items with all metadata.\r\n\r\nI wasn't able to reproduce the issue, but I will ask the customer to validate with the bootstrap MSBuild I built from this PR and see if it goes away.",
  "state": "MERGED",
  "createdAt": "2021-04-28T22:50:13Z",
  "updatedAt": "2021-04-30T22:06:30Z",
  "closedAt": "2021-04-30T21:57:44Z",
  "mergedAt": "2021-04-30T21:57:44Z",
  "additions": 190,
  "deletions": 8,
  "changedFiles": 5,
  "headRefName": "dev/kirillo/6379",
  "isDraft": false,
  "author": {
    "login": "KirillOsenkov"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "b67e3d9139c45748fa5d6b75a64f90026a01d8b5",
          "message": "Snapshot Items of TaskParameters from another AppDomain\n\nFixes https://github.com/dotnet/msbuild/issues/6379\n\nWe have a situation where we are in a worker node and a task runs in a separate AppDomain and logs a TaskParameterEventArgs. Since logging is asynchronous there's a risk that by the time the node packet translator accesses the TaskParameterEventArgs.Items the AppDomain is already unloaded and we crash when trying to enumerate item metadata.\n\nDetect that we're in another AppDomain and eagerly take a snapshot of task items with all metadata.",
          "committedDate": "2021-04-28T22:49:20Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "db022c0736a218f98f5ba24599d7faf6bd93e4d7",
          "message": "Take Items snapshot if any item is a __TransparentProxy\n\nEven if we are in the default AppDomain it can happen that TaskParameterEventArgs is created in the default AppDomain, but the Items passed to it originate from a different AppDomain.\n\nWe have to detect this case and take the items snapshot immediately otherwise that AppDomain can get unloaded.",
          "committedDate": "2021-04-29T19:36:07Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ac7dd0f37f7c00daf0a4c09a9b0943673c366627",
          "message": "Don't send yield-return iterators across AppDomain boundaries\n\nTo access the metadata of items from another AppDomain we can't use yield return because the generated iterator class is not marked as [Serializable]. Provide eager codepaths for cross-AppDomain scenarios that return simple arrays.\n\nWe can't always return simple arrays because in the general case we want to stream metadata directly to consumers without allocating a collection to store the results.",
          "committedDate": "2021-04-29T19:40:08Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80656660b6eaeb95446fe864da2983685dc549ab",
          "message": "Improve a comment and make the entire method conditional",
          "committedDate": "2021-04-30T18:20:08Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Private build with the fix is available at https://kirillosenkovfiles.blob.core.windows.net/kirillosenkovblob/msbuild-pr6382.zip for the customer to test. I've responded on the devcomm issue with this, waiting for answer.",
        "createdAt": "2021-04-28T23:29:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "OK the bad news is that I've debugged on Manikandan's machine and the issue still reproduces, so this PR doesn't work as is.\r\n\r\nThe good news is that I've learned that the problematic task is ResolveComReference and I've gotten out a good callstack and an exception:\r\n\r\n```\r\nSystem.Runtime.Serialization.SerializationException: 'Type 'Microsoft.Build.Utilities.TaskItem+<Microsoft-Build-Framework-IMetadataContainer-EnumerateMetadata>d__32' in Assembly 'Microsoft.Build.Utilities.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.'\r\n\r\n \tmscorlib.dll!System.Runtime.Serialization.FormatterServices.InternalGetSerializableMembers(System.RuntimeType type)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.FormatterServices.GetSerializableMembers.AnonymousMethod__0(System.Runtime.Serialization.MemberHolder _)\tUnknown\r\n \tmscorlib.dll!System.Collections.Concurrent.ConcurrentDictionary<System.Runtime.Serialization.MemberHolder, System.Reflection.MemberInfo[]>.GetOrAdd(System.Runtime.Serialization.MemberHolder key, System.Func<System.Runtime.Serialization.MemberHolder, System.Reflection.MemberInfo[]> valueFactory)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.FormatterServices.GetSerializableMembers(System.Type type, System.Runtime.Serialization.StreamingContext context)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitMemberInfo()\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(object obj, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.SerializationBinder binder)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.Serialize(object obj, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.SerializationBinder binder)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(object graph, System.Runtime.Remoting.Messaging.Header[] inHeaders, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter serWriter, bool fCheck)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(System.IO.Stream serializationStream, object graph, System.Runtime.Remoting.Messaging.Header[] headers, bool fCheck)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSerializer.SerializeMessageParts(System.Collections.ArrayList argsToSerialize)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage.SmuggledMethodReturnMessage(System.Runtime.Remoting.Messaging.IMethodReturnMessage mrm)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage.SmuggleIfPossible(System.Runtime.Remoting.Messaging.IMessage msg)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.DoDispatch(byte[] reqStmBuff, System.Runtime.Remoting.Messaging.SmuggledMethodCallMessage smuggledMcm, out System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage smuggledMrm)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.DoTransitionDispatchCallback(object[] args)\tUnknown\r\n \tmscorlib.dll!System.Threading.Thread.CompleteCrossContextCallback(System.Threading.InternalCrossContextDelegate ftnToCall, object[] args)\tUnknown\r\n \t[AppDomain (MSBuild.exe, #1) -> AppDomain (taskAppDomain (in-proc), #2)]\t\r\n \tmscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.DoTransitionDispatch(byte[] reqStmBuff, System.Runtime.Remoting.Messaging.SmuggledMethodCallMessage smuggledMcm, out System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage smuggledMrm)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Proxies.RemotingProxy.CallProcessMessage(System.Runtime.Remoting.Messaging.IMessageSink ms, System.Runtime.Remoting.Messaging.IMessage reqMsg, System.Runtime.Remoting.Contexts.ArrayWithSize proxySinks, System.Threading.Thread currentThread, System.Runtime.Remoting.Contexts.Context currentContext, bool bSkippingContextChain)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Proxies.RemotingProxy.InternalInvoke(System.Runtime.Remoting.Messaging.IMethodCallMessage reqMcmMsg, bool useDispatchMessage, int callType)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Proxies.RemotingProxy.Invoke(System.Runtime.Remoting.Messaging.IMessage reqMsg)\tUnknown\r\n \tmscorlib.dll!System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(ref System.Runtime.Remoting.Proxies.MessageData msgData, int type)\tUnknown\r\n>\tMicrosoft.Build.Framework.dll!Microsoft.Build.Framework.ITaskItemExtensions.EnumerateMetadata(Microsoft.Build.Framework.ITaskItem taskItem) Line 25\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BuildEventArgsWriter.Write(Microsoft.Build.Framework.ITaskItem item, bool writeMetadata) Line 894\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BuildEventArgsWriter.WriteTaskItemList(System.Collections.IEnumerable items, bool writeMetadata) Line 767\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BuildEventArgsWriter.Write(Microsoft.Build.Framework.TaskParameterEventArgs e) Line 512\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BuildEventArgsWriter.Write(Microsoft.Build.Framework.BuildMessageEventArgs e) Line 421\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BuildEventArgsWriter.WriteCore(Microsoft.Build.Framework.BuildEventArgs e) Line 183\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BuildEventArgsWriter.Write(Microsoft.Build.Framework.BuildEventArgs e) Line 136\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BinaryLogger.Write(Microsoft.Build.Framework.BuildEventArgs e) Line 243\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Logging.BinaryLogger.EventSource_AnyEventRaised(object sender, Microsoft.Build.Framework.BuildEventArgs e) Line 233\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.AnyEventRaisedHandler(object sender, Microsoft.Build.Framework.BuildEventArgs e) Line 2358\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseAnyEvent(object sender, Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 884\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseMessageEvent(object sender, Microsoft.Build.Framework.BuildMessageEventArgs buildEvent) Line 363\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.Consume(Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 225\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.Consume(Microsoft.Build.Framework.BuildEventArgs buildEvent, int sinkId) Line 211\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventRedirectorToSink.Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 55\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.CentralForwardingLogger.EventSource_AnyEventRaised(object sender, Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 113\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseAnyEvent(object sender, Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 884\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.RaiseMessageEvent(object sender, Microsoft.Build.Framework.BuildMessageEventArgs buildEvent) Line 363\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.EventSourceSink.Consume(Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 225\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.LoggingService.RouteBuildEvent(Microsoft.Build.Framework.BuildEventArgs eventArg) Line 1462\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.LoggingService.RouteBuildEvent(object loggingEvent) Line 1422\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.LoggingService.ProcessLoggingEvent(object buildEvent, bool allowThrottling) Line 1138\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.LoggingService.LogBuildEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 1104\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.Logging.LoggingContext.LogBuildEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) Line 250\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.ItemGroupLoggingHelper.LogTaskParameter(Microsoft.Build.BackEnd.Logging.LoggingContext loggingContext, Microsoft.Build.Framework.TaskParameterMessageKind messageKind, string itemType, System.Collections.IList items, bool logItemMetadata) Line 263\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskExecutionHost.GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, Microsoft.Build.Framework.ITaskItem[] outputs, Microsoft.Build.Construction.ElementLocation parameterLocation, Microsoft.Build.Framework.TaskPropertyInfo parameter) Line 1487\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.GatherTaskOutputs(string parameterName, Microsoft.Build.Construction.ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName) Line 436\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.GatherTaskOutputs(Microsoft.Build.BackEnd.ITaskExecutionHost taskExecutionHost, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask, Microsoft.Build.BackEnd.ItemBucket bucket) Line 1138\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(Microsoft.Build.BackEnd.ITaskExecutionHost taskExecutionHost, Microsoft.Build.BackEnd.Logging.TaskLoggingContext taskLoggingContext, Microsoft.Build.BackEnd.TaskHost taskHost, Microsoft.Build.BackEnd.ItemBucket bucket, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask) Line 962\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.InitializeAndExecuteTask(Microsoft.Build.BackEnd.Logging.TaskLoggingContext taskLoggingContext, Microsoft.Build.BackEnd.ItemBucket bucket, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, Microsoft.Build.BackEnd.TaskHost taskHost, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask) Line 655\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteBucket(Microsoft.Build.BackEnd.TaskHost taskHost, Microsoft.Build.BackEnd.ItemBucket bucket, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask, System.Collections.Generic.Dictionary<string, string> lookupHash) Line 437\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup lookup) Line 325\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.Logging.TargetLoggingContext loggingContext, Microsoft.Build.BackEnd.BuildRequestEntry requestEntry, Microsoft.Build.BackEnd.ITargetBuilderCallback targetBuilderCallback, Microsoft.Build.Execution.ProjectTargetInstanceChild taskInstance, Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup inferLookup, Microsoft.Build.BackEnd.Lookup executeLookup, System.Threading.CancellationToken cancellationToken) Line 179\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TargetEntry.ProcessBucket(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup lookupForInference, Microsoft.Build.BackEnd.Lookup lookupForExecution) Line 816\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TargetEntry.ExecuteTarget(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder, Microsoft.Build.BackEnd.BuildRequestEntry requestEntry, Microsoft.Build.BackEnd.Logging.ProjectLoggingContext projectLoggingContext, System.Threading.CancellationToken cancellationToken) Line 499\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TargetBuilder.ProcessTargetStack(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder) Line 495\tC#\r\n```\r\n\r\nSo basically we need to think about marking all data structures as `[Serializable]` if they go across AppDomains. I've gotten a binlog and some more leads and I will try to reconstruct a repro tomorrow.\r\n\r\nI am continuing to work on this as highest priority and I'm sure we'll get a repro and confirmed fix by EOW.",
        "createdAt": "2021-04-29T06:47:17Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "This is the closure generated by this `yield return`:\r\n`Microsoft.Build.Utilities.TaskItem+<Microsoft-Build-Framework-IMetadataContainer-EnumerateMetadata>d__32`\r\nhttps://github.com/dotnet/msbuild/blob/4f72ae4cfb09d03dccd7fc628d619ef4ab5aa479/src/Build/Instance/ProjectItemInstance.cs#L1085",
        "createdAt": "2021-04-29T06:50:48Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "OK I'm getting somewhere with a local repro:\r\n\r\n```\r\nBuild FAILED.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n```",
        "createdAt": "2021-04-29T06:57:31Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "OK I have a local repro for the single-process case (stack above).",
        "createdAt": "2021-04-29T07:02:39Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I have to confess I expected a lot of things under ITaskItem, but `__TransparentProxy` wasn't one of them:\r\n![image](https://user-images.githubusercontent.com/679326/116513713-d94d4e80-a87e-11eb-9c40-ddf32c9e1a1f.png)\r\n",
        "createdAt": "2021-04-29T07:07:30Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Interesting, so with the main branch of MSBuild I'm able to easily repro the other exception:\r\n\r\n```\r\nException rethrown at [0]:\r\n   at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg)\r\n   at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData& msgData, Int32 type)\r\n   at Microsoft.Build.Framework.IMetadataContainer.EnumerateMetadata()\r\n   at Microsoft.Build.Framework.ITaskItemExtensions.EnumerateMetadata(ITaskItem taskItem) in C:\\msbuild2\\src\\Framework\\ITaskItemExtensions.cs:line 25\r\n   at Microsoft.Build.Logging.BuildEventArgsWriter.Write(ITaskItem item, Boolean writeMetadata) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BuildEventArgsWriter.cs:line 894\r\n   at Microsoft.Build.Logging.BuildEventArgsWriter.WriteTaskItemList(IEnumerable items, Boolean writeMetadata) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BuildEventArgsWriter.cs:line 767\r\n   at Microsoft.Build.Logging.BuildEventArgsWriter.Write(TaskParameterEventArgs e) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BuildEventArgsWriter.cs:line 512\r\n   at Microsoft.Build.Logging.BuildEventArgsWriter.Write(BuildMessageEventArgs e) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BuildEventArgsWriter.cs:line 421\r\n   at Microsoft.Build.Logging.BuildEventArgsWriter.WriteCore(BuildEventArgs e) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BuildEventArgsWriter.cs:line 183\r\n   at Microsoft.Build.Logging.BuildEventArgsWriter.Write(BuildEventArgs e) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BuildEventArgsWriter.cs:line 136\r\n   at Microsoft.Build.Logging.BinaryLogger.Write(BuildEventArgs e) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BinaryLogger.cs:line 243\r\n   at Microsoft.Build.Logging.BinaryLogger.EventSource_AnyEventRaised(Object sender, BuildEventArgs e) in C:\\msbuild2\\src\\Build\\Logging\\BinaryLogger\\BinaryLogger.cs:line 233\r\n   at Microsoft.Build.Evaluation.ProjectCollection.ReusableLogger.AnyEventRaisedHandler(Object sender, BuildEventArgs e) in C:\\msbuild2\\src\\Build\\Definition\\ProjectCollection.cs:line 2358\r\n```\r\n\r\nBut in my PR branch I couldn't repro this.\r\n\r\nThere's still the other problem in the main node, which I'll fix first thing tomorrow.",
        "createdAt": "2021-04-29T07:21:09Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "OK I got a full repro for both the central node and the worker node:\r\n![image](https://user-images.githubusercontent.com/679326/116515825-a6f12080-a881-11eb-8ac1-4a58e64380b3.png)\r\n",
        "createdAt": "2021-04-29T07:27:20Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "And yes, confirmed that this PR does fix the \"worker node\" case :) At least it's not entirely missing the mark.",
        "createdAt": "2021-04-29T07:29:51Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Minimal repro is embarrasingly simple: just have four of these in a solution and build with `/m /bl`:\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFramework>net472</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <COMReference Include=\"Microsoft.Office.Core\">\r\n      <Guid>{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}</Guid>\r\n      <VersionMajor>2</VersionMajor>\r\n      <VersionMinor>5</VersionMinor>\r\n      <Lcid>0</Lcid>\r\n      <WrapperTool>primary</WrapperTool>\r\n      <Isolated>False</Isolated>\r\n      <EmbedInteropTypes>True</EmbedInteropTypes>\r\n    </COMReference>\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```",
        "createdAt": "2021-04-29T07:31:18Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Checklist for after the storm:\r\n\r\n - [ ] add a test that exercises COMReference and AppDomains\r\n - [ ] improve the experience of MSBuild central node crashing with Build FAILED 0 errors 0 warnings (throwing in GatherTaskItemOutputs can repro)\r\n - [ ] worker node crashing is a much better experience, but should probably still add verbiage to open an issue at https://github.com/dotnet/msbuild/issues/new",
        "createdAt": "2021-04-29T07:34:12Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "OK I ran this ten times and both main node and worker node seem to be working fine with this. I'll try and double-check with the customer tonight to see if this fixes it for him.",
        "createdAt": "2021-04-29T19:41:57Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Updated bootstrap MSBuild with the latest fix: https://kirillosenkovfiles.blob.core.windows.net/kirillosenkovblob/msbuild-pr6382-2.zip",
        "createdAt": "2021-04-29T19:53:53Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I ran both nodes under debugger with first-chance exceptions on and didn't see any exceptions.",
        "createdAt": "2021-04-29T20:00:10Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Failing test seems to be Microsoft.Build.UnitTests.BackEnd.BuildManager_Tests.OverlappingBuildsOfTheSameProjectSameTargetsAreAllowed. Probably innocuous.",
        "createdAt": "2021-04-29T21:28:15Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Thanks, I've filed https://github.com/dotnet/msbuild/issues/6390 for the flaky test.",
        "createdAt": "2021-04-29T21:45:04Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Confirmed with the customer that the latest build fixes it for him. I think we\u2019re all good here.",
        "createdAt": "2021-04-30T06:33:10Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Certainly my preference would be to ship this ASAP so that it makes it into the next preview and unbreaks the world, and we could work on adding tests and trying to regain some perf in separate PRs.\r\n\r\nI'm pretty sure adding a test won't be too difficult but I'm nervous if this misses the next preview.",
        "createdAt": "2021-04-30T18:03:00Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Filed an issue to track here:\r\nhttps://github.com/dotnet/msbuild/issues/6394",
        "createdAt": "2021-04-30T18:04:25Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm seeing no discernible perf difference between this PR and main:\r\n\r\nPR 6382 | main | 16.9\r\n-- | -- | --\r\n13.425 | 15.315 | 16.783\r\n13.54 | 13.553 | 16.728\r\n14.266 | 13.698 | 16.997\r\n13.762 | 14.719 | 17.315\r\n13.094 | 12.848 | 16.92\r\n13.706 | 13.473 | 17.851\r\n13.58 | 14.074 | 17.089\r\n13.181 | 13.557 | 18.783\r\n13.111 | 13.565 | 16.651\r\n",
        "createdAt": "2021-04-30T19:24:49Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This only checks that we might be in an app domain rathe than that we necessarily are, right? Is there any way to tell that we are? Also, maybe remove the part of the comment about default app domain? I was confused until I looked at what CreateItemsSnapshot actually does.",
              "createdAt": "2021-04-30T15:05:53Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -271,6 +272,11 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n             bool logItemMetadata,\n             DateTime timestamp)\n         {\n+            // Only run this method if we use AppDomains and not in the default AppDomain\n+#if FEATURE_APPDOMAIN",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good point, I've fixed the comment",
              "createdAt": "2021-04-30T18:21:03Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -271,6 +272,11 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n             bool logItemMetadata,\n             DateTime timestamp)\n         {\n+            // Only run this method if we use AppDomains and not in the default AppDomain\n+#if FEATURE_APPDOMAIN",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need this if not FEATURE_APPDOMAIN?",
              "createdAt": "2021-04-30T15:12:33Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -281,6 +287,60 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n             return args;\n         }\n \n+        private static void CreateItemsSnapshot(ref IList items)\n+        {\n+            if (items == null)\n+            {\n+                return;\n+            }\n+\n+#if FEATURE_APPDOMAIN\n+            // If we're in the default AppDomain, but any of the items come from a different AppDomain\n+            // we need to take a snapshot of the items right now otherwise that AppDomain might get\n+            // unloaded by the time we want to consume the items.\n+            // If we're not in the default AppDomain, always take the items snapshot.\n+            //\n+            // It is unfortunate to need to be doing this check, but ResolveComReference and other tasks\n+            // still use AppDomains and create a TaskParameterEventArgs in the default AppDomain, but\n+            // pass it Items from another AppDomain.\n+            if (AppDomain.CurrentDomain.IsDefaultAppDomain())\n+            {\n+                bool needsSnapshot = false;\n+                foreach (var item in items)\n+                {\n+                    if (RemotingServices.IsTransparentProxy(item))\n+                    {\n+                        needsSnapshot = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!needsSnapshot)\n+                {\n+                    return;\n+                }\n+            }\n+#endif\n+\n+            int count = items.Count;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If APPDOMAIN is not defined, we won't be in this method anyway since the callsite is also conditional.",
              "createdAt": "2021-04-30T18:16:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -281,6 +287,60 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n             return args;\n         }\n \n+        private static void CreateItemsSnapshot(ref IList items)\n+        {\n+            if (items == null)\n+            {\n+                return;\n+            }\n+\n+#if FEATURE_APPDOMAIN\n+            // If we're in the default AppDomain, but any of the items come from a different AppDomain\n+            // we need to take a snapshot of the items right now otherwise that AppDomain might get\n+            // unloaded by the time we want to consume the items.\n+            // If we're not in the default AppDomain, always take the items snapshot.\n+            //\n+            // It is unfortunate to need to be doing this check, but ResolveComReference and other tasks\n+            // still use AppDomains and create a TaskParameterEventArgs in the default AppDomain, but\n+            // pass it Items from another AppDomain.\n+            if (AppDomain.CurrentDomain.IsDefaultAppDomain())\n+            {\n+                bool needsSnapshot = false;\n+                foreach (var item in items)\n+                {\n+                    if (RemotingServices.IsTransparentProxy(item))\n+                    {\n+                        needsSnapshot = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!needsSnapshot)\n+                {\n+                    return;\n+                }\n+            }\n+#endif\n+\n+            int count = items.Count;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "That additional #if is just to make the compiler happy. Technically we could make the entire method conditional.",
              "createdAt": "2021-04-30T18:17:16Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -281,6 +287,60 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n             return args;\n         }\n \n+        private static void CreateItemsSnapshot(ref IList items)\n+        {\n+            if (items == null)\n+            {\n+                return;\n+            }\n+\n+#if FEATURE_APPDOMAIN\n+            // If we're in the default AppDomain, but any of the items come from a different AppDomain\n+            // we need to take a snapshot of the items right now otherwise that AppDomain might get\n+            // unloaded by the time we want to consume the items.\n+            // If we're not in the default AppDomain, always take the items snapshot.\n+            //\n+            // It is unfortunate to need to be doing this check, but ResolveComReference and other tasks\n+            // still use AppDomains and create a TaskParameterEventArgs in the default AppDomain, but\n+            // pass it Items from another AppDomain.\n+            if (AppDomain.CurrentDomain.IsDefaultAppDomain())\n+            {\n+                bool needsSnapshot = false;\n+                foreach (var item in items)\n+                {\n+                    if (RemotingServices.IsTransparentProxy(item))\n+                    {\n+                        needsSnapshot = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!needsSnapshot)\n+                {\n+                    return;\n+                }\n+            }\n+#endif\n+\n+            int count = items.Count;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In what situations is this null?",
              "createdAt": "2021-04-30T15:20:47Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1076,6 +1086,28 @@ internal int DirectMetadataCount\n                 }\n             }\n \n+            /// <summary>\n+            /// Used to return metadata from another AppDomain. Can't use yield return because the\n+            /// generated state machine is not marked as [Serializable], so we need to allocate.\n+            /// </summary>\n+            /// <param name=\"list\">The source list to return metadata from.</param>\n+            /// <returns>An array of string key-value pairs representing metadata.</returns>\n+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)\n+            {\n+                var result = new List<KeyValuePair<string, string>>(list.Count);\n+\n+                foreach (var projectMetadataInstance in list)\n+                {\n+                    if (projectMetadataInstance != null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't exactly know, if this is never null it could significantly simplify things as then we'd know the Count in advance, but the null check was in the original code and I was extremely careful to preserve the semantics. Certainly not going to risk removing the null check in this release ;) Perhaps in 17.",
              "createdAt": "2021-04-30T17:58:52Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1076,6 +1086,28 @@ internal int DirectMetadataCount\n                 }\n             }\n \n+            /// <summary>\n+            /// Used to return metadata from another AppDomain. Can't use yield return because the\n+            /// generated state machine is not marked as [Serializable], so we need to allocate.\n+            /// </summary>\n+            /// <param name=\"list\">The source list to return metadata from.</param>\n+            /// <returns>An array of string key-value pairs representing metadata.</returns>\n+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)\n+            {\n+                var result = new List<KeyValuePair<string, string>>(list.Count);\n+\n+                foreach (var projectMetadataInstance in list)\n+                {\n+                    if (projectMetadataInstance != null)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Alternative: allocate array of length list.Count then send it.\r\nAdvantage: only one allocation\r\nPossible disadvantage: If there are null instances, there would be some nulls at the end\r\nWorkaround with reduced speed: count nulls before allocating the array and allocate an appropriately-sized array.",
              "createdAt": "2021-04-30T15:22:53Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1076,6 +1086,28 @@ internal int DirectMetadataCount\n                 }\n             }\n \n+            /// <summary>\n+            /// Used to return metadata from another AppDomain. Can't use yield return because the\n+            /// generated state machine is not marked as [Serializable], so we need to allocate.\n+            /// </summary>\n+            /// <param name=\"list\">The source list to return metadata from.</param>\n+            /// <returns>An array of string key-value pairs representing metadata.</returns>\n+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)\n+            {\n+                var result = new List<KeyValuePair<string, string>>(list.Count);\n+\n+                foreach (var projectMetadataInstance in list)\n+                {\n+                    if (projectMetadataInstance != null)\n+                    {\n+                        result.Add(new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue));\n+                    }\n+                }\n+\n+                // Probably better to send the raw array across the wire even if it's another allocation.\n+                return result.ToArray();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, exactly. Those potential null instances break that. In the two other cases I directly allocate the array, but here I have to use a list.\r\n\r\nGood news is that this is only where AppDomains are involved, and we don't really care about perf in these isolated scenarios. The mainline scenarios are not affected.",
              "createdAt": "2021-04-30T18:00:35Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1076,6 +1086,28 @@ internal int DirectMetadataCount\n                 }\n             }\n \n+            /// <summary>\n+            /// Used to return metadata from another AppDomain. Can't use yield return because the\n+            /// generated state machine is not marked as [Serializable], so we need to allocate.\n+            /// </summary>\n+            /// <param name=\"list\">The source list to return metadata from.</param>\n+            /// <returns>An array of string key-value pairs representing metadata.</returns>\n+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)\n+            {\n+                var result = new List<KeyValuePair<string, string>>(list.Count);\n+\n+                foreach (var projectMetadataInstance in list)\n+                {\n+                    if (projectMetadataInstance != null)\n+                    {\n+                        result.Add(new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue));\n+                    }\n+                }\n+\n+                // Probably better to send the raw array across the wire even if it's another allocation.\n+                return result.ToArray();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't there a CopyMetadataTo function? There also seems to be CloneCustomMetadata.",
              "createdAt": "2021-04-30T15:25:15Z",
              "path": "src/Framework/TaskItemData.cs",
              "diffHunk": "@@ -25,6 +25,26 @@ public TaskItemData(string itemSpec, IDictionary<string, string> metadata)\n             Metadata = metadata ?? _emptyMetadata;\n         }\n \n+        /// <summary>\n+        /// Clone the task item and all metadata to create a snapshot\n+        /// </summary>\n+        /// <param name=\"original\">An <see cref=\"ITaskItem\"/> to clone</param>\n+        public TaskItemData(ITaskItem original)\n+        {\n+            ItemSpec = original.ItemSpec;\n+            var metadata = original.EnumerateMetadata();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I wasn't sure if CloneCustomMetadata will work across appdomains so decided not to risk it.",
              "createdAt": "2021-04-30T18:01:42Z",
              "path": "src/Framework/TaskItemData.cs",
              "diffHunk": "@@ -25,6 +25,26 @@ public TaskItemData(string itemSpec, IDictionary<string, string> metadata)\n             Metadata = metadata ?? _emptyMetadata;\n         }\n \n+        /// <summary>\n+        /// Clone the task item and all metadata to create a snapshot\n+        /// </summary>\n+        /// <param name=\"original\">An <see cref=\"ITaskItem\"/> to clone</param>\n+        public TaskItemData(ITaskItem original)\n+        {\n+            ItemSpec = original.ItemSpec;\n+            var metadata = original.EnumerateMetadata();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}