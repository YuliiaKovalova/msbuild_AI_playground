{
  "number": 8506,
  "title": "Document 'Resolve Assembly Reference core scenarios'",
  "body": "Fixes #8441\r\n\r\n### Context\r\n\r\nThis document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects. The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously slow build tasks.\r\n\r\n### Changes Made\r\n\r\nAdded the document ([preview link](https://github.com/ladipro/msbuild/blob/8441-rar-core-design/documentation/design/rar-core-scenarios.md)).",
  "state": "MERGED",
  "createdAt": "2023-02-28T12:09:58Z",
  "updatedAt": "2023-04-04T17:20:17Z",
  "closedAt": "2023-04-04T15:36:39Z",
  "mergedAt": "2023-04-04T15:36:38Z",
  "additions": 200,
  "deletions": 0,
  "changedFiles": 1,
  "headRefName": "8441-rar-core-design",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Documentation",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "8cea19e524fa49c25c888402446f978a804247a7",
          "message": "Document 'Resolve Assembly Reference core scenarios'",
          "committedDate": "2023-02-28T12:08:08Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e5370bacbaca52305557b7d7c14ec1fe6406d35c",
          "message": "Update documentation/design/rar-core-scenarios.md\n\nCo-authored-by: Forgind <12969783+Forgind@users.noreply.github.com>",
          "committedDate": "2023-03-10T14:36:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "02391155043b9055db9238ef158d48f2da321442",
          "message": "PR feedback: Shelve immutable NuGet refs, rework disk cache save",
          "committedDate": "2023-03-10T20:55:28Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f9d6001cafa5e7497ca5d65ead92937b4600fca6",
          "message": "Update documentation/design/rar-core-scenarios.md\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-04-04T11:51:15Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d945667dc4d9e070b397fbc408c34410323a97dd",
          "message": "Update documentation/design/rar-core-scenarios.md\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-04-04T11:51:23Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "\"Modern\" here I think is a bit too strong. We must know transitive dependency closure for any project that targets .NET Framework, which is still a lot of projects we care about.",
              "createdAt": "2023-02-28T17:12:02Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That's true. I have reworded the sentence, thank you!",
              "createdAt": "2023-03-10T21:04:44Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "At least one case where the assumption is invalid: in dotnet/runtime, the \"SDK\"/targeting pack is being built up, but is used in place. https://github.com/dotnet/runtime/issues/61451 is one example where caching that was perfectly valid for end users caused problems in the runtime build.",
              "createdAt": "2023-02-28T17:18:12Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oh, interesting. It looks like this was a bug in the SDK task that @rokonec fixed in https://github.com/dotnet/sdk/pull/26104/commits/200d8251548185c9056692003c2694521c7c3062 and https://github.com/dotnet/sdk/pull/26104/commits/d1b4626c56de6873f7e0afbf3de2a31e9531b58f.",
              "createdAt": "2023-03-02T14:23:02Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This sounds like a good win.",
              "createdAt": "2023-02-28T18:05:58Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this true when targeting .NET Framework? I think that's where we'd see a win there. Though the reference assemblies aren't in the .NET (Core) SDK itself, so maybe we could separately update the netfx reference assembly packages to have a cache (and update RAR to not push it to the projects).",
              "createdAt": "2023-02-28T18:10:35Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.\n+\n+### Don't use the SDK disk pre-cache\n+\n+The idea of pre-generated on-disk cache is sound. For the `ExternallyResolved` SDK assemblies specifically, though, it effectively duplicates the information already\n+present in `FrameworkList.xml`. That is, it maps assembly paths to assembly names. If the need arises we may want to re-design the pre-cache to remove the major\n+drawback that it duplicates itself into all per-project caches. Cold RAR would load both caches and combine their contents (currently it's either or). Until then,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That could work. Or we could enhance `FrameworkList.xml` which, as David Kean has pointed out, ships with netfx ref assemblies already, to also include dependencies. Now it has versions and public key tokens.\r\n\r\nI generally consider projects targeting netfx as lower priority for this work. Not because they are not widely used, but because the number of references is so much lower so the perf is usually not that bad.",
              "createdAt": "2023-03-03T09:41:40Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.\n+\n+### Don't use the SDK disk pre-cache\n+\n+The idea of pre-generated on-disk cache is sound. For the `ExternallyResolved` SDK assemblies specifically, though, it effectively duplicates the information already\n+present in `FrameworkList.xml`. That is, it maps assembly paths to assembly names. If the need arises we may want to re-design the pre-cache to remove the major\n+drawback that it duplicates itself into all per-project caches. Cold RAR would load both caches and combine their contents (currently it's either or). Until then,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This makes me really nervous, even with an opt-out. Do we have any kind of breakdown of time spent checking timestamps for nuget packages vs overall, to get an idea of how much time we could save with this mechanism?",
              "createdAt": "2023-02-28T18:14:05Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I imagine this would be complicated by time spent on I/O vs. time spent on actual computations, right?",
              "createdAt": "2023-03-02T01:52:48Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> This makes me really nervous, even with an opt-out. Do we have any kind of breakdown of time spent checking timestamps for nuget packages vs overall, to get an idea of how much time we could save with this mechanism?\r\n\r\nI am ok with leaving NuGet references as is for now. Agreed that the risk/benefit ratio is too high.\r\n\r\n> I imagine this would be complicated by time spent on I/O vs. time spent on actual computations, right?\r\n\r\nThat's true for all of RAR but in general I/O is far more important to optimize. Unless we have an O(N^3) or worse logic hiding somewhere, the time of a typical RAR execution is likely dominated by I/O.",
              "createdAt": "2023-03-02T14:32:50Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'm not pursuing this anymore. The NuGet proposal has been marked as \"shelved\".",
              "createdAt": "2023-03-10T21:01:34Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This sounds good to me. Have we documented AssemblyVersion and PublicKeyToken metadata? I'm wondering if it's likely that someone specifies this but gets it wrong so starting to trust it would cause problems.",
              "createdAt": "2023-02-28T18:16:12Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The `ResolveAssemblyReference` task docs don't mention these and the `Reference` item type doesn't appear to be documented at all. So it looks ok to start trusting it with the contingency plan of introducing new metadata in the unlikely case that it breaks someone.",
              "createdAt": "2023-03-03T09:13:55Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nlocations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and\r\n```",
              "createdAt": "2023-03-02T01:22:34Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thank you!",
              "createdAt": "2023-03-10T14:36:45Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this also ok if the user replaces files in a coherent way, i.e., overwrites files with equivalent files of (the same) later version? I'm thinking of our Deploy-MSBuild script.",
              "createdAt": "2023-03-02T01:51:29Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If the files are really equivalent in terms of assembly name/version, then I believe it would be ok. In general the mitigation for scenarios like the Deploy-MSBuild script is to kill all relevant processes to get rid of potentially stale caches. Which is something we are already doing on Windows to be able to overwrite MSBuild binaries, so it shouldn't be an extra burden.",
              "createdAt": "2023-03-02T14:04:56Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This would be a regression if we loaded the on-disk cache only when the in-memory cache is empty because a single process may execute RAR on multiple projects at different times, and each project would have its own set of projects that it cares about, right?",
              "createdAt": "2023-03-02T01:55:12Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I would load it if there is an in-memory cache miss, not only if the in-memory is empty. I *think* that it shouldn't regress the cache hit rate.\r\n\r\nRelated to this is the existing problem of the per-project disk cache being non-deterministic. Depending on what the node has built before it may contain more assemblies than actually needed. This would also be nice to address, for example by explicitly marking records used during the execution and saving only those. What do you think?",
              "createdAt": "2023-03-02T14:43:09Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Sorry for being confusing; I agree, but I was wondering if we could optimize that further but think that my proposed optimization would be a regression.\r\n\r\nOnly saving relevant assembly information is interesting. I could see it helping or hurting. Here's what I'm thinking:\r\nGood:\r\nSmaller footprint on disk\r\nIf we decide we need to load the cache (because we saw a cache miss), that load is faster and more targeted\r\nIf we decide we need to serialize to disk, that serialization is faster because there are fewer things in it\r\n\r\nBad:\r\nIf we decide we need to serialize to disk, that serialization is slower because we need to do some processing to figure out what we're actually serializing\r\nIf the node is used for multiple projects again (as is likely), there's a higher chance of a cache miss leading to deserializing another cache. So like if we have projects A and B with disjoint assembly dependencies, and we put one of B's dependencies in A's cache, then when we call RAR on A, we load B's dependency, and when we call RAR on B, we don't have to go back to disk to retrieve that dependency from B's cache. If this is common, it would outweigh the benefit of faster cache deserialization, since computers do well with bulk operations, not sequences of quick disk accesses.\r\nMakes RAR's caches a bit more complicated (minor)\r\n\r\nOverall, I'm not sure how to weigh those against each other. The footprint on disk seems like the biggest win to me, and I _think_ that would outweigh the other factors in my view, but I could easily be wrong.",
              "createdAt": "2023-03-02T22:25:01Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> Overall, I'm not sure how to weigh those against each other. The footprint on disk seems like the biggest win to me, and I think that would outweigh the other factors in my view, but I could easily be wrong.\r\n\r\n+1\r\nAnd the more I think about it, the more weight I put on deterministic behavior.\r\n\r\nThe downside with potentially having to read every project's cache (unless one is a superset of another and happens to be loaded first) only applies to cold builds, too.",
              "createdAt": "2023-03-03T08:53:56Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm a little confused here. If we no longer read the serialized cache at the start of RAR, then how would we know if it's dirty or not? During RAR's execution, we'd add a bunch of things to the \"will be serialized to disk\" cache (because it was initially empty), which means it's always dirty.",
              "createdAt": "2023-03-02T02:00:42Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's a great point. Let me think. These are the possible scenarios:\r\n1. No disk cache exists, memory cache is empty or incomplete.\r\n2. No disk cache exists, memory cache has everything we need.\r\n3. Disk cache exists, memory cache is empty or incomplete.\r\n4. Disk cache exists, memory cache has everything we need.\r\n\r\nFor 1. and 2., we will want to dump the relevant entries from memory to disk when we're done.\r\n\r\nFor 3. as well, because we need something we don't have in memory, so we load the disk cache, mark it dirty, save at the end.\r\n\r\nFor 4., we don't have the need to load the disk cache so we don't know if it's complete. It may be incomplete and saving the state at the end could make it \"better\" but at the expense of reading and diffing, which defeats the optimization. I think it's fine, loading would be lazy, saving would be also lazy.",
              "createdAt": "2023-03-02T14:59:05Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "4 is the only interesting case in my opinion, since we wouldn't be diverging from current behavior on 1-3. I spent some time trying to come up with a \"quick and dirty\" way to figure out if we should still write the cache for 4. As a fairly easy example, we could say that if the cache is present, but it's tiny, and we have quite a lot of information to cache, that must mean it's incomplete, and we should overwrite it. But that raises the question of what that really means, since it's hard to predict exactly how much memory the cache _should_ take up. Not writing anything seems fine to me as a heuristic in general.\r\n\r\nOne other point that I want to bring up (that doesn't defeat the idea in my opinion) is how much saving we get in the \"good\" case versus how much do we lose in the \"bad\" case. I seem to recall serializing the cache takes only like 2% of cacheless RAR's execution time, whereas caches can reduce RAR's execution time by more like 70%. That sounds like we should be pretty confident that we don't need that cache before we omit writing it to disk. On the other hand, every bit counts, and in the scenario you most care about (inner loop), that shouldn't be an issue. In the worst case, we might have to resolve some assemblies once, but then we'd then fall into case 3 and write the full, correct cache to disk, so we wouldn't hit that case again unless the cache is later deleted or corrupted.",
              "createdAt": "2023-03-03T00:39:02Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thank you, these are great points.\r\n\r\nMy hope is that by implementing other optimizations, primarily the better handling of SDK assemblies, the 70% figure will get significantly lower, making disk cache manipulation more interesting to optimize.\r\n\r\nWhat's still troublesome about the lazy cache saving is that it is non-deterministic. Having a cache that's guaranteed to have certain well-defined content after each build is a very good property to have. For instance, in dev box scenarios it would otherwise be hard to reliably \"prime\" a repo enlistment - the system may prime by building the full solution and then the developer uses the box to build a specific project that happens to have an incomplete cache and get sub-optimal first-time build perf.\r\n\r\nOk, I think I'm now leaning towards saving always. What we could do perf-wise is perform the save asynchronously. That could have measurable effect on slower storage systems but it may as well be just an unnecessary overcomplication, introducing other issues (e.g. cache read by a process while still being written by another one).",
              "createdAt": "2023-03-03T08:44:13Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have rewritten the per project disk cache paragraphs. In addition to what's discussed in this comment thread, I've also added a potential optimization to skip saves if we know they won't change the contents of the cache file.",
              "createdAt": "2023-03-10T20:59:14Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.\n+\n+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project\n+references, so optimizing them has the best bang for the buck.\n+\n+### Obtain assembly names from the SDK\n+\n+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its\n+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies\n+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)\n+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense\n+to save it to disk.\n+\n+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,\n+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.\n+\n+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not\n+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only\n+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.\n+\n+### Treat NuGet references as immutable\n+\n+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as\n+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller\n+because the number of NuGet references is typically lower. The proposal is to use the immutability assumption by default, and provide an opt-out mechanism, likely in\n+the form of a new `PackageReference` metadatum for the user to indicate that they plan to update references in the package.\n+\n+### Don't load the per project disk cache when not needed\n+\n+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to\n+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is\n+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.\n+\n+As for saving the per-project cache, the logic would stay the same as it is today. If the in-memory cache is marked _dirty_ because it's not identical to what had\n+been read from the cache, it would be written back to disk. As a special case, the cache would be considered dirty if the file does not exist at all. This is to\n+support scenarios like rebuilding a project by a _hot_ RAR. RAR would be able to satisfy everything from memory, but because rebuild has cleaned the intermediate\n+directory, the state would not otherwise be persisted.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Btw. this is interesting line of thoughts as well. Having a benefit of not knowing the RAR internals and seeing things oversimplified - I'm thinking that if we'd have a long running process (e.g. MSBuild server), we can collect info via FileWatchers, prior the start of the build we'd perform a dummy 'marker' change - so that we can see whether this was received and hence we can trust the state prior the build (otherwise we'd need to fallback to traditional way) and then during the build we'd need to diligently explicitly update the cache (detours tracker might be a strategy here) when changing file system state (e.g. writing build outputs) - so that we can trust the cache state.\r\n\r\nIt surely get's quite complicated, but it then solves the hard choices of honoring/ignoring changes in low-freqency changing locations (sdk ref assemblies, nuget cache). \r\n\r\nBut I agree that this definitely isn't a low hanging fruit and it's definitely worth to explore lower cost improvements first.",
              "createdAt": "2023-03-02T09:56:11Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Thank you, yes, I forgot about the trick with a dummy marker change. If watcher callbacks are guaranteed to be delivered in order, it may be worth experimenting with.\r\n\r\nIn general I believe RAR and MSBuild as a whole is in a state where it gets more value from simplifying the logic, rather than adding more complexity. The caching done as part of RAR alone is currently quite a mess, with caches implemented at several layers of the system, often duplicating data and generally being hard to reason about.",
              "createdAt": "2023-03-03T08:13:48Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That sounds very reasonable.\r\nI'm all for simplifications",
              "createdAt": "2023-03-03T09:19:03Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,193 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation]() and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical modern build, RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\n+\n+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR\n+has to touch the disk.\n+\n+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually\n+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.\n+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the\n+file with a .NET metadata reader.\n+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening\n+the file with a .NET metadata reader.\n+\n+## Optimizations\n+\n+RAR optimizations tend to revolve around caching of information that is expensive to calculate.\n+\n+### Existing caching\n+\n+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.\n+\n+#### **Per invocation in-memory cache**\n+\n+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot\n+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.\n+One issue with this cache is that the key is not normalized so a file specified as `C:\\dir\\file` will use a different cache entry than the same file specified as\n+`C:/dir/file`.\n+\n+#### **Per process in-memory cache**\n+\n+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last\n+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer\n+considered valid.\n+\n+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`\n+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that\n+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is\n+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like\n+`C:\\_nugetpackages\\microsoft.aspnetcore.app.ref\\7.0.2\\ref\\net7.0`, for example.\n+\n+#### **Per project disk cache**\n+\n+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the\n+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified\n+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written\n+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.\n+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.\n+\n+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents\n+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom\n+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.\n+\n+#### **SDK disk pre-cache**\n+\n+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global\n+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the\n+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.\n+\n+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`\n+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.\n+\n+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.\n+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the\n+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also\n+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.\n+\n+## Proposed design\n+\n+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly\n+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional\n+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help\n+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.\n+\n+For regular project references the system works as about as efficient as possible.\n+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.\n+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the\n+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.\n+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.\n+\n+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.\n+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race\n+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.\n+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- For project references (reference given as a path to an assembly file that is not guaranteed to have its dependencies resolved), RAR must be able to look\r\n```",
              "createdAt": "2023-04-03T20:10:44Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,200 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nIn the OrchardCore solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.\r\n```",
              "createdAt": "2023-04-03T20:12:08Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,200 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly\n+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are\n+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is\n+established.\n+\n+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the\n+combined SDK, NuGet, and project references in one input array.\n+\n+## Design\n+\n+To meet the requirements, RAR must internally be able to do the following.\n+\n+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores\n+the reference.\n+\n+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as\n+`C:\\_nugetpackages\\microsoft.netcore.app.ref\\7.0.2\\ref\\net7.0\\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be\n+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees\n+such an AssemblyRef in another assembly.\n+\n+- For project references (reference given as a path to an assembly file that is not guatanteed to have its dependencies resolved), RAR must be able to look\n+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.\n+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,\n+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is\n+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,\n+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.\n+\n+## Scale\n+\n+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything\n+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.\n+In the OrchardCode solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\"file o<ins>n</ins> disk\"",
              "createdAt": "2023-04-04T17:08:25Z",
              "path": "documentation/design/rar-core-scenarios.md",
              "diffHunk": "@@ -0,0 +1,200 @@\n+# Resolve Assembly Reference core scenarios\n+\n+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.\n+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously\n+slow build tasks.\n+\n+## Overview\n+\n+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different\n+locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and\n+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description\n+of its features.\n+\n+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,\n+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of\n+the \"resolvers\", internal classes implementing various resolution strategies, are not used in modern scenarios.\n+\n+## Requirements\n+\n+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the\n+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because\n+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,\n+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.\n+\n+### Inputs\n+\n+In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.\n+\n+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the\n+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are\n+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are\n+guaranteed to be passed in.\n+\n+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,\n+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.\n+\n+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly\n+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            }
          ]
        }
      }
    ]
  }
}