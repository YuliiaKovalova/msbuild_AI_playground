{
  "number": 6035,
  "title": "Optimize Match-on-metadata",
  "body": "Fixes [AB#1261123](https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems/edit/1261123) (feedback ticket)\r\n\r\n### Context\r\nChecking metadata for matches was taking (#fragments in item) * (#fragments in item to remove) * (#metadata). For many users, this was extremely slow.\r\n\r\n### Changes Made\r\nPut fragments into a custom MetadataSet object before checking for a match. This takes it from O(n * r * m) to O(m * (n + r)). Since m is normally small, this is a substantial improvement.\r\n\r\n### Testing\r\nTime on a single operation went from ~180 seconds to ~150 ms for the penultimate version. It also passes @cdmihai's extensive unit tests.*\r\n\r\n### Notes\r\nIs there any reason to keep the error for referencing multiple items? As a user, I would expect not-match-on-metadata to ignore metadata and match-on-metadata to ignore the item.\r\nIs it ok to rely on IEnumerable returning element in a consistent order?\r\nShould we keep returning no-match if all the metadata are empty on both items? It makes more sense to me to have that be a match, and it would simplify the code slightly. If it makes more sense to others, now would be the time to do it, since the code isn't that old.\r\n\r\n\\* Except one on paths. Not sure why that's failing, since it's passing in VS, just not from the command line. Will look into it more.",
  "state": "MERGED",
  "createdAt": "2021-01-14T18:35:10Z",
  "updatedAt": "2021-02-24T07:58:49Z",
  "closedAt": "2021-02-24T07:58:49Z",
  "mergedAt": "2021-02-24T07:58:49Z",
  "additions": 212,
  "deletions": 151,
  "changedFiles": 20,
  "headRefName": "metadata-opt",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "ba4b65371796b78cb62c95a3ff17ee3b574d4073",
          "message": "Cache possible matches",
          "committedDate": "2021-01-11T19:05:14Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a124438b12a3967080672a85d8b27642883daf80",
          "message": "Use custom set and move to RemoveOperation",
          "committedDate": "2021-01-12T15:51:28Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8db0cabbff0769c462e39925c5c0a2ce960d5e90",
          "message": "Account for matchOnMetadataOptions",
          "committedDate": "2021-01-12T16:03:21Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c68b2b2b49b891e328e6e8e8e5d2e5ecc0a53cc",
          "message": "Merge https://github.com/dotnet/msbuild into metadata-opt",
          "committedDate": "2021-01-13T23:56:57Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c8d7089988af029e7c274f5459029eb100f64f8e",
          "message": "Incorporate both ItemGroupIntrinsicTask and RemoveOperation\n\nAlso moves construction to the constructor",
          "committedDate": "2021-01-14T00:07:02Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "17f52251911d7f35351e63629d3679b4100b6ebc",
          "message": "Little cleanup",
          "committedDate": "2021-01-14T01:48:29Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "978bf35c0ee1ee724f2de3207b65ec0b40da67a9",
          "message": "Comments + make iterative",
          "committedDate": "2021-01-14T17:39:17Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ab951b865d40e20728ed56c9818464a391627f18",
          "message": "Fix tests",
          "committedDate": "2021-01-14T18:06:46Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9d335f24ed298e202f08a62263b29000a0916299",
          "message": "Remove unnecessary usings",
          "committedDate": "2021-01-14T18:07:00Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f71a467e248464af7fbf62e704ed88e2b3093a5b",
          "message": "Add error back",
          "committedDate": "2021-01-14T18:31:43Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9263be71fbf865094544e194487ed7f60229979",
          "message": "Remove unnecessary string",
          "committedDate": "2021-01-14T18:34:50Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "08d561bc6a23bf9675cb3123c07daab880c1565d",
          "message": "Comments and permit multiple items/metadata",
          "committedDate": "2021-01-21T01:06:53Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d7ce8b2bdec543c4794c6a97508ed1ccf1f622ac",
          "message": "Comments and correct test",
          "committedDate": "2021-01-21T20:49:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "87361a63641f4730499f55817903e51c495a725c",
          "message": "Add comment and fix path comparer",
          "committedDate": "2021-01-22T20:38:35Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "47492aedf20c7439b31fd2a3523a9ddef4cd0bca",
          "message": "Explicitly name type\n\nBecause mono not up-to-date ;(",
          "committedDate": "2021-01-22T21:16:56Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7fe958742a964a11132b64505edb989a657a2930",
          "message": "Also...",
          "committedDate": "2021-01-22T21:23:41Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "58b8a840f66d0dbf19df4d1d07ad9065db430d44",
          "message": "mono",
          "committedDate": "2021-01-22T23:18:10Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I believe if you do `AB/<feedback ticket number>` then a tool that kevin pilch made will auto-link to the ticket",
        "createdAt": "2021-01-14T23:36:44Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2021-01-21T02:22:38Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2021-01-21T02:22:46Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "You clearly get the advantage (disadvantage? \ud83d\ude0b) of a simpler data structure, but the logic of how to construct the key is more complicated, which partially balances it out. Time to hash a particular string is officially constant but in practice scales according to the length of the string (nlg(n) and assumes the string is short, if I remember correctly), so I don't think the total hashing time would be less. We would win on lookups in the dictionary, but that isn't really relevant. We would also have to factor in time-to-construct the string, which would also always create a new string unless there happens to be exactly one metadatum, and we put in an optimization to not add a character to the end of that. (The argument against an optimization is that we would have to find out that we don't need the extra character, which would either require counting the length of an enumerable (fast, but still theoretically O(n)) or creating something like a StringBuilder, adding it to that StringBuilder, and having a check that the SB has only had one thing added to it before stringifying it. Admittedly, that part should be better with StringTools, so this argument is pretty weak.)\r\n\r\nThe biggest disadvantage in my mind is with reusing strings, since even if we concatenated them all in one step, we'd still make a new string for each item, and if there are several metadata or the metadata are large (noting that these are metadata values, not metadata keys), it could end up consuming a lot of memory. This is a case in which StringTools would struggle because each of the metadata values, once concatenated to others, could be unique, in which case we'd make a large number of unique large strings. Even matching on two metadata, if the values are large, say, \"description\" and \"path\" (with long paths enabled), these could be hundreds or even thousands of characters. With a metadata trie, we don't make any new strings. With a single hash set, we would.",
        "createdAt": "2021-01-29T16:30:28Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Thank you for the detailed analysis!\r\n\r\n> With a metadata trie, we don't make any new strings.\r\n\r\nActually we do if `MatchOnMetadataOptions.PathLike` is used, though I agree that usually the footprint of the Trie would be smaller than that of a flat set. As long as the Trie is not significantly less efficient in the worst case (all values distinct and path-normalized) I think that a slightly more complex datastructure is justified. Thanks again for taking care of this one!",
        "createdAt": "2021-02-01T12:43:45Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd keep this as a separate method to have ExecuteRemove read nicer by only contain top level intent and delegating more nitty gritty implementation details to helper methods. Like the other if branch.",
              "createdAt": "2021-01-15T02:00:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -249,7 +249,18 @@\n             }\n             else\n             {\n-                itemsToRemove = FindItemsUsingMatchOnMetadata(group, child, bucket, matchOnMetadata, matchingOptions);\n+                ImmutableList<string> metadataList = matchOnMetadata.ToImmutableList();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd keep MetadataSet as a hidden implementation detail in ItemSpec. The ItemSpec users do not need to know about it.",
              "createdAt": "2021-01-15T02:02:42Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -55,13 +56,23 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder\n                 var items = ImmutableHashSet.CreateBuilder<I>();\n                 foreach (ItemData item in listBuilder)\n                 {\n-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : _itemSpec.MatchesItemOnMetadata(item.Item, _matchOnMetadata, _matchOnMetadataOptions))\n+                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))\n                         items.Add(item.Item);\n                 }\n \n                 return items.ToImmutableList();\n             }\n \n+            private bool MatchesItemOnMetadata(I item)\n+            {\n+                if (metadataSet == null)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "They don't have to know about it anyway. The methods that call it in ItemGroupIntrinsicTask and LazyItemEvaluator.RemoveOperation are both private. I count that as close enough.",
              "createdAt": "2021-01-16T00:57:43Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -55,13 +56,23 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder\n                 var items = ImmutableHashSet.CreateBuilder<I>();\n                 foreach (ItemData item in listBuilder)\n                 {\n-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : _itemSpec.MatchesItemOnMetadata(item.Item, _matchOnMetadata, _matchOnMetadataOptions))\n+                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))\n                         items.Add(item.Item);\n                 }\n \n                 return items.ToImmutableList();\n             }\n \n+            private bool MatchesItemOnMetadata(I item)\n+            {\n+                if (metadataSet == null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "By users I meant Itemspec API users. When somebody tries to understand the code in ItemGroupIntrinsicTask  or in LazyItemEvaluator.RemoveOperation they'll get hit with two concepts they have to understand: Itemspec and MetadataSet. If you hide MetadataSet inside Itemspec it becomes an implementation detail that people don't have to care about unless they're interested in how Itemspec works. Whatever.",
              "createdAt": "2021-01-21T04:11:36Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -55,13 +56,23 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder\n                 var items = ImmutableHashSet.CreateBuilder<I>();\n                 foreach (ItemData item in listBuilder)\n                 {\n-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : _itemSpec.MatchesItemOnMetadata(item.Item, _matchOnMetadata, _matchOnMetadataOptions))\n+                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))\n                         items.Add(item.Item);\n                 }\n \n                 return items.ToImmutableList();\n             }\n \n+            private bool MatchesItemOnMetadata(I item)\n+            {\n+                if (metadataSet == null)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How does this type check, isn't ItemSpec.Fragments a list of the base class ItemSpecFragment? (`List<ItemSpecFragment>`) ",
              "createdAt": "2021-01-15T02:13:34Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Good question. It might be casting it automatically when it sees that, but I'm not sure. I don't think we should care about other kinds of fragments, since I don't think they can have metadata, so I think this is ok, but that was a lot of \"I think\"s.",
              "createdAt": "2021-01-16T01:12:01Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "As far as whether this is actually a safe, I should have mentioned that the type is checked before the MetadataSet is constructed, so it should always be correct.",
              "createdAt": "2021-01-25T23:27:54Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Naming convention, field name is missing the leading underscore.",
              "createdAt": "2021-01-15T09:17:34Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -14,6 +14,7 @@ class RemoveOperation : LazyItemOperation\n         {\n             readonly ImmutableList<string> _matchOnMetadata;\n             readonly MatchOnMetadataOptions _matchOnMetadataOptions;\n+            private MetadataSet<P, I> metadataSet;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This lazy initialization of `metadataSet` is not thread safe. Is it guaranteed to always run only on one thread?",
              "createdAt": "2021-01-15T09:28:28Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -55,13 +56,23 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder\n                 var items = ImmutableHashSet.CreateBuilder<I>();\n                 foreach (ItemData item in listBuilder)\n                 {\n-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : _itemSpec.MatchesItemOnMetadata(item.Item, _matchOnMetadata, _matchOnMetadataOptions))\n+                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))\n                         items.Add(item.Item);\n                 }\n \n                 return items.ToImmutableList();\n             }\n \n+            private bool MatchesItemOnMetadata(I item)\n+            {\n+                if (metadataSet == null)\n+                {\n+                    metadataSet = new MetadataSet<P, I>(_matchOnMetadataOptions, _matchOnMetadata, _itemSpec);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I can put it in the constructor\u2014shouldn't affect perf, assuming operations are always executed.",
              "createdAt": "2021-01-16T00:40:11Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -55,13 +56,23 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder\n                 var items = ImmutableHashSet.CreateBuilder<I>();\n                 foreach (ItemData item in listBuilder)\n                 {\n-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : _itemSpec.MatchesItemOnMetadata(item.Item, _matchOnMetadata, _matchOnMetadataOptions))\n+                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))\n                         items.Add(item.Item);\n                 }\n \n                 return items.ToImmutableList();\n             }\n \n+            private bool MatchesItemOnMetadata(I item)\n+            {\n+                if (metadataSet == null)\n+                {\n+                    metadataSet = new MetadataSet<P, I>(_matchOnMetadataOptions, _matchOnMetadata, _itemSpec);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: The class can be `sealed`.",
              "createdAt": "2021-01-15T09:29:08Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Names missing leading underscores, both fields can be `readonly`.",
              "createdAt": "2021-01-15T09:30:35Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The question is whether the matching `IEnumerable<>` is passed to the constructor and to `Contains`. It appears to be true although I wonder if there's a way to enforce it in the code.",
              "createdAt": "2021-01-15T09:40:35Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)\n+            {\n+                foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)\n+                {\n+                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);\n+                }\n+            }\n+        }\n+\n+        private MetadataSet(StringComparer comparer)\n+        {\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+        }\n+\n+        // Relies on IEnumerable returning the metadata in a reasonable order. Reasonable?",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Redundant dictionary lookup.\r\n\r\n```suggestion\r\n                if (!current.children.TryGetValue(normalizedString, out MetadataSet<P, I> child))\r\n                {\r\n                    child = new MetadataSet<P, I>(comparer);\r\n                    current.children.Add(normalizedString, child);\r\n                }\r\n                current = child;\r\n```",
              "createdAt": "2021-01-15T09:43:53Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)\n+            {\n+                foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)\n+                {\n+                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);\n+                }\n+            }\n+        }\n+\n+        private MetadataSet(StringComparer comparer)\n+        {\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+        }\n+\n+        // Relies on IEnumerable returning the metadata in a reasonable order. Reasonable?\n+        private void Add(IEnumerable<string> metadata, StringComparer comparer)\n+        {\n+            MetadataSet<P, I> current = this;\n+            foreach (string m in metadata)\n+            {\n+                string normalizedString = normalize(m);\n+                if (current.children.TryGetValue(normalizedString, out MetadataSet<P, I> child))\n+                {\n+                    current = child;\n+                }\n+                else\n+                {\n+                    current.children.Add(normalizedString, new MetadataSet<P, I>(comparer));\n+                    current = current.children[normalizedString];\n+                }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: `current` to match the name used in `Add`?",
              "createdAt": "2021-01-15T09:46:20Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)\n+            {\n+                foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)\n+                {\n+                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);\n+                }\n+            }\n+        }\n+\n+        private MetadataSet(StringComparer comparer)\n+        {\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+        }\n+\n+        // Relies on IEnumerable returning the metadata in a reasonable order. Reasonable?\n+        private void Add(IEnumerable<string> metadata, StringComparer comparer)\n+        {\n+            MetadataSet<P, I> current = this;\n+            foreach (string m in metadata)\n+            {\n+                string normalizedString = normalize(m);\n+                if (current.children.TryGetValue(normalizedString, out MetadataSet<P, I> child))\n+                {\n+                    current = child;\n+                }\n+                else\n+                {\n+                    current.children.Add(normalizedString, new MetadataSet<P, I>(comparer));\n+                    current = current.children[normalizedString];\n+                }\n+            }\n+        }\n+\n+        internal bool Contains(IEnumerable<string> metadata)\n+        {\n+            bool nonEmptyFound = false;\n+            MetadataSet<P, I> curr = this;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why the conversion to `ImmutableList<>`? You should be able to make the `MetadataSet<,>` constructor take `IEnumerable<>`.",
              "createdAt": "2021-01-15T09:56:23Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -249,7 +249,18 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu\n             }\n             else\n             {\n-                itemsToRemove = FindItemsUsingMatchOnMetadata(group, child, bucket, matchOnMetadata, matchingOptions);\n+                ImmutableList<string> metadataList = matchOnMetadata.ToImmutableList();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why isn't this `return false`? The previous code was checking if all metadata is defined *and* their value matches. I suggest adding test coverage for the case where `m` is empty.",
              "createdAt": "2021-01-15T10:32:58Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)\n+            {\n+                foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)\n+                {\n+                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);\n+                }\n+            }\n+        }\n+\n+        private MetadataSet(StringComparer comparer)\n+        {\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+        }\n+\n+        // Relies on IEnumerable returning the metadata in a reasonable order. Reasonable?\n+        private void Add(IEnumerable<string> metadata, StringComparer comparer)\n+        {\n+            MetadataSet<P, I> current = this;\n+            foreach (string m in metadata)\n+            {\n+                string normalizedString = normalize(m);\n+                if (current.children.TryGetValue(normalizedString, out MetadataSet<P, I> child))\n+                {\n+                    current = child;\n+                }\n+                else\n+                {\n+                    current.children.Add(normalizedString, new MetadataSet<P, I>(comparer));\n+                    current = current.children[normalizedString];\n+                }\n+            }\n+        }\n+\n+        internal bool Contains(IEnumerable<string> metadata)\n+        {\n+            bool nonEmptyFound = false;\n+            MetadataSet<P, I> curr = this;\n+            foreach (string m in metadata)\n+            {\n+                if (!String.IsNullOrEmpty(m))\n+                {\n+                    nonEmptyFound = true;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "From https://github.com/dotnet/msbuild/pull/4997:\r\n`if a metadata name doesn't exist in both items, then it's considered a match. Special case: if none of the metadata exist in both items, then it should not match.`\r\n\r\nBut you're right\u2014the code I'm replacing checks for string.Empty and automatically returns false. Given our conversation in the PR review meeting, I'll change to that. Thanks!",
              "createdAt": "2021-01-16T00:47:13Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +459,78 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private Dictionary<string, MetadataSet<P, I>> children;\n+        Func<string, string> normalize;\n+\n+        internal MetadataSet(MatchOnMetadataOptions options, ImmutableList<string> metadata, ItemSpec<P, I> itemSpec)\n+        {\n+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+            normalize = options == MatchOnMetadataOptions.PathLike ? p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory) : p => p;\n+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)\n+            {\n+                foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)\n+                {\n+                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);\n+                }\n+            }\n+        }\n+\n+        private MetadataSet(StringComparer comparer)\n+        {\n+            children = new Dictionary<string, MetadataSet<P, I>>(comparer);\n+        }\n+\n+        // Relies on IEnumerable returning the metadata in a reasonable order. Reasonable?\n+        private void Add(IEnumerable<string> metadata, StringComparer comparer)\n+        {\n+            MetadataSet<P, I> current = this;\n+            foreach (string m in metadata)\n+            {\n+                string normalizedString = normalize(m);\n+                if (current.children.TryGetValue(normalizedString, out MetadataSet<P, I> child))\n+                {\n+                    current = child;\n+                }\n+                else\n+                {\n+                    current.children.Add(normalizedString, new MetadataSet<P, I>(comparer));\n+                    current = current.children[normalizedString];\n+                }\n+            }\n+        }\n+\n+        internal bool Contains(IEnumerable<string> metadata)\n+        {\n+            bool nonEmptyFound = false;\n+            MetadataSet<P, I> curr = this;\n+            foreach (string m in metadata)\n+            {\n+                if (!String.IsNullOrEmpty(m))\n+                {\n+                    nonEmptyFound = true;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Don't delete the tests, instead replace the exception assertion with an assertion on I2's contents",
              "createdAt": "2021-01-21T02:19:03Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -1988,63 +1988,6 @@ public void KeepWithItemReferenceOnNonmatchingMetadata()\n             items.ElementAt(3).GetMetadataValue(\"d\").ShouldBe(\"d\");\n         }\n \n-        [Fact]\n-        public void FailWithMatchingMultipleMetadata()",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "The new test implies you can match with multiple data now though. If we want to keep that, the `FailWithMatchingMultipleMetadata` test is actually invalid.",
              "createdAt": "2021-01-22T00:43:44Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -1988,63 +1988,6 @@ public void KeepWithItemReferenceOnNonmatchingMetadata()\n             items.ElementAt(3).GetMetadataValue(\"d\").ShouldBe(\"d\");\n         }\n \n-        [Fact]\n-        public void FailWithMatchingMultipleMetadata()",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Changed it to \"RemoveWithMatchingMultipleMetdata.\" I did enable matching multiple.",
              "createdAt": "2021-01-22T16:28:57Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -1988,63 +1988,6 @@ public void KeepWithItemReferenceOnNonmatchingMetadata()\n             items.ElementAt(3).GetMetadataValue(\"d\").ShouldBe(\"d\");\n         }\n \n-        [Fact]\n-        public void FailWithMatchingMultipleMetadata()",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For both of the tests, assert that the right items are left in I2.",
              "createdAt": "2021-01-21T02:21:20Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -2418,8 +2418,9 @@ public void FailWithMatchingMultipleMetadata()\n \n                 <I2 Remove='@(I1)' MatchOnMetadata='M1;M2'/>\");\n \n-            Should.Throw<InvalidProjectFileException>(() => ObjectModelHelpers.CreateInMemoryProject(content))\n-                .HelpKeyword.ShouldBe(\"MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem\");\n+            Project project = ObjectModelHelpers.CreateInMemoryProject(content);\n+            IEnumerable<ProjectItem> items = project.ItemsIgnoringCondition.Where(i => i.ItemType.Equals(\"I2\"));\n+            items.Count().ShouldBe(3);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why use this convoluted data structure instead of dumping all metadata values from the Itemspec into a flat set of normalized metadata values?",
              "createdAt": "2021-01-21T04:35:51Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +458,74 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal sealed class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private readonly Dictionary<string, MetadataSet<P, I>> _children;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Still not 100% sure I agree with the data structure, but I want to clarify my understanding from the PR review today.\r\n\r\nA flat set of normalized metadata values would prevent us from being able to determine exactly _which_ metadata values from _which_ items were matched.\r\n\r\nWe'd need to do this to enable the logic in a test like `RemoveWithMultipleItemReferenceOnMatchingMetadata`.\r\n```xml\r\n<I3 Remove='@(I1);@(I2)' MatchOnMetadata='M1' />\r\n```\r\nThis remove attribute effectively translates to:\r\nRemove items in I3 where:\r\n- I1 **OR** I2 match on the following metadata:\r\n   - M1\r\n\r\nI believe this also enables something like:\r\n\r\n```xml\r\n<I3 Remove='@(I1);@(I2)' MatchOnMetadata='M1;M2' />\r\n```\r\nWhere this remove attribute translates to:\r\nRemove items in I3 where:\r\n- I1 **OR** I2 match on the following metadata:\r\n   - M1 **AND** M2\r\n\r\n@Forgind is this understanding correct? If so I think there should be a test for multiple items and multiple metadata.",
              "createdAt": "2021-01-22T18:25:44Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +458,74 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal sealed class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private readonly Dictionary<string, MetadataSet<P, I>> _children;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Wrote detailed comment for MetadataTrie class. Will push soon.",
              "createdAt": "2021-01-22T20:29:48Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +458,74 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    internal sealed class MetadataSet<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable\n+    {\n+        private readonly Dictionary<string, MetadataSet<P, I>> _children;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please don't forget to change the error message to reflect the relaxed validation.",
              "createdAt": "2021-01-21T10:50:00Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -13,13 +13,22 @@ internal partial class LazyItemEvaluator<P, I, M, D>\n         class RemoveOperation : LazyItemOperation\n         {\n             readonly ImmutableList<string> _matchOnMetadata;\n-            readonly MatchOnMetadataOptions _matchOnMetadataOptions;\n+            private MetadataSet<P, I> _metadataSet;\n \n             public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)\n                 : base(builder, lazyEvaluator)\n             {\n                 _matchOnMetadata = builder.MatchOnMetadata.ToImmutable();\n-                _matchOnMetadataOptions = builder.MatchOnMetadataOptions;\n+\n+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(\n+                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment),\n+                    new BuildEventFileInfo(string.Empty),\n+                    \"OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "So matching the names of metadata is case insensitive, but their values are not. The values being case sensitive makes sense. I remember us having a discussion on the topic in a linux issue.\r\n\r\nJust thinking out loud.",
              "createdAt": "2021-01-22T00:50:18Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -2010,12 +2010,16 @@ public void FailWithMatchingMultipleMetadata()\n                     </Target></Project>\");\n             IntrinsicTask task = CreateIntrinsicTask(content);\n             Lookup lookup = LookupHelpers.CreateEmptyLookup();\n-            Assert.ThrowsAny<InvalidProjectFileException>(() => ExecuteTask(task, lookup))\n-                .HelpKeyword.ShouldBe(\"MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem\");\n+            ExecuteTask(task, lookup);\n+            ICollection<ProjectItemInstance> items = lookup.GetItems(\"I2\");\n+            items.Count().ShouldBe(3);\n+            items.ElementAt(0).EvaluatedInclude.ShouldBe(\"a2\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "MatchOnMetadata allows three options: case sensitive, case insensitive, and pathlike. The third is most similar to what you were thinking, I think, with defaulting to case insensitive regardless of OS.",
              "createdAt": "2021-01-22T16:28:25Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -2010,12 +2010,16 @@ public void FailWithMatchingMultipleMetadata()\n                     </Target></Project>\");\n             IntrinsicTask task = CreateIntrinsicTask(content);\n             Lookup lookup = LookupHelpers.CreateEmptyLookup();\n-            Assert.ThrowsAny<InvalidProjectFileException>(() => ExecuteTask(task, lookup))\n-                .HelpKeyword.ShouldBe(\"MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem\");\n+            ExecuteTask(task, lookup);\n+            ICollection<ProjectItemInstance> items = lookup.GetItems(\"I2\");\n+            items.Count().ShouldBe(3);\n+            items.ElementAt(0).EvaluatedInclude.ShouldBe(\"a2\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\ude04 ",
              "createdAt": "2021-01-29T14:22:01Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -504,4 +458,111 @@ public GlobFragment(string textFragment, string projectDirectory)\n             && TextFragment[2] == '*'\n             && FileUtilities.IsAnySlash(TextFragment[3]);\n     }\n+\n+    /// <summary>\n+    /// A Trie representing the sets of values of specified metadata taken on by the referenced items.\n+    /// A single flat list or set of metadata values would not work in this case because we are matching\n+    /// on multiple metadata. If one item specifies NotTargetFramework to be net46 and TargetFramework to\n+    /// be netcoreapp3.1, we wouldn't want to match that to an item with TargetFramework 46 and\n+    /// NotTargetFramework netcoreapp3.1.\n+    /// \n+    /// Implementing this as a list of sets where each metadatum key has its own set also would not work\n+    /// because different items could match on different metadata, and we want to check to see if any\n+    /// single item matches on all the metadata. As an example, consider this scenario:\n+    /// Item Baby has metadata GoodAt=\"eating\" BadAt=\"talking\" OkAt=\"sleeping\"\n+    /// Item Child has metadata GoodAt=\"sleeping\" BadAt=\"eating\" OkAt=\"talking\"\n+    /// Item Adolescent has metadata GoodAt=\"talking\" BadAt=\"sleeping\" OkAt=\"eating\"\n+    /// Specifying these three metadata:\n+    /// Item Forgind with metadata GoodAt=\"sleeping\" BadAt=\"talking\" OkAt=\"eating\"",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}