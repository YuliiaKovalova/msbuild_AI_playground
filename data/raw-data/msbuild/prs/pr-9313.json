{
  "number": 9313,
  "title": "Add task for metadata resolution",
  "body": "### Context\r\nThe metadata is needed by VS. Since DTB call to msbuild from the legacy project system is already asynchronous, this change is the optimal solution for requesting assembly info.\r\n\r\n### Changes Made\r\nAdd GetComAssembliesMetadata task for gathering assembly metadata.\r\n\r\n### Testing\r\nUTs are added.\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2023-10-09T10:09:32Z",
  "updatedAt": "2023-11-15T10:32:06Z",
  "closedAt": "2023-11-15T10:32:06Z",
  "mergedAt": "2023-11-15T10:32:06Z",
  "additions": 644,
  "deletions": 82,
  "changedFiles": 15,
  "headRefName": "dev/ykovalova/add_task_for_metadata_resolution",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f87b976fe75244e923fca046a2b88b47a052785e",
          "message": "add GetAssembliesMetadata task for assembly attributes resolution",
          "committedDate": "2023-10-05T12:20:44Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0cfa26ab5a8fe1f9b14f4fcea4428ad066fc2c96",
          "message": "include GetComAssembliesMetadata task iin Microsoft.Common.tasks",
          "committedDate": "2023-10-05T15:25:35Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba0adeb82d6b86704110cb3effe96bef3a26222e",
          "message": "Extend target GenerateApplicationManifest with GetComAssembliesMetadata",
          "committedDate": "2023-10-09T10:05:48Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81889272091942fc7d120583e3713027e757a4b9",
          "message": "update UsingTask tag",
          "committedDate": "2023-10-09T10:29:41Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1357f7396c886342aa7816fb989a7184051ddef4",
          "message": "fix build",
          "committedDate": "2023-10-09T11:15:54Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "84cc9c64cba4a11b58575929e1045b1e7097a490",
          "message": "add SupportedOSPlatform to",
          "committedDate": "2023-10-09T11:28:49Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d35c22eb286413378528a3a5a77475d1aca5bf9e",
          "message": "fix review comments",
          "committedDate": "2023-10-11T08:25:21Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0eb79f5cffd3965fbe0d285902edab9bc0dec8d5",
          "message": "fix test failure",
          "committedDate": "2023-10-11T09:00:34Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "063d0f54fc5ec4e7abe3da5542e294fbdfeeb969",
          "message": "merge",
          "committedDate": "2023-10-16T08:24:08Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "706c93b51965120f3e56c7b047f098eda40c2fb2",
          "message": "fix nit review comments",
          "committedDate": "2023-10-16T08:24:20Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73a9d9525fd35f9cc348df3e9f8e0d043e17cc32",
          "message": "fix test failure",
          "committedDate": "2023-10-16T09:04:47Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "44cfd55dc66d803f97dc64d12f5fabf0793c8a25",
          "message": "update target desctiption",
          "committedDate": "2023-10-16T11:29:39Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4d49f7008f65196181eb701743256f8b3d9e39c",
          "message": "fix review comments",
          "committedDate": "2023-10-24T09:06:42Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "06a4c41d0fd1edc59099085b71217642c4017018",
          "message": "fix review comment with Custom_COM",
          "committedDate": "2023-10-27T13:41:39Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3034b1b40f666f9e4de4092a75fc95719c4676de",
          "message": "fix build issue",
          "committedDate": "2023-10-27T13:59:47Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f5294e3fd7e95d5783c9bee72ae11a790bf368ac",
          "message": "fix build issue",
          "committedDate": "2023-10-27T14:50:34Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dda8df70f5f0a45b5804f99778c44f649b313a63",
          "message": "add header to the test file",
          "committedDate": "2023-10-27T17:00:14Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "537d0f13d6c980e0df5549a8747b1b864ffe12c0",
          "message": "add missed header",
          "committedDate": "2023-10-27T17:09:56Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "182c5fc2e65f97224a5f06f91099cde9f3c1ae80",
          "message": "add directory check",
          "committedDate": "2023-11-01T14:30:20Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "509c1403e2560bc1288c38d9040a4a82eaa006db",
          "message": "fix review comments",
          "committedDate": "2023-11-06T13:33:03Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> (Context: CSProj is currently doing some assembly metadata scanning on the main VS thread. This work is addressing the issue by adding a design-time target+task as a replacement.)\r\n\r\nCan y'all help me understand why \"move that to a thread\" isn't a good option here?",
        "createdAt": "2023-10-13T11:30:54Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> > (Context: CSProj is currently doing some assembly metadata scanning on the main VS thread. This work is addressing the issue by adding a design-time target+task as a replacement.)\r\n> \r\n> Can y'all help me understand why \"move that to a thread\" isn't a good option here?\r\n\r\nIt's complex and error-prone due to COM objects usage, compared to the idea of getting the needed information during already asynchronous DTB .",
        "createdAt": "2023-10-13T11:47:46Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "Adding to Yuliia's comment, keeping it in VS would be non-trivial threading-wise, especially since it is happening deep in the C++ implementation of the legacy project system. We feel it fits better with DT builds which CSProj is already doing - this is just one target to add to the build request. We get caching of the result for free, for example.",
        "createdAt": "2023-10-13T11:49:12Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "@rainersigwald, could you help me to understand naming convention here for props and target? Since it is planned to use it internally only, do I need to use '_' at the beginning of the names?",
        "createdAt": "2023-10-13T13:03:37Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "> Since it is planned to use it internally only, do I need to use '_' at the beginning of the names.\r\n\r\nYes please. Leading `_` is the closest we have to a \"private\" modifier.",
        "createdAt": "2023-10-13T13:51:20Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Do we understand what it would take to have CSProj ship and use its own design time targets that would only be loaded within VS design time builds? This target seems like a great candidate for that. There was a similar question recently that could have also used such targets.",
        "createdAt": "2023-10-29T23:17:54Z",
        "author": {
          "login": "drewnoakes"
        }
      },
      {
        "body": "> Do we understand what it would take to have CSProj ship and use its own design time targets that would only be loaded within VS design time builds? This target seems like a great candidate for that. There was a similar question recently that could have also used such targets.\r\n\r\nDrew, we have discussed in internally, unfortunately it's a huge chunk of work that potentially affects VS performance due to adding new assemblies in the process.",
        "createdAt": "2023-11-06T10:13:03Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: These tasks are alphabetically sorted. Unless there's a good reason to break it, I suggest moving it to follow the convention.",
              "createdAt": "2023-10-09T13:50:26Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -73,6 +73,7 @@\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveAssemblyReference\"              AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet\"            AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"                   AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.GetComAssembliesMetadata\"              AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This file has a lot of whitespace changes. Are they intentional?",
              "createdAt": "2023-10-09T13:52:32Z",
              "path": "src/Tasks/Microsoft.Common.overridetasks",
              "diffHunk": "@@ -9,32 +9,36 @@\n \n   <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->\n \n-  <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"  AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildToolsVersion)' == '3.5'\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"       AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildToolsVersion)' == '3.5'\" />",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I wanted to save the indentation like this :)\r\n![image](https://github.com/dotnet/msbuild/assets/95473390/1e447c5e-f019-4587-b683-e6d80943e2d1)\r\n",
              "createdAt": "2023-10-09T15:00:36Z",
              "path": "src/Tasks/Microsoft.Common.overridetasks",
              "diffHunk": "@@ -9,32 +9,36 @@\n \n   <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->\n \n-  <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"  AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildToolsVersion)' == '3.5'\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"       AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildToolsVersion)' == '3.5'\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Aha! It may not have been the best idea to indent the file like this but I guess it makes sense to preserve it when making updates.",
              "createdAt": "2023-10-10T07:31:07Z",
              "path": "src/Tasks/Microsoft.Common.overridetasks",
              "diffHunk": "@@ -9,32 +9,36 @@\n \n   <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->\n \n-  <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"  AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildToolsVersion)' == '3.5'\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.ResolveComReference\"       AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildToolsVersion)' == '3.5'\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The new task should run only in design time builds. It is currently missing such a condition and it runs in regular builds as well, which is not desired.",
              "createdAt": "2023-10-09T14:20:22Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4169,6 +4201,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n             _DeploymentComputeNativeManifestInfo;\n             _DeploymentComputeClickOnceManifestInfo;\n             ResolveComReferences;\n+            GetComAssembliesMetadata;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Also, it appears to be quite slow. I built a trivial project on the command line and got this:\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/12206368/fc57df35-10da-4005-b0ef-8bfcb37a198f)\r\n",
              "createdAt": "2023-10-09T14:21:43Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4169,6 +4201,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n             _DeploymentComputeNativeManifestInfo;\n             _DeploymentComputeClickOnceManifestInfo;\n             ResolveComReferences;\n+            GetComAssembliesMetadata;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Assuming the new project system doesn't need this task and it's really only for CSProj, I don't think the way it's currently done is correct. Instead of adding it to `ResolveReferencesDependsOn` in this file, do you think it would be possible for CSProj to explicitly request the target to run?\r\n\r\nSide question: Does the new project system also extract this metadata? If so, what is the mechanism?\r\n\r\nAlso, why is it added as a `GenerateApplicationManifest` dependency here?",
              "createdAt": "2023-10-10T07:45:48Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4169,6 +4201,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n             _DeploymentComputeNativeManifestInfo;\n             _DeploymentComputeClickOnceManifestInfo;\n             ResolveComReferences;\n+            GetComAssembliesMetadata;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The new task should ship only in the Framework version of `Microsoft.Build.Tasks.Core.dll`. It should be excluded from .NET either here in the project file or with an #ifdef in the source file.",
              "createdAt": "2023-10-09T14:28:45Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -327,6 +328,7 @@\n     </Compile>\n     <Compile Include=\"ResourceHandling\\*.cs\" />\n     <Compile Include=\"GetCompatiblePlatform.cs\" />\n+    <Compile Include=\"GetComAssembliesMetadata.cs\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`.",
              "createdAt": "2023-10-10T07:48:55Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyAttributes.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Collection of assembly attributes.\n+    /// </summary>\n+    internal class AssemblyAttributes",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `specilied`.",
              "createdAt": "2023-10-10T07:49:49Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It's wasteful to create two strings with the same content.\r\n\r\n```suggestion\r\n                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\r\n                assemblyAttributes.DefaultAlias = assemblyAttributes.AssemblyName;\r\n```\r\n\r\nAlso, are `AssemblyName` and `DefaultAlias` really supposed to always be the same? ",
              "createdAt": "2023-10-10T07:59:01Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);\n+\n+                // get the assembly, if there is no assembly, it is a module reference\n+                if (assemblyScope == 0)\n+                {\n+                    return null;\n+                }\n+\n+                AssemblyAttributes assemblyAttributes = new()\n+                {\n+                    AssemblyFullPath = _sourceFile,\n+                    IsAssembly = true,\n+                };\n+\n+                // will be populated with the assembly name\n+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];\n+                asmMetaPtr = AllocAsmMeta();\n+                _assemblyImport.GetAssemblyProps(\n+                    assemblyScope,\n+                    out IntPtr publicKeyPtr,\n+                    out uint publicKeyLength,\n+                    out uint hashAlgorithmId,\n+                    defaultCharArray,\n+\n+                    // the default buffer size is taken from csproj call\n+                    GENMAN_STRING_BUF_SIZE,\n+                    out uint nameLength,\n+                    asmMetaPtr,\n+                    out uint flags);\n+\n+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\n+                assemblyAttributes.DefaultAlias = new string(defaultCharArray, 0, (int)nameLength - 1);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "discussed offline",
              "createdAt": "2023-10-11T08:01:08Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);\n+\n+                // get the assembly, if there is no assembly, it is a module reference\n+                if (assemblyScope == 0)\n+                {\n+                    return null;\n+                }\n+\n+                AssemblyAttributes assemblyAttributes = new()\n+                {\n+                    AssemblyFullPath = _sourceFile,\n+                    IsAssembly = true,\n+                };\n+\n+                // will be populated with the assembly name\n+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];\n+                asmMetaPtr = AllocAsmMeta();\n+                _assemblyImport.GetAssemblyProps(\n+                    assemblyScope,\n+                    out IntPtr publicKeyPtr,\n+                    out uint publicKeyLength,\n+                    out uint hashAlgorithmId,\n+                    defaultCharArray,\n+\n+                    // the default buffer size is taken from csproj call\n+                    GENMAN_STRING_BUF_SIZE,\n+                    out uint nameLength,\n+                    asmMetaPtr,\n+                    out uint flags);\n+\n+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\n+                assemblyAttributes.DefaultAlias = new string(defaultCharArray, 0, (int)nameLength - 1);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This is not needed now that the task compiles only for .NET Framework.",
              "createdAt": "2023-10-10T08:01:20Z",
              "path": "src/Tasks/GetComAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,129 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of COM assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetComAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            if (!NativeMethodsShared.IsWindows)\n+            {\n+                Log.LogErrorWithCodeFromResources(\"General.TaskRequiresWindows\", nameof(GetComAssembliesMetadata));\n+                return false;\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: No need to ifdef when this code compiles only for .NET Framework.",
              "createdAt": "2023-10-10T08:03:05Z",
              "path": "src/Tasks/GetComAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,129 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of COM assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetComAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            if (!NativeMethodsShared.IsWindows)\n+            {\n+                Log.LogErrorWithCodeFromResources(\"General.TaskRequiresWindows\", nameof(GetComAssembliesMetadata));\n+                return false;\n+            }\n+\n+#if FEATURE_APPDOMAIN",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "typo: `Assemby`.",
              "createdAt": "2023-10-10T08:04:28Z",
              "path": "src/Tasks/GetComAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,129 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of COM assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetComAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            if (!NativeMethodsShared.IsWindows)\n+            {\n+                Log.LogErrorWithCodeFromResources(\"General.TaskRequiresWindows\", nameof(GetComAssembliesMetadata));\n+                return false;\n+            }\n+\n+#if FEATURE_APPDOMAIN\n+\n+            var assembliesMetadata = new List<ITaskItem>();\n+            foreach (string assemblyPath in AssembyPaths)\n+            {\n+                AssemblyInformation assemblyInformation = new(assemblyPath);\n+                AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();\n+\n+                if (attributes != null)\n+                {\n+                    assembliesMetadata.Add(SetItemMetadata(attributes));\n+                }\n+            }\n+\n+            _assembliesMetadata = assembliesMetadata.ToArray();\n+#endif\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// List of assembly paths.\n+        /// </summary>\n+        [Required]\n+        public string[] AssembyPaths",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        private string GetStringCustomAttribute(IMetaDataImport2 import2, uint assemblyScope, string attributeName)\r\n```",
              "createdAt": "2023-10-10T08:07:14Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);\n+\n+                // get the assembly, if there is no assembly, it is a module reference\n+                if (assemblyScope == 0)\n+                {\n+                    return null;\n+                }\n+\n+                AssemblyAttributes assemblyAttributes = new()\n+                {\n+                    AssemblyFullPath = _sourceFile,\n+                    IsAssembly = true,\n+                };\n+\n+                // will be populated with the assembly name\n+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];\n+                asmMetaPtr = AllocAsmMeta();\n+                _assemblyImport.GetAssemblyProps(\n+                    assemblyScope,\n+                    out IntPtr publicKeyPtr,\n+                    out uint publicKeyLength,\n+                    out uint hashAlgorithmId,\n+                    defaultCharArray,\n+\n+                    // the default buffer size is taken from csproj call\n+                    GENMAN_STRING_BUF_SIZE,\n+                    out uint nameLength,\n+                    asmMetaPtr,\n+                    out uint flags);\n+\n+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\n+                assemblyAttributes.DefaultAlias = new string(defaultCharArray, 0, (int)nameLength - 1);\n+\n+                ASSEMBLYMETADATA asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));\n+                assemblyAttributes.MajorVersion = asmMeta.usMajorVersion;\n+                assemblyAttributes.MinorVersion = asmMeta.usMinorVersion;\n+                assemblyAttributes.RevisionNumber = asmMeta.usRevisionNumber;\n+                assemblyAttributes.BuildNumber = asmMeta.usBuildNumber;\n+                assemblyAttributes.Culture = Marshal.PtrToStringUni(asmMeta.rpLocale);\n+\n+                byte[] publicKey = new byte[publicKeyLength];\n+                Marshal.Copy(publicKeyPtr, publicKey, 0, (int)publicKeyLength);\n+                assemblyAttributes.PublicKey = BitConverter.ToString(publicKey).Replace(\"-\", string.Empty);\n+                assemblyAttributes.PublicKeyLength = publicKeyLength;\n+\n+                if (import2 != null)\n+                {\n+                    assemblyAttributes.Description = GetStringCustomAttribute(import2, assemblyScope, \"System.Reflection.AssemblyDescriptionAttribute\");\n+                    assemblyAttributes.TargetFrameworkMoniker = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.Versioning.TargetFrameworkAttribute\");\n+                    assemblyAttributes.Guid = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.GuidAttribute\");\n+                    if (!string.IsNullOrEmpty(assemblyAttributes.Guid))\n+                    {\n+                        string importedFromTypeLibString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.ImportedFromTypeLibAttribute\");\n+                        if (!string.IsNullOrEmpty(importedFromTypeLibString))\n+                        {\n+                            assemblyAttributes.IsImportedFromTypeLib = true;\n+                        }\n+                        else\n+                        {\n+                            string primaryInteropAssemblyString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute\");\n+                            assemblyAttributes.IsImportedFromTypeLib = !string.IsNullOrEmpty(primaryInteropAssemblyString);\n+                        }\n+                    }\n+                }\n+\n+                assemblyAttributes.RuntimeVersion = GetRuntimeVersion(_sourceFile);\n+\n+                import2.GetPEKind(out uint peKind, out _);\n+                assemblyAttributes.PeKind = peKind;\n+\n+                return assemblyAttributes;\n+            }\n+            finally\n+            {\n+                FreeAsmMeta(asmMetaPtr);\n+            }\n+        }\n+\n+        private string GetStringCustomAttribute(IMetaDataImport2 import2, uint assemblyScope, string propertyName)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This comment looks outdated, maybe wasn't correct in the original code either. I believe we're reading the first string in the custom attribute value here, not necessarily `AssemblyTitle`.",
              "createdAt": "2023-10-10T08:11:27Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);\n+\n+                // get the assembly, if there is no assembly, it is a module reference\n+                if (assemblyScope == 0)\n+                {\n+                    return null;\n+                }\n+\n+                AssemblyAttributes assemblyAttributes = new()\n+                {\n+                    AssemblyFullPath = _sourceFile,\n+                    IsAssembly = true,\n+                };\n+\n+                // will be populated with the assembly name\n+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];\n+                asmMetaPtr = AllocAsmMeta();\n+                _assemblyImport.GetAssemblyProps(\n+                    assemblyScope,\n+                    out IntPtr publicKeyPtr,\n+                    out uint publicKeyLength,\n+                    out uint hashAlgorithmId,\n+                    defaultCharArray,\n+\n+                    // the default buffer size is taken from csproj call\n+                    GENMAN_STRING_BUF_SIZE,\n+                    out uint nameLength,\n+                    asmMetaPtr,\n+                    out uint flags);\n+\n+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\n+                assemblyAttributes.DefaultAlias = new string(defaultCharArray, 0, (int)nameLength - 1);\n+\n+                ASSEMBLYMETADATA asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));\n+                assemblyAttributes.MajorVersion = asmMeta.usMajorVersion;\n+                assemblyAttributes.MinorVersion = asmMeta.usMinorVersion;\n+                assemblyAttributes.RevisionNumber = asmMeta.usRevisionNumber;\n+                assemblyAttributes.BuildNumber = asmMeta.usBuildNumber;\n+                assemblyAttributes.Culture = Marshal.PtrToStringUni(asmMeta.rpLocale);\n+\n+                byte[] publicKey = new byte[publicKeyLength];\n+                Marshal.Copy(publicKeyPtr, publicKey, 0, (int)publicKeyLength);\n+                assemblyAttributes.PublicKey = BitConverter.ToString(publicKey).Replace(\"-\", string.Empty);\n+                assemblyAttributes.PublicKeyLength = publicKeyLength;\n+\n+                if (import2 != null)\n+                {\n+                    assemblyAttributes.Description = GetStringCustomAttribute(import2, assemblyScope, \"System.Reflection.AssemblyDescriptionAttribute\");\n+                    assemblyAttributes.TargetFrameworkMoniker = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.Versioning.TargetFrameworkAttribute\");\n+                    assemblyAttributes.Guid = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.GuidAttribute\");\n+                    if (!string.IsNullOrEmpty(assemblyAttributes.Guid))\n+                    {\n+                        string importedFromTypeLibString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.ImportedFromTypeLibAttribute\");\n+                        if (!string.IsNullOrEmpty(importedFromTypeLibString))\n+                        {\n+                            assemblyAttributes.IsImportedFromTypeLib = true;\n+                        }\n+                        else\n+                        {\n+                            string primaryInteropAssemblyString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute\");\n+                            assemblyAttributes.IsImportedFromTypeLib = !string.IsNullOrEmpty(primaryInteropAssemblyString);\n+                        }\n+                    }\n+                }\n+\n+                assemblyAttributes.RuntimeVersion = GetRuntimeVersion(_sourceFile);\n+\n+                import2.GetPEKind(out uint peKind, out _);\n+                assemblyAttributes.PeKind = peKind;\n+\n+                return assemblyAttributes;\n+            }\n+            finally\n+            {\n+                FreeAsmMeta(asmMetaPtr);\n+            }\n+        }\n+\n+        private string GetStringCustomAttribute(IMetaDataImport2 import2, uint assemblyScope, string propertyName)\n+        {\n+            int hr = import2.GetCustomAttributeByName(assemblyScope, propertyName, out IntPtr data, out uint valueLen);\n+\n+            // get the AssemblyTitle",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit / perfectly fine to ignore:\r\n\r\n```suggestion\r\n        private TaskItem CreateItemWithMetadata(AssemblyAttributes attributes)\r\n```",
              "createdAt": "2023-10-10T08:20:39Z",
              "path": "src/Tasks/GetComAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,129 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of COM assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetComAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            if (!NativeMethodsShared.IsWindows)\n+            {\n+                Log.LogErrorWithCodeFromResources(\"General.TaskRequiresWindows\", nameof(GetComAssembliesMetadata));\n+                return false;\n+            }\n+\n+#if FEATURE_APPDOMAIN\n+\n+            var assembliesMetadata = new List<ITaskItem>();\n+            foreach (string assemblyPath in AssembyPaths)\n+            {\n+                AssemblyInformation assemblyInformation = new(assemblyPath);\n+                AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();\n+\n+                if (attributes != null)\n+                {\n+                    assembliesMetadata.Add(SetItemMetadata(attributes));\n+                }\n+            }\n+\n+            _assembliesMetadata = assembliesMetadata.ToArray();\n+#endif\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// List of assembly paths.\n+        /// </summary>\n+        [Required]\n+        public string[] AssembyPaths\n+        {\n+            get => _assemblyPaths;\n+\n+            set\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(AssembyPaths));\n+                _assemblyPaths = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Gets a list of resolved assembly metadata.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssembliesMetadata => _assembliesMetadata;\n+\n+        /// <summary>\n+        /// Sets metadata on the assembly path.\n+        /// </summary>\n+        private TaskItem SetItemMetadata(AssemblyAttributes attributes)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it necessary to keep this? As opposed to implicitly using the length of `PublicKey` (divided by 2 to account for hex encoding).",
              "createdAt": "2023-10-10T08:27:11Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyAttributes.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Collection of assembly attributes.\n+    /// </summary>\n+    internal class AssemblyAttributes\n+    {\n+        public string AssemblyFullPath { get; set; } = string.Empty;\n+\n+        public string AssemblyName { get; set; } = string.Empty;\n+\n+        public string DefaultAlias { get; set; } = string.Empty;\n+\n+        public string Description { get; set; } = string.Empty;\n+\n+        public string Culture { get; set; } = string.Empty;\n+\n+        public string RuntimeVersion { get; set; } = string.Empty;\n+\n+        public ushort MajorVersion { get; set; }\n+\n+        public ushort MinorVersion { get; set; }\n+\n+        public ushort BuildNumber { get; set; }\n+\n+        public ushort RevisionNumber { get; set; }\n+\n+        // it is a byte[] converted to string\n+        public string PublicKey { get; set; } = string.Empty;\n+\n+        public uint PublicKeyLength { get; set; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`FreeAsmMeta` is internally marshaling the `IntPtr` to a structure, which in most cases is wasteful as we've already done it in this method. Can you please optimize, maybe by introducing another overload of `FreeAsmMeta` taking `ref ASSEMBLYMETADATA` as a second argument?",
              "createdAt": "2023-10-10T08:31:23Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);\n+\n+                // get the assembly, if there is no assembly, it is a module reference\n+                if (assemblyScope == 0)\n+                {\n+                    return null;\n+                }\n+\n+                AssemblyAttributes assemblyAttributes = new()\n+                {\n+                    AssemblyFullPath = _sourceFile,\n+                    IsAssembly = true,\n+                };\n+\n+                // will be populated with the assembly name\n+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];\n+                asmMetaPtr = AllocAsmMeta();\n+                _assemblyImport.GetAssemblyProps(\n+                    assemblyScope,\n+                    out IntPtr publicKeyPtr,\n+                    out uint publicKeyLength,\n+                    out uint hashAlgorithmId,\n+                    defaultCharArray,\n+\n+                    // the default buffer size is taken from csproj call\n+                    GENMAN_STRING_BUF_SIZE,\n+                    out uint nameLength,\n+                    asmMetaPtr,\n+                    out uint flags);\n+\n+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\n+                assemblyAttributes.DefaultAlias = new string(defaultCharArray, 0, (int)nameLength - 1);\n+\n+                ASSEMBLYMETADATA asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));\n+                assemblyAttributes.MajorVersion = asmMeta.usMajorVersion;\n+                assemblyAttributes.MinorVersion = asmMeta.usMinorVersion;\n+                assemblyAttributes.RevisionNumber = asmMeta.usRevisionNumber;\n+                assemblyAttributes.BuildNumber = asmMeta.usBuildNumber;\n+                assemblyAttributes.Culture = Marshal.PtrToStringUni(asmMeta.rpLocale);\n+\n+                byte[] publicKey = new byte[publicKeyLength];\n+                Marshal.Copy(publicKeyPtr, publicKey, 0, (int)publicKeyLength);\n+                assemblyAttributes.PublicKey = BitConverter.ToString(publicKey).Replace(\"-\", string.Empty);\n+                assemblyAttributes.PublicKeyLength = publicKeyLength;\n+\n+                if (import2 != null)\n+                {\n+                    assemblyAttributes.Description = GetStringCustomAttribute(import2, assemblyScope, \"System.Reflection.AssemblyDescriptionAttribute\");\n+                    assemblyAttributes.TargetFrameworkMoniker = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.Versioning.TargetFrameworkAttribute\");\n+                    assemblyAttributes.Guid = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.GuidAttribute\");\n+                    if (!string.IsNullOrEmpty(assemblyAttributes.Guid))\n+                    {\n+                        string importedFromTypeLibString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.ImportedFromTypeLibAttribute\");\n+                        if (!string.IsNullOrEmpty(importedFromTypeLibString))\n+                        {\n+                            assemblyAttributes.IsImportedFromTypeLib = true;\n+                        }\n+                        else\n+                        {\n+                            string primaryInteropAssemblyString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute\");\n+                            assemblyAttributes.IsImportedFromTypeLib = !string.IsNullOrEmpty(primaryInteropAssemblyString);\n+                        }\n+                    }\n+                }\n+\n+                assemblyAttributes.RuntimeVersion = GetRuntimeVersion(_sourceFile);\n+\n+                import2.GetPEKind(out uint peKind, out _);\n+                assemblyAttributes.PeKind = peKind;\n+\n+                return assemblyAttributes;\n+            }\n+            finally\n+            {\n+                FreeAsmMeta(asmMetaPtr);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "done",
              "createdAt": "2023-10-11T08:03:46Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,113 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specilied assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);\n+\n+                // get the assembly, if there is no assembly, it is a module reference\n+                if (assemblyScope == 0)\n+                {\n+                    return null;\n+                }\n+\n+                AssemblyAttributes assemblyAttributes = new()\n+                {\n+                    AssemblyFullPath = _sourceFile,\n+                    IsAssembly = true,\n+                };\n+\n+                // will be populated with the assembly name\n+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];\n+                asmMetaPtr = AllocAsmMeta();\n+                _assemblyImport.GetAssemblyProps(\n+                    assemblyScope,\n+                    out IntPtr publicKeyPtr,\n+                    out uint publicKeyLength,\n+                    out uint hashAlgorithmId,\n+                    defaultCharArray,\n+\n+                    // the default buffer size is taken from csproj call\n+                    GENMAN_STRING_BUF_SIZE,\n+                    out uint nameLength,\n+                    asmMetaPtr,\n+                    out uint flags);\n+\n+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);\n+                assemblyAttributes.DefaultAlias = new string(defaultCharArray, 0, (int)nameLength - 1);\n+\n+                ASSEMBLYMETADATA asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));\n+                assemblyAttributes.MajorVersion = asmMeta.usMajorVersion;\n+                assemblyAttributes.MinorVersion = asmMeta.usMinorVersion;\n+                assemblyAttributes.RevisionNumber = asmMeta.usRevisionNumber;\n+                assemblyAttributes.BuildNumber = asmMeta.usBuildNumber;\n+                assemblyAttributes.Culture = Marshal.PtrToStringUni(asmMeta.rpLocale);\n+\n+                byte[] publicKey = new byte[publicKeyLength];\n+                Marshal.Copy(publicKeyPtr, publicKey, 0, (int)publicKeyLength);\n+                assemblyAttributes.PublicKey = BitConverter.ToString(publicKey).Replace(\"-\", string.Empty);\n+                assemblyAttributes.PublicKeyLength = publicKeyLength;\n+\n+                if (import2 != null)\n+                {\n+                    assemblyAttributes.Description = GetStringCustomAttribute(import2, assemblyScope, \"System.Reflection.AssemblyDescriptionAttribute\");\n+                    assemblyAttributes.TargetFrameworkMoniker = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.Versioning.TargetFrameworkAttribute\");\n+                    assemblyAttributes.Guid = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.GuidAttribute\");\n+                    if (!string.IsNullOrEmpty(assemblyAttributes.Guid))\n+                    {\n+                        string importedFromTypeLibString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.ImportedFromTypeLibAttribute\");\n+                        if (!string.IsNullOrEmpty(importedFromTypeLibString))\n+                        {\n+                            assemblyAttributes.IsImportedFromTypeLib = true;\n+                        }\n+                        else\n+                        {\n+                            string primaryInteropAssemblyString = GetStringCustomAttribute(import2, assemblyScope, \"System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute\");\n+                            assemblyAttributes.IsImportedFromTypeLib = !string.IsNullOrEmpty(primaryInteropAssemblyString);\n+                        }\n+                    }\n+                }\n+\n+                assemblyAttributes.RuntimeVersion = GetRuntimeVersion(_sourceFile);\n+\n+                import2.GetPEKind(out uint peKind, out _);\n+                assemblyAttributes.PeKind = peKind;\n+\n+                return assemblyAttributes;\n+            }\n+            finally\n+            {\n+                FreeAsmMeta(asmMetaPtr);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n#if NETFRAMEWORK\r\n```\r\n\r\nAs the new task is not really related to appdomains.",
              "createdAt": "2023-10-10T08:33:07Z",
              "path": "src/Tasks.UnitTests/GetComAssembliesMetadata_Tests.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+\n+#if FEATURE_APPDOMAIN",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this path really guaranteed to exist on all machines where this test runs? Can you reference the real `mscorlib` in `\\Windows\\Microsoft.NET\\Framework\\v4.0.30319` instead?",
              "createdAt": "2023-10-10T08:35:55Z",
              "path": "src/Tasks.UnitTests/GetComAssembliesMetadata_Tests.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+\n+#if FEATURE_APPDOMAIN\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Sdk;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class GetComAssembliesMetadata_Tests\n+    {\n+        private static string TestAssembliesPaths { get; } = Path.Combine(AppContext.BaseDirectory, \"TestResources\", \"Assemblies\");\n+\n+        [Fact]\n+        public void CheckPresenceOfCustomCOMAssemblyAttributes()\n+        {\n+            string assemblyPath = Path.Combine(TestAssembliesPaths, \"Custom_COM.dll\");\n+            GetComAssembliesMetadata t = new() { AssembyPaths = new[] { assemblyPath } };\n+\n+            bool isSuccess = t.Execute();\n+\n+            isSuccess.ShouldBeTrue();\n+            t.AssembliesMetadata[0].ItemSpec.ShouldBe(assemblyPath);\n+            t.AssembliesMetadata[0].GetMetadata(\"AssemblyName\").ShouldBe(\"Custom_COM\");\n+            t.AssembliesMetadata[0].GetMetadata(\"IsImportedFromTypeLib\").ShouldBe(\"False\");\n+            t.AssembliesMetadata[0].GetMetadata(\"RevisionNumber\").ShouldBe(\"4\");\n+            t.AssembliesMetadata[0].GetMetadata(\"IsAssembly\").ShouldBe(\"True\");\n+            t.AssembliesMetadata[0].GetMetadata(\"RuntimeVersion\").ShouldBe(\"v4.0.30319\");\n+            t.AssembliesMetadata[0].GetMetadata(\"MajorVersion\").ShouldBe(\"1\");\n+            t.AssembliesMetadata[0].GetMetadata(\"MinorVersion\").ShouldBe(\"2\");\n+            t.AssembliesMetadata[0].GetMetadata(\"PeKind\").ShouldBe(\"1\");\n+            t.AssembliesMetadata[0].GetMetadata(\"Guid\").ShouldBe(\"a48efb66-2596-4c6a-87ab-c8a765e54429\");\n+            t.AssembliesMetadata[0].GetMetadata(\"BuildNumber\").ShouldBe(\"3\");\n+            t.AssembliesMetadata[0].GetMetadata(\"Description\").ShouldBe(\"description for com\");\n+            t.AssembliesMetadata[0].GetMetadata(\"Culture\").ShouldBeEmpty();\n+            t.AssembliesMetadata[0].GetMetadata(\"TargetFrameworkMoniker\").ShouldBe(\".NETFramework,Version=v4.7.2\");\n+            t.AssembliesMetadata[0].GetMetadata(\"DefaultAlias\").ShouldBe(\"Custom_COM\");\n+            t.AssembliesMetadata[0].GetMetadata(\"PublicKey\").ShouldBeEmpty();\n+            t.AssembliesMetadata[0].GetMetadata(\"PublicKeyLength\").ShouldBe(\"0\");\n+        }\n+\n+        [Fact]\n+        public void CheckPresenceOfCOMAssemblyAttributes()\n+        {\n+            string programFilesX86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);\n+            string programFilesRefAssemblyLocation = Path.Combine(programFilesX86, \"Reference Assemblies\\\\Microsoft\\\\Framework\");\n+            string assemblyPath = Path.Combine(programFilesRefAssemblyLocation, \".NETFramework\", \"v4.7.2\", \"mscorlib.dll\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe?:\r\n```suggestion\r\n        public string PublicKeyBase64 { get; set; } = string.Empty;\r\n```",
              "createdAt": "2023-10-11T10:48:46Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyAttributes.cs",
              "diffHunk": "@@ -0,0 +1,50 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Collection of assembly attributes.\n+    /// </summary>\n+    internal sealed class AssemblyAttributes\n+    {\n+        public string AssemblyFullPath { get; set; } = string.Empty;\n+\n+        public string AssemblyName { get; set; } = string.Empty;\n+\n+        public string DefaultAlias { get; set; } = string.Empty;\n+\n+        public string Description { get; set; } = string.Empty;\n+\n+        public string Culture { get; set; } = string.Empty;\n+\n+        public string RuntimeVersion { get; set; } = string.Empty;\n+\n+        public ushort MajorVersion { get; set; }\n+\n+        public ushort MinorVersion { get; set; }\n+\n+        public ushort BuildNumber { get; set; }\n+\n+        public ushort RevisionNumber { get; set; }\n+\n+        // it is a byte[] converted to string\n+        public string PublicKey { get; set; } = string.Empty;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: should it rather be `FEATURE_ASSEMBLYLOADCONTEXT`?",
              "createdAt": "2023-10-11T10:49:23Z",
              "path": "src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs",
              "diffHunk": "@@ -0,0 +1,78 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I don't know the difference between these two :)",
              "createdAt": "2023-10-11T12:28:20Z",
              "path": "src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs",
              "diffHunk": "@@ -0,0 +1,78 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I don't think this one should be keyed off of a feature. We just need this functionality only in the Framework version of the task.",
              "createdAt": "2023-10-11T12:51:14Z",
              "path": "src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs",
              "diffHunk": "@@ -0,0 +1,78 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be in #if conditional section?",
              "createdAt": "2023-10-11T10:50:47Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -10,12 +10,14 @@\n using System.Linq;\n using System.Runtime.InteropServices;\n #endif\n-using System.Runtime.Versioning;\n using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Security.Cryptography;\n+using System.Security.Cryptography.X509Certificates;\n using System.Text;\n-\n using Microsoft.Build.Shared;\n using Microsoft.Build.Shared.FileSystem;\n+using static Microsoft.Build.Shared.FileSystem.WindowsNative;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            Dictionary<string, string> metadata = new()\r\n            {\r\n                { nameof(attributes.AssemblyName), attributes.AssemblyName },\r\n                { nameof(attributes.RuntimeVersion), attributes.RuntimeVersion },\r\n                { nameof(attributes.RevisionNumber), attributes.RevisionNumber.ToString() },\r\n                { nameof(attributes.BuildNumber), attributes.BuildNumber.ToString() },\r\n                { nameof(attributes.Culture), attributes.Culture },\r\n                { nameof(attributes.DefaultAlias), attributes.DefaultAlias },\r\n                { nameof(attributes.Description), attributes.Description },\r\n                { nameof(attributes.Guid), attributes.Guid },\r\n                { nameof(attributes.MajorVersion), attributes.MajorVersion.ToString() },\r\n                { nameof(attributes.MinorVersion), attributes.MinorVersion.ToString() },\r\n                { nameof(attributes.PeKind), attributes.PeKind.ToString() },\r\n                { nameof(attributes.PublicKey), attributes.PublicKey },\r\n                { nameof(attributes.IsAssembly), attributes.IsAssembly.ToString() },\r\n                { nameof(attributes.TargetFrameworkMoniker), attributes.TargetFrameworkMoniker },\r\n                { nameof(attributes.IsImportedFromTypeLib), attributes.IsImportedFromTypeLib.ToString() },\r\n            };\r\n```",
              "createdAt": "2023-10-11T10:56:39Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,120 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            var assembliesMetadata = new List<ITaskItem>();\n+            foreach (string assemblyPath in AssemblyPaths)\n+            {\n+                AssemblyInformation assemblyInformation = new(assemblyPath);\n+                AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();\n+\n+                if (attributes != null)\n+                {\n+                    assembliesMetadata.Add(CreateItemWithMetadata(attributes));\n+                }\n+            }\n+\n+            _assembliesMetadata = assembliesMetadata.ToArray();\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// List of assembly paths.\n+        /// </summary>\n+        [Required]\n+        public string[] AssemblyPaths\n+        {\n+            get => _assemblyPaths;\n+\n+            set\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(AssemblyPaths));\n+                _assemblyPaths = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Gets a list of resolved assembly metadata.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssembliesMetadata => _assembliesMetadata;\n+\n+        /// <summary>\n+        /// Sets metadata on the assembly path.\n+        /// </summary>\n+        private TaskItem CreateItemWithMetadata(AssemblyAttributes attributes)\n+        {\n+            TaskItem referenceItem = new()\n+            {\n+                ItemSpec = attributes.AssemblyFullPath,\n+            };\n+\n+            IMetadataContainer referenceItemAsMetadataContainer = referenceItem;\n+            referenceItemAsMetadataContainer.ImportMetadata(EnumerateCommonMetadata());\n+\n+            return referenceItem;\n+\n+            IEnumerable<KeyValuePair<string, string>> EnumerateCommonMetadata()\n+            {\n+                yield return new KeyValuePair<string, string>(nameof(attributes.AssemblyName), attributes.AssemblyName);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.RuntimeVersion), attributes.RuntimeVersion);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.RevisionNumber), attributes.RevisionNumber.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.BuildNumber), attributes.BuildNumber.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Culture), attributes.Culture);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.DefaultAlias), attributes.DefaultAlias);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Description), attributes.Description);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Guid), attributes.Guid);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.MajorVersion), attributes.MajorVersion.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.MinorVersion), attributes.MinorVersion.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.PeKind), attributes.PeKind.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.PublicKey), attributes.PublicKey);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.IsAssembly), attributes.IsAssembly.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.TargetFrameworkMoniker), attributes.TargetFrameworkMoniker);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.IsImportedFromTypeLib), attributes.IsImportedFromTypeLib.ToString());\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "yield usage was inspired by this part of code\r\nhttps://github.com/dotnet/msbuild/blob/a9341111228592c25c43ecf6858e7b39e525b5a1/src/Tasks/AssemblyDependency/ReferenceTable.cs#L2860",
              "createdAt": "2023-10-11T12:31:01Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,120 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            var assembliesMetadata = new List<ITaskItem>();\n+            foreach (string assemblyPath in AssemblyPaths)\n+            {\n+                AssemblyInformation assemblyInformation = new(assemblyPath);\n+                AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();\n+\n+                if (attributes != null)\n+                {\n+                    assembliesMetadata.Add(CreateItemWithMetadata(attributes));\n+                }\n+            }\n+\n+            _assembliesMetadata = assembliesMetadata.ToArray();\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// List of assembly paths.\n+        /// </summary>\n+        [Required]\n+        public string[] AssemblyPaths\n+        {\n+            get => _assemblyPaths;\n+\n+            set\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(AssemblyPaths));\n+                _assemblyPaths = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Gets a list of resolved assembly metadata.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssembliesMetadata => _assembliesMetadata;\n+\n+        /// <summary>\n+        /// Sets metadata on the assembly path.\n+        /// </summary>\n+        private TaskItem CreateItemWithMetadata(AssemblyAttributes attributes)\n+        {\n+            TaskItem referenceItem = new()\n+            {\n+                ItemSpec = attributes.AssemblyFullPath,\n+            };\n+\n+            IMetadataContainer referenceItemAsMetadataContainer = referenceItem;\n+            referenceItemAsMetadataContainer.ImportMetadata(EnumerateCommonMetadata());\n+\n+            return referenceItem;\n+\n+            IEnumerable<KeyValuePair<string, string>> EnumerateCommonMetadata()\n+            {\n+                yield return new KeyValuePair<string, string>(nameof(attributes.AssemblyName), attributes.AssemblyName);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.RuntimeVersion), attributes.RuntimeVersion);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.RevisionNumber), attributes.RevisionNumber.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.BuildNumber), attributes.BuildNumber.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Culture), attributes.Culture);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.DefaultAlias), attributes.DefaultAlias);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Description), attributes.Description);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Guid), attributes.Guid);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.MajorVersion), attributes.MajorVersion.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.MinorVersion), attributes.MinorVersion.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.PeKind), attributes.PeKind.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.PublicKey), attributes.PublicKey);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.IsAssembly), attributes.IsAssembly.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.TargetFrameworkMoniker), attributes.TargetFrameworkMoniker);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.IsImportedFromTypeLib), attributes.IsImportedFromTypeLib.ToString());\n+            }",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Jan's suggestion looks good - although it would be interesting to measure. My guess is that the `yield` version may allocate less but the `Dictionary` one would be faster.",
              "createdAt": "2023-10-11T12:55:32Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,120 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            var assembliesMetadata = new List<ITaskItem>();\n+            foreach (string assemblyPath in AssemblyPaths)\n+            {\n+                AssemblyInformation assemblyInformation = new(assemblyPath);\n+                AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();\n+\n+                if (attributes != null)\n+                {\n+                    assembliesMetadata.Add(CreateItemWithMetadata(attributes));\n+                }\n+            }\n+\n+            _assembliesMetadata = assembliesMetadata.ToArray();\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// List of assembly paths.\n+        /// </summary>\n+        [Required]\n+        public string[] AssemblyPaths\n+        {\n+            get => _assemblyPaths;\n+\n+            set\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(AssemblyPaths));\n+                _assemblyPaths = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Gets a list of resolved assembly metadata.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssembliesMetadata => _assembliesMetadata;\n+\n+        /// <summary>\n+        /// Sets metadata on the assembly path.\n+        /// </summary>\n+        private TaskItem CreateItemWithMetadata(AssemblyAttributes attributes)\n+        {\n+            TaskItem referenceItem = new()\n+            {\n+                ItemSpec = attributes.AssemblyFullPath,\n+            };\n+\n+            IMetadataContainer referenceItemAsMetadataContainer = referenceItem;\n+            referenceItemAsMetadataContainer.ImportMetadata(EnumerateCommonMetadata());\n+\n+            return referenceItem;\n+\n+            IEnumerable<KeyValuePair<string, string>> EnumerateCommonMetadata()\n+            {\n+                yield return new KeyValuePair<string, string>(nameof(attributes.AssemblyName), attributes.AssemblyName);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.RuntimeVersion), attributes.RuntimeVersion);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.RevisionNumber), attributes.RevisionNumber.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.BuildNumber), attributes.BuildNumber.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Culture), attributes.Culture);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.DefaultAlias), attributes.DefaultAlias);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Description), attributes.Description);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.Guid), attributes.Guid);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.MajorVersion), attributes.MajorVersion.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.MinorVersion), attributes.MinorVersion.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.PeKind), attributes.PeKind.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.PublicKey), attributes.PublicKey);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.IsAssembly), attributes.IsAssembly.ToString());\n+                yield return new KeyValuePair<string, string>(nameof(attributes.TargetFrameworkMoniker), attributes.TargetFrameworkMoniker);\n+                yield return new KeyValuePair<string, string>(nameof(attributes.IsImportedFromTypeLib), attributes.IsImportedFromTypeLib.ToString());\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please consider replacing `C:/` and `Windows` with the value of the `SystemRoot` environment variable for robustness.",
              "createdAt": "2023-10-12T08:37:31Z",
              "path": "src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs",
              "diffHunk": "@@ -0,0 +1,78 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Sdk;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class GetAssembliesMetadata_Tests\n+    {\n+        private static string TestAssembliesPaths { get; } = Path.Combine(AppContext.BaseDirectory, \"TestResources\", \"Assemblies\");\n+\n+        [Fact]\n+        public void CheckPresenceOfCustomCOMAssemblyAttributes()\n+        {\n+            string assemblyPath = Path.Combine(TestAssembliesPaths, \"Custom_COM.dll\");\n+            GetAssembliesMetadata t = new() { AssemblyPaths = new[] { assemblyPath } };\n+\n+            bool isSuccess = t.Execute();\n+\n+            isSuccess.ShouldBeTrue();\n+            t.AssembliesMetadata[0].ItemSpec.ShouldBe(assemblyPath);\n+            t.AssembliesMetadata[0].GetMetadata(\"AssemblyName\").ShouldBe(\"Custom_COM\");\n+            t.AssembliesMetadata[0].GetMetadata(\"IsImportedFromTypeLib\").ShouldBe(\"False\");\n+            t.AssembliesMetadata[0].GetMetadata(\"RevisionNumber\").ShouldBe(\"4\");\n+            t.AssembliesMetadata[0].GetMetadata(\"IsAssembly\").ShouldBe(\"True\");\n+            t.AssembliesMetadata[0].GetMetadata(\"RuntimeVersion\").ShouldBe(\"v4.0.30319\");\n+            t.AssembliesMetadata[0].GetMetadata(\"MajorVersion\").ShouldBe(\"1\");\n+            t.AssembliesMetadata[0].GetMetadata(\"MinorVersion\").ShouldBe(\"2\");\n+            t.AssembliesMetadata[0].GetMetadata(\"PeKind\").ShouldBe(\"1\");\n+            t.AssembliesMetadata[0].GetMetadata(\"Guid\").ShouldBe(\"a48efb66-2596-4c6a-87ab-c8a765e54429\");\n+            t.AssembliesMetadata[0].GetMetadata(\"BuildNumber\").ShouldBe(\"3\");\n+            t.AssembliesMetadata[0].GetMetadata(\"Description\").ShouldBe(\"description for com\");\n+            t.AssembliesMetadata[0].GetMetadata(\"Culture\").ShouldBeEmpty();\n+            t.AssembliesMetadata[0].GetMetadata(\"TargetFrameworkMoniker\").ShouldBe(\".NETFramework,Version=v4.7.2\");\n+            t.AssembliesMetadata[0].GetMetadata(\"DefaultAlias\").ShouldBe(\"Custom_COM\");\n+            t.AssembliesMetadata[0].GetMetadata(\"PublicKeyHex\").ShouldBeEmpty();\n+        }\n+\n+        [Fact]\n+        public void CheckPresenceOfCOMAssemblyAttributes()\n+        {\n+            string assemblyPath = Path.Combine(\"C:/\", \"Windows\", \"Microsoft.NET\", \"Framework\", \"v4.0.30319\", \"mscorlib.dll\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Please add `asmMeta.rpLocale = IntPtr.Zero;` after this line as a defense against potential double free.",
              "createdAt": "2023-10-12T08:51:45Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -844,6 +942,19 @@ private static void FreeAsmMeta(IntPtr asmMetaPtr)\n             {\n                 // Marshal the assembly metadata back to a managed type.\n                 var asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));\n+                FreeAsmMeta(asmMetaPtr, ref asmMeta);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Free the assembly metadata structure.\n+        /// </summary>\n+        /// <param name=\"asmMetaPtr\">The pointer.</param>\n+        /// <param name=\"asmMeta\">Marshaled assembly metadata to the managed type.</param>\n+        private static void FreeAsmMeta(IntPtr asmMetaPtr, ref ASSEMBLYMETADATA asmMeta)\n+        {\n+            if (asmMetaPtr != IntPtr.Zero)\n+            {\n                 // Free unmanaged memory.\n                 Marshal.FreeCoTaskMem(asmMeta.rpLocale);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n\r\n```suggestion\r\n        /// Creates a TaskItem and populates it with the given assembly attributes.\r\n```",
              "createdAt": "2023-10-12T08:57:20Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,119 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Resolves metadata for the specified set of assemblies.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public class GetAssembliesMetadata : TaskExtension\n+    {\n+        /// <summary>\n+        /// Assembly paths.\n+        /// </summary>\n+        private string[] _assemblyPaths = Array.Empty<string>();\n+\n+        /// <summary>\n+        /// Set of resolved assembly metadata.\n+        /// </summary>\n+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();\n+\n+        /// <summary>\n+        /// Execute the task.\n+        /// </summary>\n+        public override bool Execute()\n+        {\n+            var assembliesMetadata = new List<ITaskItem>();\n+            foreach (string assemblyPath in AssemblyPaths)\n+            {\n+                AssemblyInformation assemblyInformation = new(assemblyPath);\n+                AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();\n+\n+                if (attributes != null)\n+                {\n+                    assembliesMetadata.Add(CreateItemWithMetadata(attributes));\n+                }\n+            }\n+\n+            _assembliesMetadata = assembliesMetadata.ToArray();\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// List of assembly paths.\n+        /// </summary>\n+        [Required]\n+        public string[] AssemblyPaths\n+        {\n+            get => _assemblyPaths;\n+\n+            set\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(AssemblyPaths));\n+                _assemblyPaths = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Gets a list of resolved assembly metadata.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssembliesMetadata => _assembliesMetadata;\n+\n+        /// <summary>\n+        /// Sets metadata on the assembly path.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since this is a design-time only target, I wonder if a DT-specific file such as [`Microsoft.Managed.DesignTime.targets`](https://github.com/dotnet/project-system/blob/main/src/Microsoft.VisualStudio.ProjectSystem.Managed/ProjectSystem/DesignTimeTargets/Microsoft.Managed.DesignTime.targets) wouldn't be a better home for it. @drewnoakes, do you think that would be reasonable or is it better to keep CSProj-specific logic here?",
              "createdAt": "2023-10-12T09:09:00Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for COM assemblies\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM referenced wrappers.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - COM assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''\"\n+      Returns=\"@(AssembliesMetadata)\"\n+      DependsOnTargets=\"ResolveComReferences\"\n+        >\n+\n+    <GetAssembliesMetadata\n+          AssembyPaths=\"@(ReferencePath)\"\n+          ContinueOnError=\"$(ContinueOnError)\">\n+\n+      <Output TaskParameter=\"AssembliesMetadata\" ItemName=\"_AssembliesMetadata\"/>\n+\n+    </GetAssembliesMetadata>\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Some questions:\r\n\r\n- Does CSProj not ship its own design-time targets? I assume not, given the question.\r\n- Is .NET Project System guaranteed to be installed everywhere that CSProj is?\r\n- Is CSProj loading the .NET Project System's design time targets already?\u00a0\r\n- Would this data be useful for the .NET Project System too? I don't see the context behind this addition.\r\n\r\nIn general we think of these targets as having a 1:1 correspondence with the binaries we ship. I feel it would be cleaner/safer to put CSProj-specific targets in a CSProj-specific design time targets file, but maybe I'm missing something.",
              "createdAt": "2023-10-12T20:44:15Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for COM assemblies\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM referenced wrappers.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - COM assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''\"\n+      Returns=\"@(AssembliesMetadata)\"\n+      DependsOnTargets=\"ResolveComReferences\"\n+        >\n+\n+    <GetAssembliesMetadata\n+          AssembyPaths=\"@(ReferencePath)\"\n+          ContinueOnError=\"$(ContinueOnError)\">\n+\n+      <Output TaskParameter=\"AssembliesMetadata\" ItemName=\"_AssembliesMetadata\"/>\n+\n+    </GetAssembliesMetadata>\n+",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Thank you. I'll defer to @YuliiaKovalova for authoritative answers. As far as I can tell CSProj doesn't have its own targets.\r\n\r\n(Context: CSProj is currently doing some assembly metadata scanning on the main VS thread. This work is addressing the issue by adding a design-time target+task as a replacement.)",
              "createdAt": "2023-10-13T07:02:42Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for COM assemblies\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM referenced wrappers.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - COM assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''\"\n+      Returns=\"@(AssembliesMetadata)\"\n+      DependsOnTargets=\"ResolveComReferences\"\n+        >\n+\n+    <GetAssembliesMetadata\n+          AssembyPaths=\"@(ReferencePath)\"\n+          ContinueOnError=\"$(ContinueOnError)\">\n+\n+      <Output TaskParameter=\"AssembliesMetadata\" ItemName=\"_AssembliesMetadata\"/>\n+\n+    </GetAssembliesMetadata>\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "To my best knowledge, csproj doesn't have any targets.",
              "createdAt": "2023-10-13T08:38:16Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for COM assemblies\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM referenced wrappers.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - COM assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''\"\n+      Returns=\"@(AssembliesMetadata)\"\n+      DependsOnTargets=\"ResolveComReferences\"\n+        >\n+\n+    <GetAssembliesMetadata\n+          AssembyPaths=\"@(ReferencePath)\"\n+          ContinueOnError=\"$(ContinueOnError)\">\n+\n+      <Output TaskParameter=\"AssembliesMetadata\" ItemName=\"_AssembliesMetadata\"/>\n+\n+    </GetAssembliesMetadata>\n+",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Maybe remove \"COM\" from this comment and add a note that the target is intended to be used only by Visual Studio?",
              "createdAt": "2023-10-13T09:24:09Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for COM assemblies",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't love checking in a binary here. Is it hard to generate at build time? At the very least please detail exactly how you created it and what's special about it.",
              "createdAt": "2023-10-23T17:29:26Z",
              "path": "src/Tasks.UnitTests/TestResources/Assemblies/Custom_COM.dll",
              "diffHunk": "",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I created a simple class library with populated assembly attributes.\r\nLet's discuss it offline too.",
              "createdAt": "2023-10-24T08:57:07Z",
              "path": "src/Tasks.UnitTests/TestResources/Assemblies/Custom_COM.dll",
              "diffHunk": "",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are the changes in this file necessary? We should never run under toolsversion 2.0 or 3.5 in the modern world and I wouldn't expect to need this kind of change.",
              "createdAt": "2023-10-23T17:36:57Z",
              "path": "src/Tasks/Microsoft.Common.overridetasks",
              "diffHunk": "",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "removed",
              "createdAt": "2023-10-24T09:13:55Z",
              "path": "src/Tasks/Microsoft.Common.overridetasks",
              "diffHunk": "",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "new code: can we enable nullable? Or is it painful because of stuff you call?",
              "createdAt": "2023-10-23T17:50:03Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,120 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\r\nit feels like this directive is useless in .net framework, doesn't it?",
              "createdAt": "2023-10-24T09:01:39Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,120 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "No, nullable analysis is a language-level feature that applies to any TF (more or less).",
              "createdAt": "2023-10-26T20:01:44Z",
              "path": "src/Tasks/GetAssembliesMetadata.cs",
              "diffHunk": "@@ -0,0 +1,120 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Globalization;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using Microsoft.Build.Tasks.AssemblyDependency;\n+using Microsoft.Build.Utilities;\n+\n+#nullable disable",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this require opening and rescanning every assembly again, after RAR already did so? Is that avoidable?",
              "createdAt": "2023-10-23T18:19:03Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,112 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specified assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            ASSEMBLYMETADATA asmMeta = new();\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It was a conscious decision to do this in a separate task to avoid bloating RAR and also to mitigate risk by keeping the old and new logic as much 1:1 as possible. It is certainly avoidable and we could explore what it would look like if we moved this work to RAR and eliminated the new task.\r\n\r\n@YuliiaKovalova can you please check if there is overlap between the data calculated here and what's already returned by RAR?",
              "createdAt": "2023-10-27T07:05:54Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,112 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specified assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            ASSEMBLYMETADATA asmMeta = new();\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "For example, now RAR returns this data for mscorlib\r\n![image](https://github.com/dotnet/msbuild/assets/95473390/da50db11-d64c-46e6-a222-724467781de5)\r\nBut we need these attributes too\r\n![image](https://github.com/dotnet/msbuild/assets/95473390/78c2319f-720e-4e2c-a302-85eed837dfab)\r\n",
              "createdAt": "2023-10-27T11:24:00Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,112 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specified assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            ASSEMBLYMETADATA asmMeta = new();\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Discussed offline: ideally there'd be some sharing here but there's not in the current process so this isn't worse and doesn't complicate RAR further.",
              "createdAt": "2023-11-14T21:09:15Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyInformation.cs",
              "diffHunk": "@@ -267,6 +269,112 @@ internal static FrameworkName GetTargetFrameworkAttribute(string path)\n             return false;\n         }\n \n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+        /// <summary>\n+        /// Collects the metadata and attributes for specified assembly.\n+        /// The requested properties are used by legacy project system.\n+        /// </summary>\n+        internal AssemblyAttributes GetAssemblyMetadata()\n+        {\n+            IntPtr asmMetaPtr = IntPtr.Zero;\n+            ASSEMBLYMETADATA asmMeta = new();\n+            try\n+            {\n+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;\n+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this only called explicitly as a DT target?",
              "createdAt": "2023-10-23T18:27:19Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        _GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for assemblies\n+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,\n+    but this target handles all the assembly references from ResolveAssemblyReferences\n+    The target is needed by the Visual Studio legacy project system\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - Resolved assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''\"\n+      Returns=\"@(_AssembliesMetadata)\"\n+      DependsOnTargets=\"ResolveComReferences\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "discuss offline ",
              "createdAt": "2023-10-24T08:47:09Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        _GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for assemblies\n+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,\n+    but this target handles all the assembly references from ResolveAssemblyReferences\n+    The target is needed by the Visual Studio legacy project system\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - Resolved assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''\"\n+      Returns=\"@(_AssembliesMetadata)\"\n+      DependsOnTargets=\"ResolveComReferences\"",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you depend on `ResolveReferences`? I don't understand why one source of references is explicitly `DependsOn` but the other is not.",
              "createdAt": "2023-10-23T18:28:17Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        _GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for assemblies\n+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,\n+    but this target handles all the assembly references from ResolveAssemblyReferences",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "From my understanding, ResolveComReferences defines wrappers for com objects (paths to the assemblies) + ResolveReferences is defined as dependency for the target.\r\n",
              "createdAt": "2023-10-24T08:46:54Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        _GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for assemblies\n+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,\n+    but this target handles all the assembly references from ResolveAssemblyReferences",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The new task is available only in Framework, so this should have a condition--or the task should have a netcore stub that fails with \"this task is not in core\".",
              "createdAt": "2023-10-23T18:34:29Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -48,6 +48,7 @@\n \n   <UsingTask TaskName=\"Microsoft.Build.Tasks.GenerateTrustInfo\"                     AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssemblyIdentity\"                   AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssembliesMetadata\"                 AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "done",
              "createdAt": "2023-10-24T09:13:38Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -48,6 +48,7 @@\n \n   <UsingTask TaskName=\"Microsoft.Build.Tasks.GenerateTrustInfo\"                     AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssemblyIdentity\"                   AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssembliesMetadata\"                 AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The relevant factor here is not \"what TargetFramework is the project building for?\" but \"what TF is _MSBuild running on_?\", so this should be\r\n\r\n```suggestion\r\n  <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssembliesMetadata\"                 AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(MSBuildRuntimeType)' == 'Full'\"/>\r\n```",
              "createdAt": "2023-10-26T20:04:09Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -48,6 +48,7 @@\n \n   <UsingTask TaskName=\"Microsoft.Build.Tasks.GenerateTrustInfo\"                     AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssemblyIdentity\"                   AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.GetAssembliesMetadata\"                 AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework'\"/>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@rainersigwald, could you tell me if it's enough to have this guard here? Or do you think it's better to include it in code too? \r\nThank you!",
              "createdAt": "2023-11-06T14:27:42Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        _GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for assemblies\n+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,\n+    but this target handles all the assembly references from ResolveAssemblyReferences\n+    This target is needed by the Visual Studio legacy project system during design time build only\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - Resolved assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''and '$(DesignTimeBuild)' == 'true' \"",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I think this is fine.",
              "createdAt": "2023-11-06T14:29:31Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3040,6 +3040,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ReferenceComWrappersToCopyLocal Include=\"@(ComReferenceWrappers)\" Condition=\"'%(ComReferenceWrappers.CopyLocal)'!='false'\"/>\n     </ItemGroup>\n \n+  </Target>\n+\n+    <!--\n+    ============================================================\n+                                        _GetAssembliesMetadata\n+\n+    Resolve Assembly attributes for assemblies\n+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,\n+    but this target handles all the assembly references from ResolveAssemblyReferences\n+    This target is needed by the Visual Studio legacy project system during design time build only\n+\n+        [IN]\n+        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.\n+\n+        [OUT]\n+        @(AssembliesMetadata) - Resolved assemblies attributes.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_GetAssembliesMetadata\"\n+      Condition=\"'@(ReferencePath)'!=''and '$(DesignTimeBuild)' == 'true' \"",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}