{
  "number": 9307,
  "title": "Binlogs Redacting support + Binlogs forward-compatibility reading support",
  "body": "Fixes #9147, #9261 and contributes to https://github.com/dotnet/msbuild/issues/8400\r\n\r\nViewer complement PR: https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/732\r\n\r\n### Important\r\nThis contains all changes from\r\n * https://github.com/dotnet/msbuild/pull/9219\r\n * https://github.com/JanKrivanek/msbuild/pull/1\r\n\r\nContext and changes are described in those individual PRs\r\nFeel free to review everything together (this PR), or separately (above 2 PRs) - but not all 3 as you'd be viewing same changes twice\r\n\r\n\r\n**TBD:**\r\n * Tests\r\n   * Simulate the fwd compat scenarios by injecting/removing/altering bytes in memory stream underlying under binlog writer and reader.\r\n   * Test the stream utility classes.\r\n * ~~localize all strings~~ Done\r\n * ~~I'm contemplating adding support for recognizing over-reading and mismatched reading during events deserialization~~ Done\r\n * [TBD for next PR] Usage documentation (when, why and how to handle errors during forward compatible reading)",
  "state": "MERGED",
  "createdAt": "2023-10-05T19:19:03Z",
  "updatedAt": "2024-01-16T18:42:08Z",
  "closedAt": "2024-01-16T18:42:07Z",
  "mergedAt": "2024-01-16T18:42:07Z",
  "additions": 3795,
  "deletions": 471,
  "changedFiles": 40,
  "headRefName": "proto/binlog-events-offsets",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "JanKrivanek"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a54016c8064139183990bda56b7199355b19a1ec",
          "message": "Add embedded content transfering and build events binary equality",
          "committedDate": "2023-11-02T09:34:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1ed8999fe524389589f54f848f6f4715ab91318a",
          "message": "Added support for embedded files; fixing, cleaning",
          "committedDate": "2023-11-02T09:34:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "699e5d44b1f1fb2202f3821f4d0eb184b6a09cb9",
          "message": "Decrease scope where accidentally exposed",
          "committedDate": "2023-11-02T09:34:59Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2a75fb69deaf169e2134765f2460d63c92729d51",
          "message": "Sealing types",
          "committedDate": "2023-11-02T09:34:59Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b83376ec17545381e438ac1e5583384df3c8992",
          "message": "Adjust visibility, add comments",
          "committedDate": "2023-11-02T09:34:59Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1c340eea759d16a307792619259287e7677960c",
          "message": "Cache encoding",
          "committedDate": "2023-11-02T09:34:59Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cdca4e823b85f8ca92e256ed0e6b62a86a116e5d",
          "message": "Fix code after merge",
          "committedDate": "2023-11-02T09:35:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c8bf570f1fb4755a43897d895197315a3ace66c1",
          "message": "Fix after merge",
          "committedDate": "2023-11-02T09:35:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b51f32078994d91f82d85a741e21afa6d5d2901d",
          "message": "Add Binlog BuildEvents offsets for forward compatibility and event buffers reading",
          "committedDate": "2023-11-02T09:35:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5ae9bb100c5ebacedb39a7ad708f920a025d8d06",
          "message": "Add tests and fixes for forward compatibility reading",
          "committedDate": "2023-11-02T09:35:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4726733acf7f4f49631329dad52e7e395bcb1d02",
          "message": "Bugfix failing tests",
          "committedDate": "2023-11-02T09:35:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4e72f67ebf29faf695f569b3f13543c07ee8a5e",
          "message": "Adjust unit test to compare unpacked binlogs",
          "committedDate": "2023-11-02T09:35:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d947b8544bfdca1fde5f660e6197b57a9e15d8f",
          "message": "Add version description",
          "committedDate": "2023-11-02T09:35:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd6b0ada030ea2d8c19154bad5c1ad25cf9b145e",
          "message": "Reflecting PR comments",
          "committedDate": "2023-11-02T09:35:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d2317eb2868e1c0799116d75b428ceecddf30f7",
          "message": "Add support for minimum supported reader version",
          "committedDate": "2023-11-02T09:35:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "651ab345ed0c7c64aef6bb4ab154decc68a0d3c3",
          "message": "Support ProjectImports=ZipFile in Replay mode",
          "committedDate": "2023-11-02T09:35:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "37f74fb3b92db8c37eef453cd4a5630e47f46e7b",
          "message": "Add more granular error information about recoverable errors",
          "committedDate": "2023-11-02T09:35:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "07411676b2c1c486a76cab5b571a2a68fbd0afa4",
          "message": "Fix tests",
          "committedDate": "2023-11-02T09:35:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d328c4269d8598d8f828c02674b5983c52a01f8b",
          "message": "Localizing strings",
          "committedDate": "2023-11-02T09:35:03Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79339e148e8b0c36520d79b8b34d44d471a735f0",
          "message": "Add tests and documentation for the forward compatibility reading",
          "committedDate": "2023-11-02T09:35:03Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c2f863ad2cc568897e58901714f3d809d15171c",
          "message": "Reflect review comments",
          "committedDate": "2023-11-02T09:35:04Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ab7ca514ef92d1bb0d8642333271236101c5f902",
          "message": "Add/Improve tests",
          "committedDate": "2023-11-02T09:35:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b57002e4ca17a3b00ecfb037d75d666f6d69d16",
          "message": "Fix test",
          "committedDate": "2023-11-02T09:35:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb20a69aedf6439c4c58a19d7b9c38ea573fe495",
          "message": "Improve test",
          "committedDate": "2023-11-02T09:35:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cfae1f7ec66c8f4f392587885f77f6bdf8237fae",
          "message": "Reflect code review comments",
          "committedDate": "2023-11-02T09:35:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4fa413a9c2110242e0c4c92523ed835b52e5cd89",
          "message": "Comment removal",
          "committedDate": "2023-11-02T09:35:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88c1113823e366b0e92d13a046575492c6627704",
          "message": "Auto-apply suggestions from code review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-11-02T09:35:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f3b208896918146014ae5a18fdcc3d708d8353f4",
          "message": "Apply code review suggestions",
          "committedDate": "2023-11-02T09:35:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d9eed778d0e0f8d3214a01499f21202aa02b811e",
          "message": "Rework and simplify the ArchiveFile OM and event",
          "committedDate": "2023-11-02T09:35:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9b2cbc29f0f580dc4b2ce0967ed320e04c563054",
          "message": "Clarified comment",
          "committedDate": "2023-11-02T09:35:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "330f842a9958deb25b022553b522f543bd75b060",
          "message": "Improve documenting comments",
          "committedDate": "2023-11-02T09:35:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3b1e76baa078796869f086ec59efeaa07fa8f7eb",
          "message": "Shouldly update adjust",
          "committedDate": "2023-11-02T09:40:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3e175ef638cec1db5392b5498da33fd7f5f9f8ac",
          "message": "Reflect review comments",
          "committedDate": "2023-11-03T11:25:16Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "709cdacfad342efe5372be5a6dc3fe2fbdc901a7",
          "message": "Fix issues after integrating with redactor",
          "committedDate": "2023-11-14T17:34:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4e2af43a335ae27ef97a0be9817a5c0d695d6489",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-11-14T17:46:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2a65f64d7dbd9f0bf09e95a667bf4ce821129771",
          "message": "Merge branch 'proto/binlog-events-offsets' of https://github.com/JanKrivanek/msbuild into proto/binlog-events-offsets",
          "committedDate": "2023-11-14T17:46:26Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "986b2f244c6edef515f177e0d1b4e26a314c227e",
          "message": "Reflect PR comments",
          "committedDate": "2023-11-14T20:33:50Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8ae922ba4c5ef45b830df725ccd5a5df22c790ae",
          "message": "Reflect PR feedback",
          "committedDate": "2023-11-15T14:55:47Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7655a081ebb0a75f92e2abb042e30389c989bb88",
          "message": "Merge remote-tracking branch 'upstream/main' into proto/binlog-events-offsets",
          "committedDate": "2023-11-23T11:25:04Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95cada7580320b585e43d99d67ed65a6b982ce28",
          "message": "Regenerate resources",
          "committedDate": "2023-11-23T11:28:42Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2e8df1877a9f523d284aac64f674ba7460181c23",
          "message": "Add suppressions for extending the newly introduced interface",
          "committedDate": "2023-11-23T11:34:27Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f5c654bd82352692fa6ebf15fa937bb627a95fbf",
          "message": "Reflect PR commnets",
          "committedDate": "2023-11-23T13:47:04Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c19bfd3fae419259e5251ce480f6ac22b156571",
          "message": "Bugfixes",
          "committedDate": "2023-11-23T19:19:42Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb7696e457c9efa07d487c5a89d1bc0b7b5f7179",
          "message": "Fix log wording",
          "committedDate": "2023-12-08T16:59:35Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "61e933de5228a0946dab6c8359618ab68ed044d5",
          "message": "Cleaning up the api (with single batch of breaking changes in the feature)",
          "committedDate": "2023-12-08T17:32:57Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb7933a5c6a6d300ea7d265ee6d289c29c528a27",
          "message": "Preserve version on raw events replay",
          "committedDate": "2023-12-11T13:26:40Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "03012249468704e414c422b3cf16b992632252f3",
          "message": "Reflecting PR comments",
          "committedDate": "2023-12-21T12:12:57Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3c73e156f3c03ba4fbeffebc4288878b62849839",
          "message": "Merge remote-tracking branch 'upstream/main' into proto/binlog-events-offsets",
          "committedDate": "2023-12-21T12:14:19Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fce1a779e87aa2592b2457d3c7b296992592ec4c",
          "message": "Reintroduce suppressions for the binlog forward compatible reading API",
          "committedDate": "2023-12-21T12:16:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b97a0806302945a2413b1f57c58127baab56d76d",
          "message": "Fix raw replay and redact perf",
          "committedDate": "2023-12-27T20:25:13Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ad4bf54536376a555bf2dbd842a5a23efdaf5f27",
          "message": "Forward compatible reading is off by default",
          "committedDate": "2024-01-09T18:04:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "38f57916d463906d36be4302e4950b22156ea44c",
          "message": "Bugfix the reading of old version of logs",
          "committedDate": "2024-01-11T11:19:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Is there a design doc or some overview of what the redactor does - it sounds interesting? \r\nEg., does it attempt to discover security tokens and suchlike, as Github does? It would only be defense in depth as it can never be perfect.",
        "createdAt": "2023-10-11T18:37:10Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "> Is there a design doc or some overview of what the redactor does - it sounds interesting? Eg., does it attempt to discover security tokens and suchlike, as Github does? It would only be defense in depth as it can never be perfect.\r\n\r\nHi @danmoseley,\r\n\r\nDesign proposal of redactor is located here: https://github.com/JanKrivanek/MSBuildBinlogRedactor/blob/main/docs/DesignProposal.md (ultimate long term wishful plan is here https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/security-metadata.md)\r\nAutodetections are in plan - so far we have just some PoC samples - couple token types detector (https://github.com/JanKrivanek/MSBuildBinlogRedactor/blob/main/src/Microsoft.Build.SensitiveDataDetector/PatternsDetector.cs) and username detector (https://github.com/JanKrivanek/MSBuildBinlogRedactor/blob/main/src/Microsoft.Build.SensitiveDataDetector/UsernameDetector.cs). But @michaelcfanning wants to contribute some more comprehensive logic they have been using in 1ES. Plus I'm trying to get CredScan team to OSS their client side library for textual data classification",
        "createdAt": "2023-10-11T19:02:16Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Jan, I can't reach these files. :)\r\n\r\n---\r\nIn reply to: [1758337727](https://github.com/dotnet/msbuild/pull/9307#issuecomment-1758337727) [](http://example.com/codeflow?ancestors=1758337727)",
        "createdAt": "2023-11-15T15:53:55Z",
        "author": {
          "login": "michaelcfanning"
        }
      },
      {
        "body": "Sorry I'm late to this review, overall I think things look good. It's high praise from me for a change of this magnitude ;)\r\n\r\nA few minor and subjective impressions.\r\n\r\nMost importantly, both the previous designs and this current one seem heavy with fine-grained interfaces which I don't think are necessary. Your primary hint that an interface is not necessary is that it only has a single implementation. Another one is that no one is actually using the interface. I haven't dug deep, but at first glance `IRawLogEventsSource` seems not justified and could be removed. `IBuildEventArgsReaderNotifications` seems fine. `IEmbeddedContentSource` seems unnecessary.\r\n\r\nI personally don't see a ton of value in localizing these types of exceptions, but since the work is already done, might as well leave it.",
        "createdAt": "2023-12-17T23:51:05Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "One other thought I had that's not necessarily for this PR, but somewhat related. Right now all binlog files start with `1F 8B 08` which is the GZip stream signature bytes (08 indicating Deflate compression). If we change the compression method for the outer stream at some point in the future, the envelope format will likely have a different signature. Long term I'd love to investigate Zstd or Lzma compression, I remember I saw more than 2x improvement in binlog sizes when I uncompressed Gzip/Deflate and recompressed with 7-Zip.\r\n\r\nWondering if we could prepare for that future today by gracefully showing a message if the binlog file doesn't start with `1F 8B 08`.\r\n\r\nCurrently we handle it relatively well:\r\n`There was an exception while reading the log file: Found invalid data while decoding.` Wondering if there's anything else we can do here, or probably not?",
        "createdAt": "2023-12-18T00:49:32Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov - thank you for review! (here and in StructuredLogger as well - both requiring significant time from your side)\r\n\r\n* Yes - I have a special feeling for fine grained interfaces. You are the second one to point that out on this PR (in different circumstance, but still the same idea) - so I know where is the problem :-) So I consolidated into the single one.\r\n\r\n* GZip vs other compressions check - good idea! Though this PR feels loaded already. I've spun that off as https://github.com/dotnet/msbuild/issues/9567\r\n\r\n* Fwd-compat by default or not - I'm curious of what you'd think about having it opt-in initially, then switch to opt-out after at least on full preview.",
        "createdAt": "2023-12-21T12:11:20Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Very nice, I made a local change on top of this PR to change the file format version to 19 and added a junk field to the end of ProjectStartedEventArgs, then opened the resulting binlog in the viewer and it was still able to open the binlog and show the error message:\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/679326/9a001865-a5dd-4033-9e14-10a77c397b57)\r\n",
        "createdAt": "2024-01-09T03:21:59Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I published the viewer update here:\r\nhttps://github.com/KirillOsenkov/MSBuildStructuredLog/releases/tag/v2.2.155\r\n\r\nThe NuGet package here:\r\nhttps://www.nuget.org/packages/MSBuild.StructuredLogger/2.2.155\r\n\r\nThe binlogtool here:\r\nhttps://www.nuget.org/packages/binlogtool/1.0.10\r\n\r\nLet's proactively test these and maybe send some PRs to Arcade, Roslyn, Maui and a few other repos to get some testing. Then when we do bump the format to 18 and 18 binlogs start to come out we won't break too many people. Both nuget.org and github now can show projects/packages that depend on MSBuild.StructuredLogger NuGet.",
        "createdAt": "2024-01-09T03:39:15Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "binlogtool seems to be working too:\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/679326/903c70d0-fa6d-49b8-aef9-474ccbb845bf)\r\n",
        "createdAt": "2024-01-09T03:44:00Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Interesting, I forgot to update the reader to read the junk byte I added, and I got a decently nice error message:\r\n![image](https://github.com/dotnet/msbuild/assets/679326/6dbacaaf-7b01-4f3e-bbb9-f6c2512afa53)",
        "createdAt": "2024-01-09T03:48:20Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Is this the behavior we want/expect when we don't opt in MSBuild to be forward compatible by default?",
        "createdAt": "2024-01-09T04:00:17Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> Is this the behavior we want/expect when we don't opt in MSBuild to be forward compatible by default?\r\n\r\nI suppose the junk byte was added without increasing the version - correct? Then it's expected - we still crash, but more gracefully.",
        "createdAt": "2024-01-09T13:11:58Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "No, I increased the version",
        "createdAt": "2024-01-09T15:51:18Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> No, I increased the version\r\n\r\nThanks @KirillOsenkov - good catch! Not expected indeed! - all the forward compatible flags (allow reading higher version, allow skipping unknown events, allow skiping unknown data in known events) should have same default setting - there was one (allow reading higher version) which was permitted by default - fixed now",
        "createdAt": "2024-01-09T18:07:11Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Let's not merge until the linked PRs are merged (to minimize breaking internal teams)",
        "createdAt": "2024-01-11T11:20:08Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this only difference with next `case BinlogRoundtripTestReplayMode.RawEvents:` If so pls consider some code reuse.",
              "createdAt": "2023-10-09T13:34:06Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -110,6 +122,44 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n                 project.Build(new ILogger[] { binaryLogger, mockLogFromBuild, serialFromBuild, parallelFromBuild }).ShouldBeTrue();\n             }\n \n+            string fileToReplay;\n+            switch (replayMode)\n+            {\n+                case BinlogRoundtripTestReplayMode.NoReplay:\n+                    fileToReplay = _logFile;\n+                    break;\n+                case BinlogRoundtripTestReplayMode.Structured:\n+                    {\n+                        var logReader = new BinaryLogReplayEventSource();\n+                        fileToReplay = _env.ExpectFile(\".binlog\").Path;\n+                        // need dummy handler to force structured replay\n+                        logReader.BuildFinished += (_, _) => { };",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "unified",
              "createdAt": "2023-10-10T19:48:12Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -110,6 +122,44 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n                 project.Build(new ILogger[] { binaryLogger, mockLogFromBuild, serialFromBuild, parallelFromBuild }).ShouldBeTrue();\n             }\n \n+            string fileToReplay;\n+            switch (replayMode)\n+            {\n+                case BinlogRoundtripTestReplayMode.NoReplay:\n+                    fileToReplay = _logFile;\n+                    break;\n+                case BinlogRoundtripTestReplayMode.Structured:\n+                    {\n+                        var logReader = new BinaryLogReplayEventSource();\n+                        fileToReplay = _env.ExpectFile(\".binlog\").Path;\n+                        // need dummy handler to force structured replay\n+                        logReader.BuildFinished += (_, _) => { };",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please document/comment why is round trip needed and possible consequences of breaking it.\r\nThis info might be of use for future devs if/when this test fails to make informed decision.",
              "createdAt": "2023-10-09T13:40:31Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +193,303 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this intentional? If so, please document the intent here.",
              "createdAt": "2023-10-09T13:42:08Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs",
              "diffHunk": "@@ -24,7 +24,7 @@ internal enum BinaryLogRecordKind\n         ProjectEvaluationStarted,\n         ProjectEvaluationFinished,\n         ProjectImported,\n-        ProjectImportArchive,\n+        ProjectImportArchive = 17,",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Removed",
              "createdAt": "2023-10-10T18:30:50Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs",
              "diffHunk": "@@ -24,7 +24,7 @@ internal enum BinaryLogRecordKind\n         ProjectEvaluationStarted,\n         ProjectEvaluationFinished,\n         ProjectImported,\n-        ProjectImportArchive,\n+        ProjectImportArchive = 17,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I believe we will need something like \"backward-compatible-with-reader-version\" constant written in binlog. \r\nIt will indicate what is minimum required version of binlog reader/viewer. At some point in future we might need to create change in binlog which is no longer backward compatible, like for example (for sake data size), removing event fields. We can either deal with it in future, or prepare for in in this PR, but I would recommend to include it here, otherwise we would be blocked to do binlog breaking changes without actually breaking users with \"undefined\" behavior.\r\nPlease consider above.",
              "createdAt": "2023-10-09T13:59:48Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -59,24 +93,65 @@ public static BinaryReader OpenReader(string sourceFilePath)\n                 // and the max throughput is reached with a 32K buffer. See details here:\n                 // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847\n                 var bufferedStream = new BufferedStream(gzipStream, 32768);\n-                return new BinaryReader(bufferedStream);\n+                return new BinaryReader(bufferedStream.ToReadableSeekableStream());\n             }\n-            catch(Exception)\n+            catch (Exception)\n             {\n                 stream?.Dispose();\n                 throw;\n             }\n         }\n \n+        /// <summary>\n+        /// Creates a <see cref=\"BuildEventArgsReader\"/> for the provided binary reader over binary log file.\n+        /// Caller is responsible for disposing the returned reader.\n+        /// </summary>\n+        /// <param name=\"binaryReader\"></param>\n+        /// <param name=\"closeInput\">Indicates whether the passed BinaryReader should be closed on disposing.</param>\n+        /// <param name=\"allowForwardCompatibility\">Unknown build events or unknown parts of known build events will be ignored if this is set to true.</param>\n+        /// <param name=\"onRecoverableReadError\">Optional handler of recoverable errors during reading.</param>\n+        /// <returns>BuildEventArgsReader over the given binlog file binary reader.</returns>\n+        public static BuildEventArgsReader OpenBuildEventsReader(\n+            BinaryReader binaryReader,\n+            bool closeInput,\n+            bool allowForwardCompatibility = true,\n+            Action<string>? onRecoverableReadError = null)\n+        {\n+            int fileFormatVersion = binaryReader.ReadInt32();\n+\n+            // the log file is written using a newer version of file format\n+            // that we don't know how to read\n+            if (!allowForwardCompatibility && fileFormatVersion > BinaryLogger.FileFormatVersion)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Perfect catch!\r\n\r\nAdded",
              "createdAt": "2023-10-10T20:27:40Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -59,24 +93,65 @@ public static BinaryReader OpenReader(string sourceFilePath)\n                 // and the max throughput is reached with a 32K buffer. See details here:\n                 // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847\n                 var bufferedStream = new BufferedStream(gzipStream, 32768);\n-                return new BinaryReader(bufferedStream);\n+                return new BinaryReader(bufferedStream.ToReadableSeekableStream());\n             }\n-            catch(Exception)\n+            catch (Exception)\n             {\n                 stream?.Dispose();\n                 throw;\n             }\n         }\n \n+        /// <summary>\n+        /// Creates a <see cref=\"BuildEventArgsReader\"/> for the provided binary reader over binary log file.\n+        /// Caller is responsible for disposing the returned reader.\n+        /// </summary>\n+        /// <param name=\"binaryReader\"></param>\n+        /// <param name=\"closeInput\">Indicates whether the passed BinaryReader should be closed on disposing.</param>\n+        /// <param name=\"allowForwardCompatibility\">Unknown build events or unknown parts of known build events will be ignored if this is set to true.</param>\n+        /// <param name=\"onRecoverableReadError\">Optional handler of recoverable errors during reading.</param>\n+        /// <returns>BuildEventArgsReader over the given binlog file binary reader.</returns>\n+        public static BuildEventArgsReader OpenBuildEventsReader(\n+            BinaryReader binaryReader,\n+            bool closeInput,\n+            bool allowForwardCompatibility = true,\n+            Action<string>? onRecoverableReadError = null)\n+        {\n+            int fileFormatVersion = binaryReader.ReadInt32();\n+\n+            // the log file is written using a newer version of file format\n+            // that we don't know how to read\n+            if (!allowForwardCompatibility && fileFormatVersion > BinaryLogger.FileFormatVersion)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "To me, this naming is little misleading. I expected the \"slice of data\" be of different size than event fragment.\r\nIf it is always exactly one event, please consider naming which implies it, like for example \"RawEventReceived\"",
              "createdAt": "2023-10-09T14:10:29Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -11,12 +11,41 @@\n \n namespace Microsoft.Build.Logging\n {\n+    internal interface IRawLogEventsSource\n+    {\n+        /// <summary>\n+        /// Event raised when non-textual log record is read.\n+        /// This means all event args and key-value pairs.\n+        /// Strings and Embedded files are not included.\n+        /// </summary>\n+        event Action<BinaryLogRecordKind, Stream>? LogDataSliceReceived;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Renamed (`RawLogRecordReceived`)",
              "createdAt": "2023-10-10T19:54:26Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -11,12 +11,41 @@\n \n namespace Microsoft.Build.Logging\n {\n+    internal interface IRawLogEventsSource\n+    {\n+        /// <summary>\n+        /// Event raised when non-textual log record is read.\n+        /// This means all event args and key-value pairs.\n+        /// Strings and Embedded files are not included.\n+        /// </summary>\n+        event Action<BinaryLogRecordKind, Stream>? LogDataSliceReceived;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: please consider more precise naming of intent \"Fast forward meta records until 1st BuildEventArgs\"",
              "createdAt": "2023-10-09T14:23:45Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -95,12 +169,168 @@ public void Dispose()\n         /// If there are no more records, returns <see langword=\"null\"/>.\n         /// </returns>\n         public BuildEventArgs? Read()\n+        {\n+            // todo - flip this into a properties - not to check on each call and to avoid params passing\n+            if ((SkipUnknownEvents || SkipUnknownEventParts) && fileFormatVersion < 18)\n+            {\n+                throw new InvalidOperationException(\n+                    $\"Forward compatible reading is not supported for file format version {fileFormatVersion} (needs >=18).\");\n+            }\n+\n+            BuildEventArgs? result = null;\n+            while (result == null)\n+            {\n+                BinaryLogRecordKind recordKind = ReadTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n+                {\n+                    return null;\n+                }\n+\n+                int serializedEventLength = 0;\n+                long preEventPosition = 0;\n+                if (fileFormatVersion >= 18)\n+                {\n+                    serializedEventLength = ReadInt32(); // record length\n+                    preEventPosition = _canSeek ? binaryReader.BaseStream.Position : 0;\n+                }\n+\n+                switch (recordKind)\n+                {\n+                    case BinaryLogRecordKind.BuildStarted:\n+                        result = ReadBuildStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.BuildFinished:\n+                        result = ReadBuildFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectStarted:\n+                        result = ReadProjectStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectFinished:\n+                        result = ReadProjectFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetStarted:\n+                        result = ReadTargetStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetFinished:\n+                        result = ReadTargetFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskStarted:\n+                        result = ReadTaskStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskFinished:\n+                        result = ReadTaskFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Error:\n+                        result = ReadBuildErrorEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Warning:\n+                        result = ReadBuildWarningEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Message:\n+                        result = ReadBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.CriticalBuildMessage:\n+                        result = ReadCriticalBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskCommandLine:\n+                        result = ReadTaskCommandLineEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskParameter:\n+                        result = ReadTaskParameterEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationStarted:\n+                        result = ReadProjectEvaluationStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationFinished:\n+                        result = ReadProjectEvaluationFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectImported:\n+                        result = ReadProjectImportedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetSkipped:\n+                        result = ReadTargetSkippedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.EnvironmentVariableRead:\n+                        result = ReadEnvironmentVariableReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ResponseFileUsed:\n+                        result = ReadResponseFileUsedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyReassignment:\n+                        result = ReadPropertyReassignmentEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.UninitializedPropertyRead:\n+                        result = ReadUninitializedPropertyReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyInitialValueSet:\n+                        result = ReadPropertyInitialValueSetEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.AssemblyLoad:\n+                        result = ReadAssemblyLoadEventArgs();\n+                        break;\n+                    default:\n+                        OnRecoverableReadError?.Invoke(\n+                            $\"BuildEvent record number {recordNumber} (serialized size: {serializedEventLength}) is of unsupported type: {recordKind}.{(SkipUnknownEvents ? \" Skipping it.\" : string.Empty)}\");\n+                        if (SkipUnknownEvents && serializedEventLength > 0)\n+                        {\n+                            SkipBytes(serializedEventLength);\n+                        }\n+                        else\n+                        {\n+                            return null;\n+                        }\n+                        break;\n+                }\n+\n+                if (fileFormatVersion >= 18)\n+                {\n+                    long postEventPosition = _canSeek ? binaryReader.BaseStream.Position : serializedEventLength;\n+                    int bytesRead = (int)(postEventPosition - preEventPosition);\n+                    if (bytesRead != serializedEventLength)\n+                    {\n+                        string error =\n+                            $\"BuildEvent record number {recordNumber} was expected to read exactly {serializedEventLength} bytes from the stream, but read {bytesRead} instead.\";\n+\n+                        if (SkipUnknownEventParts && bytesRead < serializedEventLength)\n+                        {\n+                            OnRecoverableReadError?.Invoke(error);\n+                            SkipBytes(serializedEventLength - bytesRead);\n+                        }\n+                        else\n+                        {\n+                            throw new InvalidDataException(error);\n+                        }\n+                    }\n+                }\n+\n+                recordNumber += 1;\n+            }\n+\n+            return result;\n+        }\n+\n+        private void SkipBytes(int count)\n+        {\n+            if (_canSeek)\n+            {\n+                binaryReader.BaseStream.Seek(count, SeekOrigin.Current);\n+            }\n+            else\n+            {\n+                byte[] buffer = ArrayPool<byte>.Shared.Rent(count);\n+                using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));\n+                binaryReader.BaseStream.ReadAtLeast(buffer, 0, count, throwOnEndOfStream: true);\n+            }\n+        }\n+\n+        private BinaryLogRecordKind ReadTillNextEvent(Func<BinaryLogRecordKind, bool> isPreprocessRecord)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "`PreprocessRecordsTillNextEvent`",
              "createdAt": "2023-10-10T19:56:19Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -95,12 +169,168 @@ public void Dispose()\n         /// If there are no more records, returns <see langword=\"null\"/>.\n         /// </returns>\n         public BuildEventArgs? Read()\n+        {\n+            // todo - flip this into a properties - not to check on each call and to avoid params passing\n+            if ((SkipUnknownEvents || SkipUnknownEventParts) && fileFormatVersion < 18)\n+            {\n+                throw new InvalidOperationException(\n+                    $\"Forward compatible reading is not supported for file format version {fileFormatVersion} (needs >=18).\");\n+            }\n+\n+            BuildEventArgs? result = null;\n+            while (result == null)\n+            {\n+                BinaryLogRecordKind recordKind = ReadTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n+                {\n+                    return null;\n+                }\n+\n+                int serializedEventLength = 0;\n+                long preEventPosition = 0;\n+                if (fileFormatVersion >= 18)\n+                {\n+                    serializedEventLength = ReadInt32(); // record length\n+                    preEventPosition = _canSeek ? binaryReader.BaseStream.Position : 0;\n+                }\n+\n+                switch (recordKind)\n+                {\n+                    case BinaryLogRecordKind.BuildStarted:\n+                        result = ReadBuildStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.BuildFinished:\n+                        result = ReadBuildFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectStarted:\n+                        result = ReadProjectStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectFinished:\n+                        result = ReadProjectFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetStarted:\n+                        result = ReadTargetStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetFinished:\n+                        result = ReadTargetFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskStarted:\n+                        result = ReadTaskStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskFinished:\n+                        result = ReadTaskFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Error:\n+                        result = ReadBuildErrorEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Warning:\n+                        result = ReadBuildWarningEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Message:\n+                        result = ReadBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.CriticalBuildMessage:\n+                        result = ReadCriticalBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskCommandLine:\n+                        result = ReadTaskCommandLineEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskParameter:\n+                        result = ReadTaskParameterEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationStarted:\n+                        result = ReadProjectEvaluationStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationFinished:\n+                        result = ReadProjectEvaluationFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectImported:\n+                        result = ReadProjectImportedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetSkipped:\n+                        result = ReadTargetSkippedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.EnvironmentVariableRead:\n+                        result = ReadEnvironmentVariableReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ResponseFileUsed:\n+                        result = ReadResponseFileUsedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyReassignment:\n+                        result = ReadPropertyReassignmentEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.UninitializedPropertyRead:\n+                        result = ReadUninitializedPropertyReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyInitialValueSet:\n+                        result = ReadPropertyInitialValueSetEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.AssemblyLoad:\n+                        result = ReadAssemblyLoadEventArgs();\n+                        break;\n+                    default:\n+                        OnRecoverableReadError?.Invoke(\n+                            $\"BuildEvent record number {recordNumber} (serialized size: {serializedEventLength}) is of unsupported type: {recordKind}.{(SkipUnknownEvents ? \" Skipping it.\" : string.Empty)}\");\n+                        if (SkipUnknownEvents && serializedEventLength > 0)\n+                        {\n+                            SkipBytes(serializedEventLength);\n+                        }\n+                        else\n+                        {\n+                            return null;\n+                        }\n+                        break;\n+                }\n+\n+                if (fileFormatVersion >= 18)\n+                {\n+                    long postEventPosition = _canSeek ? binaryReader.BaseStream.Position : serializedEventLength;\n+                    int bytesRead = (int)(postEventPosition - preEventPosition);\n+                    if (bytesRead != serializedEventLength)\n+                    {\n+                        string error =\n+                            $\"BuildEvent record number {recordNumber} was expected to read exactly {serializedEventLength} bytes from the stream, but read {bytesRead} instead.\";\n+\n+                        if (SkipUnknownEventParts && bytesRead < serializedEventLength)\n+                        {\n+                            OnRecoverableReadError?.Invoke(error);\n+                            SkipBytes(serializedEventLength - bytesRead);\n+                        }\n+                        else\n+                        {\n+                            throw new InvalidDataException(error);\n+                        }\n+                    }\n+                }\n+\n+                recordNumber += 1;\n+            }\n+\n+            return result;\n+        }\n+\n+        private void SkipBytes(int count)\n+        {\n+            if (_canSeek)\n+            {\n+                binaryReader.BaseStream.Seek(count, SeekOrigin.Current);\n+            }\n+            else\n+            {\n+                byte[] buffer = ArrayPool<byte>.Shared.Rent(count);\n+                using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));\n+                binaryReader.BaseStream.ReadAtLeast(buffer, 0, count, throwOnEndOfStream: true);\n+            }\n+        }\n+\n+        private BinaryLogRecordKind ReadTillNextEvent(Func<BinaryLogRecordKind, bool> isPreprocessRecord)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It is little bit inconsistent. Here, we raise `OnRecoverableReadErro` even if it is not recoverable while bellow we only throw exception and not raise it. I think we can consider to raise error also before we throw that InvalidDataException",
              "createdAt": "2023-10-09T14:30:47Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -95,12 +169,168 @@ public void Dispose()\n         /// If there are no more records, returns <see langword=\"null\"/>.\n         /// </returns>\n         public BuildEventArgs? Read()\n+        {\n+            // todo - flip this into a properties - not to check on each call and to avoid params passing\n+            if ((SkipUnknownEvents || SkipUnknownEventParts) && fileFormatVersion < 18)\n+            {\n+                throw new InvalidOperationException(\n+                    $\"Forward compatible reading is not supported for file format version {fileFormatVersion} (needs >=18).\");\n+            }\n+\n+            BuildEventArgs? result = null;\n+            while (result == null)\n+            {\n+                BinaryLogRecordKind recordKind = ReadTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n+                {\n+                    return null;\n+                }\n+\n+                int serializedEventLength = 0;\n+                long preEventPosition = 0;\n+                if (fileFormatVersion >= 18)\n+                {\n+                    serializedEventLength = ReadInt32(); // record length\n+                    preEventPosition = _canSeek ? binaryReader.BaseStream.Position : 0;\n+                }\n+\n+                switch (recordKind)\n+                {\n+                    case BinaryLogRecordKind.BuildStarted:\n+                        result = ReadBuildStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.BuildFinished:\n+                        result = ReadBuildFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectStarted:\n+                        result = ReadProjectStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectFinished:\n+                        result = ReadProjectFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetStarted:\n+                        result = ReadTargetStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetFinished:\n+                        result = ReadTargetFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskStarted:\n+                        result = ReadTaskStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskFinished:\n+                        result = ReadTaskFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Error:\n+                        result = ReadBuildErrorEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Warning:\n+                        result = ReadBuildWarningEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Message:\n+                        result = ReadBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.CriticalBuildMessage:\n+                        result = ReadCriticalBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskCommandLine:\n+                        result = ReadTaskCommandLineEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskParameter:\n+                        result = ReadTaskParameterEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationStarted:\n+                        result = ReadProjectEvaluationStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationFinished:\n+                        result = ReadProjectEvaluationFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectImported:\n+                        result = ReadProjectImportedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetSkipped:\n+                        result = ReadTargetSkippedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.EnvironmentVariableRead:\n+                        result = ReadEnvironmentVariableReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ResponseFileUsed:\n+                        result = ReadResponseFileUsedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyReassignment:\n+                        result = ReadPropertyReassignmentEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.UninitializedPropertyRead:\n+                        result = ReadUninitializedPropertyReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyInitialValueSet:\n+                        result = ReadPropertyInitialValueSetEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.AssemblyLoad:\n+                        result = ReadAssemblyLoadEventArgs();\n+                        break;\n+                    default:\n+                        OnRecoverableReadError?.Invoke(",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I'll try to be brave and will go the other way - the `OnRecoverableReadError` is only raised when we can continue. Exception is thrown otherwise. Allways. That means we break the scenario where unknown events lead to simple end of reading (returning of null) - which is dangerous and I believe incorrect behavior.\r\nIt might break few of our tests (then will then need to set the forwardCompatibility flag) that uses this for some reason. But other than that it should not break sane scenario.\r\n\r\nThoughts?",
              "createdAt": "2023-10-10T20:03:12Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -95,12 +169,168 @@ public void Dispose()\n         /// If there are no more records, returns <see langword=\"null\"/>.\n         /// </returns>\n         public BuildEventArgs? Read()\n+        {\n+            // todo - flip this into a properties - not to check on each call and to avoid params passing\n+            if ((SkipUnknownEvents || SkipUnknownEventParts) && fileFormatVersion < 18)\n+            {\n+                throw new InvalidOperationException(\n+                    $\"Forward compatible reading is not supported for file format version {fileFormatVersion} (needs >=18).\");\n+            }\n+\n+            BuildEventArgs? result = null;\n+            while (result == null)\n+            {\n+                BinaryLogRecordKind recordKind = ReadTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n+                {\n+                    return null;\n+                }\n+\n+                int serializedEventLength = 0;\n+                long preEventPosition = 0;\n+                if (fileFormatVersion >= 18)\n+                {\n+                    serializedEventLength = ReadInt32(); // record length\n+                    preEventPosition = _canSeek ? binaryReader.BaseStream.Position : 0;\n+                }\n+\n+                switch (recordKind)\n+                {\n+                    case BinaryLogRecordKind.BuildStarted:\n+                        result = ReadBuildStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.BuildFinished:\n+                        result = ReadBuildFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectStarted:\n+                        result = ReadProjectStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectFinished:\n+                        result = ReadProjectFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetStarted:\n+                        result = ReadTargetStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetFinished:\n+                        result = ReadTargetFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskStarted:\n+                        result = ReadTaskStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskFinished:\n+                        result = ReadTaskFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Error:\n+                        result = ReadBuildErrorEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Warning:\n+                        result = ReadBuildWarningEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.Message:\n+                        result = ReadBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.CriticalBuildMessage:\n+                        result = ReadCriticalBuildMessageEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskCommandLine:\n+                        result = ReadTaskCommandLineEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TaskParameter:\n+                        result = ReadTaskParameterEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationStarted:\n+                        result = ReadProjectEvaluationStartedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectEvaluationFinished:\n+                        result = ReadProjectEvaluationFinishedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ProjectImported:\n+                        result = ReadProjectImportedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.TargetSkipped:\n+                        result = ReadTargetSkippedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.EnvironmentVariableRead:\n+                        result = ReadEnvironmentVariableReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.ResponseFileUsed:\n+                        result = ReadResponseFileUsedEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyReassignment:\n+                        result = ReadPropertyReassignmentEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.UninitializedPropertyRead:\n+                        result = ReadUninitializedPropertyReadEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.PropertyInitialValueSet:\n+                        result = ReadPropertyInitialValueSetEventArgs();\n+                        break;\n+                    case BinaryLogRecordKind.AssemblyLoad:\n+                        result = ReadAssemblyLoadEventArgs();\n+                        break;\n+                    default:\n+                        OnRecoverableReadError?.Invoke(",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Intentional whitespace change?",
              "createdAt": "2023-10-12T12:47:24Z",
              "path": "src/Build/CompatibilitySuppressions.xml",
              "diffHunk": "@@ -1,4 +1,4 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->\n <Suppressions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n-</Suppressions>\n+</Suppressions>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty line.",
              "createdAt": "2023-10-17T11:55:38Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -34,12 +34,30 @@ internal class ProjectImportsCollector\n         // this will form a chain of file write tasks, running sequentially on a background thread\n         private Task _currentTask = Task.CompletedTask;\n \n-        public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension = \".ProjectImports.zip\")\n+        internal static void FlushBlobToFile(\n+            string logFilePath,\n+            Stream contentStream)\n+        {\n+            string archiveFilePath = GetArchiveFilePath(logFilePath, DefaultSourcesArchiveExtension);\n+\n+            using var fileStream = new FileStream(archiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);\n+            contentStream.CopyTo(fileStream);\n+        }\n+\n+        // Archive file will be stored alongside the binlog\n+        private static string GetArchiveFilePath(string logFilePath, string sourcesArchiveExtension)\n+            => Path.ChangeExtension(logFilePath, sourcesArchiveExtension);\n+        ",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra space after `//`.",
              "createdAt": "2023-10-17T12:01:37Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -122,61 +155,82 @@ public void AddFileFromMemory(string filePath, string data)\n         private void AddFileCore(string filePath)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n-            if (_processedFiles.Contains(filePath))\n+            if (!ShouldAddFile(ref filePath, true, true))\n             {\n                 return;\n             }\n \n-            if (!File.Exists(filePath))\n+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n+            AddFileData(filePath, content, null);\n+        }\n+\n+        /// <remarks>\n+        /// This method doesn't need locking/synchronization because it's only called\n+        /// from a task that is chained linearly\n+        /// </remarks>\n+        private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n-                _processedFiles.Add(filePath);\n                 return;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n+            using var content = new MemoryStream(Encoding.UTF8.GetBytes(data));\n+            AddFileData(filePath, content, entryCreationStamp);\n+        }\n \n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+        private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n                 return;\n             }\n \n-            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n-            using Stream entryStream = OpenArchiveEntry(filePath);\n-            content.CopyTo(entryStream);\n+            AddFileData(filePath, data, entryCreationStamp);\n         }\n \n-        /// <remarks>\n-        /// This method doesn't need locking/synchronization because it's only called\n-        /// from a task that is chained linearly\n-        /// </remarks>\n-        private void AddFileFromMemoryCore(string filePath, string data)\n+        private void AddFileData(string filePath, Stream data, DateTimeOffset? entryCreationStamp)\n+        {\n+            using Stream entryStream = OpenArchiveEntry(filePath, entryCreationStamp);\n+            data.CopyTo(entryStream);\n+        }\n+\n+        private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool makeAbsolute)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n             if (_processedFiles.Contains(filePath))\n             {\n-                return;\n+                return false;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n-\n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+            if (checkFileExistence && !File.Exists(filePath))\n             {\n-                return;\n+                _processedFiles.Add(filePath);\n+                return false;\n             }\n \n-            using (Stream entryStream = OpenArchiveEntry(filePath))\n-            using (var content = new MemoryStream(Encoding.UTF8.GetBytes(data)))\n+            // Only make the path absolute if it's request. In the replay scenario, the file entries\n+            //  are read from zip archive - where ':' is stripped and path can then seem relative.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I use the extra space to indicate continuing sentence or paragraph in longer comments. Probably should switch to single space and dividing by extra empty line?\r\n\r\nIn either case - it's superfluous in this specific case - so removing.",
              "createdAt": "2023-10-20T08:55:34Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -122,61 +155,82 @@ public void AddFileFromMemory(string filePath, string data)\n         private void AddFileCore(string filePath)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n-            if (_processedFiles.Contains(filePath))\n+            if (!ShouldAddFile(ref filePath, true, true))\n             {\n                 return;\n             }\n \n-            if (!File.Exists(filePath))\n+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n+            AddFileData(filePath, content, null);\n+        }\n+\n+        /// <remarks>\n+        /// This method doesn't need locking/synchronization because it's only called\n+        /// from a task that is chained linearly\n+        /// </remarks>\n+        private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n-                _processedFiles.Add(filePath);\n                 return;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n+            using var content = new MemoryStream(Encoding.UTF8.GetBytes(data));\n+            AddFileData(filePath, content, entryCreationStamp);\n+        }\n \n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+        private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n                 return;\n             }\n \n-            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n-            using Stream entryStream = OpenArchiveEntry(filePath);\n-            content.CopyTo(entryStream);\n+            AddFileData(filePath, data, entryCreationStamp);\n         }\n \n-        /// <remarks>\n-        /// This method doesn't need locking/synchronization because it's only called\n-        /// from a task that is chained linearly\n-        /// </remarks>\n-        private void AddFileFromMemoryCore(string filePath, string data)\n+        private void AddFileData(string filePath, Stream data, DateTimeOffset? entryCreationStamp)\n+        {\n+            using Stream entryStream = OpenArchiveEntry(filePath, entryCreationStamp);\n+            data.CopyTo(entryStream);\n+        }\n+\n+        private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool makeAbsolute)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n             if (_processedFiles.Contains(filePath))\n             {\n-                return;\n+                return false;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n-\n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+            if (checkFileExistence && !File.Exists(filePath))\n             {\n-                return;\n+                _processedFiles.Add(filePath);\n+                return false;\n             }\n \n-            using (Stream entryStream = OpenArchiveEntry(filePath))\n-            using (var content = new MemoryStream(Encoding.UTF8.GetBytes(data)))\n+            // Only make the path absolute if it's request. In the replay scenario, the file entries\n+            //  are read from zip archive - where ':' is stripped and path can then seem relative.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can the caller absolutize the path before calling this method? `bool ShouldAddFile(string filePath, bool checkFileExistence)` would be a cleaner signature.",
              "createdAt": "2023-10-17T12:07:04Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -122,61 +155,82 @@ public void AddFileFromMemory(string filePath, string data)\n         private void AddFileCore(string filePath)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n-            if (_processedFiles.Contains(filePath))\n+            if (!ShouldAddFile(ref filePath, true, true))\n             {\n                 return;\n             }\n \n-            if (!File.Exists(filePath))\n+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n+            AddFileData(filePath, content, null);\n+        }\n+\n+        /// <remarks>\n+        /// This method doesn't need locking/synchronization because it's only called\n+        /// from a task that is chained linearly\n+        /// </remarks>\n+        private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n-                _processedFiles.Add(filePath);\n                 return;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n+            using var content = new MemoryStream(Encoding.UTF8.GetBytes(data));\n+            AddFileData(filePath, content, entryCreationStamp);\n+        }\n \n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+        private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n                 return;\n             }\n \n-            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n-            using Stream entryStream = OpenArchiveEntry(filePath);\n-            content.CopyTo(entryStream);\n+            AddFileData(filePath, data, entryCreationStamp);\n         }\n \n-        /// <remarks>\n-        /// This method doesn't need locking/synchronization because it's only called\n-        /// from a task that is chained linearly\n-        /// </remarks>\n-        private void AddFileFromMemoryCore(string filePath, string data)\n+        private void AddFileData(string filePath, Stream data, DateTimeOffset? entryCreationStamp)\n+        {\n+            using Stream entryStream = OpenArchiveEntry(filePath, entryCreationStamp);\n+            data.CopyTo(entryStream);\n+        }\n+\n+        private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool makeAbsolute)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I agree it would be cleaner - but it would unfortunately be on an expense of speed or corectness.\r\n\r\nBy pushing the absolutizing to callers, we'd perform this unnecesarily in case a relative path is used and it was already seen previously (all other processing - including absolutizing - is skipped in such case). \r\n\r\nThe other option is to absolutize here once needed, but unconditionaly - But we cannot absolutize all paths as in replay scenario, the paths from the binlog archive seem relative to `Path` utils (stripping of the ':' in path by the `ZipArchive`) and would be wrongly absolutized.\r\n\r\nThe replay scenario is new btw. - as previously we never (incorrectly) replied files from the archive, but instead from the system on which the replay run.",
              "createdAt": "2023-10-20T09:05:58Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -122,61 +155,82 @@ public void AddFileFromMemory(string filePath, string data)\n         private void AddFileCore(string filePath)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n-            if (_processedFiles.Contains(filePath))\n+            if (!ShouldAddFile(ref filePath, true, true))\n             {\n                 return;\n             }\n \n-            if (!File.Exists(filePath))\n+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n+            AddFileData(filePath, content, null);\n+        }\n+\n+        /// <remarks>\n+        /// This method doesn't need locking/synchronization because it's only called\n+        /// from a task that is chained linearly\n+        /// </remarks>\n+        private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n-                _processedFiles.Add(filePath);\n                 return;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n+            using var content = new MemoryStream(Encoding.UTF8.GetBytes(data));\n+            AddFileData(filePath, content, entryCreationStamp);\n+        }\n \n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+        private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n                 return;\n             }\n \n-            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n-            using Stream entryStream = OpenArchiveEntry(filePath);\n-            content.CopyTo(entryStream);\n+            AddFileData(filePath, data, entryCreationStamp);\n         }\n \n-        /// <remarks>\n-        /// This method doesn't need locking/synchronization because it's only called\n-        /// from a task that is chained linearly\n-        /// </remarks>\n-        private void AddFileFromMemoryCore(string filePath, string data)\n+        private void AddFileData(string filePath, Stream data, DateTimeOffset? entryCreationStamp)\n+        {\n+            using Stream entryStream = OpenArchiveEntry(filePath, entryCreationStamp);\n+            data.CopyTo(entryStream);\n+        }\n+\n+        private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool makeAbsolute)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Thank you for the detailed explanation.",
              "createdAt": "2023-10-26T07:03:50Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -122,61 +155,82 @@ public void AddFileFromMemory(string filePath, string data)\n         private void AddFileCore(string filePath)\n         {\n             // quick check to avoid repeated disk access for Exists etc.\n-            if (_processedFiles.Contains(filePath))\n+            if (!ShouldAddFile(ref filePath, true, true))\n             {\n                 return;\n             }\n \n-            if (!File.Exists(filePath))\n+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n+            AddFileData(filePath, content, null);\n+        }\n+\n+        /// <remarks>\n+        /// This method doesn't need locking/synchronization because it's only called\n+        /// from a task that is chained linearly\n+        /// </remarks>\n+        private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n-                _processedFiles.Add(filePath);\n                 return;\n             }\n \n-            filePath = Path.GetFullPath(filePath);\n+            using var content = new MemoryStream(Encoding.UTF8.GetBytes(data));\n+            AddFileData(filePath, content, entryCreationStamp);\n+        }\n \n-            // if the file is already included, don't include it again\n-            if (!_processedFiles.Add(filePath))\n+        private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)\n+        {\n+            // quick check to avoid repeated disk access for Exists etc.\n+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))\n             {\n                 return;\n             }\n \n-            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);\n-            using Stream entryStream = OpenArchiveEntry(filePath);\n-            content.CopyTo(entryStream);\n+            AddFileData(filePath, data, entryCreationStamp);\n         }\n \n-        /// <remarks>\n-        /// This method doesn't need locking/synchronization because it's only called\n-        /// from a task that is chained linearly\n-        /// </remarks>\n-        private void AddFileFromMemoryCore(string filePath, string data)\n+        private void AddFileData(string filePath, Stream data, DateTimeOffset? entryCreationStamp)\n+        {\n+            using Stream entryStream = OpenArchiveEntry(filePath, entryCreationStamp);\n+            data.CopyTo(entryStream);\n+        }\n+\n+        private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool makeAbsolute)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`.",
              "createdAt": "2023-10-17T12:11:16Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Missing space after `if`.",
              "createdAt": "2023-10-17T12:11:43Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Should be moved up to the rest of the field declarations.",
              "createdAt": "2023-10-17T12:15:06Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this throw when attempted to seek backwards?",
              "createdAt": "2023-10-17T12:17:07Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Added check in the SkipBytes code.",
              "createdAt": "2023-10-20T10:26:14Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't believe this matches the documented `Stream` semantics. `Stream.Read` should not throw when requested to read more than what's available. It should read min(count, _available_), up to and including 0 if end of the stream has been reached.",
              "createdAt": "2023-10-17T12:22:28Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This is the most interresting point from the review.\r\nI still believe we want this and it's a legitimate step outside the general baseclass documented use.\r\n\r\n**The motivation:**\r\ntl;dr;: this - https://github.com/dotnet/msbuild/pull/9307/files#diff-3ddd8d601460ba4c5ec2996442f059a2e7c2659c00ac7acd346931434722faddR225\r\nOne of the 'forward compatibility reading' scenarios I want to support is a future change in internal representation of pre-existing BuildEventArgs data type, while such change is not append-only.\r\nIt's possible to detect such change and gracefully point it out and even recover if wished by caller. That can lead to better user experience. One subscenario is when members are removed (or their type changed) from a type in a future revisions. The reader code would then try to read extra data from the `StreamReader` and the easiest way to detect this is by throwing in such case. This is the easiest way of surfacing the broken expectation to the `BuildEventArgsReader`, without the need to cache the last read data (to be able to 'rollback' the over-read attempt).\r\nAlso to be able to recover from over-read attempt, we need to break the attempt before it is performed - otherwise we would lose the data that instead belongs to the next record.\r\n\r\n**Possible Side Effects:**\r\nI believe there are none - as we allways read through `BinaryReader` through which we allways try to read exact amount of bytes (for a given primitive type or for a given size of string).\r\nAlso the behavior is switched on only when explicitly opted in on that stream: https://github.com/dotnet/msbuild/pull/9307/files#diff-844cbc09b4b4aa566826f89cb133e56efc10a7ee54f85f0a98b7d632d5f001b1R59-R62\r\nThe opting-in property should however be very clearly documented (which it is not today).\r\n\r\n**Alternative:**\r\n * Not supporting detection of over-reading\r\n * Implementing custom rollback capable `Stream` or `BinaryReader` - those would just rise some flag after over-reads and then would be able to replay the performed read as if it did not happen. This would require extra caching for each read call.\r\n\r\n**Thoughts?**\r\nDoes the behavior sound acceptable under the presented conditions? Or would you suggest different choice? (roll back capable caching stream? Any other way?)\r\n\r\n",
              "createdAt": "2023-10-18T11:53:57Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "There is one more alternative - replacing the `throw` code with:\r\n\r\n```csharp\r\ncount = (int)(_maxAllowedPosition - _position);\r\n```\r\n\r\nThis will evectively lead to `EndOfStreamException` and rest of logic remains identical (just the catch need to adjust).\r\n\r\nSlight disadvantage is that we cannot pass any custom information with the exception and that we're not able to distinguish true end of stream (corrupted log) and end of substream. Though the true end of stream would trip on the attempt to read the next record type.\r\n\r\n**Does this sound as the proper replacement?**",
              "createdAt": "2023-10-23T11:18:30Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes, adjusting `count` instead of throwing sounds like a good change to me.\r\n\r\n> One subscenario is when members are removed (or their type changed) from a type in a future revisions.\r\n\r\nMy first reaction to this is: Should be super rare and if we really have a good reason to make such changes/overhaul, we would bump min reader version.",
              "createdAt": "2023-10-26T06:27:03Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Understood.\r\n\r\nI agree in the first part (conforming to Stream contracts).\r\n\r\nI disagree with the second part (event format change should lead to reader version increase). The reason being that reader is able to recover gracefully and the API user have the last call in deciding whether such change is breaking for them or not (discussed in the suggested doc: https://github.com/dotnet/msbuild/pull/9307/files#diff-10da6addf61b7431a6e2deb63435f116d5402ebb0532b5ce3c97b54a0438f721R138-R140).\r\n\r\nE.g. if I'd be writing analysis tools that extracts and analyses all errors and warnings - I do not care that `AssemblyLoadedBuildEventArgs` changed its format. Would I have been writting the tool listing all assemblies loaded during the build - it would be breaking for me (but I wouldn't mind if I cannot properly read `BuildWarningEventArgs`).\r\n\r\nThe required reader version should ideally only idnicate major structural changes that would make reader unusable.\r\n",
              "createdAt": "2023-10-26T08:40:16Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "> E.g. if I'd be writing analysis tools that extracts and analyses all errors and warnings - I do not care that AssemblyLoadedBuildEventArgs changed its format. \r\n\r\nThat's a fair point. Although if I have a tool that analyses `AssemblyLoadedBuildEventArgs` and we allow arbitrary modifications to the structure, throwing on an over-read is not guaranteed to help. If we remove a field in one version and then add another field in the next version, the length may be the same but my tool would be reading bogus data.. Basically, my point is that if we really want to allow arbitrary changes and still be forward compatible, we would need the file to include a schema of some sort. Without it it's still best effort (and in this case also against an API semantic convention).",
              "createdAt": "2023-10-26T09:40:03Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Great point on theoretical possibility of colision of format of 2 different versions!\r\nThe documentation needs to be very clear about this.\r\n\r\nI suggest:\r\n * [will update] Let's update the doc to explicitly call out it's a best effort compatibility and refrences update (to match not only the reader version, but the binlog version as well) is allways preferable option.\r\n * [stays as is] MSBuild devs can decide per each OM change if they want to increase required reader version or not.\r\n * [stays as is] API users can decide whether format error is breaking even if reader version supports it.\r\n\r\nDoes that sound acceptable?",
              "createdAt": "2023-10-26T12:08:30Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Sounds good, thank you.",
              "createdAt": "2023-10-26T13:19:47Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Documentation updated.\r\nPlus called out the specific case you brought: https://github.com/dotnet/msbuild/pull/9307/files#diff-10da6addf61b7431a6e2deb63435f116d5402ebb0532b5ce3c97b54a0438f721R170\r\n",
              "createdAt": "2023-10-30T11:53:22Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Missing space after `if`.",
              "createdAt": "2023-10-17T12:22:47Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));\n+            }\n+\n+            int cnt = _stream.Read(buffer, offset, count);\n+            _position += cnt;\n+            return cnt;\n+        }\n+\n+        public override long Seek(long offset, SeekOrigin origin)\n+        {\n+            if(origin != SeekOrigin.Current)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "From the docs:\r\n\r\n\r\n_**InvalidOperationException**\r\nThis exception is thrown in scenarios in which it is generally sometimes possible for the object to perform the requested operation, and the object state determines whether the operation can be performed._\r\n\r\nWould `NotSupportedException` be a better exception type to use?",
              "createdAt": "2023-10-17T12:26:26Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));\n+            }\n+\n+            int cnt = _stream.Read(buffer, offset, count);\n+            _position += cnt;\n+            return cnt;\n+        }\n+\n+        public override long Seek(long offset, SeekOrigin origin)\n+        {\n+            if(origin != SeekOrigin.Current)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_SeekNonOrigin\"));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Same for `SetLength` and `Write` below.",
              "createdAt": "2023-10-17T12:26:50Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));\n+            }\n+\n+            int cnt = _stream.Read(buffer, offset, count);\n+            _position += cnt;\n+            return cnt;\n+        }\n+\n+        public override long Seek(long offset, SeekOrigin origin)\n+        {\n+            if(origin != SeekOrigin.Current)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_SeekNonOrigin\"));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this throw when attempted to seek backwards (`offset < 0`)?",
              "createdAt": "2023-10-17T12:27:46Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// A wrapper stream that allows position tracking and forward seeking.\n+    /// </summary>\n+    internal class TransparentReadStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private long _position;\n+\n+        public static Stream EnsureSeekableStream(Stream stream)\n+        {\n+            if (stream.CanSeek)\n+            {\n+                return stream;\n+            }\n+\n+            if(!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)\n+        {\n+            if (stream is TransparentReadStream transparentReadStream)\n+            {\n+                return transparentReadStream;\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_MustBeReadable\"));\n+            }\n+\n+            return new TransparentReadStream(stream);\n+        }\n+\n+        private TransparentReadStream(Stream stream)\n+        {\n+            _stream = stream;\n+        }\n+\n+        public int? BytesCountAllowedToRead\n+        {\n+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }\n+        }\n+\n+        // if we haven't constrained the allowed read size - do not report it being unfinished either.\n+        public int BytesCountAllowedToReadRemaining =>\n+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);\n+\n+        private long _maxAllowedPosition = long.MaxValue;\n+        public override bool CanRead => _stream.CanRead;\n+        public override bool CanSeek => true;\n+        public override bool CanWrite => false;\n+        public override long Length => _stream.Length;\n+        public override long Position\n+        {\n+            get => _position;\n+            set => this.SkipBytes((int)(value - _position), true);\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Flush();\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count)\n+        {\n+            if (_position + count > _maxAllowedPosition)\n+            {\n+                throw new StreamChunkOverReadException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_StreamUtils_OverRead\", count,\n+                        _maxAllowedPosition - _position));\n+            }\n+\n+            int cnt = _stream.Read(buffer, offset, count);\n+            _position += cnt;\n+            return cnt;\n+        }\n+\n+        public override long Seek(long offset, SeekOrigin origin)\n+        {\n+            if(origin != SeekOrigin.Current)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_StreamUtils_SeekNonOrigin\"));\n+            }\n+\n+            this.SkipBytes((int)offset, true);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Many of these are unused.\r\n\r\n```suggestion\r\nusing System;\r\nusing System.IO;\r\nusing Microsoft.Build.Shared;\r\n```",
              "createdAt": "2023-10-17T12:29:14Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs",
              "diffHunk": "@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Some of this are unused.",
              "createdAt": "2023-10-17T12:43:13Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs",
              "diffHunk": "@@ -0,0 +1,59 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This extension method looks unused.",
              "createdAt": "2023-10-17T12:44:06Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Diagnostics;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal static class StreamExtensions\n+    {\n+        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)\n+        {\n+            Debug.Assert(offset + minimumBytes <= buffer.Length);\n+\n+            int totalRead = 0;\n+            while (totalRead < minimumBytes)\n+            {\n+                int read = stream.Read(buffer, offset, minimumBytes - totalRead);\n+                if (read == 0)\n+                {\n+                    if (throwOnEndOfStream)\n+                    {\n+                        throw new InvalidDataException(\"Unexpected end of stream.\");\n+                    }\n+\n+                    return totalRead;\n+                }\n+\n+                totalRead += read;\n+                offset += read;\n+            }\n+\n+            return totalRead;\n+        }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra space after `0,`.",
              "createdAt": "2023-10-17T12:47:13Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Diagnostics;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal static class StreamExtensions\n+    {\n+        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)\n+        {\n+            Debug.Assert(offset + minimumBytes <= buffer.Length);\n+\n+            int totalRead = 0;\n+            while (totalRead < minimumBytes)\n+            {\n+                int read = stream.Read(buffer, offset, minimumBytes - totalRead);\n+                if (read == 0)\n+                {\n+                    if (throwOnEndOfStream)\n+                    {\n+                        throw new InvalidDataException(\"Unexpected end of stream.\");\n+                    }\n+\n+                    return totalRead;\n+                }\n+\n+                totalRead += read;\n+                offset += read;\n+            }\n+\n+            return totalRead;\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream)\n+        {\n+            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);\n+            using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));\n+            return SkipBytes(stream, bytesCount, throwOnEndOfStream, buffer);\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream, byte[] buffer)\n+        {\n+            long totalRead = 0;\n+            while (totalRead < bytesCount)\n+            {\n+                int read = stream.Read(buffer, 0,  (int)Math.Min(bytesCount - totalRead, buffer.Length));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Unused outside of this class. Make it a private helper? Also, `throwOnEndOfStream` is always true.",
              "createdAt": "2023-10-17T12:48:25Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Diagnostics;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal static class StreamExtensions\n+    {\n+        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)\n+        {\n+            Debug.Assert(offset + minimumBytes <= buffer.Length);\n+\n+            int totalRead = 0;\n+            while (totalRead < minimumBytes)\n+            {\n+                int read = stream.Read(buffer, offset, minimumBytes - totalRead);\n+                if (read == 0)\n+                {\n+                    if (throwOnEndOfStream)\n+                    {\n+                        throw new InvalidDataException(\"Unexpected end of stream.\");\n+                    }\n+\n+                    return totalRead;\n+                }\n+\n+                totalRead += read;\n+                offset += read;\n+            }\n+\n+            return totalRead;\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream)\n+        {\n+            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);\n+            using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));\n+            return SkipBytes(stream, bytesCount, throwOnEndOfStream, buffer);\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream, byte[] buffer)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I believe this comment is still valid. The method is not called with `throwOnEndOfStream = false`.",
              "createdAt": "2023-11-02T14:25:46Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Diagnostics;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal static class StreamExtensions\n+    {\n+        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)\n+        {\n+            Debug.Assert(offset + minimumBytes <= buffer.Length);\n+\n+            int totalRead = 0;\n+            while (totalRead < minimumBytes)\n+            {\n+                int read = stream.Read(buffer, offset, minimumBytes - totalRead);\n+                if (read == 0)\n+                {\n+                    if (throwOnEndOfStream)\n+                    {\n+                        throw new InvalidDataException(\"Unexpected end of stream.\");\n+                    }\n+\n+                    return totalRead;\n+                }\n+\n+                totalRead += read;\n+                offset += read;\n+            }\n+\n+            return totalRead;\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream)\n+        {\n+            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);\n+            using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));\n+            return SkipBytes(stream, bytesCount, throwOnEndOfStream, buffer);\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream, byte[] buffer)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "\ud83d\udc4d Removed the conditioning (it can allways be added if needed)",
              "createdAt": "2023-11-03T11:13:00Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Buffers;\n+using System.Diagnostics;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal static class StreamExtensions\n+    {\n+        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)\n+        {\n+            Debug.Assert(offset + minimumBytes <= buffer.Length);\n+\n+            int totalRead = 0;\n+            while (totalRead < minimumBytes)\n+            {\n+                int read = stream.Read(buffer, offset, minimumBytes - totalRead);\n+                if (read == 0)\n+                {\n+                    if (throwOnEndOfStream)\n+                    {\n+                        throw new InvalidDataException(\"Unexpected end of stream.\");\n+                    }\n+\n+                    return totalRead;\n+                }\n+\n+                totalRead += read;\n+                offset += read;\n+            }\n+\n+            return totalRead;\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream)\n+        {\n+            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);\n+            using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));\n+            return SkipBytes(stream, bytesCount, throwOnEndOfStream, buffer);\n+        }\n+\n+        public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream, byte[] buffer)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "May not be needed, please see the comment in `TransparentReadStream.Read`.",
              "createdAt": "2023-10-17T12:51:06Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamChunkOverreadException.cs",
              "diffHunk": "@@ -0,0 +1,22 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    public class StreamChunkOverReadException : Exception",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty line.",
              "createdAt": "2023-10-17T12:51:42Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/IEmbeddedContentSource.cs",
              "diffHunk": "@@ -0,0 +1,18 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal interface IEmbeddedContentSource\n+    {\n+        ",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`.",
              "createdAt": "2023-10-17T12:52:01Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs",
              "diffHunk": "@@ -0,0 +1,59 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// Bounded read-only, forward-only view over an underlying stream.\n+    /// </summary>\n+    internal class SubStream : Stream",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Some of these are unused.",
              "createdAt": "2023-10-17T12:57:02Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/IBinlogReaderErrors.cs",
              "diffHunk": "@@ -0,0 +1,27 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This method is not called internally and not covered with tests.",
              "createdAt": "2023-10-17T13:02:47Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+public static class ArchiveFileEventArgsExtensions\n+{\n+    public static Action<ArchiveFileEventArgs> ToArchiveFileHandler(this Action<StringReadEventArgs> stringHandler)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Added usage to tests",
              "createdAt": "2023-10-23T11:20:56Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+public static class ArchiveFileEventArgsExtensions\n+{\n+    public static Action<ArchiveFileEventArgs> ToArchiveFileHandler(this Action<StringReadEventArgs> stringHandler)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra space after `ArchiveFile`.",
              "createdAt": "2023-10-17T13:04:42Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,55 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging;\n+\n+public sealed class ArchiveFileEventArgs : EventArgs\n+{\n+    private ArchiveFile  _archiveFile;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Public class should have a doc comment.",
              "createdAt": "2023-10-17T13:06:52Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,55 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging;\n+\n+public sealed class ArchiveFileEventArgs : EventArgs",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Public class should have a doc comment.",
              "createdAt": "2023-10-17T13:07:00Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    public sealed class ArchiveFile",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Move fields up before methods and properties?",
              "createdAt": "2023-10-17T13:08:07Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    public sealed class ArchiveFile\n+    {\n+        public ArchiveFile(string fullPath, Stream contentStream)\n+        {\n+            FullPath = fullPath;\n+            _contentReader = new StreamReader(contentStream);\n+        }\n+\n+        public ArchiveFile(string fullPath, string content)\n+        {\n+            FullPath = fullPath;\n+            _content = content;\n+            _stringAcquired = true;\n+            _contentReader = StreamReader.Null;\n+        }\n+\n+        internal static ArchiveFile From(ZipArchiveEntry entry)\n+        {\n+            return new ArchiveFile(entry.FullName, entry.Open());\n+        }\n+\n+        public string FullPath { get; }\n+        public bool CanUseReader => !_stringAcquired;\n+        public bool CanUseString => !_streamAcquired;\n+\n+        /// <summary>\n+        /// Fetches the file content as a stream reader (forward only).\n+        /// This prevents the content to be read as string.\n+        /// </summary>\n+        /// <returns></returns>\n+        /// <exception cref=\"InvalidOperationException\"></exception>\n+        public StreamReader GetContentReader()\n+        {\n+            if (_stringAcquired)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_ArchiveFile_AcquiredAsString\"));\n+            }\n+\n+            _streamAcquired = true;\n+            return _contentReader;\n+        }\n+\n+        /// <summary>\n+        /// Fetches the file content as a string.\n+        /// This prevents the content to be fetched via StreamReader.\n+        /// </summary>\n+        /// <returns></returns>\n+        /// <exception cref=\"InvalidOperationException\"></exception>\n+        public string GetContent()\n+        {\n+            if (_streamAcquired)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"Binlog_ArchiveFile_AcquiredAsStream\"));\n+            }\n+\n+            if (!_stringAcquired)\n+            {\n+                _stringAcquired = true;\n+                _content = _contentReader.ReadToEnd();\n+            }\n+\n+            return _content!;\n+        }\n+\n+        private bool _streamAcquired;\n+        private bool _stringAcquired;\n+        private readonly StreamReader _contentReader;\n+        private string? _content;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty line.",
              "createdAt": "2023-10-17T13:23:09Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -230,32 +276,18 @@ public void Shutdown()\n \n             Traits.Instance.EscapeHatches.LogProjectImports = _initialLogImports;\n \n+",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `compatibile`.",
              "createdAt": "2023-10-17T13:31:56Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -85,24 +171,124 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)\n         /// <param name=\"binaryReader\">The binary log content binary reader - caller is responsible for disposing.</param>\n         /// <param name=\"cancellationToken\">A <see cref=\"CancellationToken\"/> indicating the replay should stop as soon as possible.</param>\n         public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken)\n+            => Replay(binaryReader, false, cancellationToken);\n+\n+        /// <summary>\n+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs\n+        /// </summary>\n+        /// <param name=\"binaryReader\">The binary log content binary reader - caller is responsible for disposing, unless <paramref name=\"closeInput\"/> is set to true.</param>\n+        /// <param name=\"closeInput\">Indicates whether the passed BinaryReader should be closed on disposing.</param>\n+        /// <param name=\"cancellationToken\">A <see cref=\"CancellationToken\"/> indicating the replay should stop as soon as possible.</param>\n+        public void Replay(BinaryReader binaryReader, bool closeInput, CancellationToken cancellationToken)\n         {\n-            int fileFormatVersion = binaryReader.ReadInt32();\n+            using var reader = OpenBuildEventsReader(binaryReader, closeInput, AllowForwardCompatibility);\n+            NotificationsSourceCreated?.Invoke(reader);\n+            Replay(reader, cancellationToken);\n+        }\n \n-            // the log file is written using a newer version of file format\n-            // that we don't know how to read\n-            if (fileFormatVersion > BinaryLogger.FileFormatVersion)\n+        /// <summary>\n+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs\n+        /// </summary>\n+        /// <param name=\"reader\">The build events reader - caller is responsible for disposing.</param>\n+        /// <param name=\"cancellationToken\">A <see cref=\"CancellationToken\"/> indicating the replay should stop as soon as possible.</param>\n+        public void Replay(BuildEventArgsReader reader, CancellationToken cancellationToken)\n+        {\n+            bool supportsForwardCompatibility = reader.FileFormatVersion >= 18;\n+\n+            // Allow any possible deferred subscriptions to be registered\n+            if (HasStructuredEventsSubscribers || !supportsForwardCompatibility)\n             {\n-                var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnsupportedLogFileFormat\", fileFormatVersion, BinaryLogger.FileFormatVersion);\n-                throw new NotSupportedException(text);\n+                _onStructuredReadingOnly?.Invoke();\n+            }\n+            else\n+            {\n+                _onRawReadingPossible?.Invoke();\n             }\n \n-            using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);\n-            NotificationsSourceCreated?.Invoke(reader);\n+            reader.EmbeddedContentRead += _embeddedContentRead;\n+            reader.StringReadDone += _stringReadDone;\n+            reader.StringEncountered += _stringEncountered;\n \n-            while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)\n+            if (HasStructuredEventsSubscribers || !supportsForwardCompatibility)\n             {\n-                Dispatch(instance);\n+                if (this._rawLogRecordReceived != null)\n+                {\n+                    throw new NotSupportedException(\n+                        ResourceUtilities.GetResourceString(\"Binlog_Source_MultiSubscribeError\"));\n+                }\n+\n+                // Forward compatibile reading makes sense only for structured events reading.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `byt`.",
              "createdAt": "2023-10-17T13:40:19Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Delete?",
              "createdAt": "2023-10-17T13:41:41Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Doesn't `Assert.Equal` handle dictionary equality exactly like this?",
              "createdAt": "2023-10-17T14:09:32Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Shamefull to admin - I didn't know that :-)\r\nThx!",
              "createdAt": "2023-10-20T10:56:42Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Missing space after `if`.",
              "createdAt": "2023-10-17T14:10:17Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }\n+\n+            void AddArchiveFile(Dictionary<string, string> files, ArchiveFileEventArgs arg)\n+            {\n+                ArchiveFile embedFile = arg.ObtainArchiveFile();\n+                string content = embedFile.GetContent();\n+                files.Add(embedFile.FullPath, content);\n+                arg.SetResult(embedFile.FullPath, content);\n+                SweepArchiveFiles();\n+            }\n+        }\n+\n+        private static bool Compare(object left, object right, out string diffReason, string name = \"\", HashSet<object> compared = null)\n+        {\n+            diffReason = null;\n+            if (compared == null)\n+            {\n+                compared = new HashSet<object>();\n+            }\n+            else if(compared.Contains(left) && compared.Contains(right))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are you sure that xUnit or Shouldly doesn't already implement this kind of deep comparison?",
              "createdAt": "2023-10-17T14:17:14Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }\n+\n+            void AddArchiveFile(Dictionary<string, string> files, ArchiveFileEventArgs arg)\n+            {\n+                ArchiveFile embedFile = arg.ObtainArchiveFile();\n+                string content = embedFile.GetContent();\n+                files.Add(embedFile.FullPath, content);\n+                arg.SetResult(embedFile.FullPath, content);\n+                SweepArchiveFiles();\n+            }\n+        }\n+\n+        private static bool Compare(object left, object right, out string diffReason, string name = \"\", HashSet<object> compared = null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'm not :-) and I admit I've done just a very quick research before implementing myself.\r\nAFAIK this is not possibly in Shouldly (https://github.com/shouldly/shouldly/issues/237#issuecomment-99112110), but I'll do better research overall (https://github.com/jamesfoster/DeepEqual looks promissing - if we're fine bringing in other test library for this).\r\nWould you know about anything recomendable - please let me know",
              "createdAt": "2023-10-18T12:05:44Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }\n+\n+            void AddArchiveFile(Dictionary<string, string> files, ArchiveFileEventArgs arg)\n+            {\n+                ArchiveFile embedFile = arg.ObtainArchiveFile();\n+                string content = embedFile.GetContent();\n+                files.Add(embedFile.FullPath, content);\n+                arg.SetResult(embedFile.FullPath, content);\n+                SweepArchiveFiles();\n+            }\n+        }\n+\n+        private static bool Compare(object left, object right, out string diffReason, string name = \"\", HashSet<object> compared = null)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I was blind - https://fluentassertions.com/objectgraphs/\r\nReplacing...",
              "createdAt": "2023-10-19T16:08:00Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }\n+\n+            void AddArchiveFile(Dictionary<string, string> files, ArchiveFileEventArgs arg)\n+            {\n+                ArchiveFile embedFile = arg.ObtainArchiveFile();\n+                string content = embedFile.GetContent();\n+                files.Add(embedFile.FullPath, content);\n+                arg.SetResult(embedFile.FullPath, content);\n+                SweepArchiveFiles();\n+            }\n+        }\n+\n+        private static bool Compare(object left, object right, out string diffReason, string name = \"\", HashSet<object> compared = null)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "That was exactly why I have introduced fluent assertions into MSBuild tests.",
              "createdAt": "2023-10-22T18:31:54Z",
              "path": "src/Build.UnitTests/BinaryLogger_Tests.cs",
              "diffHunk": "@@ -140,6 +185,314 @@ public void TestBinaryLoggerRoundtrip(string projectText)\n             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);\n         }\n \n+        /// <summary>\n+        /// This test validate then binlog file content is identical upon replaying.\n+        /// The identity can be defined via 3 ways:\n+        ///   * byte-for-byte equality\n+        ///   * byte-for-byte equality of unzipped content\n+        ///   * structured equality of events\n+        ///\n+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),\n+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -\n+        ///  the assertions can be simply removed.\n+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality\n+        ///  is not dropping or altering any information.\n+        /// </summary>\n+        /// <param name=\"projectText\"></param>\n+        /// <param name=\"replayMode\"></param>\n+        [Theory]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]\n+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]\n+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)\n+        {\n+            var binaryLogger = new BinaryLogger();\n+\n+            binaryLogger.Parameters = _logFile;\n+\n+            // build and log into binary logger\n+            using (ProjectCollection collection = new())\n+            {\n+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);\n+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();\n+            }\n+\n+            var logReader = new BinaryLogReplayEventSource();\n+            string replayedLogFile = _env.ExpectFile(\".binlog\").Path;\n+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)\n+            {\n+                // need dummy handler to force structured replay\n+                logReader.BuildFinished += (_, _) => { };\n+            }\n+\n+            BinaryLogger outputBinlog = new BinaryLogger()\n+            {\n+                Parameters = $\"LogFile={replayedLogFile};OmitInitialInfo\"\n+            };\n+            outputBinlog.Initialize(logReader);\n+            logReader.Replay(_logFile);\n+            outputBinlog.Shutdown();\n+\n+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);\n+            // If this assertation complicates development - it can possibly be removed\n+            // The structured equality above should be enough.\n+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);\n+        }\n+\n+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)\n+        {\n+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);\n+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);\n+            const int bufferSize = 4096;\n+\n+            int readCount = 0;\n+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)\n+            {\n+                var bytes2 = br2.ReadBytes(bufferSize);\n+\n+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(() =>\n+                    $\"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(\",\", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(\",\", bytes2)}\");\n+                readCount += bufferSize;\n+            }\n+\n+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, \"Second buffer contains byt after first end\");\n+        }\n+\n+        private static void AssertFilesAreBinaryEqual(string firstPath, string secondPath)\n+        {\n+            FileInfo first = new(firstPath);\n+            FileInfo second = new(secondPath);\n+\n+            // Skipping shortcut test - so that we can better troubleshoot failures.\n+            ////if (first.Length != second.Length)\n+            ////{\n+            ////    Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            ////}\n+\n+            if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))\n+            {\n+                return;\n+            }\n+\n+            using FileStream fs1 = first.OpenRead();\n+            using FileStream fs2 = second.OpenRead();\n+            for (int i = 0; i < Math.Min(first.Length, second.Length); i++)\n+            {\n+                byte b1 = (byte)fs1.ReadByte();\n+                byte b2 = (byte)fs2.ReadByte();\n+                if (b1 != b2)\n+                {\n+                    Assert.Fail(\n+                        $\"Files ({first.Name}:{first.Length} and {second.Name}:{second.Length} sizes) are not equal at byte {i} ({b1} vs {b2})\");\n+                }\n+            }\n+\n+            if (first.Length != second.Length)\n+            {\n+                Assert.Fail($\"Files differ in size ({first.Name}:{first.Length} and {second.Name}:{second.Length}\");\n+            }\n+        }\n+\n+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)\n+        {\n+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);\n+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);\n+\n+            Dictionary<string, string> embedFiles1 = new();\n+            Dictionary<string, string> embedFiles2 = new();\n+\n+            reader1.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles1, arg);\n+\n+            reader2.ArchiveFileEncountered += arg\n+                => AddArchiveFile(embedFiles2, arg);\n+\n+            int i = 0;\n+            while (reader1.Read() is { } ev1)\n+            {\n+                i++;\n+                var ev2 = reader2.Read();\n+                if (!Compare(ev1, ev2, out string diffReason, $\"event arg {i}\"))\n+                {\n+                    Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at event {i} ({diffReason})\");\n+                }\n+            }\n+            // Read the second reader - to confirm there are no more events\n+            //  and to force the embedded files to be read.\n+            reader2.Read().ShouldBeNull($\"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}\");\n+\n+            SweepArchiveFiles();\n+\n+            embedFiles1.ShouldBeEmpty();\n+            embedFiles2.ShouldBeEmpty();\n+\n+            void SweepArchiveFiles()\n+            {\n+                List<string> toRemove = new();\n+                foreach (var file in embedFiles1)\n+                {\n+                    if (embedFiles2.TryGetValue(file.Key, out string content))\n+                    {\n+                        if (!string.Equals(file.Value, content))\n+                        {\n+                            Assert.Fail($\"Binlogs ({firstPath} and {secondPath}) are not equal at embedded file {file.Key}\");\n+                        }\n+                        toRemove.Add(file.Key);\n+                        embedFiles2.Remove(file.Key);\n+                    }\n+                }\n+\n+                foreach (var file in toRemove)\n+                {\n+                    embedFiles1.Remove(file);\n+                }\n+            }\n+\n+            void AddArchiveFile(Dictionary<string, string> files, ArchiveFileEventArgs arg)\n+            {\n+                ArchiveFile embedFile = arg.ObtainArchiveFile();\n+                string content = embedFile.GetContent();\n+                files.Add(embedFile.FullPath, content);\n+                arg.SetResult(embedFile.FullPath, content);\n+                SweepArchiveFiles();\n+            }\n+        }\n+\n+        private static bool Compare(object left, object right, out string diffReason, string name = \"\", HashSet<object> compared = null)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I would personally prefer it written like this:\r\n\r\n```suggestion\r\n            if (_lastSubStream?.IsAtEnd == false)\r\n```\r\n\r\n(Not blocking, feel free to ignore.)",
              "createdAt": "2023-10-17T14:21:17Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -59,33 +66,128 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa\n         /// <param name=\"fileFormatVersion\">The file format version of the log file being read.</param>\n         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)\n         {\n-            this.binaryReader = binaryReader;\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+            // make sure the reader we're going to use wraps the transparent stream wrapper\n+            this.binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n             this.fileFormatVersion = fileFormatVersion;\n         }\n \n-        public void Dispose()\n+        /// <summary>\n+        /// Directs whether the passed <see cref=\"BinaryReader\"/> should be closed when this instance is disposed.\n+        /// Defaults to \"false\".\n+        /// </summary>\n+        public bool CloseInput { private get; set; } = false;\n+\n+        /// <summary>\n+        /// Indicates whether unknown BuildEvents should be silently skipped. Read returns null otherwise.\n+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).\n+        /// </summary>\n+        public bool SkipUnknownEvents\n         {\n-            stringStorage.Dispose();\n+            set\n+            {\n+                if (value)\n+                {\n+                    EnsureForwardCompatibleReadingSupported();\n+                }\n+\n+                _skipUnknownEvents = value;\n+            }\n         }\n \n         /// <summary>\n-        /// An event that allows the subscriber to be notified when a string is read from the binary log.\n-        /// Subscriber may adjust the string by setting <see cref=\"StringReadEventArgs.StringToBeUsed\"/> property.\n-        /// The passed event arg can be reused and should not be stored.\n+        /// Indicates whether unread parts of BuildEvents (probably added in newer format of particular BuildEvent)should be silently skipped. Exception thrown otherwise.\n+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).\n         /// </summary>\n-        public event Action<StringReadEventArgs>? StringReadDone;\n+        public bool SkipUnknownEventParts\n+        {\n+            set\n+            {\n+                if (value)\n+                {\n+                    EnsureForwardCompatibleReadingSupported();\n+                }\n+                _skipUnknownEventParts = value;\n+            }\n+        }\n+\n+        private void EnsureForwardCompatibleReadingSupported()\n+        {\n+            if (fileFormatVersion < 18)\n+            {\n+                throw new InvalidOperationException(\n+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_FwdCompatUnsupported\",\n+                        fileFormatVersion));\n+            }\n+        }\n \n         /// <summary>\n-        /// An event that allows the caller to be notified when a string is encountered in the binary log.\n-        /// BinaryReader passed in ctor is at the beginning of the string at this point.\n+        /// Receives recoverable errors during reading.\n+        /// Applicable mainly when <see cref=\"SkipUnknownEvents\"/> or <see cref=\"SkipUnknownEventParts\"/> is set to true.\"/>\n         /// </summary>\n+        public event Action<ReaderErrorType, string>? OnRecoverableReadError;\n+\n+        public void Dispose()\n+        {\n+            stringStorage.Dispose();\n+            if (CloseInput)\n+            {\n+                binaryReader.Dispose();\n+            }\n+        }\n+\n+        /// <inheritdoc cref=\"IBuildEventStringsReader.StringReadDone\"/>\n+        public event Action<StringReadEventArgs>? StringReadDone;\n+\n+        /// <inheritdoc cref=\"IBuildEventStringsReader.StringEncountered\"/>\n         public event Action? StringEncountered;\n \n+        public int FileFormatVersion => fileFormatVersion;\n+\n+        /// <inheritdoc cref=\"IEmbeddedContentSource.EmbeddedContentRead\"/>\n+        internal event Action<EmbeddedContentEventArgs>? EmbeddedContentRead;\n+\n+        /// <inheritdoc cref=\"IBuildFileReader.ArchiveFileEncountered\"/>\n+        public event Action<ArchiveFileEventArgs>? ArchiveFileEncountered;\n+\n+        private SubStream? _lastSubStream;\n+\n         /// <summary>\n-        /// Raised when the log reader encounters a binary blob embedded in the stream.\n-        /// The arguments include the blob kind and the byte buffer with the contents.\n+        /// Reads the next serialized log record from the <see cref=\"BinaryReader\"/>.\n         /// </summary>\n-        internal event Action<BinaryLogRecordKind, byte[]>? OnBlobRead;\n+        /// <returns>ArraySegment containing serialized BuildEventArgs record</returns>\n+        internal (BinaryLogRecordKind RecordKind, Stream Stream) ReadRaw()\n+        {\n+            // This method is internal and condition is checked once before calling in loop,\n+            //  so avoiding it here on each call.\n+            // But keeping it for documentation purposes - in case someone will try to call it and debug issues.\n+            ////if (fileFormatVersion < 18)\n+            ////{\n+            ////    throw new InvalidOperationException(\n+            ////                           $\"Raw data reading is not supported for file format version {fileFormatVersion} (needs >=18).\");\n+            ////}\n+\n+            if (!(_lastSubStream?.IsAtEnd ?? true))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should the `18` be a named constant?",
              "createdAt": "2023-10-17T14:29:05Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -96,113 +198,174 @@ public void Dispose()\n         /// </returns>\n         public BuildEventArgs? Read()\n         {\n-            BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();\n-\n-            // Skip over data storage records since they don't result in a BuildEventArgs.\n-            // just ingest their data and continue.\n-            while (IsAuxiliaryRecord(recordKind))\n+            BuildEventArgs? result = null;\n+            while (result == null)\n             {\n-                // these are ordered by commonality\n-                if (recordKind == BinaryLogRecordKind.String)\n+                BinaryLogRecordKind recordKind = PreprocessRecordsTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n                 {\n-                    ReadStringRecord();\n+                    return null;\n                 }\n-                else if (recordKind == BinaryLogRecordKind.NameValueList)\n+\n+                int serializedEventLength = 0;\n+                if (fileFormatVersion >= 18)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This can be a switch expression.\r\n\r\n```C#\r\nreturn recordKind switch\r\n{\r\n    BinaryLogRecordKind.BuildStarted => ReadBuildStartedEventArgs(),\r\n    BinaryLogRecordKind.BuildFinished => ReadBuildFinishedEventArgs(), \r\n    ...\r\n\r\n    _ => null,\r\n}\r\n```",
              "createdAt": "2023-10-17T14:48:32Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -96,113 +198,174 @@ public void Dispose()\n         /// </returns>\n         public BuildEventArgs? Read()\n         {\n-            BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();\n-\n-            // Skip over data storage records since they don't result in a BuildEventArgs.\n-            // just ingest their data and continue.\n-            while (IsAuxiliaryRecord(recordKind))\n+            BuildEventArgs? result = null;\n+            while (result == null)\n             {\n-                // these are ordered by commonality\n-                if (recordKind == BinaryLogRecordKind.String)\n+                BinaryLogRecordKind recordKind = PreprocessRecordsTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n                 {\n-                    ReadStringRecord();\n+                    return null;\n                 }\n-                else if (recordKind == BinaryLogRecordKind.NameValueList)\n+\n+                int serializedEventLength = 0;\n+                if (fileFormatVersion >= 18)\n                 {\n-                    ReadNameValueList();\n+                    serializedEventLength = ReadInt32(); // record length\n+                    _readStream.BytesCountAllowedToRead = serializedEventLength;\n                 }\n-                else if (recordKind == BinaryLogRecordKind.ProjectImportArchive)\n+\n+                bool hasError = false;\n+                try\n+                {\n+                    result = ReadBuildEventArgs(recordKind);\n+                }\n+                catch (Exception e) when (e is InvalidDataException dataException ||\n+                                          e is FormatException formatException ||\n+                                          e is StreamChunkOverReadException overReadException)\n                 {\n-                    ReadBlob(recordKind);\n+                    hasError = true;\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderMismatchedRead\",\n+                            recordNumber, serializedEventLength, e.Message) + (_skipUnknownEventParts\n+                            ? \" \" + ResourceUtilities.GetResourceString(\"Binlog_ReaderSkippingRecord\")\n+                            : string.Empty);\n+\n+                    HandleError(error, _skipUnknownEventParts, ReaderErrorType.UnknownFormatOfEventData, e);\n+                }\n+\n+                if (result == null && !hasError)\n+                {\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderUnknownType\",\n+                            recordNumber, serializedEventLength, recordKind) + (_skipUnknownEvents\n+                            ? \" \" + ResourceUtilities.GetResourceString(\"Binlog_ReaderSkippingRecord\")\n+                            : string.Empty);\n+\n+                    HandleError(error, _skipUnknownEvents, ReaderErrorType.UnkownEventType);\n+                }\n+\n+                if (_readStream.BytesCountAllowedToReadRemaining > 0)\n+                {\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderUnderRead\",\n+                            recordNumber, serializedEventLength, serializedEventLength - _readStream.BytesCountAllowedToReadRemaining);\n+\n+                    HandleError(error, _skipUnknownEventParts, ReaderErrorType.UnknownEventData);\n                 }\n \n                 recordNumber += 1;\n+            }\n \n-                recordKind = (BinaryLogRecordKind)ReadInt32();\n+            return result;\n+\n+            void HandleError(string msg, bool noThrow, ReaderErrorType readerErrorType, Exception? innerException = null)\n+            {\n+                if (noThrow)\n+                {\n+                    OnRecoverableReadError?.Invoke(readerErrorType, msg);\n+                    SkipBytes(_readStream.BytesCountAllowedToReadRemaining);\n+                }\n+                else\n+                {\n+                    throw new InvalidDataException(msg, innerException);\n+                }\n             }\n+        }\n \n-            BuildEventArgs? result = null;\n+        private BuildEventArgs? ReadBuildEventArgs(BinaryLogRecordKind recordKind)\n+        {\n             switch (recordKind)\n             {\n-                case BinaryLogRecordKind.EndOfFile:\n-                    break;\n                 case BinaryLogRecordKind.BuildStarted:\n-                    result = ReadBuildStartedEventArgs();\n-                    break;\n+                    return ReadBuildStartedEventArgs();\n                 case BinaryLogRecordKind.BuildFinished:\n-                    result = ReadBuildFinishedEventArgs();\n-                    break;\n+                    return ReadBuildFinishedEventArgs();\n                 case BinaryLogRecordKind.ProjectStarted:\n-                    result = ReadProjectStartedEventArgs();\n-                    break;\n+                    return ReadProjectStartedEventArgs();\n                 case BinaryLogRecordKind.ProjectFinished:\n-                    result = ReadProjectFinishedEventArgs();\n-                    break;\n+                    return ReadProjectFinishedEventArgs();\n                 case BinaryLogRecordKind.TargetStarted:\n-                    result = ReadTargetStartedEventArgs();\n-                    break;\n+                    return ReadTargetStartedEventArgs();\n                 case BinaryLogRecordKind.TargetFinished:\n-                    result = ReadTargetFinishedEventArgs();\n-                    break;\n+                    return ReadTargetFinishedEventArgs();\n                 case BinaryLogRecordKind.TaskStarted:\n-                    result = ReadTaskStartedEventArgs();\n-                    break;\n+                    return ReadTaskStartedEventArgs();\n                 case BinaryLogRecordKind.TaskFinished:\n-                    result = ReadTaskFinishedEventArgs();\n-                    break;\n+                    return ReadTaskFinishedEventArgs();\n                 case BinaryLogRecordKind.Error:\n-                    result = ReadBuildErrorEventArgs();\n-                    break;\n+                    return ReadBuildErrorEventArgs();\n                 case BinaryLogRecordKind.Warning:\n-                    result = ReadBuildWarningEventArgs();\n-                    break;\n+                    return ReadBuildWarningEventArgs();\n                 case BinaryLogRecordKind.Message:\n-                    result = ReadBuildMessageEventArgs();\n-                    break;\n+                    return ReadBuildMessageEventArgs();\n                 case BinaryLogRecordKind.CriticalBuildMessage:\n-                    result = ReadCriticalBuildMessageEventArgs();\n-                    break;\n+                    return ReadCriticalBuildMessageEventArgs();\n                 case BinaryLogRecordKind.TaskCommandLine:\n-                    result = ReadTaskCommandLineEventArgs();\n-                    break;\n+                    return ReadTaskCommandLineEventArgs();\n                 case BinaryLogRecordKind.TaskParameter:\n-                    result = ReadTaskParameterEventArgs();\n-                    break;\n+                    return ReadTaskParameterEventArgs();\n                 case BinaryLogRecordKind.ProjectEvaluationStarted:\n-                    result = ReadProjectEvaluationStartedEventArgs();\n-                    break;\n+                    return ReadProjectEvaluationStartedEventArgs();\n                 case BinaryLogRecordKind.ProjectEvaluationFinished:\n-                    result = ReadProjectEvaluationFinishedEventArgs();\n-                    break;\n+                    return ReadProjectEvaluationFinishedEventArgs();\n                 case BinaryLogRecordKind.ProjectImported:\n-                    result = ReadProjectImportedEventArgs();\n-                    break;\n+                    return ReadProjectImportedEventArgs();\n                 case BinaryLogRecordKind.TargetSkipped:\n-                    result = ReadTargetSkippedEventArgs();\n-                    break;\n+                    return ReadTargetSkippedEventArgs();\n                 case BinaryLogRecordKind.EnvironmentVariableRead:\n-                    result = ReadEnvironmentVariableReadEventArgs();\n-                    break;\n+                    return ReadEnvironmentVariableReadEventArgs();\n                 case BinaryLogRecordKind.ResponseFileUsed:\n-                    result = ReadResponseFileUsedEventArgs();\n-                    break;\n+                    return ReadResponseFileUsedEventArgs();\n                 case BinaryLogRecordKind.PropertyReassignment:\n-                    result = ReadPropertyReassignmentEventArgs();\n-                    break;\n+                    return ReadPropertyReassignmentEventArgs();\n                 case BinaryLogRecordKind.UninitializedPropertyRead:\n-                    result = ReadUninitializedPropertyReadEventArgs();\n-                    break;\n+                    return ReadUninitializedPropertyReadEventArgs();\n                 case BinaryLogRecordKind.PropertyInitialValueSet:\n-                    result = ReadPropertyInitialValueSetEventArgs();\n-                    break;\n+                    return ReadPropertyInitialValueSetEventArgs();\n                 case BinaryLogRecordKind.AssemblyLoad:\n-                    result = ReadAssemblyLoadEventArgs();\n-                    break;\n+                    return ReadAssemblyLoadEventArgs();\n+                default:\n+                    return null;\n             }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: we are breaking coding practise with non _ private members here. I prefer to use `this.field` for all of those at least in scope of new written code. Or better renaming it to _*",
              "createdAt": "2023-10-23T14:07:15Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -59,33 +67,128 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa\n         /// <param name=\"fileFormatVersion\">The file format version of the log file being read.</param>\n         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)\n         {\n-            this.binaryReader = binaryReader;\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+            // make sure the reader we're going to use wraps the transparent stream wrapper\n+            this.binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n             this.fileFormatVersion = fileFormatVersion;\n         }\n \n-        public void Dispose()\n+        /// <summary>\n+        /// Directs whether the passed <see cref=\"BinaryReader\"/> should be closed when this instance is disposed.\n+        /// Defaults to \"false\".\n+        /// </summary>\n+        public bool CloseInput { private get; set; } = false;\n+\n+        /// <summary>\n+        /// Indicates whether unknown BuildEvents should be silently skipped. Read returns null otherwise.\n+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).\n+        /// </summary>\n+        public bool SkipUnknownEvents\n         {\n-            stringStorage.Dispose();\n+            set\n+            {\n+                if (value)\n+                {\n+                    EnsureForwardCompatibleReadingSupported();\n+                }\n+\n+                _skipUnknownEvents = value;\n+            }\n         }\n \n         /// <summary>\n-        /// An event that allows the subscriber to be notified when a string is read from the binary log.\n-        /// Subscriber may adjust the string by setting <see cref=\"StringReadEventArgs.StringToBeUsed\"/> property.\n-        /// The passed event arg can be reused and should not be stored.\n+        /// Indicates whether unread parts of BuildEvents (probably added in newer format of particular BuildEvent)should be silently skipped. Exception thrown otherwise.\n+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).\n         /// </summary>\n-        public event Action<StringReadEventArgs>? StringReadDone;\n+        public bool SkipUnknownEventParts\n+        {\n+            set\n+            {\n+                if (value)\n+                {\n+                    EnsureForwardCompatibleReadingSupported();\n+                }\n+                _skipUnknownEventParts = value;\n+            }\n+        }\n+\n+        private void EnsureForwardCompatibleReadingSupported()\n+        {\n+            if (fileFormatVersion < ForwardCompatibilityMinimalVersion)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "renamed pre-existing privates to have prefix",
              "createdAt": "2023-10-24T12:24:06Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -59,33 +67,128 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa\n         /// <param name=\"fileFormatVersion\">The file format version of the log file being read.</param>\n         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)\n         {\n-            this.binaryReader = binaryReader;\n+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);\n+            // make sure the reader we're going to use wraps the transparent stream wrapper\n+            this.binaryReader = binaryReader.BaseStream == _readStream\n+                ? binaryReader\n+                : new BinaryReader(_readStream);\n             this.fileFormatVersion = fileFormatVersion;\n         }\n \n-        public void Dispose()\n+        /// <summary>\n+        /// Directs whether the passed <see cref=\"BinaryReader\"/> should be closed when this instance is disposed.\n+        /// Defaults to \"false\".\n+        /// </summary>\n+        public bool CloseInput { private get; set; } = false;\n+\n+        /// <summary>\n+        /// Indicates whether unknown BuildEvents should be silently skipped. Read returns null otherwise.\n+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).\n+        /// </summary>\n+        public bool SkipUnknownEvents\n         {\n-            stringStorage.Dispose();\n+            set\n+            {\n+                if (value)\n+                {\n+                    EnsureForwardCompatibleReadingSupported();\n+                }\n+\n+                _skipUnknownEvents = value;\n+            }\n         }\n \n         /// <summary>\n-        /// An event that allows the subscriber to be notified when a string is read from the binary log.\n-        /// Subscriber may adjust the string by setting <see cref=\"StringReadEventArgs.StringToBeUsed\"/> property.\n-        /// The passed event arg can be reused and should not be stored.\n+        /// Indicates whether unread parts of BuildEvents (probably added in newer format of particular BuildEvent)should be silently skipped. Exception thrown otherwise.\n+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).\n         /// </summary>\n-        public event Action<StringReadEventArgs>? StringReadDone;\n+        public bool SkipUnknownEventParts\n+        {\n+            set\n+            {\n+                if (value)\n+                {\n+                    EnsureForwardCompatibleReadingSupported();\n+                }\n+                _skipUnknownEventParts = value;\n+            }\n+        }\n+\n+        private void EnsureForwardCompatibleReadingSupported()\n+        {\n+            if (fileFormatVersion < ForwardCompatibilityMinimalVersion)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NOTE: When older reader reads new format, under read might be quite common. Generating message which will not be used might effect performance. This does more concerning in LogViewer codebase than here though. Just please consider it in related LogViewer code.",
              "createdAt": "2023-10-24T10:30:43Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -96,11 +199,130 @@ public void Dispose()\n         /// </returns>\n         public BuildEventArgs? Read()\n         {\n+            BuildEventArgs? result = null;\n+            while (result == null)\n+            {\n+                BinaryLogRecordKind recordKind = PreprocessRecordsTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n+                {\n+                    return null;\n+                }\n+\n+                int serializedEventLength = 0;\n+                if (fileFormatVersion >= ForwardCompatibilityMinimalVersion)\n+                {\n+                    serializedEventLength = ReadInt32(); // record length\n+                    _readStream.BytesCountAllowedToRead = serializedEventLength;\n+                }\n+\n+                bool hasError = false;\n+                try\n+                {\n+                    result = ReadBuildEventArgs(recordKind);\n+                }\n+                catch (Exception e) when (\n+                    // We throw this on mismatches in metadata (name-value list, strings index).\n+                    e is InvalidDataException ||\n+                    // Thrown when BinaryReader is unable to deserialize binary data into expected type.\n+                    e is FormatException ||\n+                    // Following 2 are thrown when we attempt to read more bytes than what is in the next event chunk.\n+                    e is StreamChunkOverReadException ||\n+                    e is EndOfStreamException)\n+                {\n+                    hasError = true;\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderMismatchedRead\",\n+                            recordNumber, serializedEventLength, e.GetType(), e.Message) + (_skipUnknownEvents\n+                            ? \" \" + ResourceUtilities.GetResourceString(\"Binlog_ReaderSkippingRecord\")\n+                            : string.Empty);\n+\n+                    HandleError(error, _skipUnknownEvents, ReaderErrorType.UnknownFormatOfEventData, recordKind, e);\n+                }\n+\n+                if (result == null && !hasError)\n+                {\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderUnknownType\",\n+                            recordNumber, serializedEventLength, recordKind) + (_skipUnknownEvents\n+                            ? \" \" + ResourceUtilities.GetResourceString(\"Binlog_ReaderSkippingRecord\")\n+                            : string.Empty);\n+\n+                    HandleError(error, _skipUnknownEvents, ReaderErrorType.UnkownEventType, recordKind);\n+                }\n+\n+                if (_readStream.BytesCountAllowedToReadRemaining > 0)\n+                {\n+                    string error =",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Changed the error arg to factory",
              "createdAt": "2023-10-24T12:24:24Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -96,11 +199,130 @@ public void Dispose()\n         /// </returns>\n         public BuildEventArgs? Read()\n         {\n+            BuildEventArgs? result = null;\n+            while (result == null)\n+            {\n+                BinaryLogRecordKind recordKind = PreprocessRecordsTillNextEvent(IsAuxiliaryRecord);\n+\n+                if (recordKind == BinaryLogRecordKind.EndOfFile)\n+                {\n+                    return null;\n+                }\n+\n+                int serializedEventLength = 0;\n+                if (fileFormatVersion >= ForwardCompatibilityMinimalVersion)\n+                {\n+                    serializedEventLength = ReadInt32(); // record length\n+                    _readStream.BytesCountAllowedToRead = serializedEventLength;\n+                }\n+\n+                bool hasError = false;\n+                try\n+                {\n+                    result = ReadBuildEventArgs(recordKind);\n+                }\n+                catch (Exception e) when (\n+                    // We throw this on mismatches in metadata (name-value list, strings index).\n+                    e is InvalidDataException ||\n+                    // Thrown when BinaryReader is unable to deserialize binary data into expected type.\n+                    e is FormatException ||\n+                    // Following 2 are thrown when we attempt to read more bytes than what is in the next event chunk.\n+                    e is StreamChunkOverReadException ||\n+                    e is EndOfStreamException)\n+                {\n+                    hasError = true;\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderMismatchedRead\",\n+                            recordNumber, serializedEventLength, e.GetType(), e.Message) + (_skipUnknownEvents\n+                            ? \" \" + ResourceUtilities.GetResourceString(\"Binlog_ReaderSkippingRecord\")\n+                            : string.Empty);\n+\n+                    HandleError(error, _skipUnknownEvents, ReaderErrorType.UnknownFormatOfEventData, recordKind, e);\n+                }\n+\n+                if (result == null && !hasError)\n+                {\n+                    string error =\n+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"Binlog_ReaderUnknownType\",\n+                            recordNumber, serializedEventLength, recordKind) + (_skipUnknownEvents\n+                            ? \" \" + ResourceUtilities.GetResourceString(\"Binlog_ReaderSkippingRecord\")\n+                            : string.Empty);\n+\n+                    HandleError(error, _skipUnknownEvents, ReaderErrorType.UnkownEventType, recordKind);\n+                }\n+\n+                if (_readStream.BytesCountAllowedToReadRemaining > 0)\n+                {\n+                    string error =",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: I think, that preparing stream for reuse is better to do on acquiring side, than on releasing side. If releaseing do not happen for future changes or bugs (conditional, exception, etc...) stream is in unknown state.\r\nSince SetLength(0) is very fast operation, it would not harm to have it on both, acquiring and releasing side.",
              "createdAt": "2023-10-24T10:58:21Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -132,11 +140,18 @@ public BuildEventArgsWriter(BinaryWriter binaryWriter)\n         /// </summary>\n         public void Write(BuildEventArgs e)\n         {\n-            WriteCore(e);\n+            BinaryLogRecordKind eventKind = WriteCore(e);\n \n-            // flush the current record and clear the MemoryStream to prepare for next use\n-            currentRecordStream.WriteTo(originalStream);\n-            currentRecordStream.SetLength(0);\n+            FlushRecordToFinalStream(eventKind, currentRecordStream);\n+        }\n+\n+        private void FlushRecordToFinalStream(BinaryLogRecordKind recordKind, MemoryStream recordStream)\n+        {\n+            using var redirectionScope = RedirectWritesToOriginalWriter();\n+            Write(recordKind);\n+            Write((int)recordStream.Length);\n+            recordStream.WriteTo(originalStream);\n+            recordStream.SetLength(0);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: This generic usage class could be in Framework assembly for reuse.",
              "createdAt": "2023-10-24T12:01:35Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+internal readonly struct CleanupScope : IDisposable",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "There are other candidates. Right now I want to keep the change scoped. Once it makes in, I'd want to move the usefull helpers out",
              "createdAt": "2023-10-24T12:25:37Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+internal readonly struct CleanupScope : IDisposable",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I expected to be able to say \"use this other one we already have\" but I couldn't find one :(",
              "createdAt": "2023-10-25T10:48:46Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+internal readonly struct CleanupScope : IDisposable",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this comment still valid? It seems to be in use.",
              "createdAt": "2023-10-24T12:52:01Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs",
              "diffHunk": "@@ -6,7 +6,10 @@ namespace Microsoft.Build.Logging\n     /// <summary>\n     /// An interface for notifications from BuildEventArgsReader\n     /// </summary>\n-    public interface IBuildEventArgsReaderNotifications : IBuildEventStringsReader\n+    public interface IBuildEventArgsReaderNotifications :\n+        IBuildEventStringsReader,\n+        IBuildFileReader,\n+        IBinlogReaderErrors\n     {\n         /* For future use */",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This was meant for the actual members of the interface.\r\n\r\nBut that comment for sure can be confusing while having questionable to no value - so I'll ditch it",
              "createdAt": "2023-10-24T12:53:44Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs",
              "diffHunk": "@@ -6,7 +6,10 @@ namespace Microsoft.Build.Logging\n     /// <summary>\n     /// An interface for notifications from BuildEventArgsReader\n     /// </summary>\n-    public interface IBuildEventArgsReaderNotifications : IBuildEventStringsReader\n+    public interface IBuildEventArgsReaderNotifications :\n+        IBuildEventStringsReader,\n+        IBuildFileReader,\n+        IBinlogReaderErrors\n     {\n         /* For future use */",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nFrom version 18, the binlog contains as well the minimum version of reader that can interpret it (stored in bytes 4 to 8). Support for best effort forward compatibility is added by this version. It is \u201cbest effort\u201d only because the binlog format is not self-describing, i.e. it doesn't carry its schema around for performance and compactness reasons.\r\n```",
              "createdAt": "2023-10-24T20:57:09Z",
              "path": "documentation/wiki/Binary-Log.md",
              "diffHunk": "@@ -90,4 +90,59 @@ When incrementing the file format, keep this in mind:\n \n The format is backwards compatible, i.e. MSBuild will be able to play back .binlog files created with an older version of MSBuild. The Viewer will also be able to open files of any older version. Since the viewer updates automatically and I can push out updates easily, we can consider the Viewer is always able to read all .binlogs.\n \n-However MSBuild of version 15.3 won't be able to read .binlogs created with MSBuild version 15.6. This means the format is unfortunately not forwards-compatible. It is not self-describing, i.e. it doesn't carry its schema around for performance and compactness reasons. This is not a problem with a Viewer because Viewer is always up-to-date (there isn't an \"old version\" of the Viewer unless people go to great lengths to prevent it from auto-updating).\n+## Forward compatibility reading\n+\n+From version 18, the binlog contains as well the minimum version of reader that can interpret it (stored in bytes 4 to 8). A support for best effor forward compatibility is added by this version. Best effort only because binlog format is not self-describing, i.e. it doesn't carry its schema around for performance and compactness reasons.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    <value>MSB4235: The log file format version is {0} with minimum required read version {1}, whereas this version of MSBuild only supports versions up to {2}.</value>\r\n```",
              "createdAt": "2023-10-24T21:01:44Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1346,7 +1346,7 @@\n     <comment>{StrBegin=\"MSB4068: \"}</comment>\n   </data>\n   <data name=\"UnsupportedLogFileFormat\" xml:space=\"preserve\">\n-    <value>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</value>\n+    <value>MSB4235: The log file format version is {0} and minimum required read version is {1}, whereas this version of MSBuild only supports versions up to {2}.</value>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}