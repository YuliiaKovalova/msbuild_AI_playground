{
  "number": 9983,
  "title": "Add dispose rule and handle it in solution (production part)",
  "body": "### Context\r\nThe absence of this rule cause a memory leak during execution.\r\n\r\n### Changes Made\r\nEnable CA2000 rule for production code and temporary make exception for test projects.\r\n",
  "state": "MERGED",
  "createdAt": "2024-04-09T17:43:54Z",
  "updatedAt": "2024-04-19T15:06:56Z",
  "closedAt": "2024-04-19T15:06:56Z",
  "mergedAt": "2024-04-19T15:06:56Z",
  "additions": 523,
  "deletions": 366,
  "changedFiles": 44,
  "headRefName": "dev/ykovalova/enable_disposable_rule_check",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "95835a566116351813b5eb669fc3c3f1444f4f35",
          "message": "add dispose part 1",
          "committedDate": "2024-04-09T17:43:40Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a372cb7628d7aa4615a6ec490b790ef573799886",
          "message": "remove extra using",
          "committedDate": "2024-04-09T18:04:39Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9884345256307e25c6fd811e5e69e4d6fce6c7e6",
          "message": "remove extra params",
          "committedDate": "2024-04-10T09:17:13Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a0f3706705233b2ab9855ce3803ddc6619f97d0",
          "message": "add dispose part 2",
          "committedDate": "2024-04-10T09:56:34Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e011c020a48f368ca0497bfadff1dcdfa95c0e98",
          "message": "fix styling errors",
          "committedDate": "2024-04-10T10:08:11Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "202049e415d06f2560671ead8fb9061a4a373eed",
          "message": "fix test",
          "committedDate": "2024-04-10T10:19:59Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a0cca6dd5c1d774b1c190d567636510c6e9c5d3",
          "message": "remove invalid dispose",
          "committedDate": "2024-04-10T10:47:16Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6b56301bafbabe9082d9aaac311b8960895f46aa",
          "message": "dispose part 3",
          "committedDate": "2024-04-11T08:05:32Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7ed50851db68d4bb947b661f4e12eb03f87f78bc",
          "message": "fix review comments",
          "committedDate": "2024-04-11T09:35:47Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ac0bd8881286a6274b97c74fb8b5d147946d6df4",
          "message": "enable rule globaly, but exclude tests",
          "committedDate": "2024-04-11T10:45:19Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbd0d17a217066ff18a37dfdff3608195e160317",
          "message": "Merge branch 'main' into dev/ykovalova/enable_disposable_rule_check",
          "committedDate": "2024-04-11T15:23:12Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19e806614918e5d9a7e5ab697073c4e1af927dc4",
          "message": "fix review comments",
          "committedDate": "2024-04-11T15:28:30Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4d75da56adca8b182e9c6a314a3599672100f0ee",
          "message": "Merge branch 'dev/ykovalova/enable_disposable_rule_check' of https://github.com/YuliiaKovalova/msbuild into dev/ykovalova/enable_disposable_rule_check",
          "committedDate": "2024-04-11T15:28:32Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "311c43bd1f62318c1a9f7e06f1eb62357904193a",
          "message": "cleanup",
          "committedDate": "2024-04-11T15:33:29Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7e7294405091d4c60ba79e883529e08774a8d937",
          "message": "remove extra dispose",
          "committedDate": "2024-04-11T15:52:55Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ef1733094989a1b8d56bc5d2998061681cf12fb",
          "message": "remove exposion of a sync version of RedirectConsoleWriter",
          "committedDate": "2024-04-11T19:57:23Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c8fee7e4a574d018db56da519787e65a7fdb6d81",
          "message": "fix review comments",
          "committedDate": "2024-04-16T10:09:58Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a282a95591e5cabd2b6a45b90a831fc69e666d14",
          "message": "fix review comments",
          "committedDate": "2024-04-18T12:23:03Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2581757500ba9bcec24a045b422f09ab3a2ba8e0",
          "message": "remove extra changes",
          "committedDate": "2024-04-18T13:54:18Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c12087311de31a41cdcc5e8ff51bf6521ff5b0c",
          "message": "fix review comments",
          "committedDate": "2024-04-19T08:13:28Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b40ea32ab5e3735ed973d2c7520b5f50b03a5082",
          "message": "remore suppression for ca2000 in deprecated folder",
          "committedDate": "2024-04-19T08:56:25Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0db7ee0bf4acb2351e95fd1eb9cab32c59400bcb",
          "message": "fix review comments",
          "committedDate": "2024-04-19T14:28:14Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "It's good to have fixed these but I would consider _not_ enabling this rule for tests, at least initially, so we can focus on the product side.",
              "createdAt": "2024-04-10T15:23:18Z",
              "path": "src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs",
              "diffHunk": "@@ -220,7 +220,8 @@ public void ConstructOverSameFileReturnsSameEvenWithOneBeingRelativePath3()\n         {\n             string content = \"<Project ToolsVersion=\\\"4.0\\\">\\r\\n</Project>\";\n \n-            ProjectRootElement projectXml1 = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));\n+            using var xmlReader = XmlReader.Create(new StringReader(content));\n+            ProjectRootElement projectXml1 = ProjectRootElement.Create(xmlReader);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this need the new block? In general I'd prefer to avoid the indentation.",
              "createdAt": "2024-04-10T15:25:27Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2004,82 +2004,84 @@ static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode,\n             IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,\n             GraphBuildRequestData graphBuildRequestData)\n         {\n-            var waitHandle = new AutoResetEvent(true);\n-            var graphBuildStateLock = new object();\n-\n-            var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);\n-            var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);\n-            var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();\n             var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);\n-            ExceptionDispatchInfo submissionException = null;\n-\n-            while (blockedNodes.Count > 0 || buildingNodes.Count > 0)\n+            using (var waitHandle = new AutoResetEvent(true))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it ok to dispose this while keeping it in the field `_lastSubStream`? That doesn't seem right to me (without looking hard).",
              "createdAt": "2024-04-10T15:43:00Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -185,9 +185,10 @@ internal RawRecord ReadRaw()\n             int serializedEventLength = ReadInt32();\n             Stream stream = _binaryReader.BaseStream.Slice(serializedEventLength);\n \n-            _lastSubStream = stream as SubStream;\n-\n-            _recordNumber += 1;\n+            using (_lastSubStream = stream as SubStream)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks fine to me (but mostly I'm just putting a comment here so this is more visible)",
              "createdAt": "2024-04-10T15:43:43Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -60,7 +60,9 @@ public static byte[] ReadToEnd(this Stream stream)\n         {\n             if (stream.TryGetLength(out long length))\n             {\n-                BinaryReader reader = new(stream);\n+                // check with Jan",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This one I don't understand, what was wrong with it before?",
              "createdAt": "2024-04-10T15:44:52Z",
              "path": "src/Deprecated/Engine/Engine/IntrinsicFunctions.cs",
              "diffHunk": "@@ -197,26 +197,34 @@ internal static object GetRegistryValueFromView(string keyName, string valueName\n                     // of that error.\n                     RegistryView view = (RegistryView)Enum.Parse(typeof(RegistryView), viewAsString, true);\n \n-                    using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))\n+                    RegistryKey key = null;\n+                    try\n                     {\n-                        if (key != null)\n+                        using (key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))\n                         {\n-                            using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n+                            if (key != null)\n                             {\n-                                // If we managed to retrieve the subkey, then move onto locating the value\n-                                if (subKey != null)\n+                                using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n                                 {\n-                                    result = subKey.GetValue(valueName);\n-                                }\n-\n-                                // We've found a value, so stop looking\n-                                if (result != null)\n-                                {\n-                                    break;\n+                                    // If we managed to retrieve the subkey, then move onto locating the value\n+                                    if (subKey != null)\n+                                    {\n+                                        result = subKey.GetValue(valueName);\n+                                    }\n+\n+                                    // We've found a value, so stop looking\n+                                    if (result != null)\n+                                    {\n+                                        break;\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n+                    finally\n+                    {\n+                        key?.Dispose();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "![image](https://github.com/dotnet/msbuild/assets/95473390/7676e38a-8a47-4abf-b822-8aff3a753f1e)\r\n",
              "createdAt": "2024-04-11T07:40:00Z",
              "path": "src/Deprecated/Engine/Engine/IntrinsicFunctions.cs",
              "diffHunk": "@@ -197,26 +197,34 @@ internal static object GetRegistryValueFromView(string keyName, string valueName\n                     // of that error.\n                     RegistryView view = (RegistryView)Enum.Parse(typeof(RegistryView), viewAsString, true);\n \n-                    using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))\n+                    RegistryKey key = null;\n+                    try\n                     {\n-                        if (key != null)\n+                        using (key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))\n                         {\n-                            using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n+                            if (key != null)\n                             {\n-                                // If we managed to retrieve the subkey, then move onto locating the value\n-                                if (subKey != null)\n+                                using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n                                 {\n-                                    result = subKey.GetValue(valueName);\n-                                }\n-\n-                                // We've found a value, so stop looking\n-                                if (result != null)\n-                                {\n-                                    break;\n+                                    // If we managed to retrieve the subkey, then move onto locating the value\n+                                    if (subKey != null)\n+                                    {\n+                                        result = subKey.GetValue(valueName);\n+                                    }\n+\n+                                    // We've found a value, so stop looking\n+                                    if (result != null)\n+                                    {\n+                                        break;\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n+                    finally\n+                    {\n+                        key?.Dispose();",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Same as the other occurrence of this pattern, I think it's worth reporting as an analyzer bug.",
              "createdAt": "2024-04-12T19:33:56Z",
              "path": "src/Deprecated/Engine/Engine/IntrinsicFunctions.cs",
              "diffHunk": "@@ -197,26 +197,34 @@ internal static object GetRegistryValueFromView(string keyName, string valueName\n                     // of that error.\n                     RegistryView view = (RegistryView)Enum.Parse(typeof(RegistryView), viewAsString, true);\n \n-                    using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))\n+                    RegistryKey key = null;\n+                    try\n                     {\n-                        if (key != null)\n+                        using (key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))\n                         {\n-                            using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n+                            if (key != null)\n                             {\n-                                // If we managed to retrieve the subkey, then move onto locating the value\n-                                if (subKey != null)\n+                                using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n                                 {\n-                                    result = subKey.GetValue(valueName);\n-                                }\n-\n-                                // We've found a value, so stop looking\n-                                if (result != null)\n-                                {\n-                                    break;\n+                                    // If we managed to retrieve the subkey, then move onto locating the value\n+                                    if (subKey != null)\n+                                    {\n+                                        result = subKey.GetValue(valueName);\n+                                    }\n+\n+                                    // We've found a value, so stop looking\n+                                    if (result != null)\n+                                    {\n+                                        break;\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n+                    finally\n+                    {\n+                        key?.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not SURE I understand the comment but it SOUNDS like it was intentionally keeping this handle open past the scope of this `using`, let's look at this closely.",
              "createdAt": "2024-04-10T15:47:13Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1337,34 +1340,36 @@ internal static int GetParentProcessId(int processId)\n             {\n                 // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.\n                 // This way, any handle we pass back is guaranteed to be one of our actual children.\n-                SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);\n-                if (childHandle.IsInvalid)\n+                using (SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "suppressed",
              "createdAt": "2024-04-11T09:39:28Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1337,34 +1340,36 @@ internal static int GetParentProcessId(int processId)\n             {\n                 // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.\n                 // This way, any handle we pass back is guaranteed to be one of our actual children.\n-                SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);\n-                if (childHandle.IsInvalid)\n+                using (SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we not need to dispose `m` too?",
              "createdAt": "2024-04-10T15:50:27Z",
              "path": "src/Tasks/ManifestUtil/XmlUtil.cs",
              "diffHunk": "@@ -115,7 +115,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona\n                 }\n \n                 var m = new MemoryStream();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Seems like there are now circumstances where this object would be created but not used, are those bad and should we avoid them?",
              "createdAt": "2024-04-10T15:52:43Z",
              "path": "src/Tasks/DownloadFile.cs",
              "diffHunk": "@@ -146,7 +146,8 @@ private async Task<bool> ExecuteAsync()\n         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)\n         {\n             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock\n-            using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true) { Timeout = TimeSpan.FromMilliseconds(Timeout) })\n+            using var httpHandler = new HttpClientHandler();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation",
              "createdAt": "2024-04-11T13:03:52Z",
              "path": "src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj",
              "diffHunk": "@@ -12,6 +12,7 @@\n     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n \n     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS;NO_FRAMEWORK_IVT</DefineConstants>\n+\t<NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Moving this line looks unnecessary.",
              "createdAt": "2024-04-11T13:13:43Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2004,13 +2004,13 @@ static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode,\n             IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,\n             GraphBuildRequestData graphBuildRequestData)\n         {\n-            var waitHandle = new AutoResetEvent(true);\n+            var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);\n+            using var waitHandle = new AutoResetEvent(true);\n             var graphBuildStateLock = new object();\n \n             var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);\n             var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);\n             var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();\n-            var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since `Synchronized()` is called here in the constructor, it should be this object's responsibility to dispose of it. The way it's done now, we _require_ the user of the object to get the `SyncWriter`, which is odd.",
              "createdAt": "2024-04-11T13:21:13Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,24 +432,21 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n+\n         internal sealed class RedirectConsoleWriter : StringWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n-            private RedirectConsoleWriter(Action<string> writeCallback)\n+            internal RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n                 _syncWriter = Synchronized(this);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "undo changes and suppressed warning. let's discuss it offline",
              "createdAt": "2024-04-11T15:34:59Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,24 +432,21 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n+\n         internal sealed class RedirectConsoleWriter : StringWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n-            private RedirectConsoleWriter(Action<string> writeCallback)\n+            internal RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n                 _syncWriter = Synchronized(this);",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "the discussed fix is published here\r\nhttps://github.com/dotnet/msbuild/pull/9983/commits/3760fcdcbe9b5f2a01c7ddfd81812c7d6f5a2347",
              "createdAt": "2024-04-11T17:09:33Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,24 +432,21 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n+\n         internal sealed class RedirectConsoleWriter : StringWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n-            private RedirectConsoleWriter(Action<string> writeCallback)\n+            internal RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n                 _syncWriter = Synchronized(this);",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "@rokonec the story of RedirectConsoleWriter starts here",
              "createdAt": "2024-04-15T09:22:14Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,24 +432,21 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n+\n         internal sealed class RedirectConsoleWriter : StringWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n-            private RedirectConsoleWriter(Action<string> writeCallback)\n+            internal RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n                 _syncWriter = Synchronized(this);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation",
              "createdAt": "2024-04-11T14:24:32Z",
              "path": "src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj",
              "diffHunk": "@@ -6,6 +6,7 @@\n     <IsShipping>false</IsShipping>\n     <IsTestProject>false</IsTestProject>\n     <IsTestLibrary>true</IsTestLibrary>\n+\t<NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`provider` is used here and then again further down. The new `Dispose()` call looks incorrect.",
              "createdAt": "2024-04-11T14:28:16Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -156,6 +156,10 @@ private string GenerateCode(out string extension)\n                 Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.CouldNotCreateProvider\", Language, e.Message);\n                 return null;\n             }\n+            finally\n+            {\n+                provider?.Dispose();\n+            }\n \n             extension = provider.FileExtension;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I packed all provider-depended parts with try/catch\r\nplease let me know if it's better\r\n",
              "createdAt": "2024-04-11T15:33:01Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -156,6 +156,10 @@ private string GenerateCode(out string extension)\n                 Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.CouldNotCreateProvider\", Language, e.Message);\n                 return null;\n             }\n+            finally\n+            {\n+                provider?.Dispose();\n+            }\n \n             extension = provider.FileExtension;",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can this be added to the pre-existing `finally` block?",
              "createdAt": "2024-04-11T14:55:05Z",
              "path": "src/Tasks/ManifestUtil/Util.cs",
              "diffHunk": "@@ -241,30 +242,37 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,\n             try\n             {\n                 s = fi.OpenRead();\n-                HashAlgorithm hashAlg;\n+                HashAlgorithm hashAlg = null;\n \n-                if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)\n+                try\n                 {\n+                    if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)\n+                    {\n #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n-                    hashAlg = SHA1.Create(\n+                        hashAlg = SHA1.Create(\n #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES\n-                        \"System.Security.Cryptography.SHA1CryptoServiceProvider\"\n+                            \"System.Security.Cryptography.SHA1CryptoServiceProvider\"\n #endif\n-                        );\n+                            );\n #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n-                }\n-                else\n-                {\n+                    }\n+                    else\n+                    {\n #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n-                    hashAlg = SHA256.Create(\n+                        hashAlg = SHA256.Create(\n #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES\n-                        \"System.Security.Cryptography.SHA256CryptoServiceProvider\"\n+                            \"System.Security.Cryptography.SHA256CryptoServiceProvider\"\n #endif\n-                        );\n+                            );\n #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n+                    }\n+                    byte[] hashBytes = hashAlg.ComputeHash(s);\n+                    hash = Convert.ToBase64String(hashBytes);\n+                }\n+                finally\n+                {\n+                    hashAlg?.Dispose();\n                 }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't look correct. The ownership of `csp` is transferred to `signer` so we should not be disposing of it here.",
              "createdAt": "2024-04-11T14:59:09Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -705,7 +705,7 @@ public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path\n                         CmiManifestSigner2 signer;\n                         if (useSha256 && rsa is RSACryptoServiceProvider rsacsp)\n                         {\n-                            RSACryptoServiceProvider csp = SignedCmiManifest2.GetFixedRSACryptoServiceProvider(rsacsp, useSha256);\n+                            using RSACryptoServiceProvider csp = SignedCmiManifest2.GetFixedRSACryptoServiceProvider(rsacsp, useSha256);\n                             signer = new CmiManifestSigner2(csp, cert, useSha256);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like we're assuming that overriding these three methods is enough, i.e. all the other `Write`/`WriteLine` overloads will call through these. Where does this guarantee come from?",
              "createdAt": "2024-04-12T18:55:47Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,28 +431,60 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n-        internal sealed class RedirectConsoleWriter : StringWriter\n+\n+        internal sealed class RedirectConsoleWriter : TextWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n+            private readonly StringWriter _internalWriter;\n+\n             private RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n-                _syncWriter = Synchronized(this);\n+                _internalWriter = new StringWriter();\n+                _syncWriter = Synchronized(_internalWriter);\n                 _timer = new Timer(TimerCallback, null, 0, 40);\n             }\n \n+            public override Encoding Encoding => _internalWriter.Encoding;\n+\n             public static TextWriter Create(Action<string> writeCallback)\n             {\n-                RedirectConsoleWriter writer = new(writeCallback);\n-                return writer._syncWriter;\n+                RedirectConsoleWriter writer = new RedirectConsoleWriter(writeCallback);\n+\n+                return writer;\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = _internalWriter.GetStringBuilder();\n+                string captured = sb.ToString();\n+                sb.Clear();\n+\n+                _writeCallback(captured);\n+                _internalWriter.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                _syncWriter.Write(value);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                _syncWriter.Write(buffer, index, count);\n+            }\n+\n+            public override void Write(string? value)\n+            {\n+                _syncWriter.Write(value);\n             }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "[pre-existing] It looks like the goal of this class is to expose a thread-safe `StringWriter` but this method is not thread-safe. Writes that happen between these two statements may be lost or corrupt the `StringBuilder`.",
              "createdAt": "2024-04-12T19:00:25Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,28 +431,60 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n-        internal sealed class RedirectConsoleWriter : StringWriter\n+\n+        internal sealed class RedirectConsoleWriter : TextWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n+            private readonly StringWriter _internalWriter;\n+\n             private RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n-                _syncWriter = Synchronized(this);\n+                _internalWriter = new StringWriter();\n+                _syncWriter = Synchronized(_internalWriter);\n                 _timer = new Timer(TimerCallback, null, 0, 40);\n             }\n \n+            public override Encoding Encoding => _internalWriter.Encoding;\n+\n             public static TextWriter Create(Action<string> writeCallback)\n             {\n-                RedirectConsoleWriter writer = new(writeCallback);\n-                return writer._syncWriter;\n+                RedirectConsoleWriter writer = new RedirectConsoleWriter(writeCallback);\n+\n+                return writer;\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = _internalWriter.GetStringBuilder();\n+                string captured = sb.ToString();\n+                sb.Clear();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "@rokonec, could you please join the discussion and advice on a better fix for RedirectConsoleWriter https://github.com/dotnet/msbuild/blob/6ef1733094989a1b8d56bc5d2998061681cf12fb/src/Build/BackEnd/Node/OutOfProcServerNode.cs#L435C55-L435C65 ?",
              "createdAt": "2024-04-15T09:21:31Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -430,28 +431,60 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;\n             _shutdownEvent.Set();\n         }\n-        internal sealed class RedirectConsoleWriter : StringWriter\n+\n+        internal sealed class RedirectConsoleWriter : TextWriter\n         {\n             private readonly Action<string> _writeCallback;\n             private readonly Timer _timer;\n             private readonly TextWriter _syncWriter;\n \n+            private readonly StringWriter _internalWriter;\n+\n             private RedirectConsoleWriter(Action<string> writeCallback)\n             {\n                 _writeCallback = writeCallback;\n-                _syncWriter = Synchronized(this);\n+                _internalWriter = new StringWriter();\n+                _syncWriter = Synchronized(_internalWriter);\n                 _timer = new Timer(TimerCallback, null, 0, 40);\n             }\n \n+            public override Encoding Encoding => _internalWriter.Encoding;\n+\n             public static TextWriter Create(Action<string> writeCallback)\n             {\n-                RedirectConsoleWriter writer = new(writeCallback);\n-                return writer._syncWriter;\n+                RedirectConsoleWriter writer = new RedirectConsoleWriter(writeCallback);\n+\n+                return writer;\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = _internalWriter.GetStringBuilder();\n+                string captured = sb.ToString();\n+                sb.Clear();",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It's odd that the analyzer requires the explicit finally. I think I would slightly prefer suppressing and reporting it to the Roslyn analyzer folks as a bug.",
              "createdAt": "2024-04-12T19:05:24Z",
              "path": "src/Build/Evaluation/IntrinsicFunctions.cs",
              "diffHunk": "@@ -291,26 +291,34 @@ internal static object GetRegistryValueFromView(string keyName, string valueName\n                         return string.Empty;\n                     }\n \n-                    using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out string subKeyName))\n+                    RegistryKey key = null;\n+                    try\n                     {\n-                        if (key != null)\n+                        using (key = GetBaseKeyFromKeyName(keyName, view, out string subKeyName))\n                         {\n-                            using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n+                            if (key != null)\n                             {\n-                                // If we managed to retrieve the subkey, then move onto locating the value\n-                                if (subKey != null)\n+                                using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))\n                                 {\n-                                    result = subKey.GetValue(valueName);\n-                                }\n-\n-                                // We've found a value, so stop looking\n-                                if (result != null)\n-                                {\n-                                    break;\n+                                    // If we managed to retrieve the subkey, then move onto locating the value\n+                                    if (subKey != null)\n+                                    {\n+                                        result = subKey.GetValue(valueName);\n+                                    }\n+\n+                                    // We've found a value, so stop looking\n+                                    if (result != null)\n+                                    {\n+                                        break;\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n+                    finally\n+                    {\n+                        key?.Dispose();\n+                    }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Another worm in the can you opened :wink:\r\n`BinaryReader` closes the underlying stream in its `Dispose`. So upon leaving this method, the stream will be closed depending on whether it supports getting length or not. Assuming the contract should be \"returns bytes but doesn't close the stream\", this should probably be changed to:\r\n```suggestion\r\n                using BinaryReader reader = new(stream, Encoding.UTF8, leaveOpen: true);\r\n```",
              "createdAt": "2024-04-12T19:24:18Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs",
              "diffHunk": "@@ -60,7 +60,8 @@ public static byte[] ReadToEnd(this Stream stream)\n         {\n             if (stream.TryGetLength(out long length))\n             {\n-                BinaryReader reader = new(stream);\n+                using BinaryReader reader = new(stream);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There is a finally block with an explicit `Dispose` call down below. I think the try/catch can now be deleted.",
              "createdAt": "2024-04-12T19:38:15Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1296,26 +1298,27 @@ internal static int GetParentProcessId(int processId)\n         else\n #endif\n         {\n-            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);\n-\n-            if (!hProcess.IsInvalid)\n+            using SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation",
              "createdAt": "2024-04-12T19:39:29Z",
              "path": "src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj",
              "diffHunk": "@@ -4,6 +4,7 @@\n     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>\n     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>\n     <IsPackable>false</IsPackable>\n+  \t<NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation",
              "createdAt": "2024-04-15T07:07:57Z",
              "path": "src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj",
              "diffHunk": "@@ -6,6 +6,7 @@\n     <IsShipping>false</IsShipping>\n     <IsTestProject>false</IsTestProject>\n     <IsTestLibrary>true</IsTestLibrary>\n+\t  <NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In this case I think expanding the try block to contain pretty much the entire method is unnecessary. Unless it's intentional and we expect these exceptions from other code, not just `CodeDomProvider.CreateProvider`), I think it would be better to add a separate `try`/`finally` and leave the original try block as is.",
              "createdAt": "2024-04-15T07:22:21Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -140,141 +140,145 @@ private string GenerateCode(out string extension)\n             extension = null;\n             bool haveGeneratedContent = false;\n \n-            CodeDomProvider provider;\n+            string code = string.Empty;\n+            CodeDomProvider provider = null;\n \n             try\n             {\n                 provider = CodeDomProvider.CreateProvider(Language);\n-            }\n-            catch (SystemException e) when\n-#if FEATURE_SYSTEM_CONFIGURATION\n-            (e is ConfigurationException || e is SecurityException)\n-#else\n-            (e.GetType().Name == \"ConfigurationErrorsException\") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456\n-#endif\n-            {\n-                Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.CouldNotCreateProvider\", Language, e.Message);\n-                return null;\n-            }\n+                extension = provider.FileExtension;\n \n-            extension = provider.FileExtension;\n+                var unit = new CodeCompileUnit();\n \n-            var unit = new CodeCompileUnit();\n+                var globalNamespace = new CodeNamespace();\n+                unit.Namespaces.Add(globalNamespace);\n \n-            var globalNamespace = new CodeNamespace();\n-            unit.Namespaces.Add(globalNamespace);\n+                // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.\n+                string comment = ResourceUtilities.GetResourceString(\"WriteCodeFragment.Comment\");\n+                globalNamespace.Comments.Add(new CodeCommentStatement(comment));\n \n-            // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.\n-            string comment = ResourceUtilities.GetResourceString(\"WriteCodeFragment.Comment\");\n-            globalNamespace.Comments.Add(new CodeCommentStatement(comment));\n+                if (AssemblyAttributes == null)\n+                {\n+                    return String.Empty;\n+                }\n \n-            if (AssemblyAttributes == null)\n-            {\n-                return String.Empty;\n-            }\n+                // For convenience, bring in the namespaces, where many assembly attributes lie\n+                foreach (string name in NamespaceImports)\n+                {\n+                    globalNamespace.Imports.Add(new CodeNamespaceImport(name));\n+                }\n \n-            // For convenience, bring in the namespaces, where many assembly attributes lie\n-            foreach (string name in NamespaceImports)\n-            {\n-                globalNamespace.Imports.Add(new CodeNamespaceImport(name));\n-            }\n+                foreach (ITaskItem attributeItem in AssemblyAttributes)\n+                {\n+                    // Some attributes only allow positional constructor arguments, or the user may just prefer them.\n+                    // To set those, use metadata names like \"_Parameter1\", \"_Parameter2\" etc.\n+                    // If a parameter index is skipped, it's an error.\n+                    IDictionary customMetadata = attributeItem.CloneCustomMetadata();\n \n-            foreach (ITaskItem attributeItem in AssemblyAttributes)\n-            {\n-                // Some attributes only allow positional constructor arguments, or the user may just prefer them.\n-                // To set those, use metadata names like \"_Parameter1\", \"_Parameter2\" etc.\n-                // If a parameter index is skipped, it's an error.\n-                IDictionary customMetadata = attributeItem.CloneCustomMetadata();\n+                    // Some metadata may indicate the types of parameters. Use that metadata to determine\n+                    // the parameter types. Those metadata items will be removed from the dictionary.\n+                    IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);\n \n-                // Some metadata may indicate the types of parameters. Use that metadata to determine\n-                // the parameter types. Those metadata items will be removed from the dictionary.\n-                IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);\n+                    var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);\n+                    var namedParameters = new List<AttributeParameter>();\n \n-                var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);\n-                var namedParameters = new List<AttributeParameter>();\n+                    foreach (DictionaryEntry entry in customMetadata)\n+                    {\n+                        string name = (string)entry.Key;\n+                        string value = (string)entry.Value;\n \n-                foreach (DictionaryEntry entry in customMetadata)\n-                {\n-                    string name = (string)entry.Key;\n-                    string value = (string)entry.Value;\n+                        // Get the declared type information for this parameter.\n+                        // If a type is not declared, then we infer the type.\n+                        if (!parameterTypes.TryGetValue(name, out ParameterType type))\n+                        {\n+                            type = new ParameterType { Kind = ParameterTypeKind.Inferred };\n+                        }\n \n-                    // Get the declared type information for this parameter.\n-                    // If a type is not declared, then we infer the type.\n-                    if (!parameterTypes.TryGetValue(name, out ParameterType type))\n-                    {\n-                        type = new ParameterType { Kind = ParameterTypeKind.Inferred };\n+                        if (name.StartsWith(\"_Parameter\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            if (!Int32.TryParse(name.Substring(\"_Parameter\".Length), out int index))\n+                            {\n+                                Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", name, \"WriteCodeFragment\");\n+                                return null;\n+                            }\n+\n+                            if (index > orderedParameters.Count || index < 1)\n+                            {\n+                                Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", index);\n+                                return null;\n+                            }\n+\n+                            // \"_Parameter01\" and \"_Parameter1\" would overwrite each other\n+                            orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };\n+                        }\n+                        else\n+                        {\n+                            namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });\n+                        }\n                     }\n \n-                    if (name.StartsWith(\"_Parameter\", StringComparison.OrdinalIgnoreCase))\n+                    bool encounteredNull = false;\n+                    List<AttributeParameter> providedOrderedParameters = new();\n+                    for (int i = 0; i < orderedParameters.Count; i++)\n                     {\n-                        if (!Int32.TryParse(name.Substring(\"_Parameter\".Length), out int index))\n+                        if (!orderedParameters[i].HasValue)\n                         {\n-                            Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", name, \"WriteCodeFragment\");\n-                            return null;\n+                            // All subsequent args should be null, else a slot was missed\n+                            encounteredNull = true;\n+                            continue;\n                         }\n \n-                        if (index > orderedParameters.Count || index < 1)\n+                        if (encounteredNull)\n                         {\n-                            Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", index);\n+                            Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", i + 1 /* back to 1 based */);\n                             return null;\n                         }\n \n-                        // \"_Parameter01\" and \"_Parameter1\" would overwrite each other\n-                        orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };\n+                        providedOrderedParameters.Add(orderedParameters[i].Value);\n                     }\n-                    else\n-                    {\n-                        namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });\n-                    }\n-                }\n \n-                bool encounteredNull = false;\n-                List<AttributeParameter> providedOrderedParameters = new();\n-                for (int i = 0; i < orderedParameters.Count; i++)\n-                {\n-                    if (!orderedParameters[i].HasValue)\n-                    {\n-                        // All subsequent args should be null, else a slot was missed\n-                        encounteredNull = true;\n-                        continue;\n-                    }\n+                    var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n+\n+                    // We might need the type of the attribute if we need to infer the\n+                    // types of the parameters. Search for it by the given type name,\n+                    // as well as within the namespaces that we automatically import.\n+                    Lazy<Type> attributeType = new(\n+                        () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\", throwOnError: false)).FirstOrDefault(),\n+                        System.Threading.LazyThreadSafetyMode.None);\n \n-                    if (encounteredNull)\n+                    if (\n+                        !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)\n+                        || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))\n                     {\n-                        Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", i + 1 /* back to 1 based */);\n                         return null;\n                     }\n \n-                    providedOrderedParameters.Add(orderedParameters[i].Value);\n+                    unit.AssemblyCustomAttributes.Add(attribute);\n+                    haveGeneratedContent = true;\n                 }\n \n-                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n-\n-                // We might need the type of the attribute if we need to infer the\n-                // types of the parameters. Search for it by the given type name,\n-                // as well as within the namespaces that we automatically import.\n-                Lazy<Type> attributeType = new(\n-                    () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\", throwOnError: false)).FirstOrDefault(),\n-                    System.Threading.LazyThreadSafetyMode.None);\n-\n-                if (\n-                    !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)\n-                    || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))\n+                var generatedCode = new StringBuilder();\n+                using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))\n                 {\n-                    return null;\n+                    provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());\n                 }\n \n-                unit.AssemblyCustomAttributes.Add(attribute);\n-                haveGeneratedContent = true;\n+                code = generatedCode.ToString();\n             }\n-\n-            var generatedCode = new StringBuilder();\n-            using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))\n+            catch (SystemException e) when\n+#if FEATURE_SYSTEM_CONFIGURATION\n+            (e is ConfigurationException || e is SecurityException)\n+#else\n+            (e.GetType().Name == \"ConfigurationErrorsException\") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456\n+#endif\n             {\n-                provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());\n+                Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.CouldNotCreateProvider\", Language, e.Message);\n+                return null;\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This looks unnecessary.",
              "createdAt": "2024-04-15T07:33:44Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -5,6 +5,7 @@\n using System.IO;\n using System.IO.Compression;\n using System.Linq;\n+using System.Runtime.InteropServices.ComTypes;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this another false positive? Both variables are initialized with `using` so `Dispose` should already be guaranteed.",
              "createdAt": "2024-04-15T07:37:33Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -146,6 +149,8 @@ public override bool Execute()\n             finally\n             {\n                 BuildEngine3.Reacquire();\n+                stream?.Dispose();\n+                zipArchive?.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We seem to expect the stream to stay open after we're done with it here, see the last statement in this method `s.Position = 0` and the callers. We should probably be constructing the `StreamReader` with `leaveOpen: true`.",
              "createdAt": "2024-04-15T07:45:22Z",
              "path": "src/Tasks/ManifestUtil/Util.cs",
              "diffHunk": "@@ -520,7 +521,7 @@ public static void WriteLogFile(string filename, Stream s)\n             }\n \n             string path = Path.Combine(logPath, filename);\n-            StreamReader r = new StreamReader(s);\n+            using StreamReader r = new StreamReader(s);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "suppressed",
              "createdAt": "2024-04-15T12:40:41Z",
              "path": "src/Tasks/ManifestUtil/Util.cs",
              "diffHunk": "@@ -520,7 +521,7 @@ public static void WriteLogFile(string filename, Stream s)\n             }\n \n             string path = Path.Combine(logPath, filename);\n-            StreamReader r = new StreamReader(s);\n+            using StreamReader r = new StreamReader(s);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We are working with `fs` below so this should probably use `leaveOpen: true`.",
              "createdAt": "2024-04-15T07:49:11Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -205,7 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)\n                         {\n                             try\n                             {\n-                                var sr = new StreamReader(fs);\n+                                using var sr = new StreamReader(fs);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "suppressed",
              "createdAt": "2024-04-15T12:40:47Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -205,7 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)\n                         {\n                             try\n                             {\n-                                var sr = new StreamReader(fs);\n+                                using var sr = new StreamReader(fs);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We return `m` from the method so we shouldn't be closing it. `leaveOpen: true` ?",
              "createdAt": "2024-04-15T07:53:47Z",
              "path": "src/Tasks/ManifestUtil/ManifestWriter.cs",
              "diffHunk": "@@ -24,7 +24,7 @@ private static Stream Serialize(Manifest manifest)\n             manifest.OnBeforeSave();\n             var m = new MemoryStream();\n             var s = new XmlSerializer(manifest.GetType());\n-            var w = new StreamWriter(m);\n+            using var w = new StreamWriter(m);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "suppressed",
              "createdAt": "2024-04-15T12:40:54Z",
              "path": "src/Tasks/ManifestUtil/ManifestWriter.cs",
              "diffHunk": "@@ -24,7 +24,7 @@ private static Stream Serialize(Manifest manifest)\n             manifest.OnBeforeSave();\n             var m = new MemoryStream();\n             var s = new XmlSerializer(manifest.GetType());\n-            var w = new StreamWriter(m);\n+            using var w = new StreamWriter(m);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is incorrect. The object is registered with the engine and disposed of at the end of the build.\r\nhttps://github.com/dotnet/msbuild/blob/6fec6072f0591bede57a71474ddc08b95e3e4c28/src/Shared/RegisteredTaskObjectCacheBase.cs#L140",
              "createdAt": "2024-04-15T08:31:09Z",
              "path": "src/Tasks/GetInstalledSDKLocations.cs",
              "diffHunk": "@@ -194,7 +194,7 @@ public override bool Execute()\n                 object staticCacheDisposer = buildEngine4.GetRegisteredTaskObject(StaticSDKCacheKey, RegisteredTaskObjectLifetime.Build);\n                 if (staticCacheDisposer == null)\n                 {\n-                    BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);\n+                    using BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We are already calling `Dispose` on line 70 below and the catch blocks use `reader` so it looks like we should not be disposing of it here.",
              "createdAt": "2024-04-15T08:38:37Z",
              "path": "src/Tasks/AppConfig/AppConfig.cs",
              "diffHunk": "@@ -34,8 +34,10 @@ internal void Load(string appConfigFilePath)\n                 // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.\n                 // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings\n                 FileStream fs = File.OpenRead(appConfigFilePath);\n-                reader = XmlReader.Create(fs, readerSettings);\n-                Read(reader);\n+                using (reader = XmlReader.Create(fs, readerSettings))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation",
              "createdAt": "2024-04-15T08:39:13Z",
              "path": "src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj",
              "diffHunk": "@@ -14,6 +14,7 @@\n     <IsTestProject>true</IsTestProject>\n     <IsLibraryTestProject>true</IsLibraryTestProject>\n     <DefineConstants>$(DefineConstants);NET35_UNITTEST</DefineConstants>\n+\t<NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Indentation",
              "createdAt": "2024-04-15T08:39:26Z",
              "path": "src/StringTools.UnitTests/StringTools.UnitTests.csproj",
              "diffHunk": "@@ -8,6 +8,7 @@\n     <AssemblyName>Microsoft.NET.StringTools.UnitTests</AssemblyName>\n     <IsTestProject>true</IsTestProject>\n     <IsLibraryTestProject>true</IsLibraryTestProject>\n+\t<NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\u2764\ufe0f ",
              "createdAt": "2024-04-15T08:41:44Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -4001,9 +4020,7 @@ private static DistributedLoggerRecord CreateForwardingLoggerRecord(ILogger logg\n         internal static void ProcessDistributedFileLogger(\n             bool distributedFileLogger,\n             string[] fileLoggerParameters,\n-            List<DistributedLoggerRecord> distributedLoggerRecords,\n-            List<ILogger> loggers,\n-            int cpuCount)\n+            List<DistributedLoggerRecord> distributedLoggerRecords)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This may close `Console.Out`.",
              "createdAt": "2024-04-15T08:44:24Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -885,10 +893,18 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n-                    if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)\n+                    TextWriter outputStream = null;\n+                    try\n+                    {\n+                        if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)\n+                        {\n+                            outputStream = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;\n+                            exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, outputStream);\n+                        }\n+                    }\n+                    finally\n                     {\n-                        TextWriter outputStream = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;\n-                        exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, outputStream);\n+                        outputStream?.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This may close `Console.Out`.",
              "createdAt": "2024-04-15T08:44:43Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -833,6 +837,10 @@ private static void DebuggerLaunchCheck()\n                         {\n                             exitType = ExitType.BuildError;\n                         }\n+                        finally\n+                        {\n+                            output?.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This could be\r\n```suggestion\r\n                using FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);\r\n```\r\nand the `Close` call near the end of the method could be deleted.",
              "createdAt": "2024-04-15T08:49:13Z",
              "path": "src/Tasks/GenerateResource.cs",
              "diffHunk": "@@ -975,7 +975,7 @@ private bool IsDangerous(String filename)\n                 dangerous = false;\n \n                 FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This call looks redundant since we do the same in the `finally` block.",
              "createdAt": "2024-04-15T08:51:32Z",
              "path": "src/Tasks/GenerateResource.cs",
              "diffHunk": "@@ -2153,11 +2156,20 @@ private void RecordFilesWritten()\n             {\n                 if (StronglyTypedFileName == null)\n                 {\n-                    CodeDomProvider provider;\n-                    if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))\n+                    CodeDomProvider provider = null;\n+                    try\n+                    {\n+                        if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))\n+                        {\n+                            StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(\n+                                provider, OutputResources[0].ItemSpec);\n+\n+                            provider.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should be done later as `provider` is used below.",
              "createdAt": "2024-04-15T08:52:40Z",
              "path": "src/Tasks/GenerateResource.cs",
              "diffHunk": "@@ -3412,11 +3424,18 @@ private bool HaveSystemResourcesExtensionsReference\n         /// <param name=\"sourceFile\">The generated strongly typed filename</param>\n         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)\n         {\n-            CodeDomProvider provider;\n-            if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))\n+            CodeDomProvider provider = null;\n+            try\n             {\n-                sourceFile = null;\n-                return;\n+                if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))\n+                {\n+                    sourceFile = null;\n+                    return;\n+                }\n+            }\n+            finally\n+            {\n+                provider?.Dispose();\n             }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't this condition always hold now that we create the file before we call this method?",
              "createdAt": "2024-04-15T08:58:57Z",
              "path": "src/Build/BackEnd/Shared/TargetResult.cs",
              "diffHunk": "@@ -339,23 +345,24 @@ private void TranslateItems(ITranslator translator)\n         /// <summary>\n         /// Gets the translator for this configuration.\n         /// </summary>\n-        private static ITranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction)\n+        private static ITranslator GetResultsCacheTranslator(\n+            TranslationDirection direction,\n+            Stream stream,\n+            string cacheFile)\n         {\n-            string cacheFile = GetCacheFile(configId, targetToCache);\n             if (direction == TranslationDirection.WriteToStream)\n             {\n-                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));\n                 if (FileSystems.Default.FileExists(cacheFile))\n                 {\n                     // If the file already exists, then we have cached this once before.  No need to cache it again since it cannot have changed.\n                     return null;\n                 }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "moved condition in the caller",
              "createdAt": "2024-04-15T12:41:45Z",
              "path": "src/Build/BackEnd/Shared/TargetResult.cs",
              "diffHunk": "@@ -339,23 +345,24 @@ private void TranslateItems(ITranslator translator)\n         /// <summary>\n         /// Gets the translator for this configuration.\n         /// </summary>\n-        private static ITranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction)\n+        private static ITranslator GetResultsCacheTranslator(\n+            TranslationDirection direction,\n+            Stream stream,\n+            string cacheFile)\n         {\n-            string cacheFile = GetCacheFile(configId, targetToCache);\n             if (direction == TranslationDirection.WriteToStream)\n             {\n-                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));\n                 if (FileSystems.Default.FileExists(cacheFile))\n                 {\n                     // If the file already exists, then we have cached this once before.  No need to cache it again since it cannot have changed.\n                     return null;\n                 }",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Shouldn't the condition be removed from this method? I see it in the caller but it's stayed here and will always be true. The `cacheFile` parameter should not be needed at all.",
              "createdAt": "2024-04-17T12:38:25Z",
              "path": "src/Build/BackEnd/Shared/TargetResult.cs",
              "diffHunk": "@@ -339,23 +345,24 @@ private void TranslateItems(ITranslator translator)\n         /// <summary>\n         /// Gets the translator for this configuration.\n         /// </summary>\n-        private static ITranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction)\n+        private static ITranslator GetResultsCacheTranslator(\n+            TranslationDirection direction,\n+            Stream stream,\n+            string cacheFile)\n         {\n-            string cacheFile = GetCacheFile(configId, targetToCache);\n             if (direction == TranslationDirection.WriteToStream)\n             {\n-                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));\n                 if (FileSystems.Default.FileExists(cacheFile))\n                 {\n                     // If the file already exists, then we have cached this once before.  No need to cache it again since it cannot have changed.\n                     return null;\n                 }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We now open the file outside of the `try` block so this will probably not work anymore.",
              "createdAt": "2024-04-15T09:02:58Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -1024,23 +1030,17 @@ private static string ResolveToolsVersion(BuildRequestData data, string defaultT\n         /// <summary>\n         /// Gets the translator for this configuration.\n         /// </summary>\n-        private ITranslator GetConfigurationTranslator(TranslationDirection direction)\n+        private ITranslator GetConfigurationTranslator(TranslationDirection direction, Stream stream, string cacheFile)\n         {\n-            string cacheFile = GetCacheFile();\n             try\n             {\n-                if (direction == TranslationDirection.WriteToStream)\n-                {\n-                    Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));\n-                    return BinaryTranslator.GetWriteTranslator(File.Create(cacheFile));\n-                }\n-                else\n-                {\n+                return direction == TranslationDirection.WriteToStream\n+                    ? BinaryTranslator.GetWriteTranslator(stream)\n+\n                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.\n-                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);\n-                }\n+                    : BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);\n             }\n-            catch (Exception e) when (e is DirectoryNotFoundException || e is UnauthorizedAccessException)\n+            catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)\n             {\n                 ErrorUtilities.ThrowInvalidOperation(\"CacheFileInaccessible\", cacheFile, e);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Here I think it would be better to fix it by constructing the `StreamReader` with `leaveOpen: true`. The way it is now, if `sr` gets collected before we leave this method it will close `fs` prematurely.\r\n",
              "createdAt": "2024-04-17T12:14:18Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -205,7 +205,9 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)\n                         {\n                             try\n                             {\n+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because it is managed by FileStream above.\n                                 var sr = new StreamReader(fs);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you assigned `new StreamWriter(getResultOutputFile)` into a separate local variable and run `?.Dispose()` on it in the finally block, would it take care of the violation?",
              "createdAt": "2024-04-17T12:21:30Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -885,10 +899,24 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n-                    if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)\n+                    TextWriter outputStream = null;\n+                    try\n+                    {\n+                        if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)\n+                        {\n+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the StreamWriter is disposed in the finally block",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: It looks like this finally block can be removed.",
              "createdAt": "2024-04-17T12:26:43Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1201,49 +1201,51 @@ internal static void KillTree(int processIdToKill)\n \n             // Grab the process handle.  We want to keep this open for the duration of the function so that\n             // it cannot be reused while we are running.\n-            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);\n-            if (hProcess.IsInvalid)\n+            using (SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill))\n             {\n-                return;\n-            }\n-\n-            try\n-            {\n-                try\n+                if (hProcess.IsInvalid)\n                 {\n-                    // Kill this process, so that no further children can be created.\n-                    thisProcess.Kill();\n+                    return;\n                 }\n-                catch (Win32Exception e) when (e.NativeErrorCode == ERROR_ACCESS_DENIED)\n-                {\n-                    // Access denied is potentially expected -- it happens when the process that\n-                    // we're attempting to kill is already dead.  So just ignore in that case.\n-                }\n-\n-                // Now enumerate our children.  Children of this process are any process which has this process id as its parent\n-                // and which also started after this process did.\n-                List<KeyValuePair<int, SafeProcessHandle>> children = GetChildProcessIds(processIdToKill, myStartTime);\n \n                 try\n                 {\n-                    foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)\n+                    try\n                     {\n-                        KillTree(childProcessInfo.Key);\n+                        // Kill this process, so that no further children can be created.\n+                        thisProcess.Kill();\n+                    }\n+                    catch (Win32Exception e) when (e.NativeErrorCode == ERROR_ACCESS_DENIED)\n+                    {\n+                        // Access denied is potentially expected -- it happens when the process that\n+                        // we're attempting to kill is already dead.  So just ignore in that case.\n+                    }\n+\n+                    // Now enumerate our children.  Children of this process are any process which has this process id as its parent\n+                    // and which also started after this process did.\n+                    List<KeyValuePair<int, SafeProcessHandle>> children = GetChildProcessIds(processIdToKill, myStartTime);\n+\n+                    try\n+                    {\n+                        foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)\n+                        {\n+                            KillTree(childProcessInfo.Key);\n+                        }\n+                    }\n+                    finally\n+                    {\n+                        foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)\n+                        {\n+                            childProcessInfo.Value.Dispose();\n+                        }\n                     }\n                 }\n                 finally\n                 {\n-                    foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)\n-                    {\n-                        childProcessInfo.Value.Dispose();\n-                    }\n+                    // Release the handle.  After this point no more children of this process exist and this process has also exited.\n+                    hProcess.Dispose();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This was previously inside the try/catch.",
              "createdAt": "2024-04-17T12:40:56Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -698,9 +698,21 @@ public void CacheIfPossible()\n                 {\n                     if (IsCacheable)\n                     {\n-                        using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream);\n+                        string cacheFile = GetCacheFile();\n+                        Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can this be just:\r\n```\r\nnew StreamReader(fs, leaveOpen: true);\r\n```\r\n?",
              "createdAt": "2024-04-18T12:37:07Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -205,9 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)\n                         {\n                             try\n                             {\n-#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because it is managed by FileStream above.\n-                                var sr = new StreamReader(fs);\n-#pragma warning restore CA2000 // Dispose objects before losing scope\n+                                using var sr = new StreamReader(fs, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "nope (:\r\n<img width=\"1778\" alt=\"image\" src=\"https://github.com/dotnet/msbuild/assets/95473390/cf88a249-1c25-4e6e-9a22-1087116257f8\">\r\n",
              "createdAt": "2024-04-18T13:39:10Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -205,9 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)\n                         {\n                             try\n                             {\n-#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because it is managed by FileStream above.\n-                                var sr = new StreamReader(fs);\n-#pragma warning restore CA2000 // Dispose objects before losing scope\n+                                using var sr = new StreamReader(fs, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "That's odd, the constructor declares all parameters except for Stream as optional \ud83d\ude22 ",
              "createdAt": "2024-04-18T14:00:06Z",
              "path": "src/Tasks/ManifestUtil/SecurityUtil.cs",
              "diffHunk": "@@ -205,9 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)\n                         {\n                             try\n                             {\n-#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because it is managed by FileStream above.\n-                                var sr = new StreamReader(fs);\n-#pragma warning restore CA2000 // Dispose objects before losing scope\n+                                using var sr = new StreamReader(fs, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Can these be defined in `eng\\Common.Test.globalconfig` so they apply to all tests in a single place and use the same phrasing as the main `.editorconfig`?",
              "createdAt": "2024-04-18T15:08:09Z",
              "path": "src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj",
              "diffHunk": "@@ -12,6 +12,7 @@\n     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n \n     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS;NO_FRAMEWORK_IVT</DefineConstants>\n+    <NoWarn>$(NoWarn);CA2000</NoWarn>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                provider?.Dispose();\r\n```",
              "createdAt": "2024-04-18T15:09:40Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -140,145 +140,154 @@ private string GenerateCode(out string extension)\n             extension = null;\n             bool haveGeneratedContent = false;\n \n-            CodeDomProvider provider;\n-\n+            CodeDomProvider provider = null;\n             try\n             {\n-                provider = CodeDomProvider.CreateProvider(Language);\n-            }\n-            catch (SystemException e) when\n+                try\n+                {\n+                    provider = CodeDomProvider.CreateProvider(Language);\n+                }\n+                catch (SystemException e) when\n #if FEATURE_SYSTEM_CONFIGURATION\n-            (e is ConfigurationException || e is SecurityException)\n+                (e is ConfigurationException || e is SecurityException)\n #else\n             (e.GetType().Name == \"ConfigurationErrorsException\") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456\n #endif\n-            {\n-                Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.CouldNotCreateProvider\", Language, e.Message);\n-                return null;\n-            }\n-\n-            extension = provider.FileExtension;\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.CouldNotCreateProvider\", Language, e.Message);\n+                    return null;\n+                }\n \n-            var unit = new CodeCompileUnit();\n+                extension = provider.FileExtension;\n \n-            var globalNamespace = new CodeNamespace();\n-            unit.Namespaces.Add(globalNamespace);\n+                var unit = new CodeCompileUnit();\n \n-            // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.\n-            string comment = ResourceUtilities.GetResourceString(\"WriteCodeFragment.Comment\");\n-            globalNamespace.Comments.Add(new CodeCommentStatement(comment));\n+                var globalNamespace = new CodeNamespace();\n+                unit.Namespaces.Add(globalNamespace);\n \n-            if (AssemblyAttributes == null)\n-            {\n-                return String.Empty;\n-            }\n+                // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.\n+                string comment = ResourceUtilities.GetResourceString(\"WriteCodeFragment.Comment\");\n+                globalNamespace.Comments.Add(new CodeCommentStatement(comment));\n \n-            // For convenience, bring in the namespaces, where many assembly attributes lie\n-            foreach (string name in NamespaceImports)\n-            {\n-                globalNamespace.Imports.Add(new CodeNamespaceImport(name));\n-            }\n+                if (AssemblyAttributes == null)\n+                {\n+                    return String.Empty;\n+                }\n \n-            foreach (ITaskItem attributeItem in AssemblyAttributes)\n-            {\n-                // Some attributes only allow positional constructor arguments, or the user may just prefer them.\n-                // To set those, use metadata names like \"_Parameter1\", \"_Parameter2\" etc.\n-                // If a parameter index is skipped, it's an error.\n-                IDictionary customMetadata = attributeItem.CloneCustomMetadata();\n+                // For convenience, bring in the namespaces, where many assembly attributes lie\n+                foreach (string name in NamespaceImports)\n+                {\n+                    globalNamespace.Imports.Add(new CodeNamespaceImport(name));\n+                }\n \n-                // Some metadata may indicate the types of parameters. Use that metadata to determine\n-                // the parameter types. Those metadata items will be removed from the dictionary.\n-                IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);\n+                foreach (ITaskItem attributeItem in AssemblyAttributes)\n+                {\n+                    // Some attributes only allow positional constructor arguments, or the user may just prefer them.\n+                    // To set those, use metadata names like \"_Parameter1\", \"_Parameter2\" etc.\n+                    // If a parameter index is skipped, it's an error.\n+                    IDictionary customMetadata = attributeItem.CloneCustomMetadata();\n \n-                var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);\n-                var namedParameters = new List<AttributeParameter>();\n+                    // Some metadata may indicate the types of parameters. Use that metadata to determine\n+                    // the parameter types. Those metadata items will be removed from the dictionary.\n+                    IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);\n \n-                foreach (DictionaryEntry entry in customMetadata)\n-                {\n-                    string name = (string)entry.Key;\n-                    string value = (string)entry.Value;\n+                    var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);\n+                    var namedParameters = new List<AttributeParameter>();\n \n-                    // Get the declared type information for this parameter.\n-                    // If a type is not declared, then we infer the type.\n-                    if (!parameterTypes.TryGetValue(name, out ParameterType type))\n+                    foreach (DictionaryEntry entry in customMetadata)\n                     {\n-                        type = new ParameterType { Kind = ParameterTypeKind.Inferred };\n+                        string name = (string)entry.Key;\n+                        string value = (string)entry.Value;\n+\n+                        // Get the declared type information for this parameter.\n+                        // If a type is not declared, then we infer the type.\n+                        if (!parameterTypes.TryGetValue(name, out ParameterType type))\n+                        {\n+                            type = new ParameterType { Kind = ParameterTypeKind.Inferred };\n+                        }\n+\n+                        if (name.StartsWith(\"_Parameter\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            if (!Int32.TryParse(name.Substring(\"_Parameter\".Length), out int index))\n+                            {\n+                                Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", name, \"WriteCodeFragment\");\n+                                return null;\n+                            }\n+\n+                            if (index > orderedParameters.Count || index < 1)\n+                            {\n+                                Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", index);\n+                                return null;\n+                            }\n+\n+                            // \"_Parameter01\" and \"_Parameter1\" would overwrite each other\n+                            orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };\n+                        }\n+                        else\n+                        {\n+                            namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });\n+                        }\n                     }\n \n-                    if (name.StartsWith(\"_Parameter\", StringComparison.OrdinalIgnoreCase))\n+                    bool encounteredNull = false;\n+                    List<AttributeParameter> providedOrderedParameters = new();\n+                    for (int i = 0; i < orderedParameters.Count; i++)\n                     {\n-                        if (!Int32.TryParse(name.Substring(\"_Parameter\".Length), out int index))\n+                        if (!orderedParameters[i].HasValue)\n                         {\n-                            Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", name, \"WriteCodeFragment\");\n-                            return null;\n+                            // All subsequent args should be null, else a slot was missed\n+                            encounteredNull = true;\n+                            continue;\n                         }\n \n-                        if (index > orderedParameters.Count || index < 1)\n+                        if (encounteredNull)\n                         {\n-                            Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", index);\n+                            Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", i + 1 /* back to 1 based */);\n                             return null;\n                         }\n \n-                        // \"_Parameter01\" and \"_Parameter1\" would overwrite each other\n-                        orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };\n+                        providedOrderedParameters.Add(orderedParameters[i].Value);\n                     }\n-                    else\n-                    {\n-                        namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });\n-                    }\n-                }\n \n-                bool encounteredNull = false;\n-                List<AttributeParameter> providedOrderedParameters = new();\n-                for (int i = 0; i < orderedParameters.Count; i++)\n-                {\n-                    if (!orderedParameters[i].HasValue)\n-                    {\n-                        // All subsequent args should be null, else a slot was missed\n-                        encounteredNull = true;\n-                        continue;\n-                    }\n+                    var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n+\n+                    // We might need the type of the attribute if we need to infer the\n+                    // types of the parameters. Search for it by the given type name,\n+                    // as well as within the namespaces that we automatically import.\n+                    Lazy<Type> attributeType = new(\n+                        () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\", throwOnError: false)).FirstOrDefault(),\n+                        System.Threading.LazyThreadSafetyMode.None);\n \n-                    if (encounteredNull)\n+                    if (\n+                        !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)\n+                        || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))\n                     {\n-                        Log.LogErrorWithCodeFromResources(\"WriteCodeFragment.SkippedNumberedParameter\", i + 1 /* back to 1 based */);\n                         return null;\n                     }\n \n-                    providedOrderedParameters.Add(orderedParameters[i].Value);\n+                    unit.AssemblyCustomAttributes.Add(attribute);\n+                    haveGeneratedContent = true;\n                 }\n \n-                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n-\n-                // We might need the type of the attribute if we need to infer the\n-                // types of the parameters. Search for it by the given type name,\n-                // as well as within the namespaces that we automatically import.\n-                Lazy<Type> attributeType = new(\n-                    () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\", throwOnError: false)).FirstOrDefault(),\n-                    System.Threading.LazyThreadSafetyMode.None);\n-\n-                if (\n-                    !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)\n-                    || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))\n+                var generatedCode = new StringBuilder();\n+                using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))\n                 {\n-                    return null;\n+                    provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());\n                 }\n \n-                unit.AssemblyCustomAttributes.Add(attribute);\n-                haveGeneratedContent = true;\n-            }\n+                string code = generatedCode.ToString();\n \n-            var generatedCode = new StringBuilder();\n-            using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))\n+                // If we just generated infrastructure, don't bother returning anything\n+                // as there's no point writing the file\n+                return haveGeneratedContent ? code : String.Empty;\n+            }\n+            finally\n             {\n-                provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());\n+                if (provider != null)\n+                {\n+                    provider.Dispose();\n+                }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n#pragma warning disable CA2000 // Dispose objects before losing scope because the HttpClientHandler is disposed by HTTPClient.Dispose()\r\n```\r\n\r\n?",
              "createdAt": "2024-04-18T15:19:25Z",
              "path": "src/Tasks/DownloadFile.cs",
              "diffHunk": "@@ -146,6 +146,7 @@ private async Task<bool> ExecuteAsync()\n         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)\n         {\n             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock\n+#pragma warning disable CA2000 // Dispose objects before losing scope because the HttpClient is disposed by HTTPClient.Dispose()",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this right? It returns the underlying `MemoryStream m` but shouldn't we dispose the `StreamWriter`?\r\n```suggestion\r\n            using var w = new StreamWriter(m, System.Text.Encoding.UTF8, bufferSize: 1024, leaveOpen: true);\r\n```",
              "createdAt": "2024-04-18T15:24:36Z",
              "path": "src/Tasks/ManifestUtil/ManifestWriter.cs",
              "diffHunk": "@@ -24,14 +24,17 @@ private static Stream Serialize(Manifest manifest)\n             manifest.OnBeforeSave();\n             var m = new MemoryStream();\n             var s = new XmlSerializer(manifest.GetType());\n+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the stream is returned to the caller and will be handled there.\n             var w = new StreamWriter(m);\n+#pragma warning restore CA2000 // Dispose objects before losing scope",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n#pragma warning disable CA2000 // Dispose objects before losing scope - caller must dispose returned handles\r\n```",
              "createdAt": "2024-04-18T15:40:52Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1337,34 +1325,38 @@ internal static int GetParentProcessId(int processId)\n             {\n                 // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.\n                 // This way, any handle we pass back is guaranteed to be one of our actual children.\n+#pragma warning disable CA2000 // Dispose objects before losing scope by design",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}