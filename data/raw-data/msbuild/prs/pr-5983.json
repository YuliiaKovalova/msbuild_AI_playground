{
  "number": 5983,
  "title": "Switch to json serialization without adding support for precomputed caches",
  "body": "We need to move off BinaryFormatter.\r\n\r\nTest of basic functionality (creates simple cache in json and reads it) passed.",
  "state": "CLOSED",
  "createdAt": "2020-12-21T17:38:12Z",
  "updatedAt": "2021-01-25T23:29:13Z",
  "closedAt": "2021-01-25T23:29:13Z",
  "mergedAt": null,
  "additions": 685,
  "deletions": 144,
  "changedFiles": 25,
  "headRefName": "serialization-only",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a79f3080ea40840edf1a6563447a8121fa45000f",
          "message": "First stab at caching more RAR info\n\nThis gives RAR the ability to save off a modified state file and load it for later use.\n\nStill to do:\n1) Verify that the precomputed cache read in is real.\n2) Change logging such that it will log messages instead of errors or warnings if there are problems with deserializing the precomputed cache\n3) Comments at relevant points\n4) Switch serialization mode to another form (json?)\n5) Validation + performance tests\n6) Have SDK opt in",
          "committedDate": "2020-07-14T23:03:06Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1d7355985217b3de3049d383a9d829173bb3d390",
          "message": "PR comments pt. 1",
          "committedDate": "2020-07-21T17:20:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "036c5a38dd759b46dc8cb52e9fa244f737a6acf1",
          "message": "Resolve first three bullet points",
          "committedDate": "2020-07-21T20:50:05Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b3b613b728bb62f2b6ca1e97c267229f5f81078",
          "message": "Next steps",
          "committedDate": "2020-08-03T20:28:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6160d48cdf18dc7ad407588204fe1f475631f7d6",
          "message": "revert to BinaryFormatter",
          "committedDate": "2020-08-03T23:01:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9b95494d0351a91a2ed82f567c1d73cf751862e7",
          "message": "Serialize mvid",
          "committedDate": "2020-08-04T20:18:06Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43195f4f368c443643f6a9757a7d025ed19e6a92",
          "message": "Design change",
          "committedDate": "2020-08-10T21:46:13Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9045d3d68f4990896ce4c9ff774b113b9164d1ce",
          "message": "Serialize AssemblyNameExtension\n\nIt was previously serializable via BinaryFormatter. This makes it serializable via System.Text.Json's JsonConverter.",
          "committedDate": "2020-09-03T00:00:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ecf24de89e7a54f51ee3b6abccb9e79556bdad05",
          "message": "Serialize SystemState\n\nAdd support for serializing SystemState using System.Text.Json rather than the older BinaryFormatter.",
          "committedDate": "2020-09-03T00:00:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b25d16087c3d0046ce40df7b2393f26417d76414",
          "message": "Opt into new serialization behavior for all serialization rather than just when serializing and deserializing the precomputed cache",
          "committedDate": "2020-09-03T00:00:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9fa92fbafc3973efa4eaf9b554e1116da3dce914",
          "message": "Merge branch 'master' into json-serialization",
          "committedDate": "2020-09-03T00:03:55Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "560806632da291d575d7251256a1f96cbb853d2b",
          "message": "PR comments\n\nI have not yet measured how long it takes to read a MVID vs. reading and parsing its references, nor have I made unit tests.",
          "committedDate": "2020-09-04T01:12:29Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ccb508da7ec32a57f3e49ee232ddca480fd73a95",
          "message": "Make DeserializeCache take a generic StateFileBase",
          "committedDate": "2020-09-08T21:13:52Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "354de87d4348988be672611b780f71fd4ac64d07",
          "message": "Use FileSystems.Default.FileExists",
          "committedDate": "2020-09-08T21:14:11Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fd76e0b73da602b5c1e0ba72cc652044d0bd02a0",
          "message": "Convert instanceLocalFileStateCache to a dictionary",
          "committedDate": "2020-09-08T21:18:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1a7695f1291079bbebe6420e67815eea3754bdc",
          "message": "Fix generic",
          "committedDate": "2020-09-22T21:52:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d71f2a6552bfb85aaa7fd3695e0ca632d73f74af",
          "message": "Merge branch 'master' of https://github.com/dotnet/msbuild into rar-cache",
          "committedDate": "2020-09-22T21:53:14Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbe102851c5dbda71ef6bf3663d61231a538ccd0",
          "message": "Build",
          "committedDate": "2020-09-22T22:28:09Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d790150b5b0d1a12a3f92894173540846a9e47b8",
          "message": "Fix bad changes",
          "committedDate": "2020-09-23T17:22:33Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a759006ef6b192171673a2bf9bc2253b25acc8a6",
          "message": "Added tests 1",
          "committedDate": "2020-10-02T22:41:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "767f1ccbddd9c72dba9c0ed8959a3c3c2073bac4",
          "message": "Finish tests\n\n...although they don't work yet",
          "committedDate": "2020-10-06T22:42:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "412c21b6339c2609f49f06ce7c8e5e6f1813940e",
          "message": "Create delegates to mock system calls",
          "committedDate": "2020-10-08T23:54:57Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0450dd2b8f6a79139775b5dbe57274fff6b73ce4",
          "message": "Merge branch 'rar-cache' of https://github.com/forgind/msbuild into json-serialization",
          "committedDate": "2020-10-09T00:04:01Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9f930f438685f685b022ef2cbd3a9486a3dc7748",
          "message": "Small fixups",
          "committedDate": "2020-10-09T00:21:30Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "58217f657497623ad60db5c1a62c4df2ea53a084",
          "message": "Make constructor internal",
          "committedDate": "2020-10-09T00:25:20Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2043c3f5bc02a1514db81c892e9a55d2f75f9598",
          "message": "PR feedback",
          "committedDate": "2020-11-12T02:19:27Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "853fd38f0c14b0fcfeb7e760d5d7e502fad31cb4",
          "message": "Avoid using overly new feature",
          "committedDate": "2020-11-12T15:57:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bda6b3720ee66f0012d2dd05da8b3c7fc3aea69e",
          "message": "Real ANE",
          "committedDate": "2020-11-12T16:17:56Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a2c0f4298c7eaa2af902e3a513e204d12fa58315",
          "message": "Merge https://github.com/dotnet/msbuild into rar-cache",
          "committedDate": "2020-11-12T16:18:21Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d92e5dadec4f96860bc34ef2bf8050e10ab454cb",
          "message": "Merge branch 'rar-cache' of https://github.com/forgind/msbuild into json-serialization",
          "committedDate": "2020-11-12T16:21:27Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "37a758301d9b1e36541be8d353bf50b2c1548448",
          "message": "fixed test",
          "committedDate": "2020-11-12T17:10:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a5577222b07804e02046e174a4ed5c860e5d3b6b",
          "message": "Update versions\n\nThe version of Arcade MSBuild currently uses uses Roslyn version 3.3.1. This updates that, but it should be removed when we've updated to a more modern version of arcade.",
          "committedDate": "2020-11-23T19:57:58Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a6851f9ae73009cbbfb123eb566e74e448433c3",
          "message": "Merge branch 'update-versions' of https://github.com/forgind/msbuild into json-serialization",
          "committedDate": "2020-11-23T19:59:03Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59aaab14e8a42ec0825b3f5941c1da774e7423a7",
          "message": "Remove MVID check",
          "committedDate": "2020-12-04T16:24:52Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "df2d5c91cbed00235629911cde5ba6fab4121ca8",
          "message": "Merge branch 'rar-cache' of https://github.com/forgind/msbuild into json-serialization",
          "committedDate": "2020-12-04T16:27:05Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2f75074e91712f19ff8dc77d2a4fb27eed2b29e",
          "message": "Merge branch 'json-serialization' of https://github.com/forgind/msbuild into serialization-only",
          "committedDate": "2020-12-21T17:51:21Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11978bb8e444226c4f6a89489f6496a79e2035fb",
          "message": "Remove precomputed cache",
          "committedDate": "2020-12-21T18:09:51Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fcbeb811c52088d407b3727e19e9ecdc2603f1aa",
          "message": "Add fallback cache creation",
          "committedDate": "2020-12-21T18:30:38Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f3ed8d648dbb57b4d71127703c1b35c54bdbdb8",
          "message": "PR comments",
          "committedDate": "2020-12-22T18:00:21Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "08aede62329e0f399961c90b8ae964645cac1245",
          "message": "Switch to async",
          "committedDate": "2020-12-22T18:32:40Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01a3b56058ea6781ad3f9e2d65ae62a1419cf954",
          "message": "Make tests pass",
          "committedDate": "2020-12-24T02:27:24Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63f4b001ffa87020b833af3af6b4bc6a56044e9e",
          "message": "Use frameworkName",
          "committedDate": "2021-01-08T15:41:08Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d50dbb4aba8fc0e632e95a4a2403d6381ed79ec5",
          "message": "Add comment",
          "committedDate": "2021-01-08T16:12:55Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like a bad merge that's overwriting NuGet updates.",
              "createdAt": "2020-12-21T21:46:01Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -1,4 +1,12 @@\n <Project>\n+\n+  <PropertyGroup>\n+      <NuGetPackageVersion>5.9.0-preview.1.6870</NuGetPackageVersion>\n+      <NuGetBuildTasksVersion Condition=\"'$(NuGetBuildTasksVersion)' == ''\">$(NuGetPackageVersion)</NuGetBuildTasksVersion>\n+      <NuGetCommandsVersion Condition=\"'$(NuGetCommandsVersion)' == ''\">$(NuGetPackageVersion)</NuGetCommandsVersion>\n+      <NuGetProtocolVersion Condition=\"'$(NuGetProtocolVersion)' == ''\">$(NuGetPackageVersion)</NuGetProtocolVersion>\n+  </PropertyGroup>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We're using this in full framework now?",
              "createdAt": "2020-12-21T21:47:41Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -986,13 +986,15 @@\n   </ItemGroup>\n   <ItemGroup>\n     <PackageReference Include=\"System.Collections.Immutable\" />\n+    <PackageReference Include=\"System.Reflection.Metadata\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Among the things that (presumably) was useful at some stage in serialization, though possibly just for BinaryFormatter-serialized caches.",
              "createdAt": "2020-12-22T16:32:14Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -986,13 +986,15 @@\n   </ItemGroup>\n   <ItemGroup>\n     <PackageReference Include=\"System.Collections.Immutable\" />\n+    <PackageReference Include=\"System.Reflection.Metadata\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If this is a normal reference it should go in the `PackageReference` group above. The comments don't apply to normal references.",
              "createdAt": "2020-12-21T21:49:23Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -986,13 +986,15 @@\n   </ItemGroup>\n   <ItemGroup>\n     <PackageReference Include=\"System.Collections.Immutable\" />\n+    <PackageReference Include=\"System.Reflection.Metadata\" />\n     <PackageReference Include=\"System.Resources.Extensions\" />\n   </ItemGroup>\n \n   <!-- Tasks need to mimic redistributing the compilers, so add references to both full framework and .net core -->\n   <ItemGroup>\n     <!-- Reference this package to get binaries at runtime even when Arcade is not adding compiler references -->\n     <PackageReference Include=\"Microsoft.Net.Compilers.Toolset\" ExcludeAssets=\"all\" Condition=\"'$(UsingToolMicrosoftNetCompilers)' == 'false'\" />\n+    <PackageReference Include=\"System.Text.Json\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "So . . . the `Unsafe` part of this name sure stands out to me. Is it necessary? Is it safe? If so, comment an explanation of why.",
              "createdAt": "2020-12-22T15:29:57Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think so, and I think so. If I remember correctly, this has to do with whether characters are escaped, and this specifies they don't need escaping, but almost everything in the cache is ultimately a number, a string, a bool, or a version, so other random characters should be flagged as \"wrong type\" outside the string, which should accept them without running them as code or immediately reject them depending on the circumstance. I don't remember which characters were being serialized incorrectly, but something was.",
              "createdAt": "2020-12-22T17:04:46Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I still want to know this for sure, and with comments in the source explaining.",
              "createdAt": "2021-01-07T23:13:32Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you call the overload that takes a stream so we don't have to materialize the possibly-LOH full string?",
              "createdAt": "2020-12-22T15:31:01Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+                deserializeOptions.Converters.Add(new SystemState.Converter());\n+                File.WriteAllText(_stateFile, JsonSerializer.Serialize<SystemState>(_cache, deserializeOptions));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Unfortunately, no. Not available in .NET Framework. If you want to switch to .net 5...",
              "createdAt": "2020-12-22T17:15:04Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+                deserializeOptions.Converters.Add(new SystemState.Converter());\n+                File.WriteAllText(_stateFile, JsonSerializer.Serialize<SystemState>(_cache, deserializeOptions));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> Not available in .NET Framework.\r\n\r\nWhat specifically isn't? I see\r\n\r\n```c#\r\npublic static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))\r\n```\r\n\r\nin the net461 decompilation.\r\n\r\n> If you want to switch to .net 5\r\n\r\nWe are doing so in #5515.",
              "createdAt": "2020-12-22T17:47:09Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+                deserializeOptions.Converters.Add(new SystemState.Converter());\n+                File.WriteAllText(_stateFile, JsonSerializer.Serialize<SystemState>(_cache, deserializeOptions));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Looks like it's really just that the documentation doesn't accurately reflect the frameworks it's available for:\r\n\r\n![image](https://user-images.githubusercontent.com/12969783/102919414-ae20a180-443d-11eb-976a-fc2e8ff28407.png)\r\n\r\n![image](https://user-images.githubusercontent.com/12969783/102921171-c8a84a00-4440-11eb-8e9e-e8ecb0f50e8b.png)\r\n",
              "createdAt": "2020-12-22T18:31:03Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.\n             }\n+\n+            _cache ??= new SystemState();\n+            _cache.SetGetLastWriteTime(getLastWriteTime);\n+            _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n             if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n-                _cache.SerializeCache(_stateFile, Log);\n+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+                deserializeOptions.Converters.Add(new SystemState.Converter());\n+                File.WriteAllText(_stateFile, JsonSerializer.Serialize<SystemState>(_cache, deserializeOptions));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Here too use the stream API to reduce allocation size.",
              "createdAt": "2020-12-22T15:33:32Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "See previous comment.",
              "createdAt": "2020-12-22T17:15:22Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Sounds like a good plan :)",
              "createdAt": "2020-12-22T15:34:14Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,27 +1857,36 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n-\n-            // Construct the cache if necessary.\n-            if (_cache == null)\n+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };\n+            deserializeOptions.Converters.Add(new SystemState.Converter());\n+            try\n+            {\n+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);\n+            }\n+            catch (Exception)\n             {\n-                _cache = new SystemState();\n+                // log message. This should happen if, for instance, the user has caches created with the BinaryFormatter.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The changes in this method look good but I don't understand why they're being made. Aren't we getting rid of BinaryFormatter?",
              "createdAt": "2020-12-22T15:42:37Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -64,9 +64,10 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)\n         /// <summary>\n         /// Reads the specified file from disk into a StateFileBase derived object.\n         /// </summary>\n-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType)\n+        internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log, bool logWarnings = true) where T : StateFileBase",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Eventually, yes, but StateFileBase is used for other classes, too. I did some cleanup while I was looking at it.",
              "createdAt": "2020-12-22T17:20:58Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -64,9 +64,10 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)\n         /// <summary>\n         /// Reads the specified file from disk into a StateFileBase derived object.\n         /// </summary>\n-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType)\n+        internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log, bool logWarnings = true) where T : StateFileBase",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This concerns me. Where are we using AssemblyNameExtension in TaskHost? Does it ever need to be serialized?\r\n\r\nIn fact, TaskHost makes an interesting addition to the choose-a-serializer problem space, @ar-may: in addition to the other constraints, an _ideal_ serializer will work on .NET 3.5 so that we can use it to communicate with a TaskHost node that is running on 3.5 (this is still used today for some tasks when targeting .NET 3.5).",
              "createdAt": "2020-12-22T15:46:08Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1004,237 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+#if !NET35",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If I remember correctly, we aren't, so it shouldn't matter, but being able to use it meant that it threw a compile-time exception.",
              "createdAt": "2020-12-22T17:22:30Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1004,237 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+#if !NET35",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you go into a fair amount of detail on why this fairly-custom converter is here? Is it required for functionality? Is it a perf improvement? Will it be necessary after https://github.com/dotnet/runtime/issues/1568 lands? Why choose the explicit-converter approach over the `JsonConverter` attribute approach?",
              "createdAt": "2020-12-22T15:54:26Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -232,22 +176,218 @@ internal FrameworkName FrameworkNameAttribute\n             }\n         }\n \n-        /// <summary>\n-        /// Construct.\n-        /// </summary>\n-        internal SystemState()\n+        internal sealed class Converter : JsonConverter<SystemState>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Note to self: haven't looked at this part because waiting on \ud83d\udc46\ud83c\udffb",
              "createdAt": "2020-12-22T15:59:38Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -232,22 +176,218 @@ internal FrameworkName FrameworkNameAttribute\n             }\n         }\n \n-        /// <summary>\n-        /// Construct.\n-        /// </summary>\n-        internal SystemState()\n+        internal sealed class Converter : JsonConverter<SystemState>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I started out with a not-customized implementation, had some difficulty getting everything to be serialized, and asked for help. You told me to write a customer serializer. For the first part of that, see https://github.com/dotnet/msbuild/pull/5514/commits/8b3b613b728bb62f2b6ca1e97c267229f5f81078.\r\n\r\nI think you suggested this is more secure, serializes everything, and hopefully runs faster than using a default converter.",
              "createdAt": "2020-12-22T17:57:34Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -232,22 +176,218 @@ internal FrameworkName FrameworkNameAttribute\n             }\n         }\n \n-        /// <summary>\n-        /// Construct.\n-        /// </summary>\n-        internal SystemState()\n+        internal sealed class Converter : JsonConverter<SystemState>",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Adding a setter here feels wrong. Generally dirtiness is a result of mutating something and not directly manipulable. Is that not true here?",
              "createdAt": "2020-12-22T15:57:26Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -264,24 +404,14 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n             redistList = RedistList.GetRedistList(installedAssemblyTableInfos);\n         }\n \n-        /// <summary>\n-        /// Serialize the contents of the class.\n-        /// </summary>\n-        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]\n-        public void GetObjectData(SerializationInfo info, StreamingContext context)\n-        {\n-            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-            info.AddValue(\"fileState\", instanceLocalFileStateCache);\n-        }\n-\n         /// <summary>\n         /// Flag that indicates\n         /// </summary>\n         /// <value></value>\n         internal bool IsDirty\n         {\n             get { return isDirty; }\n+            set { isDirty = value; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is true, but this is very useful in the test I deleted. (It's among the \"not actually necessary but present\" changes I mentioned.) I'd prefer not to bother with deleting and readding them.",
              "createdAt": "2020-12-22T17:28:18Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -264,24 +404,14 @@ AssemblyTableInfo[] installedAssemblyTableInfos\n             redistList = RedistList.GetRedistList(installedAssemblyTableInfos);\n         }\n \n-        /// <summary>\n-        /// Serialize the contents of the class.\n-        /// </summary>\n-        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]\n-        public void GetObjectData(SerializationInfo info, StreamingContext context)\n-        {\n-            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));\n-\n-            info.AddValue(\"fileState\", instanceLocalFileStateCache);\n-        }\n-\n         /// <summary>\n         /// Flag that indicates\n         /// </summary>\n         /// <value></value>\n         internal bool IsDirty\n         {\n             get { return isDirty; }\n+            set { isDirty = value; }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why go through the getter when we have direct access?",
              "createdAt": "2020-12-22T15:59:09Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -540,7 +669,7 @@ out fileState.frameworkName\n \n             dependencies = fileState.dependencies;\n             scatterFiles = fileState.scatterFiles;\n-            frameworkName = fileState.frameworkName;\n+            frameworkName = fileState.FrameworkNameAttribute;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Does it matter? The getter just returns it.\r\n\r\nI think I tried to eliminate the field but found it was necessary and put it back.",
              "createdAt": "2020-12-22T17:29:32Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -540,7 +669,7 @@ out fileState.frameworkName\n \n             dependencies = fileState.dependencies;\n             scatterFiles = fileState.scatterFiles;\n-            frameworkName = fileState.frameworkName;\n+            frameworkName = fileState.FrameworkNameAttribute;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Please put it all the way back. Unnecessary churn like this makes reviews harder and generally hurts understandability of the codebase.",
              "createdAt": "2021-01-07T23:18:15Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -540,7 +669,7 @@ out fileState.frameworkName\n \n             dependencies = fileState.dependencies;\n             scatterFiles = fileState.scatterFiles;\n-            frameworkName = fileState.frameworkName;\n+            frameworkName = fileState.FrameworkNameAttribute;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't this a slightly different codepath now? The older version checked `retVal._serializedVersion != CurrentSerializationVersion` before logging this, should we check the same here?",
              "createdAt": "2021-01-08T00:51:17Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -77,32 +78,35 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp\n                     using (FileStream s = new FileStream(stateFile, FileMode.Open))\n                     {\n                         var formatter = new BinaryFormatter();\n-                        object deserializedObject = formatter.Deserialize(s);\n-                        retVal = deserializedObject as StateFileBase;\n-\n-                        // If the deserialized object is null then there would be no cast error but retVal would still be null\n-                        // only log the message if there would have been a cast error\n-                        if (retVal == null && deserializedObject != null)\n-                        {\n-                            // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due\n-                            // to a new version number on the tasks class. \"Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase\".\n-                            // If there is an invalid cast, a message rather than a warning should be emitted.\n-                            log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n-                        }\n-\n-                        if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))\n+                        deserializedObject = formatter.Deserialize(s);\n+                        retVal = deserializedObject as T;\n+                    }\n+                    // If the deserialized object is null then there would be no cast error but retVal would still be null\n+                    // only log the message if there would have been a cast error\n+                    if (retVal == null && deserializedObject != null)\n+                    {\n+                        // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due\n+                        // to a new version number on the tasks class. \"Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase\".\n+                        // If there is an invalid cast, a message rather than a warning should be emitted.\n+                        log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n+                    }\n+                    else if (retVal != null && !(retVal is T))\n+                    {\n+                        if (logWarnings)\n                         {\n-                            log.LogWarningWithCodeFromResources(\"General.CouldNotReadStateFile\", stateFile,\n-                                log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n-                            retVal = null;\n+                            log.LogWarningWithCodeFromResources(\"General.CouldNotReadStateFile\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n                         }\n-\n-                        // If we get back a valid object and internals were changed, things are likely to be null. Check the version before we use it.\n-                        if (retVal != null && retVal._serializedVersion != CurrentSerializationVersion)\n+                        else\n                         {\n-                            log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n-                            retVal = null;\n+                            log.LogMessageFromResources(\"General.CouldNotReadStateFile\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I don't see what you mean? It looks to me like the retVal._serializedVersion != CurrentSerializationVersion check is after logging a warning (always) in the old code. The changes here are:\r\n1) The conditions were mutually exclusive --> switch to else if\r\n2) Make function parameterized instead of explicitly taking a type as an argument\r\n3) Give the option of not logging warnings",
              "createdAt": "2021-01-08T15:57:55Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -77,32 +78,35 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp\n                     using (FileStream s = new FileStream(stateFile, FileMode.Open))\n                     {\n                         var formatter = new BinaryFormatter();\n-                        object deserializedObject = formatter.Deserialize(s);\n-                        retVal = deserializedObject as StateFileBase;\n-\n-                        // If the deserialized object is null then there would be no cast error but retVal would still be null\n-                        // only log the message if there would have been a cast error\n-                        if (retVal == null && deserializedObject != null)\n-                        {\n-                            // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due\n-                            // to a new version number on the tasks class. \"Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase\".\n-                            // If there is an invalid cast, a message rather than a warning should be emitted.\n-                            log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n-                        }\n-\n-                        if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))\n+                        deserializedObject = formatter.Deserialize(s);\n+                        retVal = deserializedObject as T;\n+                    }\n+                    // If the deserialized object is null then there would be no cast error but retVal would still be null\n+                    // only log the message if there would have been a cast error\n+                    if (retVal == null && deserializedObject != null)\n+                    {\n+                        // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due\n+                        // to a new version number on the tasks class. \"Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase\".\n+                        // If there is an invalid cast, a message rather than a warning should be emitted.\n+                        log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n+                    }\n+                    else if (retVal != null && !(retVal is T))\n+                    {\n+                        if (logWarnings)\n                         {\n-                            log.LogWarningWithCodeFromResources(\"General.CouldNotReadStateFile\", stateFile,\n-                                log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n-                            retVal = null;\n+                            log.LogWarningWithCodeFromResources(\"General.CouldNotReadStateFile\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n                         }\n-\n-                        // If we get back a valid object and internals were changed, things are likely to be null. Check the version before we use it.\n-                        if (retVal != null && retVal._serializedVersion != CurrentSerializationVersion)\n+                        else\n                         {\n-                            log.LogMessageFromResources(\"General.CouldNotReadStateFileMessage\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));\n-                            retVal = null;\n+                            log.LogMessageFromResources(\"General.CouldNotReadStateFile\", stateFile, log.FormatResourceString(\"General.IncompatibleStateFileType\"));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is this capturing exactly? Could you comment the first use of reader.Read() in this context?",
              "createdAt": "2021-01-08T01:01:05Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1004,237 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+#if !NET35\n+        internal class Converter : JsonConverter<AssemblyNameExtension>\n+        {\n+            public override AssemblyNameExtension Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n+            {\n+                AssemblyNameExtension ane = new AssemblyNameExtension();\n+                if (reader.TokenType != JsonTokenType.StartObject)\n+                {\n+                    throw new JsonException();\n+                }\n+                while (reader.Read())\n+                {\n+                    if (reader.TokenType == JsonTokenType.EndObject)\n+                    {\n+                        return ane;\n+                    }\n+                    else if (reader.TokenType == JsonTokenType.Null)\n+                    {\n+                        return null;\n+                    }\n+                    else if (reader.TokenType != JsonTokenType.PropertyName)\n+                    {\n+                        throw new JsonException();\n+                    }\n+                    string parameter = reader.GetString();\n+                    reader.Read();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "This probably does deserve a comment, since it's kinda overloaded.\r\n\r\nThe Json reader is set up such that every thing (technical term) of interest has its own type. In particular, when specifying that a particular property has a particular value, it has the \"PropertyName\" token followed by the token(s) representing the property. If that property is not null, it will start with a \"StartObject\" token if it's an object or a \"StartArray\" token if it's an array, or just have a value we read below. If it's null, it just starts with null, and there isn't anything else.\r\n\r\nIn this case, I read the first token. If it's null, that means that the json has something like \"propertyName\"=null, which is valid though avoided unless you modify it by hand. Having the null check you commented on means that we don't keep reading the object if it happens to be null. GetString() would have returned a valid property name on the ANE that wasn't set.\r\n\r\nIf the property isn't null, it skips over the \"StartObject\", etc. and lets us start reading the interesting stuff immediately or parses the token as appropriate. Does that make sense?",
              "createdAt": "2021-01-08T16:08:11Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1004,237 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+#if !NET35\n+        internal class Converter : JsonConverter<AssemblyNameExtension>\n+        {\n+            public override AssemblyNameExtension Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n+            {\n+                AssemblyNameExtension ane = new AssemblyNameExtension();\n+                if (reader.TokenType != JsonTokenType.StartObject)\n+                {\n+                    throw new JsonException();\n+                }\n+                while (reader.Read())\n+                {\n+                    if (reader.TokenType == JsonTokenType.EndObject)\n+                    {\n+                        return ane;\n+                    }\n+                    else if (reader.TokenType == JsonTokenType.Null)\n+                    {\n+                        return null;\n+                    }\n+                    else if (reader.TokenType != JsonTokenType.PropertyName)\n+                    {\n+                        throw new JsonException();\n+                    }\n+                    string parameter = reader.GetString();\n+                    reader.Read();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does it mean when we see null here? What would we have just read from `GetString()` if we fall into this case?",
              "createdAt": "2021-01-08T01:03:50Z",
              "path": "src/Shared/AssemblyNameExtension.cs",
              "diffHunk": "@@ -993,5 +1004,237 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n             info.AddValue(\"immutable\", immutable);\n             info.AddValue(\"remapped\", remappedFrom);\n         }\n+\n+#if !NET35\n+        internal class Converter : JsonConverter<AssemblyNameExtension>\n+        {\n+            public override AssemblyNameExtension Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n+            {\n+                AssemblyNameExtension ane = new AssemblyNameExtension();\n+                if (reader.TokenType != JsonTokenType.StartObject)\n+                {\n+                    throw new JsonException();\n+                }\n+                while (reader.Read())\n+                {\n+                    if (reader.TokenType == JsonTokenType.EndObject)\n+                    {\n+                        return ane;\n+                    }\n+                    else if (reader.TokenType == JsonTokenType.Null)\n+                    {\n+                        return null;\n+                    }\n+                    else if (reader.TokenType != JsonTokenType.PropertyName)\n+                    {\n+                        throw new JsonException();\n+                    }\n+                    string parameter = reader.GetString();\n+                    reader.Read();\n+                    if (reader.TokenType == JsonTokenType.Null)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      }
    ]
  }
}