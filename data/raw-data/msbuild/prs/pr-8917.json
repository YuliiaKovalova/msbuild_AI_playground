{
  "number": 8917,
  "title": "Deprecate binfmt in build event args",
  "body": "Fixes #8823 and #9008\r\n\r\n### Context\r\nBinaryFormat deprecations is forcing us to us drop support of CustomEventArgs derived from EventArgs as those are serialized by omnipotent-but-unsecure BinaryFormatter.\r\n\r\n### Changes Made\r\n- making new sealed classes for implementing Custom events (message, warning, error, custom)\r\n- throwing exception when we detect EventArgs is about to be serialized by TranslateDotNet\r\n- fixing existing classes (ExternalProjectStartedEventArgs, ExternalProjectFinishedEventArgs, ...)\r\n- unit tests \r\n\r\n### Testing\r\n- unit tests\r\n- local debugging with temporary code changes\r\n- local tests\r\n\r\n### Notes\r\n- Consider use commits for easier review\r\n- Log Viewer is not handling these new events yet - recommended to do it soon in different PR sooner than later. This version does not change LogViewer event contract. \r\n",
  "state": "MERGED",
  "createdAt": "2023-06-20T11:55:06Z",
  "updatedAt": "2023-12-16T18:44:23Z",
  "closedAt": "2023-08-09T14:58:03Z",
  "mergedAt": "2023-08-09T14:58:03Z",
  "additions": 1798,
  "deletions": 369,
  "changedFiles": 47,
  "headRefName": "rokonec/8823-deprecate-binfmt-in-BuildEventArgs",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": {
    "title": "VS 17.8"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "21f2ab84cc7b9e0d342800bd2cae1a7103732bf3",
          "message": "Fix to properly serialize TargetFinishedEventArgs.TargetOutput",
          "committedDate": "2023-06-20T08:36:03Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "efc9def861ddf5f18c43b7fa1702100a0a44541a",
          "message": "New extended EventArgs for custom events data",
          "committedDate": "2023-06-20T08:49:56Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c09abb476759ebeb3333d8c8734042fe7d4e415c",
          "message": "Fix log LogMessagePacketBase constructor",
          "committedDate": "2023-06-20T08:50:45Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c64a832987ff0220eaa9561bff348a5ee855e63f",
          "message": "Issue warning when EventArgs is serialized by BinaryFormatter",
          "committedDate": "2023-06-20T08:53:42Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7d13c0d3db218c6f744127bf1071df912cfbcfcd",
          "message": "Make ExternalProject*EventArgs serialize without BinaryFormatter\n\nThere was lots of dead code which makes it appear as if ExternalProject*EventArgs are properly custom serialized, but in reality these were treated as CustomEvent with TranslateDotNet generic binary formatter.",
          "committedDate": "2023-06-20T09:11:40Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1ea7e5bf56dc0e07d8ec8e4caafeb413a0018a4e",
          "message": "Various unit tests",
          "committedDate": "2023-06-20T09:43:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f7a910c20a321369c3a86ed6b63e1b4e43004c1",
          "message": "Minor fixes",
          "committedDate": "2023-06-20T11:27:03Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c5a5248605109c2a75984a0def219b5986a685f",
          "message": "Fix unit test - AssemblyLoadBuildEventArgs_Tests",
          "committedDate": "2023-06-20T12:01:42Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "579a8bb97628b47dc3b1182ea4bdb4137d16a7bf",
          "message": "Covering missing events by UnitTests and fixing them",
          "committedDate": "2023-06-20T16:58:02Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30bef087e6a0d1bdb1f011864f23cf70b17f246a",
          "message": "Remove AggressiveInlining",
          "committedDate": "2023-06-20T19:49:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e5762244c6dce5c908d89aea71518d0418e2160d",
          "message": "Removing MethodImplOptions.AggressiveInlining",
          "committedDate": "2023-06-20T20:03:40Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9441a38cb1f937bf2d8b3d26716367a46ac17983",
          "message": "Improve comment",
          "committedDate": "2023-06-22T14:27:35Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "364ef7b59aa85c18155d848fc24c7e5260cbe3a6",
          "message": "Fix LoggingService warn => msg | error mapping for extended data",
          "committedDate": "2023-06-22T14:28:15Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e9253fe7a9cb4e18941b1cf9c389efce8a685fd",
          "message": "Merge branch 'main' into rokonec/8823-deprecate-binfmt-in-BuildEventArgs",
          "committedDate": "2023-06-27T14:56:56Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2fd7c0d2961c9b96e4f38e80b79e4c214dc4993",
          "message": "Issue warnings only on dotnetcore runtime.",
          "committedDate": "2023-06-30T13:56:31Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "87430c4d0400e59e505cca6c885dd62b419cf281",
          "message": "Merge branch 'rokonec/8823-deprecate-binfmt-in-BuildEventArgs' of https://github.com/rokonec/msbuild into rokonec/8823-deprecate-binfmt-in-BuildEventArgs",
          "committedDate": "2023-06-30T13:56:37Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1382cc2bd892ab71c6bda2c929530cdf169a4af1",
          "message": "Fix aka link in deprecated resx",
          "committedDate": "2023-07-12T08:57:36Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f62fdf15b74fd7d16a2dac62e9eddac1ab50802b",
          "message": "Regenerate xlf after resx changes",
          "committedDate": "2023-07-19T12:19:12Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2cf14c8816c9fa357edd9781473ccd6d56911863",
          "message": "add global variable for displaying custom build event warning",
          "committedDate": "2023-07-20T08:16:41Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cbee4cd2e13de4aa953a55b2ae921673800a705f",
          "message": "remove unused directive",
          "committedDate": "2023-07-20T08:29:39Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b62ad4b6d3f4045e56fa339e94b02cc4762e2206",
          "message": "apply code changes + add shallow test case",
          "committedDate": "2023-07-25T08:56:43Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68c52d550ae21ced86ba677962effc4cb3cc8bc3",
          "message": "Fixing Code and unit tests",
          "committedDate": "2023-07-25T13:33:27Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c5d88b9cbe0c4fedb081f5f88eb93e5f6f19154",
          "message": "Merge branch 'main' into rokonec/8823-deprecate-binfmt-in-BuildEventArgs",
          "committedDate": "2023-07-26T09:38:50Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a30ff3e703d29f030704dd9378a8cdbe2975d5a",
          "message": "add tests coverage",
          "committedDate": "2023-07-26T12:54:49Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "54ecd83b6afc397c6922740a4e458320d1ca3578",
          "message": "Merge branch 'rokonec/8823-deprecate-binfmt-in-BuildEventArgs' of https://github.com/rokonec/msbuild into rokonec/8823-deprecate-binfmt-in-BuildEventArgs",
          "committedDate": "2023-07-26T12:55:17Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c02e0476b536d57f51e177aa5a98251f8440cfc3",
          "message": "update test attribute",
          "committedDate": "2023-07-26T14:02:59Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "de6e2b6fb2f597fb9992e7b2ab65c899af29577a",
          "message": "update theory attribute",
          "committedDate": "2023-07-26T16:00:46Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5285736f54a794ab487e60c3d193980cd3ccb0eb",
          "message": "fix review comments",
          "committedDate": "2023-07-27T12:24:15Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f46d557a1a562893d6e8f4c9d04e374d8cc36c54",
          "message": "fix compilation error",
          "committedDate": "2023-07-27T13:12:39Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8cb23506bca77e8b7ac0b92dd5aadaae0f4b508a",
          "message": "Send error on CORE",
          "committedDate": "2023-07-27T16:09:28Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a5a318f015e21df1a147bd89f0023fe044b70ce",
          "message": "Using switch\n\nCo-authored-by: Ladi Prosek <ladi.prosek@gmail.com>",
          "committedDate": "2023-08-09T11:31:24Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1e9069d53de7211643cd32d08d9d31304fec74a5",
          "message": "Revert deprecated resx changes",
          "committedDate": "2023-08-09T11:43:17Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7dc20cde876e2c84878549765ebde689bf707a3a",
          "message": "Make deser constructors internal",
          "committedDate": "2023-08-09T12:16:48Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@rainersigwald - the warnings now apply only for core - should we mark this as candidate for 17.7 payload?",
        "createdAt": "2023-07-10T15:31:55Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "[celebrate]     Yuliia Kovalova reacted to your message:\r\n________________________________\r\nFrom: Roman Konecny ***@***.***>\r\nSent: Wednesday, August 9, 2023 2:58:17 PM\r\nTo: dotnet/msbuild ***@***.***>\r\nCc: Yuliia Kovalova ***@***.***>; Mention ***@***.***>\r\nSubject: Re: [dotnet/msbuild] Deprecate binfmt in build event args (PR #8917)\r\n\r\n\r\nMerged #8917<https://github.com/dotnet/msbuild/pull/8917> into main.\r\n\r\n\u2014\r\nReply to this email directly, view it on GitHub<https://github.com/dotnet/msbuild/pull/8917#event-10048827358>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AWYM53TT7HZV7FYZUFSA6BLXUOQQTANCNFSM6AAAAAAZNFKUQE>.\r\nYou are receiving this because you were mentioned.Message ID: ***@***.***>\r\n",
        "createdAt": "2023-08-09T15:26:27Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "`we expect json mostly` sounds missleading - it sounds as if MSBuild is doing anything with the data.\r\n\r\nHow about?: `Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data`",
              "createdAt": "2023-06-21T15:09:04Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs\n+{\n+    /// <summary>\n+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref=\"ExtendedData\"/>.\n+    /// </summary>\n+    string ExtendedType { get; set; }\n+\n+    /// <summary>\n+    /// Metadata of <see cref=\"ExtendedData\"/>.\n+    /// Example usage:\n+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref=\"ExtendedData\"/>.\n+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.\n+    /// </summary>\n+    Dictionary<string, string?>? ExtendedMetadata { get; set; }\n+\n+    /// <summary>\n+    /// Transparent data as string.\n+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.\n+    /// Custom code can use any serialization they deem safe, though we expect json mostly. In case on binary data, base64 can be used.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Nice. Will do.",
              "createdAt": "2023-06-22T13:47:37Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs\n+{\n+    /// <summary>\n+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref=\"ExtendedData\"/>.\n+    /// </summary>\n+    string ExtendedType { get; set; }\n+\n+    /// <summary>\n+    /// Metadata of <see cref=\"ExtendedData\"/>.\n+    /// Example usage:\n+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref=\"ExtendedData\"/>.\n+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.\n+    /// </summary>\n+    Dictionary<string, string?>? ExtendedMetadata { get; set; }\n+\n+    /// <summary>\n+    /// Transparent data as string.\n+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.\n+    /// Custom code can use any serialization they deem safe, though we expect json mostly. In case on binary data, base64 can be used.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you want to extract ReadDictionary?",
              "createdAt": "2023-06-21T15:14:49Z",
              "path": "src/Shared/BinaryReaderExtensions.cs",
              "diffHunk": "@@ -81,5 +81,30 @@ public static unsafe Guid ReadGuid(this BinaryReader reader)\n         {\n             return new Guid(reader.ReadBytes(sizeof(Guid)));\n         }\n+\n+        public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtendedBuildEventArgs data)\n+        {\n+            data.ExtendedType = reader.ReadString();\n+            data.ExtendedData = reader.ReadOptionalString();\n+\n+            bool haveMetadata = reader.ReadBoolean();\n+            if (haveMetadata)\n+            {\n+                data.ExtendedMetadata = new();\n+\n+                int count = reader.Read7BitEncodedInt();\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = reader.ReadString();\n+                    string? value = reader.ReadOptionalString();\n+\n+                    data.ExtendedMetadata.Add(key, value);\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I though about it, but since this is only place which needed it, I recommend postpone it till we have at least two usages.",
              "createdAt": "2023-06-22T13:52:55Z",
              "path": "src/Shared/BinaryReaderExtensions.cs",
              "diffHunk": "@@ -81,5 +81,30 @@ public static unsafe Guid ReadGuid(this BinaryReader reader)\n         {\n             return new Guid(reader.ReadBytes(sizeof(Guid)));\n         }\n+\n+        public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtendedBuildEventArgs data)\n+        {\n+            data.ExtendedType = reader.ReadString();\n+            data.ExtendedData = reader.ReadOptionalString();\n+\n+            bool haveMetadata = reader.ReadBoolean();\n+            if (haveMetadata)\n+            {\n+                data.ExtendedMetadata = new();\n+\n+                int count = reader.Read7BitEncodedInt();\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = reader.ReadString();\n+                    string? value = reader.ReadOptionalString();\n+\n+                    data.ExtendedMetadata.Add(key, value);\n+                }",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Oh right - I'm once again trapped by us having this type of serialization vs the ITranslatable serialization (where dictionaries are handled a lot).",
              "createdAt": "2023-06-23T09:29:46Z",
              "path": "src/Shared/BinaryReaderExtensions.cs",
              "diffHunk": "@@ -81,5 +81,30 @@ public static unsafe Guid ReadGuid(this BinaryReader reader)\n         {\n             return new Guid(reader.ReadBytes(sizeof(Guid)));\n         }\n+\n+        public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtendedBuildEventArgs data)\n+        {\n+            data.ExtendedType = reader.ReadString();\n+            data.ExtendedData = reader.ReadOptionalString();\n+\n+            bool haveMetadata = reader.ReadBoolean();\n+            if (haveMetadata)\n+            {\n+                data.ExtendedMetadata = new();\n+\n+                int count = reader.Read7BitEncodedInt();\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = reader.ReadString();\n+                    string? value = reader.ReadOptionalString();\n+\n+                    data.ExtendedMetadata.Add(key, value);\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can param-less ctor be used here? If the values are not default for the types fields - should they actually be made the defaults?",
              "createdAt": "2023-06-21T15:18:39Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -536,6 +593,17 @@ private BuildEventArgs GetBuildEventArgFromId()\n                 LoggingEventType.ProjectImportedEvent => new ProjectImportedEventArgs(),\n                 LoggingEventType.TargetSkipped => new TargetSkippedEventArgs(),\n                 LoggingEventType.Telemetry => new TelemetryEventArgs(),\n+                LoggingEventType.ExtendedCustomEvent => new ExtendedCustomBuildEventArgs(),\n+                LoggingEventType.ExtendedBuildErrorEvent => new ExtendedBuildErrorEventArgs(),\n+                LoggingEventType.ExtendedBuildWarningEvent => new ExtendedBuildWarningEventArgs(),\n+                LoggingEventType.ExtendedBuildMessageEvent => new ExtendedBuildMessageEventArgs(),\n+                LoggingEventType.ExternalProjectStartedEvent => new ExternalProjectStartedEventArgs(null, null, null, null, null),\n+                LoggingEventType.ExternalProjectFinishedEvent => new ExternalProjectFinishedEventArgs(null, null, null, null, false),\n+                LoggingEventType.CriticalBuildMessage => new CriticalBuildMessageEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),\n+                LoggingEventType.MetaprojectGenerated => new MetaprojectGeneratedEventArgs(null, null, null),",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes, but these classes do not have public () constructors and I did not want to changed their API.",
              "createdAt": "2023-06-22T13:56:28Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -536,6 +593,17 @@ private BuildEventArgs GetBuildEventArgFromId()\n                 LoggingEventType.ProjectImportedEvent => new ProjectImportedEventArgs(),\n                 LoggingEventType.TargetSkipped => new TargetSkippedEventArgs(),\n                 LoggingEventType.Telemetry => new TelemetryEventArgs(),\n+                LoggingEventType.ExtendedCustomEvent => new ExtendedCustomBuildEventArgs(),\n+                LoggingEventType.ExtendedBuildErrorEvent => new ExtendedBuildErrorEventArgs(),\n+                LoggingEventType.ExtendedBuildWarningEvent => new ExtendedBuildWarningEventArgs(),\n+                LoggingEventType.ExtendedBuildMessageEvent => new ExtendedBuildMessageEventArgs(),\n+                LoggingEventType.ExternalProjectStartedEvent => new ExternalProjectStartedEventArgs(null, null, null, null, null),\n+                LoggingEventType.ExternalProjectFinishedEvent => new ExternalProjectFinishedEventArgs(null, null, null, null, false),\n+                LoggingEventType.CriticalBuildMessage => new CriticalBuildMessageEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),\n+                LoggingEventType.MetaprojectGenerated => new MetaprojectGeneratedEventArgs(null, null, null),",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "`protected internal` should do the trick here.\r\nSome of those classes have their protected parameterless ctor - so just changing it to protected internal would suffice.\r\n\r\nIt of course expose those to our code - which we might not want as well.\r\nI'm fine with this as is - leaving up on you to decide",
              "createdAt": "2023-06-23T09:35:25Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -536,6 +593,17 @@ private BuildEventArgs GetBuildEventArgFromId()\n                 LoggingEventType.ProjectImportedEvent => new ProjectImportedEventArgs(),\n                 LoggingEventType.TargetSkipped => new TargetSkippedEventArgs(),\n                 LoggingEventType.Telemetry => new TelemetryEventArgs(),\n+                LoggingEventType.ExtendedCustomEvent => new ExtendedCustomBuildEventArgs(),\n+                LoggingEventType.ExtendedBuildErrorEvent => new ExtendedBuildErrorEventArgs(),\n+                LoggingEventType.ExtendedBuildWarningEvent => new ExtendedBuildWarningEventArgs(),\n+                LoggingEventType.ExtendedBuildMessageEvent => new ExtendedBuildMessageEventArgs(),\n+                LoggingEventType.ExternalProjectStartedEvent => new ExternalProjectStartedEventArgs(null, null, null, null, null),\n+                LoggingEventType.ExternalProjectFinishedEvent => new ExternalProjectFinishedEventArgs(null, null, null, null, false),\n+                LoggingEventType.CriticalBuildMessage => new CriticalBuildMessageEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),\n+                LoggingEventType.MetaprojectGenerated => new MetaprojectGeneratedEventArgs(null, null, null),",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Thanks! ;-)",
              "createdAt": "2023-06-21T15:21:59Z",
              "path": "src/Framework/AssemblyLoadBuildEventArgs.cs",
              "diffHunk": "@@ -44,6 +44,8 @@ public AssemblyLoadBuildEventArgs()\n \n         internal override void WriteToStream(BinaryWriter writer)\n         {\n+            base.WriteToStream(writer);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "All the properties here feel like \"set once, never reassign\" - are getters needed?",
              "createdAt": "2023-06-21T15:24:45Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I am following our EventArgs design pattern where all properties are get/set and user is empowered and responsible to deal with them properly.",
              "createdAt": "2023-06-22T13:58:27Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "`user is empowered and responsible to deal with them properly.` - We should \u2122 this and stick it to front of our repo readme :-)",
              "createdAt": "2023-06-23T09:36:58Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Interesting this went unnoticed for so long :-O",
              "createdAt": "2023-06-21T15:30:11Z",
              "path": "src/Build/BackEnd/Components/Communications/LogMessagePacket.cs",
              "diffHunk": "@@ -31,7 +31,7 @@ internal LogMessagePacket(KeyValuePair<int, BuildEventArgs>? nodeBuildEvent)\n         /// Constructor for deserialization\n         /// </summary>\n         private LogMessagePacket(ITranslator translator)\n-            : base(translator)\n+            : base(translator, new TargetFinishedTranslator(TranslateTargetFinishedEvent))",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "It was causing loss of `TranslateTargetFinishedEvent.TargetOutputs  in IPC serialization and the only consequences was missing data in binary log.",
              "createdAt": "2023-06-22T14:01:09Z",
              "path": "src/Build/BackEnd/Components/Communications/LogMessagePacket.cs",
              "diffHunk": "@@ -31,7 +31,7 @@ internal LogMessagePacket(KeyValuePair<int, BuildEventArgs>? nodeBuildEvent)\n         /// Constructor for deserialization\n         /// </summary>\n         private LogMessagePacket(ITranslator translator)\n-            : base(translator)\n+            : base(translator, new TargetFinishedTranslator(TranslateTargetFinishedEvent))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not neccesary now - but the `IsSerializable` should be replaced. We'll need to remove `Serializable` attribute from the events soon (it's the next step of BinaryFormatter deprecation effort - those are going to become deprecated, then completely removed), so this code will then break.\r\n\r\nIt's as well fine if you just create item for this for the future",
              "createdAt": "2023-06-21T15:35:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -1079,7 +1079,9 @@ internal void MarkAsInactive()\n         /// </summary>\n         internal bool IsEventSerializable(BuildEventArgs e)\n         {\n-            if (!e.GetType().GetTypeInfo().IsSerializable)\n+            // Types which are not serializable and are not IExtendedBuildEventArgs as\n+            // those always implement custom serialization by WriteToStream and CreateFromStream.\n+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "(applies to all usages)",
              "createdAt": "2023-06-21T16:00:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -1079,7 +1079,9 @@ internal void MarkAsInactive()\n         /// </summary>\n         internal bool IsEventSerializable(BuildEventArgs e)\n         {\n-            if (!e.GetType().GetTypeInfo().IsSerializable)\n+            // Types which are not serializable and are not IExtendedBuildEventArgs as\n+            // those always implement custom serialization by WriteToStream and CreateFromStream.\n+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I agree, although we will have to remove it only for dotnet core, and keep it in windows which will spoil few files with #IFDEFS. However, it is a no-goal of this PR.",
              "createdAt": "2023-06-22T14:03:23Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -1079,7 +1079,9 @@ internal void MarkAsInactive()\n         /// </summary>\n         internal bool IsEventSerializable(BuildEventArgs e)\n         {\n-            if (!e.GetType().GetTypeInfo().IsSerializable)\n+            // Types which are not serializable and are not IExtendedBuildEventArgs as\n+            // those always implement custom serialization by WriteToStream and CreateFromStream.\n+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Agree on both.\r\nWe just need to keep it in back of our heads - it will snap back soon (net9 likely)",
              "createdAt": "2023-06-23T09:38:45Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -1079,7 +1079,9 @@ internal void MarkAsInactive()\n         /// </summary>\n         internal bool IsEventSerializable(BuildEventArgs e)\n         {\n-            if (!e.GetType().GetTypeInfo().IsSerializable)\n+            // Types which are not serializable and are not IExtendedBuildEventArgs as\n+            // those always implement custom serialization by WriteToStream and CreateFromStream.\n+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be ifdef-ed for the core only?",
              "createdAt": "2023-06-21T15:37:05Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -572,6 +572,20 @@ private void SendPacket(INodePacket packet)\n             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n             {\n                 _nodeEndpoint.SendData(packet);\n+                if (packet is LogMessagePacketBase logMessage)\n+                {\n+                    if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                    {\n+                        BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                        // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                        // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                        // EventArgs derived from existing EventArgs.\n+                        _loggingService.LogWarning(buildEvent?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,\n+                            \"DeprecatedEventSerialization\",\n+                            buildEvent?.GetType().Name ?? string.Empty);\n+                    }\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "@rainersigwald Based on our communication I thought we will make this warning even for windows so Internal partners have visibility of it. Shall we have this warn Core only or Windows as well?",
              "createdAt": "2023-06-22T14:05:24Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -572,6 +572,20 @@ private void SendPacket(INodePacket packet)\n             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n             {\n                 _nodeEndpoint.SendData(packet);\n+                if (packet is LogMessagePacketBase logMessage)\n+                {\n+                    if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                    {\n+                        BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                        // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                        // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                        // EventArgs derived from existing EventArgs.\n+                        _loggingService.LogWarning(buildEvent?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,\n+                            \"DeprecatedEventSerialization\",\n+                            buildEvent?.GetType().Name ?? string.Empty);\n+                    }\n+                }",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Users can allways mask the warning, so _probably_ fine ... Have you looked on FullFw usages in your repos research as well? How often are custome events used in FullFw build extensibility?",
              "createdAt": "2023-06-23T09:41:10Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -572,6 +572,20 @@ private void SendPacket(INodePacket packet)\n             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n             {\n                 _nodeEndpoint.SendData(packet);\n+                if (packet is LogMessagePacketBase logMessage)\n+                {\n+                    if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                    {\n+                        BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                        // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                        // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                        // EventArgs derived from existing EventArgs.\n+                        _loggingService.LogWarning(buildEvent?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,\n+                            \"DeprecatedEventSerialization\",\n+                            buildEvent?.GetType().Name ?? string.Empty);\n+                    }\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "There were quite a few FullFw custom events. However, not all will necessary start to use new MSBuild tooling. Also very often those custom event did not cross process so it is not serialized.\r\nI understand that company policy is to not use binfmt even in windows. But I have heard it differently form differently sources.\r\nI think we shall meet and discuss it.",
              "createdAt": "2023-06-27T10:00:30Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -572,6 +572,20 @@ private void SendPacket(INodePacket packet)\n             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n             {\n                 _nodeEndpoint.SendData(packet);\n+                if (packet is LogMessagePacketBase logMessage)\n+                {\n+                    if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                    {\n+                        BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                        // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                        // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                        // EventArgs derived from existing EventArgs.\n+                        _loggingService.LogWarning(buildEvent?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,\n+                            \"DeprecatedEventSerialization\",\n+                            buildEvent?.GetType().Name ?? string.Empty);\n+                    }\n+                }",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Team have decided to have warning only for `dotnet`. I will change it.",
              "createdAt": "2023-06-30T13:33:58Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -572,6 +572,20 @@ private void SendPacket(INodePacket packet)\n             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n             {\n                 _nodeEndpoint.SendData(packet);\n+                if (packet is LogMessagePacketBase logMessage)\n+                {\n+                    if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                    {\n+                        BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                        // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                        // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                        // EventArgs derived from existing EventArgs.\n+                        _loggingService.LogWarning(buildEvent?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,\n+                            \"DeprecatedEventSerialization\",\n+                            buildEvent?.GetType().Name ?? string.Empty);\n+                    }\n+                }",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2023-06-30T13:56:59Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -572,6 +572,20 @@ private void SendPacket(INodePacket packet)\n             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n             {\n                 _nodeEndpoint.SendData(packet);\n+                if (packet is LogMessagePacketBase logMessage)\n+                {\n+                    if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                    {\n+                        BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                        // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                        // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                        // EventArgs derived from existing EventArgs.\n+                        _loggingService.LogWarning(buildEvent?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,\n+                            \"DeprecatedEventSerialization\",\n+                            buildEvent?.GetType().Name ?? string.Empty);\n+                    }\n+                }",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Where is this being referenced? (shouldn't the [src/Shared/Resources/Strings.shared.resx](https://github.com/dotnet/msbuild/pull/8917/files#diff-c7dca4082a1c8d4a5266ea02ca9e78e6104f37b6039474e9f7b734e972f56f4f) actually be used?)",
              "createdAt": "2023-06-21T16:28:21Z",
              "path": "src/Deprecated/Engine/Resources/Strings.resx",
              "diffHunk": "@@ -1181,6 +1181,9 @@\n   <data name=\"DefaultTargets\" UESanitized=\"false\" Visibility=\"Public\">\n     <value>[default]</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" UESanitized=\"false\" Visibility=\"Public\">",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "It is in both. I have found resx string \"ExpectedEventToBeSerializable\" with similar intent in both so I have copied this approach as I believed it might be used from deprecated code too. I believe/hope it will soon be really deprecated and gone.",
              "createdAt": "2023-06-22T14:08:03Z",
              "path": "src/Deprecated/Engine/Resources/Strings.resx",
              "diffHunk": "@@ -1181,6 +1181,9 @@\n   <data name=\"DefaultTargets\" UESanitized=\"false\" Visibility=\"Public\">\n     <value>[default]</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" UESanitized=\"false\" Visibility=\"Public\">",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "If you're not actually using it in Deprecated, there is no need to add the string (`ExpectedEventToBeSerializable` _is_ used, so that's different). I recommend removing the changes under `src/Deprecated` from the PR.",
              "createdAt": "2023-08-07T09:43:16Z",
              "path": "src/Deprecated/Engine/Resources/Strings.resx",
              "diffHunk": "@@ -1181,6 +1181,9 @@\n   <data name=\"DefaultTargets\" UESanitized=\"false\" Visibility=\"Public\">\n     <value>[default]</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" UESanitized=\"false\" Visibility=\"Public\">",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good point. Removed",
              "createdAt": "2023-08-09T11:44:30Z",
              "path": "src/Deprecated/Engine/Resources/Strings.resx",
              "diffHunk": "@@ -1181,6 +1181,9 @@\n   <data name=\"DefaultTargets\" UESanitized=\"false\" Visibility=\"Public\">\n     <value>[default]</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" UESanitized=\"false\" Visibility=\"Public\">",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`#if NET`?",
              "createdAt": "2023-06-21T16:31:02Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1146,15 +1146,30 @@ private void SendBuildEvent(BuildEventArgs e)\n         {\n             if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)\n             {\n-                if (!e.GetType().GetTypeInfo().IsSerializable)\n+                // Types which are not serializable and are not IExtendedBuildEventArgs as\n+                // those always implement custom serialization by WriteToStream and CreateFromStream.\n+                if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)\n                 {\n                     // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact\n                     // that the warning that we constructed is serializable, so everything should be good.\n                     LogWarningFromResource(\"ExpectedEventToBeSerializable\", e.GetType().Name);\n                     return;\n                 }\n \n-                _nodeEndpoint.SendData(new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e)));\n+                LogMessagePacket logMessage = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e));\n+                _nodeEndpoint.SendData(logMessage);\n+\n+                if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                {\n+                    BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                    // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                    // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                    // EventArgs derived from existing EventArgs.\n+                    LogWarningFromResource(\n+                        \"DeprecatedEventSerialization\",\n+                        buildEvent?.GetType().Name ?? string.Empty);\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Lets decide as team. See other comment.",
              "createdAt": "2023-06-22T14:08:46Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1146,15 +1146,30 @@ private void SendBuildEvent(BuildEventArgs e)\n         {\n             if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)\n             {\n-                if (!e.GetType().GetTypeInfo().IsSerializable)\n+                // Types which are not serializable and are not IExtendedBuildEventArgs as\n+                // those always implement custom serialization by WriteToStream and CreateFromStream.\n+                if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)\n                 {\n                     // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact\n                     // that the warning that we constructed is serializable, so everything should be good.\n                     LogWarningFromResource(\"ExpectedEventToBeSerializable\", e.GetType().Name);\n                     return;\n                 }\n \n-                _nodeEndpoint.SendData(new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e)));\n+                LogMessagePacket logMessage = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e));\n+                _nodeEndpoint.SendData(logMessage);\n+\n+                if (logMessage.EventType == LoggingEventType.CustomEvent)\n+                {\n+                    BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;\n+\n+                    // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                    // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                    // EventArgs derived from existing EventArgs.\n+                    LogWarningFromResource(\n+                        \"DeprecatedEventSerialization\",\n+                        buildEvent?.GetType().Name ?? string.Empty);\n+                }",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need to keep those? Especially `WriteBuildMessageEventToStream` and `WriteBuildWarningEventToStream` - since we are now extending the associated events and hence relying on their `WriteToStream`/`CreateFromStream` - it looks as possible source of errors that the 'base' events wouldn't be serialized with `WriteToStream`/`CreateFromStream`, but the derived would be serialied with those - those can easily get out of sync",
              "createdAt": "2023-06-21T16:36:34Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -690,12 +803,6 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even\n                 case LoggingEventType.BuildWarningEvent:\n                     WriteBuildWarningEventToStream((BuildWarningEventArgs)buildEvent, translator);\n                     break;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I tried it, and had to reverted it back as messages with `#IF TASKHOST` did not have required infrastructure code there.",
              "createdAt": "2023-06-22T14:11:24Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -690,12 +803,6 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even\n                 case LoggingEventType.BuildWarningEvent:\n                     WriteBuildWarningEventToStream((BuildWarningEventArgs)buildEvent, translator);\n                     break;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can probably get converted (and so custom data thrown away) by our code in some places - e.g. https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Logging/LoggingService.cs#L1437-L1478\r\nIt is not a new situation - same would happen even before, but as we are now explicitly guiding to use those new events - we should probably at least document that in xml comments",
              "createdAt": "2023-06-21T16:39:03Z",
              "path": "src/Framework/ExtendedBuildWarningEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Generic custom warning events including extended data for event enriching.\n+/// Extended data are implemented by <see cref=\"IExtendedBuildEventArgs\"/>\n+/// </summary>\n+public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExtendedBuildEventArgs",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes, good catch. I am aware of it, this is however same for today customer errors and messages derived from existing EventArgs.\r\nHowever, this is probably still bug and now, we actually can fix it by reusing extended data. \r\nWill try...",
              "createdAt": "2023-06-22T14:16:49Z",
              "path": "src/Framework/ExtendedBuildWarningEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Generic custom warning events including extended data for event enriching.\n+/// Extended data are implemented by <see cref=\"IExtendedBuildEventArgs\"/>\n+/// </summary>\n+public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExtendedBuildEventArgs",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Fixed in https://github.com/dotnet/msbuild/pull/8917/commits/364ef7b59aa85c18155d848fc24c7e5260cbe3a6\r\nPlease review.\r\nNOTE: I am not big fan of this as it feel to me wrong to do mapping on this place. Feel free to advice better approach.\r\n",
              "createdAt": "2023-06-22T14:33:24Z",
              "path": "src/Framework/ExtendedBuildWarningEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Generic custom warning events including extended data for event enriching.\n+/// Extended data are implemented by <see cref=\"IExtendedBuildEventArgs\"/>\n+/// </summary>\n+public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExtendedBuildEventArgs",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like wrong link - should be `https://aka.ms/msbuild/eventargs` instead?",
              "createdAt": "2023-07-10T15:33:31Z",
              "path": "src/Deprecated/Engine/Resources/Strings.resx",
              "diffHunk": "@@ -1181,6 +1181,9 @@\n   <data name=\"DefaultTargets\" UESanitized=\"false\" Visibility=\"Public\">\n     <value>[default]</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" UESanitized=\"false\" Visibility=\"Public\">\n+    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/metadata-self-ref</value>",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The learn article probably needs update to mention the deprecation of `CustomBuildEventArgs` and their intended replacement.\r\n\r\nGive @ghogen requirements on what/how needs to be publicly documented (or possibly create doc bug with details here https://github.com/dotnet/docs/issues) - so that this gets on documentation plan early enough",
              "createdAt": "2023-07-10T15:36:38Z",
              "path": "src/Shared/Resources/Strings.shared.resx",
              "diffHunk": "@@ -66,6 +66,9 @@\n   <data name=\"ExpectedEventToBeSerializable\" Visibility=\"Public\">\n     <value>Event type \"{0}\" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" Visibility=\"Public\">\n+    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Spined off as separate item: https://github.com/dotnet/msbuild/issues/9016",
              "createdAt": "2023-07-12T11:58:49Z",
              "path": "src/Shared/Resources/Strings.shared.resx",
              "diffHunk": "@@ -66,6 +66,9 @@\n   <data name=\"ExpectedEventToBeSerializable\" Visibility=\"Public\">\n     <value>Event type \"{0}\" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>\n   </data>\n+  <data name=\"DeprecatedEventSerialization\" Visibility=\"Public\">\n+    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we rather do this check before the serialization attempt? As otherwise if `EnableUnsafeBinaryFormatterSerialization` is not opted in, the build can crash on the serialization attemt and the warning (that should be a friendlier alternative) would not even get emitted. @rokonec - thoughts?\r\n\r\nPlus if the custom events are discarded - the warning message should explicitly mention that (as it's behavioral change).",
              "createdAt": "2023-07-25T12:09:11Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -900,8 +900,28 @@ public void PacketReceived(int node, INodePacket packet)\n             }\n \n             LogMessagePacket loggingPacket = (LogMessagePacket)packet;\n-            InjectNonSerializedData(loggingPacket);\n-            ProcessLoggingEvent(loggingPacket.NodeBuildEvent);\n+\n+            if (loggingPacket.EventType == LoggingEventType.CustomEvent\n+                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)\n+                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)\n+            {\n+                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;\n+\n+                // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                // EventArgs derived from existing EventArgs.\n+                LogWarning(\n+                    buildEvent?.BuildEventContext ?? BuildEventContext.Invalid,\n+                    null,\n+                    BuildEventFileInfo.Empty,\n+                    \"DeprecatedEventSerialization\",\n+                    buildEvent?.GetType().Name ?? string.Empty);\n+            }\n+            else\n+            {\n+                InjectNonSerializedData(loggingPacket);\n+                ProcessLoggingEvent(loggingPacket.NodeBuildEvent);\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The current adjustment looks good \ud83d\udc4d https://github.com/dotnet/msbuild/commit/68c52d550ae21ced86ba677962effc4cb3cc8bc3",
              "createdAt": "2023-07-25T15:42:45Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -900,8 +900,28 @@ public void PacketReceived(int node, INodePacket packet)\n             }\n \n             LogMessagePacket loggingPacket = (LogMessagePacket)packet;\n-            InjectNonSerializedData(loggingPacket);\n-            ProcessLoggingEvent(loggingPacket.NodeBuildEvent);\n+\n+            if (loggingPacket.EventType == LoggingEventType.CustomEvent\n+                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)\n+                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)\n+            {\n+                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;\n+\n+                // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>\n+                // Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+                // EventArgs derived from existing EventArgs.\n+                LogWarning(\n+                    buildEvent?.BuildEventContext ?? BuildEventContext.Invalid,\n+                    null,\n+                    BuildEventFileInfo.Empty,\n+                    \"DeprecatedEventSerialization\",\n+                    buildEvent?.GetType().Name ?? string.Empty);\n+            }\n+            else\n+            {\n+                InjectNonSerializedData(loggingPacket);\n+                ProcessLoggingEvent(loggingPacket.NodeBuildEvent);\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we give this a MSBxxxx code so that it can be supressed with `MSBuildWarningsAsMessages`?",
              "createdAt": "2023-07-26T12:25:08Z",
              "path": "src/Shared/Resources/xlf/Strings.shared.cs.xlf",
              "diffHunk": "@@ -22,6 +22,11 @@\n         <target state=\"translated\">MSB4008: Bylo nalezeno konfliktn\u00ed sestaven\u00ed pro sestaven\u00ed \u00falohy {0} v um\u00edst\u011bn\u00ed {1}.</target>\n         <note>{StrBegin=\"MSB4008: \"}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>\n       </trans-unit>\n+      <trans-unit id=\"DeprecatedEventSerialization\">\n+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "We already have opt-out mechanism. Since main reason of all those changes is to get rid of BinFmt wherever possible, I feel like there is no need to for easy suppression. In other words, we would rather have them fix it.",
              "createdAt": "2023-07-26T18:40:12Z",
              "path": "src/Shared/Resources/xlf/Strings.shared.cs.xlf",
              "diffHunk": "@@ -22,6 +22,11 @@\n         <target state=\"translated\">MSB4008: Bylo nalezeno konfliktn\u00ed sestaven\u00ed pro sestaven\u00ed \u00falohy {0} v um\u00edst\u011bn\u00ed {1}.</target>\n         <note>{StrBegin=\"MSB4008: \"}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>\n       </trans-unit>\n+      <trans-unit id=\"DeprecatedEventSerialization\">\n+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The two tests are carbon copies.\r\n\r\nHow about making this a nontest method taking 3 args (3rd being the FW) and then having the two test methods just call into it?",
              "createdAt": "2023-07-27T09:54:11Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"\n+<Project>\n+\n+  <Target Name=`MainTarget`>\n+    <MSBuild Projects=`{0}` Targets=`ChildTarget` />\n+  </Target>\n+\n+</Project>\";\n+\n+        private string childProjectWithCustomBuildEvent = $@\"\n+<Project>\n+\n+    <UsingTask TaskName=\"\"CustomBuildEventTask\"\" AssemblyFile=\"\"{Assembly.GetExecutingAssembly().Location}\"\" />\n+    <Target Name=`ChildTarget`>\n+        <CustomBuildEventTask />\n+    </Target>\n+\n+</Project>\";\n+\n+\n+        /// <summary>\n+        /// The mock logger for testing.\n+        /// </summary>\n+        private readonly MockLogger _logger;\n+\n+        /// <summary>\n+        /// The standard build manager for each test.\n+        /// </summary>\n+        private readonly BuildManager _buildManager;\n+\n+        /// <summary>\n+        /// The project collection used.\n+        /// </summary>\n+        private readonly ProjectCollection _projectCollection;\n+\n+        private readonly TestEnvironment _env;\n+        private readonly ITestOutputHelper _output;\n+\n+        /// <summary>\n+        /// SetUp\n+        /// </summary>\n+        public BuildManager_Logging_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.\n+            BuildManager.DefaultBuildManager.Dispose();\n+\n+            _logger = new MockLogger(output);\n+            _buildManager = new BuildManager();\n+            _projectCollection = new ProjectCollection();\n+\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [DotNetOnlyTheory]\n+        [InlineData(\"1\", true)]\n+        [InlineData(\"0\", false)]\n+        [InlineData(\"\", true)]\n+        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The value of MSBUILDCUSTOMBUILDEVENTWARNING depends on the running environment (core vs framework). How can I emulate that based on FW param?\r\nThe specified Theories guarantee the specifics of running.",
              "createdAt": "2023-07-27T11:30:41Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"\n+<Project>\n+\n+  <Target Name=`MainTarget`>\n+    <MSBuild Projects=`{0}` Targets=`ChildTarget` />\n+  </Target>\n+\n+</Project>\";\n+\n+        private string childProjectWithCustomBuildEvent = $@\"\n+<Project>\n+\n+    <UsingTask TaskName=\"\"CustomBuildEventTask\"\" AssemblyFile=\"\"{Assembly.GetExecutingAssembly().Location}\"\" />\n+    <Target Name=`ChildTarget`>\n+        <CustomBuildEventTask />\n+    </Target>\n+\n+</Project>\";\n+\n+\n+        /// <summary>\n+        /// The mock logger for testing.\n+        /// </summary>\n+        private readonly MockLogger _logger;\n+\n+        /// <summary>\n+        /// The standard build manager for each test.\n+        /// </summary>\n+        private readonly BuildManager _buildManager;\n+\n+        /// <summary>\n+        /// The project collection used.\n+        /// </summary>\n+        private readonly ProjectCollection _projectCollection;\n+\n+        private readonly TestEnvironment _env;\n+        private readonly ITestOutputHelper _output;\n+\n+        /// <summary>\n+        /// SetUp\n+        /// </summary>\n+        public BuildManager_Logging_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.\n+            BuildManager.DefaultBuildManager.Dispose();\n+\n+            _logger = new MockLogger(output);\n+            _buildManager = new BuildManager();\n+            _projectCollection = new ProjectCollection();\n+\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [DotNetOnlyTheory]\n+        [InlineData(\"1\", true)]\n+        [InlineData(\"0\", false)]\n+        [InlineData(\"\", true)]\n+        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just a suggestion - feel free to keep as is\r\n\r\n```suggestion\r\n            _env.SetEnvironmentVariable(\"MSBUILDCUSTOMBUILDEVENTWARNING\", envVariableValue);\r\n```\r\n\r\nThis is shorter and makes it explicit that if the passed value is `null` we want to explicitly clear the env var (despite the `_env` disposal already clears the variables). The test case would then need to pass `null` instead of `\"\"`",
              "createdAt": "2023-07-27T10:05:02Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"\n+<Project>\n+\n+  <Target Name=`MainTarget`>\n+    <MSBuild Projects=`{0}` Targets=`ChildTarget` />\n+  </Target>\n+\n+</Project>\";\n+\n+        private string childProjectWithCustomBuildEvent = $@\"\n+<Project>\n+\n+    <UsingTask TaskName=\"\"CustomBuildEventTask\"\" AssemblyFile=\"\"{Assembly.GetExecutingAssembly().Location}\"\" />\n+    <Target Name=`ChildTarget`>\n+        <CustomBuildEventTask />\n+    </Target>\n+\n+</Project>\";\n+\n+\n+        /// <summary>\n+        /// The mock logger for testing.\n+        /// </summary>\n+        private readonly MockLogger _logger;\n+\n+        /// <summary>\n+        /// The standard build manager for each test.\n+        /// </summary>\n+        private readonly BuildManager _buildManager;\n+\n+        /// <summary>\n+        /// The project collection used.\n+        /// </summary>\n+        private readonly ProjectCollection _projectCollection;\n+\n+        private readonly TestEnvironment _env;\n+        private readonly ITestOutputHelper _output;\n+\n+        /// <summary>\n+        /// SetUp\n+        /// </summary>\n+        public BuildManager_Logging_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.\n+            BuildManager.DefaultBuildManager.Dispose();\n+\n+            _logger = new MockLogger(output);\n+            _buildManager = new BuildManager();\n+            _projectCollection = new ProjectCollection();\n+\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [DotNetOnlyTheory]\n+        [InlineData(\"1\", true)]\n+        [InlineData(\"0\", false)]\n+        [InlineData(\"\", true)]\n+        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)\n+        {\n+            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, new[] { \"main\", \"child1\" }, string.Empty);\n+\n+            ILoggingService service = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);\n+            service.RegisterLogger(_logger);\n+\n+            if (!string.IsNullOrEmpty(envVariableValue))\n+            {\n+                _env.SetEnvironmentVariable(\"MSBUILDCUSTOMBUILDEVENTWARNING\", envVariableValue);\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: this and the `childProjectWithCustomBuildEvent` should be `const` and name start with `_` (to follow the suit of other fields in this file)",
              "createdAt": "2023-07-27T10:38:03Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "unfortunately, I can't make them constants\r\nhttps://learn.microsoft.com/en-us/dotnet/csharp/misc/cs0133?f1url=%3FappId%3Droslyn%26k%3Dk(CS0133)",
              "createdAt": "2023-07-27T12:22:28Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Oh right. They could be `readonly`.\r\nBut it doesn't matter in test code",
              "createdAt": "2023-07-27T13:33:07Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is not 100% clear what the message is expected to contain. Can the resource be referenced here? \r\n\r\nSomething along the lines `.ShouldContain(string.Format(ResourceUtilities.GetResourceString(\"DeprecatedEventSerialization\"), \"MyCustomBuildEventArgs\"))`",
              "createdAt": "2023-07-27T10:43:43Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs",
              "diffHunk": "@@ -0,0 +1,214 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Xunit.NetCore.Extensions;\n+using static Microsoft.Build.UnitTests.ObjectModelHelpers;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class BuildManager_Logging_Tests : IDisposable\n+    {\n+        private string mainProject = @\"\n+<Project>\n+\n+  <Target Name=`MainTarget`>\n+    <MSBuild Projects=`{0}` Targets=`ChildTarget` />\n+  </Target>\n+\n+</Project>\";\n+\n+        private string childProjectWithCustomBuildEvent = $@\"\n+<Project>\n+\n+    <UsingTask TaskName=\"\"CustomBuildEventTask\"\" AssemblyFile=\"\"{Assembly.GetExecutingAssembly().Location}\"\" />\n+    <Target Name=`ChildTarget`>\n+        <CustomBuildEventTask />\n+    </Target>\n+\n+</Project>\";\n+\n+\n+        /// <summary>\n+        /// The mock logger for testing.\n+        /// </summary>\n+        private readonly MockLogger _logger;\n+\n+        /// <summary>\n+        /// The standard build manager for each test.\n+        /// </summary>\n+        private readonly BuildManager _buildManager;\n+\n+        /// <summary>\n+        /// The project collection used.\n+        /// </summary>\n+        private readonly ProjectCollection _projectCollection;\n+\n+        private readonly TestEnvironment _env;\n+        private readonly ITestOutputHelper _output;\n+\n+        /// <summary>\n+        /// SetUp\n+        /// </summary>\n+        public BuildManager_Logging_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.\n+            BuildManager.DefaultBuildManager.Dispose();\n+\n+            _logger = new MockLogger(output);\n+            _buildManager = new BuildManager();\n+            _projectCollection = new ProjectCollection();\n+\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [DotNetOnlyTheory]\n+        [InlineData(\"1\", true)]\n+        [InlineData(\"0\", false)]\n+        [InlineData(\"\", true)]\n+        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)\n+        {\n+            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, new[] { \"main\", \"child1\" }, string.Empty);\n+\n+            ILoggingService service = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);\n+            service.RegisterLogger(_logger);\n+\n+            if (!string.IsNullOrEmpty(envVariableValue))\n+            {\n+                _env.SetEnvironmentVariable(\"MSBUILDCUSTOMBUILDEVENTWARNING\", envVariableValue);\n+            }\n+            _env.SetEnvironmentVariable(\"MSBUILDNOINPROCNODE\", \"1\");\n+\n+            _buildManager.BeginBuild(BuildParameters);\n+\n+            try\n+            {\n+                var child1ProjectPath = testFiles.CreatedFiles[1];\n+                var cleanedUpChildContents = CleanupFileContents(childProjectWithCustomBuildEvent);\n+                File.WriteAllText(child1ProjectPath, cleanedUpChildContents);\n+\n+                var mainProjectPath = testFiles.CreatedFiles[0];\n+                var cleanedUpMainContents = CleanupFileContents(string.Format(mainProject, child1ProjectPath));\n+                File.WriteAllText(mainProjectPath, cleanedUpMainContents);\n+\n+                var buildRequestData = new BuildRequestData(\n+                   mainProjectPath,\n+                   new Dictionary<string, string>(),\n+                   MSBuildConstants.CurrentToolsVersion,\n+                   new[] { \"MainTarget\" },\n+                   null);\n+\n+                var submission = _buildManager.PendBuildRequest(buildRequestData);\n+\n+                var result = submission.Execute();\n+\n+                var allEvents = _logger.AllBuildEvents;\n+\n+                if (isWarningExpected)\n+                {\n+                    allEvents.OfType<BuildWarningEventArgs>().ShouldHaveSingleItem();\n+                    allEvents.First(x => x is BuildWarningEventArgs).Message.ShouldContain(\"MyCustomBuildEventArgs\");",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Swap the conditions so the faster `is not` check comes first?",
              "createdAt": "2023-08-07T08:06:53Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1147,7 +1147,9 @@ private void SendBuildEvent(BuildEventArgs e)\n             if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)\n             {\n #pragma warning disable SYSLIB0050\n-                if (!e.GetType().GetTypeInfo().IsSerializable)\n+                // Types which are not serializable and are not IExtendedBuildEventArgs as\n+                // those always implement custom serialization by WriteToStream and CreateFromStream.\n+                if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Geed point, but in runtime `e is not IExtendedBuildEventArgs` will almost always be true. In situation like that I try order ifs for readability i.e. most important to left.",
              "createdAt": "2023-08-09T10:08:29Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1147,7 +1147,9 @@ private void SendBuildEvent(BuildEventArgs e)\n             if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)\n             {\n #pragma warning disable SYSLIB0050\n-                if (!e.GetType().GetTypeInfo().IsSerializable)\n+                // Types which are not serializable and are not IExtendedBuildEventArgs as\n+                // those always implement custom serialization by WriteToStream and CreateFromStream.\n+                if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Swap conditions.",
              "createdAt": "2023-08-07T08:37:35Z",
              "path": "src/Build/Instance/TaskFactoryLoggingHost.cs",
              "diffHunk": "@@ -338,7 +338,9 @@ internal void MarkAsInactive()\n         internal bool IsEventSerializable(BuildEventArgs e)\n         {\n #pragma warning disable SYSLIB0050\n-            if (!e.GetType().GetTypeInfo().IsSerializable)\n+            // Types which are not serializable and are not IExtendedBuildEventArgs as\n+            // those always implement custom serialization by WriteToStream and CreateFromStream.\n+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Suggestion:\r\n\r\n```suggestion\r\n                    warning.ProjectFile = buildEvent switch\r\n                    {\r\n                        BuildMessageEventArgs buildMessageEvent => buildMessageEvent.ProjectFile,\r\n                        BuildErrorEventArgs buildErrorEvent => buildErrorEvent.ProjectFile,\r\n                        BuildWarningEventArgs buildWarningEvent => buildWarningEvent.ProjectFile,\r\n                        _ => null,\r\n                    };\r\n```",
              "createdAt": "2023-08-07T08:52:59Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -901,9 +901,65 @@ public void PacketReceived(int node, INodePacket packet)\n \n             LogMessagePacket loggingPacket = (LogMessagePacket)packet;\n             InjectNonSerializedData(loggingPacket);\n+\n+            WarnOnDeprecatedCustomArgsSerialization(loggingPacket);\n+\n             ProcessLoggingEvent(loggingPacket.NodeBuildEvent);\n         }\n \n+        /// <summary>\n+        /// Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet.\n+        /// Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom\n+        /// EventArgs derived from existing EventArgs.\n+        /// </summary>\n+        private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)\n+        {\n+            if (loggingPacket.EventType == LoggingEventType.CustomEvent\n+                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)\n+                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)\n+            {\n+                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;\n+                BuildEventContext buildEventContext = buildEvent?.BuildEventContext ?? BuildEventContext.Invalid;\n+\n+                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\n+                    out string warningCode,\n+                    out string helpKeyword,\n+                    \"DeprecatedEventSerialization\",\n+                    buildEvent?.GetType().Name ?? string.Empty);\n+\n+                BuildWarningEventArgs warning = new(\n+                    null,\n+                    warningCode,\n+                    BuildEventFileInfo.Empty.File,\n+                    BuildEventFileInfo.Empty.Line,\n+                    BuildEventFileInfo.Empty.Column,\n+                    BuildEventFileInfo.Empty.EndLine,\n+                    BuildEventFileInfo.Empty.EndColumn,\n+                    message,\n+                    helpKeyword,\n+                    \"MSBuild\");\n+\n+                warning.BuildEventContext = buildEventContext;\n+                if (warning.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)\n+                {\n+                    if (buildEvent is BuildMessageEventArgs buildMessageEvent)\n+                    {\n+                        warning.ProjectFile = buildMessageEvent.ProjectFile;\n+                    }\n+                    else if (buildEvent is BuildErrorEventArgs buildErrorEvent)\n+                    {\n+                        warning.ProjectFile = buildErrorEvent.ProjectFile;\n+                    }\n+                    else if (buildEvent is BuildWarningEventArgs buildWarningEvent)\n+                    {\n+                        warning.ProjectFile = buildWarningEvent.ProjectFile;\n+                    }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a chance we could make `EventType` a virtual property to avoid (most of) these type checks?",
              "createdAt": "2023-08-07T09:10:13Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -573,6 +641,15 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n             {\n                 return LoggingEventType.ProjectStartedEvent;\n             }\n+            else if (eventType == typeof(ExternalProjectStartedEventArgs))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I copied used coding practice above. I am not sure if introducing `LoggingEventType` into events is desirable, as it would enforce events to include de/ser implementation details. Creating dictionary for mapping `Type -> LoggingEventType` would be better, but I'd rather have refactoring of logmessages code in its own PR.",
              "createdAt": "2023-08-09T10:13:46Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -573,6 +641,15 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n             {\n                 return LoggingEventType.ProjectStartedEvent;\n             }\n+            else if (eventType == typeof(ExternalProjectStartedEventArgs))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Sounds good, thank you for checking.",
              "createdAt": "2023-08-09T13:24:01Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -573,6 +641,15 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n             {\n                 return LoggingEventType.ProjectStartedEvent;\n             }\n+            else if (eventType == typeof(ExternalProjectStartedEventArgs))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is the motivation for introducing this abstraction with Type, Data, and Metadata, instead of just `Dictionary<string, string?> ExtendedData`? It looks as though all of this is owned by the custom implementation (i.e. MSBuild doesn't interpret it) and simplifying it would make the hard-coded default `\"undefined\"` ExtendedType go away.",
              "createdAt": "2023-08-07T09:20:09Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs\n+{\n+    /// <summary>\n+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref=\"ExtendedData\"/>.\n+    /// </summary>\n+    string ExtendedType { get; set; }\n+\n+    /// <summary>\n+    /// Metadata of <see cref=\"ExtendedData\"/>.\n+    /// Example usage:\n+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref=\"ExtendedData\"/>.\n+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.\n+    /// </summary>\n+    Dictionary<string, string?>? ExtendedMetadata { get; set; }\n+\n+    /// <summary>\n+    /// Transparent data as string.\n+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.\n+    /// Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data...\n+    /// </summary>\n+    string? ExtendedData { get; set; }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It is based on my experience, opinionated, what shall generic purpose message/event have.\r\n\r\ntype => unique identifier of message content, for example cpp_error or my_structured_log_message\r\nmetadata => optional, describes data required to understand payload, for example `content_type=xml | json` or  `compression= none | gzip | deflate`\r\ndata => actual payload, in our case it is string as we expect mostly json, but people could base64 binaries if they want\r\n\r\nMetadata can often be included into type like \"cpp_error+json\" but it is considered bad practice.\r\n\r\nSimilar approach of type+metadata+payload is used by many protocols including html, tcp/ip, amqp ...\r\n\r\nI agree it is little bit overengineered, and people will usually not leverage it, but the price for including it was acceptable, IMO.\r\n\r\n\r\n\r\n",
              "createdAt": "2023-08-09T09:58:11Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs\n+{\n+    /// <summary>\n+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref=\"ExtendedData\"/>.\n+    /// </summary>\n+    string ExtendedType { get; set; }\n+\n+    /// <summary>\n+    /// Metadata of <see cref=\"ExtendedData\"/>.\n+    /// Example usage:\n+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref=\"ExtendedData\"/>.\n+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.\n+    /// </summary>\n+    Dictionary<string, string?>? ExtendedMetadata { get; set; }\n+\n+    /// <summary>\n+    /// Transparent data as string.\n+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.\n+    /// Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data...\n+    /// </summary>\n+    string? ExtendedData { get; set; }",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Ok, since we can't extend interfaces later, overengineering makes sense I guess. If the parameterless constructors which set `ExtendedType` to the hardcoded `\"undefined\"` string are really for deserialization only, could they be made internal?",
              "createdAt": "2023-08-09T10:37:32Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs\n+{\n+    /// <summary>\n+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref=\"ExtendedData\"/>.\n+    /// </summary>\n+    string ExtendedType { get; set; }\n+\n+    /// <summary>\n+    /// Metadata of <see cref=\"ExtendedData\"/>.\n+    /// Example usage:\n+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref=\"ExtendedData\"/>.\n+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.\n+    /// </summary>\n+    Dictionary<string, string?>? ExtendedMetadata { get; set; }\n+\n+    /// <summary>\n+    /// Transparent data as string.\n+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.\n+    /// Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data...\n+    /// </summary>\n+    string? ExtendedData { get; set; }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "good, point. Done",
              "createdAt": "2023-08-09T12:17:31Z",
              "path": "src/Framework/IExtendedBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Interface for Extended EventArgs to allow enriching particular events with extended data.\n+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.\n+/// </summary>\n+public interface IExtendedBuildEventArgs\n+{\n+    /// <summary>\n+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref=\"ExtendedData\"/>.\n+    /// </summary>\n+    string ExtendedType { get; set; }\n+\n+    /// <summary>\n+    /// Metadata of <see cref=\"ExtendedData\"/>.\n+    /// Example usage:\n+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref=\"ExtendedData\"/>.\n+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.\n+    /// </summary>\n+    Dictionary<string, string?>? ExtendedMetadata { get; set; }\n+\n+    /// <summary>\n+    /// Transparent data as string.\n+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.\n+    /// Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data...\n+    /// </summary>\n+    string? ExtendedData { get; set; }",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not seeing ProjectImportedEventArgs here",
              "createdAt": "2023-12-16T18:44:22Z",
              "path": "src/Build.UnitTests/BackEnd/NodePackets_Tests.cs",
              "diffHunk": "@@ -57,8 +58,21 @@ public void VerifyEventType()\n             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, \"message\", \"help\", \"ProjectFile\", \"targetNames\", null, null, null);\n             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs(\"message\", \"help\", \"ProjectFile\", true);\n             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs(\"message\", \"help\", \"senderName\", \"projectFile\", \"targetNames\");\n+            ExternalProjectFinishedEventArgs externalFinishedEvent = new(\"message\", \"help\", \"senderName\", \"projectFile\", true);\n             ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();\n             ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();\n+            AssemblyLoadBuildEventArgs assemblyLoad = new(AssemblyLoadingContext.Evaluation, null, null, \"path\", Guid.NewGuid(), null);\n+            ExtendedBuildErrorEventArgs extError = new(\"extError\", \"SubCategoryForSchemaValidationErrors\", \"MSB4000\", \"file\", 1, 2, 3, 4, \"message\", \"help\", \"sender\");\n+            ExtendedBuildWarningEventArgs extWarning = new(\"extWarn\", \"SubCategoryForSchemaValidationErrors\", \"MSB4000\", \"file\", 1, 2, 3, 4, \"message\", \"help\", \"sender\");\n+            ExtendedBuildMessageEventArgs extMessage = new(\"extMsg\", \"SubCategoryForSchemaValidationErrors\", \"MSB4000\", \"file\", 1, 2, 3, 4, \"message\", \"help\", \"sender\", MessageImportance.Normal);\n+            ExtendedCustomBuildEventArgs extCustom = new(\"extCustom\", \"message\", \"help\", \"sender\");\n+            CriticalBuildMessageEventArgs criticalMessage = new(\"Subcategory\", \"Code\", \"File\", 1, 2, 3, 4, \"{0}\", \"HelpKeyword\", \"Sender\", DateTime.Now, \"arg1\");\n+            PropertyInitialValueSetEventArgs propInit = new(\"prop\", \"val\", \"propsource\", \"message\", \"help\", \"sender\", MessageImportance.Normal);\n+            MetaprojectGeneratedEventArgs metaProjectGenerated = new(\"metaName\", \"path\", \"message\");\n+            PropertyReassignmentEventArgs propReassign = new(\"prop\", \"prevValue\", \"newValue\", \"loc\", \"message\", \"help\", \"sender\", MessageImportance.Normal);\n+            ResponseFileUsedEventArgs responseFileUsed = new(\"path\");\n+            UninitializedPropertyReadEventArgs uninitializedPropertyRead = new(\"prop\", \"message\", \"help\", \"sender\", MessageImportance.Normal);\n+            EnvironmentVariableReadEventArgs environmentVariableRead = new(\"env\", \"message\", \"help\", \"sender\", MessageImportance.Normal);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}