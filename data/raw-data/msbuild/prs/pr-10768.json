{
  "number": 10768,
  "title": "EventSourceSink refactor",
  "body": "Fixes #10245\r\n\r\n### Context\r\nEventSourceSink.cs\r\n\r\n### Changes Made\r\nremoved RaiseSomeEvent handlers and replaced them by generic one.\r\n\r\n### Testing\r\n\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2024-10-08T09:48:54Z",
  "updatedAt": "2024-10-09T20:00:07Z",
  "closedAt": "2024-10-09T08:05:50Z",
  "mergedAt": "2024-10-09T08:05:50Z",
  "additions": 81,
  "deletions": 639,
  "changedFiles": 1,
  "headRefName": "EventSourceSink-refactor-10245",
  "isDraft": false,
  "author": {
    "login": "SimaTian"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "01473dd6d92c1c74e86df34187184cca549fecd7",
          "message": "replaced RaiseSomeEvent handlers by a generic one and lambdas",
          "committedDate": "2024-10-08T09:49:33Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tbartonek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "48fa78f8de58e139098cb78125b7e45ee0d97537",
          "message": "removing something that slipped in",
          "committedDate": "2024-10-08T10:12:52Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tbartonek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "be1c09c8d27ae26dab8a57ba0708a959d065199b",
          "message": "reintroducing skipped try catch. RaiseAnyEvent added since it is doing separate logging. removing null arguments, removing #nullable disable",
          "committedDate": "2024-10-08T12:23:19Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tbartonek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3ab782175917dce44faefddf60e43f959f7f34dc",
          "message": "nullable fix, argument annotation fix",
          "committedDate": "2024-10-08T14:01:23Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tbartonek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@dotnet-policy-service agree [company=\"Microsoft\"]\r\n",
        "createdAt": "2024-10-08T09:50:23Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "What is our approach to squashing? Do we squash everything to one commit before merge or is there some other sort of rule of thumb to follow please?",
        "createdAt": "2024-10-08T10:14:18Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "> What is our approach to squashing? Do we squash everything to one commit before merge or is there some other sort of rule of thumb to follow please?\r\n\r\nWe squash during merging (GH can do that for you).",
        "createdAt": "2024-10-08T13:00:36Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "@dotnet-policy-service agree company=\"Microsoft\"",
        "createdAt": "2024-10-08T14:18:52Z",
        "author": {
          "login": "SimaTian"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I will remove this. Tbh, I'm not sure where this came from.",
              "createdAt": "2024-10-08T10:12:01Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -8,6 +8,7 @@\n using Microsoft.Build.Shared;\n \n using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;\n+using static Microsoft.Build.BackEnd.Logging.EventSourceSink;",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This argument seems to bve allways passed as `null` - so it sounds like we can completely remove it - right?",
              "createdAt": "2024-10-08T10:21:03Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -321,662 +323,48 @@ internal void UnregisterAllEventHandlers()\n \n         #region Private Methods\n \n-        /// <summary>\n-        /// Raises a message event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildMessageEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)\n-        {\n-            if (MessageRaised != null)\n-            {\n-                try\n-                {\n-                    MessageRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises an error event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildErrorEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent)\n-        {\n-            if (ErrorRaised != null)\n-            {\n-                try\n-                {\n-                    ErrorRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a warning event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildWarningEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent)\n-        {\n-            if (WarningRaised != null)\n-            {\n-                try\n-                {\n-                    WarningRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent)\n-        {\n-            if (BuildStarted != null)\n-            {\n-                try\n-                {\n-                    BuildStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n+        public delegate void ArgsHandler<in TArgs>(object sender, TArgs e) where TArgs : BuildEventArgs;\n \n         /// <summary>\n-        /// Raises a \"build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent)\n-        {\n-            if (BuildFinished != null)\n-            {\n-                try\n-                {\n-                    BuildFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"project build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">ProjectStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent)\n-        {\n-            if (ProjectStarted != null)\n-            {\n-                try\n-                {\n-                    ProjectStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"project build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">ProjectFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent)\n-        {\n-            if (ProjectFinished != null)\n-            {\n-                try\n-                {\n-                    ProjectFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"target build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TargetStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent)\n-        {\n-            if (TargetStarted != null)\n-            {\n-                try\n-                {\n-                    TargetStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"target build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TargetFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent)\n-        {\n-            if (TargetFinished != null)\n-            {\n-                try\n-                {\n-                    TargetFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"task execution started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TaskStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent)\n-        {\n-            if (TaskStarted != null)\n-            {\n-                try\n-                {\n-                    TaskStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"task finished executing\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TaskFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent)\n-        {\n-            if (TaskFinished != null)\n-            {\n-                try\n-                {\n-                    TaskFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a custom event to all registered loggers.\n+        /// Raises a message event to all registered loggers.\n         /// </summary>\n         /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">CustomBuildEventArgs</param>\n+        /// <param name=\"buildEvent\">event args</param>\n+        /// <param name=\"handler\">argument handler that invokes the respective event</param>\n+        /// <param name=\"followUp\"> either anyEvent, customEvent or statusEvent</param>\n         /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n         /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n         /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent)\n+        private void RaiseEvent<TArgs>(object sender, TArgs buildEvent, ArgsHandler<TArgs> handler, ArgsHandler<TArgs> followUp)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "sounds about right. I glazed over it since it wasn't in my area of focus.\r\nWill do in the next pass over.",
              "createdAt": "2024-10-08T10:27:38Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -321,662 +323,48 @@ internal void UnregisterAllEventHandlers()\n \n         #region Private Methods\n \n-        /// <summary>\n-        /// Raises a message event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildMessageEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)\n-        {\n-            if (MessageRaised != null)\n-            {\n-                try\n-                {\n-                    MessageRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises an error event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildErrorEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent)\n-        {\n-            if (ErrorRaised != null)\n-            {\n-                try\n-                {\n-                    ErrorRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a warning event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildWarningEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent)\n-        {\n-            if (WarningRaised != null)\n-            {\n-                try\n-                {\n-                    WarningRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent)\n-        {\n-            if (BuildStarted != null)\n-            {\n-                try\n-                {\n-                    BuildStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n+        public delegate void ArgsHandler<in TArgs>(object sender, TArgs e) where TArgs : BuildEventArgs;\n \n         /// <summary>\n-        /// Raises a \"build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent)\n-        {\n-            if (BuildFinished != null)\n-            {\n-                try\n-                {\n-                    BuildFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"project build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">ProjectStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent)\n-        {\n-            if (ProjectStarted != null)\n-            {\n-                try\n-                {\n-                    ProjectStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"project build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">ProjectFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent)\n-        {\n-            if (ProjectFinished != null)\n-            {\n-                try\n-                {\n-                    ProjectFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"target build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TargetStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent)\n-        {\n-            if (TargetStarted != null)\n-            {\n-                try\n-                {\n-                    TargetStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"target build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TargetFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent)\n-        {\n-            if (TargetFinished != null)\n-            {\n-                try\n-                {\n-                    TargetFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"task execution started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TaskStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent)\n-        {\n-            if (TaskStarted != null)\n-            {\n-                try\n-                {\n-                    TaskStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"task finished executing\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TaskFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent)\n-        {\n-            if (TaskFinished != null)\n-            {\n-                try\n-                {\n-                    TaskFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a custom event to all registered loggers.\n+        /// Raises a message event to all registered loggers.\n         /// </summary>\n         /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">CustomBuildEventArgs</param>\n+        /// <param name=\"buildEvent\">event args</param>\n+        /// <param name=\"handler\">argument handler that invokes the respective event</param>\n+        /// <param name=\"followUp\"> either anyEvent, customEvent or statusEvent</param>\n         /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n         /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n         /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent)\n+        private void RaiseEvent<TArgs>(object sender, TArgs buildEvent, ArgsHandler<TArgs> handler, ArgsHandler<TArgs> followUp)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Maybe `followUp` -> `followUpHandler`?\r\n\r\nThe `followUp` sounds too generic to me",
              "createdAt": "2024-10-08T10:22:06Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -321,662 +323,48 @@ internal void UnregisterAllEventHandlers()\n \n         #region Private Methods\n \n-        /// <summary>\n-        /// Raises a message event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildMessageEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)\n-        {\n-            if (MessageRaised != null)\n-            {\n-                try\n-                {\n-                    MessageRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises an error event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildErrorEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent)\n-        {\n-            if (ErrorRaised != null)\n-            {\n-                try\n-                {\n-                    ErrorRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a warning event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildWarningEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent)\n-        {\n-            if (WarningRaised != null)\n-            {\n-                try\n-                {\n-                    WarningRaised(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseAnyEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent)\n-        {\n-            if (BuildStarted != null)\n-            {\n-                try\n-                {\n-                    BuildStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n+        public delegate void ArgsHandler<in TArgs>(object sender, TArgs e) where TArgs : BuildEventArgs;\n \n         /// <summary>\n-        /// Raises a \"build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">BuildFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent)\n-        {\n-            if (BuildFinished != null)\n-            {\n-                try\n-                {\n-                    BuildFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"project build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">ProjectStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent)\n-        {\n-            if (ProjectStarted != null)\n-            {\n-                try\n-                {\n-                    ProjectStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"project build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">ProjectFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent)\n-        {\n-            if (ProjectFinished != null)\n-            {\n-                try\n-                {\n-                    ProjectFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"target build started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TargetStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent)\n-        {\n-            if (TargetStarted != null)\n-            {\n-                try\n-                {\n-                    TargetStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"target build finished\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TargetFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent)\n-        {\n-            if (TargetFinished != null)\n-            {\n-                try\n-                {\n-                    TargetFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"task execution started\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TaskStartedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent)\n-        {\n-            if (TaskStarted != null)\n-            {\n-                try\n-                {\n-                    TaskStarted(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a \"task finished executing\" event to all registered loggers.\n-        /// </summary>\n-        /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">TaskFinishedEventArgs</param>\n-        /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n-        /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n-        /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent)\n-        {\n-            if (TaskFinished != null)\n-            {\n-                try\n-                {\n-                    TaskFinished(sender, buildEvent);\n-                }\n-                catch (LoggerException)\n-                {\n-                    // if a logger has failed politely, abort immediately\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-                    throw;\n-                }\n-                catch (Exception exception)\n-                {\n-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings\n-                    // if a fellow logger is throwing in an event handler.\n-                    this.UnregisterAllEventHandlers();\n-\n-                    if (ExceptionHandling.IsCriticalException(exception))\n-                    {\n-                        throw;\n-                    }\n-\n-                    InternalLoggerException.Throw(exception, buildEvent, \"FatalErrorWhileLogging\", false);\n-                }\n-            }\n-\n-            RaiseStatusEvent(sender, buildEvent);\n-        }\n-\n-        /// <summary>\n-        /// Raises a custom event to all registered loggers.\n+        /// Raises a message event to all registered loggers.\n         /// </summary>\n         /// <param name=\"sender\">sender of the event</param>\n-        /// <param name=\"buildEvent\">CustomBuildEventArgs</param>\n+        /// <param name=\"buildEvent\">event args</param>\n+        /// <param name=\"handler\">argument handler that invokes the respective event</param>\n+        /// <param name=\"followUp\"> either anyEvent, customEvent or statusEvent</param>\n         /// <exception cref=\"LoggerException\">When EventHandler raises an logger exception the LoggerException is rethrown</exception>\n         /// <exception cref=\"InternalLoggerException\">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>\n         /// <exception cref=\"Exception\">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>\n-        private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent)\n+        private void RaiseEvent<TArgs>(object sender, TArgs buildEvent, ArgsHandler<TArgs> handler, ArgsHandler<TArgs> followUp)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "the follow up is  AnyEventRaised here, but in RaiseMessageEvent is RaiseAnyEvent - AnyEventRaised with try catch block of its own. don't we still need it?",
              "createdAt": "2024-10-08T10:31:32Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +224,59 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(null, buildMessageEvent, (o, args) => MessageRaised?.Invoke(o, args), (o, args) => AnyEventRaised?.Invoke(o, args));",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "same for StatusEventRaised as a follow up. in RaisedTaskStartedEvent is RaiseStatusEvent - StatusEventRaised with try catch",
              "createdAt": "2024-10-08T10:33:45Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +224,59 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(null, buildMessageEvent, (o, args) => MessageRaised?.Invoke(o, args), (o, args) => AnyEventRaised?.Invoke(o, args));\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    RaiseEvent(null, taskStartedEvent, (o, args) => TaskStarted?.Invoke(o, args), (o, args) => StatusEventRaised?.Invoke(o, args));",
              "author": {
                "login": "surayya-MS"
              }
            },
            {
              "body": "good catch.\r\nSo if we need the try-catch, it would be this invocation instead:\r\n  ``` RaiseEvent(buildMessageEvent, (args) => MessageRaised?.Invoke(null, args), (args) => RaiseEvent(args, (args) => AnyEventRaised?.Invoke(null, args), null)); ```\r\n?\r\nAlternatively, since this is starting to look quite lambda-ish and not readable enough, I can keep around the RaiseStatusEvent and pass it instead of the lambda since it suddenly doesn't look all that nice.\r\n\r\nThat being said, if we already succesfully passed specific event handler, shoudln't the generic one be fine as-is? (could be unnecessarily dangerous?)",
              "createdAt": "2024-10-08T10:49:47Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +224,59 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(null, buildMessageEvent, (o, args) => MessageRaised?.Invoke(o, args), (o, args) => AnyEventRaised?.Invoke(o, args));\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    RaiseEvent(null, taskStartedEvent, (o, args) => TaskStarted?.Invoke(o, args), (o, args) => StatusEventRaised?.Invoke(o, args));",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "suggestion: RaiseEvent is called for StatusEventRaised and with RaiseAnyEvent as follow up multiple times. does it workk to define `ArgsHandler<BuildEventArgs> raiseStatusEvent = args => RaiseEvent(args, args=>StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);` before the switch?",
              "createdAt": "2024-10-08T14:37:04Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);",
              "author": {
                "login": "surayya-MS"
              }
            },
            {
              "body": "That is lambda hiding some complexity there:\r\n`ArgsHandler<BuildFinishedEventArgs> BuildFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);`\r\nvs\r\n`ArgsHandler<BuildStartedEventArgs> BuildStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);`\r\ne.g. the BuildEventArgs type is different at each invocation.\r\n\r\nI've tried some similar stuff, but it usually ends up with the compiler complaining about type mismatch. Maybe I'm just not familiar enough with generics though?",
              "createdAt": "2024-10-08T15:37:21Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "in that case, I'm okay with merging as it is now.",
              "createdAt": "2024-10-08T15:46:21Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why use the old event versus reactive extensions?",
              "createdAt": "2024-10-09T11:44:26Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -27,92 +25,92 @@ internal sealed class EventSourceSink :\n         /// <summary>\n         /// This event is raised to log a message.\n         /// </summary>\n-        public event BuildMessageEventHandler MessageRaised;\n+        public event BuildMessageEventHandler? MessageRaised;",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "IIRC this was discussed earlier on a different PR already. \r\n* Rx.NET needs additional libs (not used accross VS or sdk) - which would require perf justification\r\n* Introducing new paradigm to existing code base with diferent paradigm is net negative (there would be two paradigms or a very extensive refactoring of the whole codebase would be needed). In a new codebase it can be great\r\n* This would be breaking to a fundamental public API (`IEventSource`)",
              "createdAt": "2024-10-09T19:58:16Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -27,92 +25,92 @@ internal sealed class EventSourceSink :\n         /// <summary>\n         /// This event is raised to log a message.\n         /// </summary>\n-        public event BuildMessageEventHandler MessageRaised;\n+        public event BuildMessageEventHandler? MessageRaised;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "consider a default action, at least a log entry",
              "createdAt": "2024-10-09T11:46:02Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(taskStartedEvent, args => TaskStarted?.Invoke(null, args), taskStartedFollowUp);\n                     break;\n                 case TaskFinishedEventArgs taskFinishedEvent:\n-                    RaiseTaskFinishedEvent(null, taskFinishedEvent);\n+                    ArgsHandler<TaskFinishedEventArgs> taskFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(taskFinishedEvent, args => TaskFinished?.Invoke(null, args), taskFinishedFollowUp);\n                     break;\n                 case TargetStartedEventArgs targetStartedEvent:\n-                    RaiseTargetStartedEvent(null, targetStartedEvent);\n+                    ArgsHandler<TargetStartedEventArgs> targetStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(targetStartedEvent, args => TargetStarted?.Invoke(null, args), targetStartedFollowUp);\n                     break;\n                 case TargetFinishedEventArgs targetFinishedEvent:\n-                    RaiseTargetFinishedEvent(null, targetFinishedEvent);\n+                    ArgsHandler<TargetFinishedEventArgs> targetFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(targetFinishedEvent, args => TargetFinished?.Invoke(null, args), targetFinishedFollowUp);\n                     break;\n                 case ProjectStartedEventArgs projectStartedEvent:\n-                    RaiseProjectStartedEvent(null, projectStartedEvent);\n+                    ArgsHandler<ProjectStartedEventArgs> projectStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(projectStartedEvent, args => ProjectStarted?.Invoke(null, args), projectStartedFollowUp);\n                     break;\n                 case ProjectFinishedEventArgs projectFinishedEvent:\n-                    RaiseProjectFinishedEvent(null, projectFinishedEvent);\n+                    ArgsHandler<ProjectFinishedEventArgs> projectFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(projectFinishedEvent, args => ProjectFinished?.Invoke(null, args), projectFinishedFollowUp);\n                     break;\n                 case BuildStartedEventArgs buildStartedEvent:\n                     HaveLoggedBuildStartedEvent = true;\n-                    RaiseBuildStartedEvent(null, buildStartedEvent);\n+                    ArgsHandler<BuildStartedEventArgs> BuildStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(buildStartedEvent, args => BuildStarted?.Invoke(null, args), BuildStartedFollowUp);\n                     break;\n                 case BuildFinishedEventArgs buildFinishedEvent:\n                     HaveLoggedBuildFinishedEvent = true;\n-                    RaiseBuildFinishedEvent(null, buildFinishedEvent);\n+                    ArgsHandler<BuildFinishedEventArgs> BuildFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(buildFinishedEvent, args => BuildFinished?.Invoke(null, args), BuildFinishedFollowUp);\n                     break;\n                 case BuildCanceledEventArgs buildCanceledEvent:\n-                    RaiseStatusEvent(null, buildCanceledEvent);\n+\n+                    RaiseEvent(buildCanceledEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case CustomBuildEventArgs customBuildEvent:\n-                    RaiseCustomEvent(null, customBuildEvent);\n+                    RaiseEvent(customBuildEvent, args => CustomEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case BuildStatusEventArgs buildStatusEvent:\n-                    RaiseStatusEvent(null, buildStatusEvent);\n+                    RaiseEvent(buildStatusEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case BuildWarningEventArgs buildWarningEvent:\n-                    RaiseWarningEvent(null, buildWarningEvent);\n+                    RaiseEvent(buildWarningEvent, args => WarningRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case BuildErrorEventArgs buildErrorEvent:\n-                    RaiseErrorEvent(null, buildErrorEvent);\n+                    RaiseEvent(buildErrorEvent, args => ErrorRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TelemetryEventArgs telemetryEvent:\n-                    RaiseTelemetryEvent(null, telemetryEvent);\n+                    RaiseEvent(telemetryEvent, args => TelemetryLogged?.Invoke(null, args), null);\n                     break;\n                 case BuildCheckEventArgs buildCheckEvent:\n-                    RaiseBuildCheckEvent(null, buildCheckEvent);\n+                    RaiseEvent(buildCheckEvent, args => BuildCheckEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n \n                 default:",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "It already has `ErrorUtilities.ThrowInternalError(\"Unknown event args type.\");`",
              "createdAt": "2024-10-09T20:00:07Z",
              "path": "src/Build/BackEnd/Components/Logging/EventSourceSink.cs",
              "diffHunk": "@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)\n         /// </summary>\n         public void Consume(BuildEventArgs buildEvent)\n         {\n+\n             switch (buildEvent)\n             {\n                 case BuildMessageEventArgs buildMessageEvent:\n-                    RaiseMessageEvent(null, buildMessageEvent);\n+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TaskStartedEventArgs taskStartedEvent:\n-                    RaiseTaskStartedEvent(null, taskStartedEvent);\n+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(taskStartedEvent, args => TaskStarted?.Invoke(null, args), taskStartedFollowUp);\n                     break;\n                 case TaskFinishedEventArgs taskFinishedEvent:\n-                    RaiseTaskFinishedEvent(null, taskFinishedEvent);\n+                    ArgsHandler<TaskFinishedEventArgs> taskFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(taskFinishedEvent, args => TaskFinished?.Invoke(null, args), taskFinishedFollowUp);\n                     break;\n                 case TargetStartedEventArgs targetStartedEvent:\n-                    RaiseTargetStartedEvent(null, targetStartedEvent);\n+                    ArgsHandler<TargetStartedEventArgs> targetStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(targetStartedEvent, args => TargetStarted?.Invoke(null, args), targetStartedFollowUp);\n                     break;\n                 case TargetFinishedEventArgs targetFinishedEvent:\n-                    RaiseTargetFinishedEvent(null, targetFinishedEvent);\n+                    ArgsHandler<TargetFinishedEventArgs> targetFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(targetFinishedEvent, args => TargetFinished?.Invoke(null, args), targetFinishedFollowUp);\n                     break;\n                 case ProjectStartedEventArgs projectStartedEvent:\n-                    RaiseProjectStartedEvent(null, projectStartedEvent);\n+                    ArgsHandler<ProjectStartedEventArgs> projectStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(projectStartedEvent, args => ProjectStarted?.Invoke(null, args), projectStartedFollowUp);\n                     break;\n                 case ProjectFinishedEventArgs projectFinishedEvent:\n-                    RaiseProjectFinishedEvent(null, projectFinishedEvent);\n+                    ArgsHandler<ProjectFinishedEventArgs> projectFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(projectFinishedEvent, args => ProjectFinished?.Invoke(null, args), projectFinishedFollowUp);\n                     break;\n                 case BuildStartedEventArgs buildStartedEvent:\n                     HaveLoggedBuildStartedEvent = true;\n-                    RaiseBuildStartedEvent(null, buildStartedEvent);\n+                    ArgsHandler<BuildStartedEventArgs> BuildStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(buildStartedEvent, args => BuildStarted?.Invoke(null, args), BuildStartedFollowUp);\n                     break;\n                 case BuildFinishedEventArgs buildFinishedEvent:\n                     HaveLoggedBuildFinishedEvent = true;\n-                    RaiseBuildFinishedEvent(null, buildFinishedEvent);\n+                    ArgsHandler<BuildFinishedEventArgs> BuildFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n+                    RaiseEvent(buildFinishedEvent, args => BuildFinished?.Invoke(null, args), BuildFinishedFollowUp);\n                     break;\n                 case BuildCanceledEventArgs buildCanceledEvent:\n-                    RaiseStatusEvent(null, buildCanceledEvent);\n+\n+                    RaiseEvent(buildCanceledEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case CustomBuildEventArgs customBuildEvent:\n-                    RaiseCustomEvent(null, customBuildEvent);\n+                    RaiseEvent(customBuildEvent, args => CustomEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case BuildStatusEventArgs buildStatusEvent:\n-                    RaiseStatusEvent(null, buildStatusEvent);\n+                    RaiseEvent(buildStatusEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case BuildWarningEventArgs buildWarningEvent:\n-                    RaiseWarningEvent(null, buildWarningEvent);\n+                    RaiseEvent(buildWarningEvent, args => WarningRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case BuildErrorEventArgs buildErrorEvent:\n-                    RaiseErrorEvent(null, buildErrorEvent);\n+                    RaiseEvent(buildErrorEvent, args => ErrorRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n                 case TelemetryEventArgs telemetryEvent:\n-                    RaiseTelemetryEvent(null, telemetryEvent);\n+                    RaiseEvent(telemetryEvent, args => TelemetryLogged?.Invoke(null, args), null);\n                     break;\n                 case BuildCheckEventArgs buildCheckEvent:\n-                    RaiseBuildCheckEvent(null, buildCheckEvent);\n+                    RaiseEvent(buildCheckEvent, args => BuildCheckEventRaised?.Invoke(null, args), RaiseAnyEvent);\n                     break;\n \n                 default:",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}