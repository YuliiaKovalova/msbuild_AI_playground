{
  "number": 6680,
  "title": "Fix lock contention in ProjectRootElementCache.Get",
  "body": "Fixes #3039\r\n\r\n### Context\r\nThere is significant amount of lock contentions in ProjectRootElementCache.Get method. \r\n(For OrchardCore project, for example, the total time spent waiting to take a lock ~1sec.)\r\nReason: the code is using a single lock to control to access the cache, and also read file into XmlDocument, when it does not exist. The later one can be slow on a slow disk.\r\n\r\n### Changes Made\r\nThe ProjectRootElementCache.Get function is rewritten to exclude IO operations from the locked sections.\r\nFor this goal we also had to separate logic of loading from logic of adding the element to the cache.\r\n\r\n### Testing\r\nUnit tests + manual testing.\r\n",
  "state": "MERGED",
  "createdAt": "2021-07-15T16:03:35Z",
  "updatedAt": "2024-03-01T15:30:20Z",
  "closedAt": "2021-07-26T06:20:32Z",
  "mergedAt": "2021-07-26T06:20:32Z",
  "additions": 142,
  "deletions": 91,
  "changedFiles": 5,
  "headRefName": "lock-contention-in-ProjectRootElementCache-3",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "53a560c9f9fabd74c441ade3da8e23d5c68b05c8",
          "message": "Rewrite Get function in ProjectRootElementCache such that IO operations (loading, etc) is out of a lock.",
          "committedDate": "2021-07-15T15:38:22Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "83f097a948f3dcaaa7c42172b1fc09f34207a1cc",
          "message": "Make all openLoader delegate functions used in Get function of the ProjectRootElementCache not to insert an element to the cache.",
          "committedDate": "2021-07-20T16:05:41Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dafe7f8ae3640f49a4f5ecb64bc4f7ec93b5d63d",
          "message": "Make SimpleProjectRootElementCache add elements to the cache in the Get function, and not in openLoader delegate function.",
          "committedDate": "2021-07-20T16:05:42Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81dcd7a20a50f8a62132e79af35e7324d64eb06d",
          "message": "Fix openLoader functions in unit tests so that they do not add element to a cache.",
          "committedDate": "2021-07-20T16:05:42Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cb1f13852f6ce33b9c6b6d99c654661bbe1f58f7",
          "message": "Addressing PR comments.",
          "committedDate": "2021-07-20T16:07:41Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a6db102cd2ee02f45ced163b2ba73049fd73f0ca",
          "message": "Remove extra lock in ProjectRootElementCache.Get for unit tests.",
          "committedDate": "2021-07-20T16:07:47Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86b30b778443bf556e188d697548146e5081fad7",
          "message": "Addressing PR comments - 2.",
          "committedDate": "2021-07-21T15:14:59Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d3fd5381c0180f79ce21347d52ba5aa6b6f4a55d",
          "message": "Addressing PR comments - 3.",
          "committedDate": "2021-07-22T10:57:06Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Experimental insertion in VS showed problems with these changes. Converting this PR to draft while I investigate and fix.",
        "createdAt": "2021-07-16T11:01:55Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "Ready for review now, the errors does not seem to be related to the changes after investigation.",
        "createdAt": "2021-07-21T09:28:59Z",
        "author": {
          "login": "AR-May"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This is inside the lock, right? Is that ok since it's a \"test-only\" codepath, or can this be avoided too?",
              "createdAt": "2021-07-15T19:20:16Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -131,15 +131,69 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             LoadProjectsReadOnly = loadProjectsReadOnly;\n         }\n \n+\n+        /// <summary>\n+        /// Returns true if given cache entry exists and is outdated.\n+        /// </summary>\n+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)\n+        {\n+            if (projectRootElement != null && _autoReloadFromDisk)\n+            {\n+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+\n+                // If the file doesn't exist on disk, go ahead and use the cached version.\n+                // It's an in-memory project that hasn't been saved yet.\n+                if (fileInfo != null)\n+                {\n+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n+                    {\n+                        // File was changed on disk by external means. Cached version is no longer valid.\n+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file\n+                        // externally and load a new project over it to see the new content. So we dump it from the cache\n+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n+                        // but clients ought not get themselves into such a state - and unless they save them to disk,\n+                        // it may not be a problem.\n+                        return true;\n+                    }\n+                    else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n+                    {\n+                        lock (_locker)\n+                        {\n+                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n+                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n+                            // the cache as we get test coverage of the rest of the cache code.\n+                            XmlDocument document = new XmlDocument();\n+                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n+\n+                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n+                            {\n+                                document.Load(xtr.Reader);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Since it is really used only in QA tests we haven't give it much thinking as for optimization. Shall we?",
              "createdAt": "2021-07-15T21:44:35Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -131,15 +131,69 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             LoadProjectsReadOnly = loadProjectsReadOnly;\n         }\n \n+\n+        /// <summary>\n+        /// Returns true if given cache entry exists and is outdated.\n+        /// </summary>\n+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)\n+        {\n+            if (projectRootElement != null && _autoReloadFromDisk)\n+            {\n+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+\n+                // If the file doesn't exist on disk, go ahead and use the cached version.\n+                // It's an in-memory project that hasn't been saved yet.\n+                if (fileInfo != null)\n+                {\n+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n+                    {\n+                        // File was changed on disk by external means. Cached version is no longer valid.\n+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file\n+                        // externally and load a new project over it to see the new content. So we dump it from the cache\n+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n+                        // but clients ought not get themselves into such a state - and unless they save them to disk,\n+                        // it may not be a problem.\n+                        return true;\n+                    }\n+                    else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n+                    {\n+                        lock (_locker)\n+                        {\n+                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n+                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n+                            // the cache as we get test coverage of the rest of the cache code.\n+                            XmlDocument document = new XmlDocument();\n+                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n+\n+                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n+                            {\n+                                document.Load(xtr.Reader);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This section is thread safe and the lock could be omitted here. This could result in multiple tests concurrently loading project XML in readonly fashion. This shall be OK and we should consider it. Worst could happen some test fails or become flaky in which situation we can put the lock back. What do you think @AR-May ?",
              "createdAt": "2021-07-15T22:57:08Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -131,15 +131,69 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             LoadProjectsReadOnly = loadProjectsReadOnly;\n         }\n \n+\n+        /// <summary>\n+        /// Returns true if given cache entry exists and is outdated.\n+        /// </summary>\n+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)\n+        {\n+            if (projectRootElement != null && _autoReloadFromDisk)\n+            {\n+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+\n+                // If the file doesn't exist on disk, go ahead and use the cached version.\n+                // It's an in-memory project that hasn't been saved yet.\n+                if (fileInfo != null)\n+                {\n+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n+                    {\n+                        // File was changed on disk by external means. Cached version is no longer valid.\n+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file\n+                        // externally and load a new project over it to see the new content. So we dump it from the cache\n+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n+                        // but clients ought not get themselves into such a state - and unless they save them to disk,\n+                        // it may not be a problem.\n+                        return true;\n+                    }\n+                    else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n+                    {\n+                        lock (_locker)\n+                        {\n+                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n+                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n+                            // the cache as we get test coverage of the rest of the cache code.\n+                            XmlDocument document = new XmlDocument();\n+                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n+\n+                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n+                            {\n+                                document.Load(xtr.Reader);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Yes, I think we can try to unlock this section, I suppose.",
              "createdAt": "2021-07-16T09:57:41Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -131,15 +131,69 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             LoadProjectsReadOnly = loadProjectsReadOnly;\n         }\n \n+\n+        /// <summary>\n+        /// Returns true if given cache entry exists and is outdated.\n+        /// </summary>\n+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)\n+        {\n+            if (projectRootElement != null && _autoReloadFromDisk)\n+            {\n+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+\n+                // If the file doesn't exist on disk, go ahead and use the cached version.\n+                // It's an in-memory project that hasn't been saved yet.\n+                if (fileInfo != null)\n+                {\n+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n+                    {\n+                        // File was changed on disk by external means. Cached version is no longer valid.\n+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file\n+                        // externally and load a new project over it to see the new content. So we dump it from the cache\n+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n+                        // but clients ought not get themselves into such a state - and unless they save them to disk,\n+                        // it may not be a problem.\n+                        return true;\n+                    }\n+                    else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n+                    {\n+                        lock (_locker)\n+                        {\n+                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n+                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n+                            // the cache as we get test coverage of the rest of the cache code.\n+                            XmlDocument document = new XmlDocument();\n+                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n+\n+                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n+                            {\n+                                document.Load(xtr.Reader);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "If it's test only I think a bit of lock contention is fine to save development effort. Just wanted to make sure that was the case.",
              "createdAt": "2021-07-16T14:41:43Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -131,15 +131,69 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             LoadProjectsReadOnly = loadProjectsReadOnly;\n         }\n \n+\n+        /// <summary>\n+        /// Returns true if given cache entry exists and is outdated.\n+        /// </summary>\n+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)\n+        {\n+            if (projectRootElement != null && _autoReloadFromDisk)\n+            {\n+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+\n+                // If the file doesn't exist on disk, go ahead and use the cached version.\n+                // It's an in-memory project that hasn't been saved yet.\n+                if (fileInfo != null)\n+                {\n+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n+                    {\n+                        // File was changed on disk by external means. Cached version is no longer valid.\n+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file\n+                        // externally and load a new project over it to see the new content. So we dump it from the cache\n+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n+                        // but clients ought not get themselves into such a state - and unless they save them to disk,\n+                        // it may not be a problem.\n+                        return true;\n+                    }\n+                    else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n+                    {\n+                        lock (_locker)\n+                        {\n+                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n+                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n+                            // the cache as we get test coverage of the rest of the cache code.\n+                            XmlDocument document = new XmlDocument();\n+                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n+\n+                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n+                            {\n+                                document.Load(xtr.Reader);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as\r\n```",
              "createdAt": "2021-07-15T19:30:28Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +212,91 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n+                if (projectRootElement != null)\n+                {\n+                    BoostEntryInStrongCache(projectRootElement);\n+\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n+                    {\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n+                    }\n+                }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n+\n                 if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n                     //  Cached project doesn't match preserveFormatting setting, so reload it\n                     projectRootElement.Reload(true, preserveFormatting);\n                 }\n+            }\n+\n+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);\n+            bool fromCacheOnly = openProjectRootElement == null;\n \n-                if (projectRootElement != null && _autoReloadFromDisk)\n+            lock (_locker)\n+            {\n+                if (projectRootElementIsInvalid)\n                 {\n-                    FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+                    DebugTraceCache(\"Not satisfied from cache: \", projectFile);\n+                    ForgetEntryIfExists(projectRootElement);\n+                }\n \n-                    // If the file doesn't exist on disk, go ahead and use the cached version.\n-                    // It's an in-memory project that hasn't been saved yet.\n-                    if (fileInfo != null)\n+                if (fromCacheOnly)\n+                {\n+                    if (projectRootElement == null || projectRootElementIsInvalid)\n                     {\n-                        bool forgetEntry = false;\n-\n-                        if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n-                        {\n-                            // File was changed on disk by external means. Cached version is no longer reliable. \n-                            // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file \n-                            // externally and load a new project over it to see the new content. So we dump it from the cache\n-                            // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n-                            // but clients ought not get themselves into such a state - and unless they save them to disk,\n-                            // it may not be a problem.  \n-                            forgetEntry = true;\n-                        }\n-                        else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n-                        {\n-                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n-                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n-                            // the cache as we get test coverage of the rest of the cache code.\n-                            XmlDocument document = new XmlDocument();\n-                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n-\n-                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n-                            {\n-                                document.Load(xtr.Reader);\n-                            }\n-\n-                            string diskContent = document.OuterXml;\n-                            string cacheContent = projectRootElement.XmlDocument.OuterXml;\n-\n-                            if (diskContent != cacheContent)\n-                            {\n-                                forgetEntry = true;\n-                            }\n-                        }\n-\n-                        if (forgetEntry)\n-                        {\n-                            ForgetEntry(projectRootElement);\n-\n-                            DebugTraceCache(\"Out of date dropped from XML cache: \", projectFile);\n-                            projectRootElement = null;\n-                        }\n+                        return null;\n+                    }\n+                    else\n+                    {\n+                        DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n+                        return projectRootElement;\n                     }\n                 }\n+            }\n \n-                if (projectRootElement == null && openProjectRootElement != null)\n-                {\n-                    projectRootElement = openProjectRootElement(projectFile, this);\n+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.\n+            if (projectRootElement == null || projectRootElementIsInvalid)\n+            {\n+                // We do not lock loading with common _locker of the cache, to avoid lock contention.\n+                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplification, as",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This message is now outdated. I'd recommend something like \"ProjectRootElement should have been added into cache\"",
              "createdAt": "2021-07-16T08:52:25Z",
              "path": "src/Build/Evaluation/SimpleProjectRootElementCache.cs",
              "diffHunk": "@@ -63,6 +63,9 @@ private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRo\n                 ErrorUtilities.VerifyThrowInternalNull(rootElement, \"projectRootElement\");\n                 ErrorUtilities.VerifyThrow(rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),\n                     \"Got project back with incorrect path\");\n+\n+                AddEntry(rootElement);\n+\n                 ErrorUtilities.VerifyThrow(_cache.TryGetValue(key, out _),\n                     \"Open should have renamed into cache and boosted\");",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "May I ask you to explain this statement? We're inside the `GetOrAdd` callback so `rootElement` will be added to the cache with the key of `projectFile`. Why are we calling another add?",
              "createdAt": "2021-07-21T11:06:33Z",
              "path": "src/Build/Evaluation/SimpleProjectRootElementCache.cs",
              "diffHunk": "@@ -63,8 +63,11 @@ private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRo\n                 ErrorUtilities.VerifyThrowInternalNull(rootElement, \"projectRootElement\");\n                 ErrorUtilities.VerifyThrow(rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),\n                     \"Got project back with incorrect path\");\n+\n+                AddEntry(rootElement);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yes, I removed AddEntry from the end of all the open functions in order to divide downloading and adding to the cache code. So, now everywhere else where I used open functions, I now need to do AddEntry exactly afterwards, so that behavior is exactly the same as before.\r\nHere, in case of SimpleProjectRootElementCache, AddEntry does a bit more than just adding to _cache (it raises an event additionally).",
              "createdAt": "2021-07-21T14:47:09Z",
              "path": "src/Build/Evaluation/SimpleProjectRootElementCache.cs",
              "diffHunk": "@@ -63,8 +63,11 @@ private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRo\n                 ErrorUtilities.VerifyThrowInternalNull(rootElement, \"projectRootElement\");\n                 ErrorUtilities.VerifyThrow(rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),\n                     \"Got project back with incorrect path\");\n+\n+                AddEntry(rootElement);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Thank you, yes, it does what it was doing before. It doesn't look right, though, to be adding inside the `GetOrAdd` callback. It means that the item will be added twice - by `AddEntry` and then attempted another add by `GetOrAdd` after the callback returns. It looks as though this should be a `TryGetValue` instead of `GetOrAdd`.\r\n\r\nJust a perf nit, really, and OK to ignore.",
              "createdAt": "2021-07-21T20:55:04Z",
              "path": "src/Build/Evaluation/SimpleProjectRootElementCache.cs",
              "diffHunk": "@@ -63,8 +63,11 @@ private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRo\n                 ErrorUtilities.VerifyThrowInternalNull(rootElement, \"projectRootElement\");\n                 ErrorUtilities.VerifyThrow(rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),\n                     \"Got project back with incorrect path\");\n+\n+                AddEntry(rootElement);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We're still loading XML under the lock here. Intentional?",
              "createdAt": "2021-07-21T11:22:15Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +209,91 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n+                if (projectRootElement != null)\n+                {\n+                    BoostEntryInStrongCache(projectRootElement);\n+\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n+                    {\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n+                    }\n+                }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n+\n                 if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n                     //  Cached project doesn't match preserveFormatting setting, so reload it\n                     projectRootElement.Reload(true, preserveFormatting);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yes, intentional. \r\nThis if section fixes a rare bug, and this code path uses it's own code for reloading. \r\nTo refactor it such that we can divide the actual download and updating the element of the cache which has to be under the lock is not worth it, so we decided.",
              "createdAt": "2021-07-21T14:10:28Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +209,91 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n+                if (projectRootElement != null)\n+                {\n+                    BoostEntryInStrongCache(projectRootElement);\n+\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n+                    {\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n+                    }\n+                }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n+\n                 if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n                     //  Cached project doesn't match preserveFormatting setting, so reload it\n                     projectRootElement.Reload(true, preserveFormatting);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: You could assign to `projectRootElement` here, the new local is not needed.",
              "createdAt": "2021-07-21T11:27:04Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +209,91 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n+                if (projectRootElement != null)\n+                {\n+                    BoostEntryInStrongCache(projectRootElement);\n+\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n+                    {\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n+                    }\n+                }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n+\n                 if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n                     //  Cached project doesn't match preserveFormatting setting, so reload it\n                     projectRootElement.Reload(true, preserveFormatting);\n                 }\n+            }\n+\n+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);\n+            bool fromCacheOnly = openProjectRootElement == null;\n \n-                if (projectRootElement != null && _autoReloadFromDisk)\n+            lock (_locker)\n+            {\n+                if (projectRootElementIsInvalid)\n                 {\n-                    FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+                    DebugTraceCache(\"Not satisfied from cache: \", projectFile);\n+                    ForgetEntryIfExists(projectRootElement);\n+                }\n \n-                    // If the file doesn't exist on disk, go ahead and use the cached version.\n-                    // It's an in-memory project that hasn't been saved yet.\n-                    if (fileInfo != null)\n+                if (fromCacheOnly)\n+                {\n+                    if (projectRootElement == null || projectRootElementIsInvalid)\n                     {\n-                        bool forgetEntry = false;\n-\n-                        if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n-                        {\n-                            // File was changed on disk by external means. Cached version is no longer reliable. \n-                            // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file \n-                            // externally and load a new project over it to see the new content. So we dump it from the cache\n-                            // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n-                            // but clients ought not get themselves into such a state - and unless they save them to disk,\n-                            // it may not be a problem.  \n-                            forgetEntry = true;\n-                        }\n-                        else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n-                        {\n-                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n-                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n-                            // the cache as we get test coverage of the rest of the cache code.\n-                            XmlDocument document = new XmlDocument();\n-                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n-\n-                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n-                            {\n-                                document.Load(xtr.Reader);\n-                            }\n-\n-                            string diskContent = document.OuterXml;\n-                            string cacheContent = projectRootElement.XmlDocument.OuterXml;\n-\n-                            if (diskContent != cacheContent)\n-                            {\n-                                forgetEntry = true;\n-                            }\n-                        }\n-\n-                        if (forgetEntry)\n-                        {\n-                            ForgetEntry(projectRootElement);\n-\n-                            DebugTraceCache(\"Out of date dropped from XML cache: \", projectFile);\n-                            projectRootElement = null;\n-                        }\n+                        return null;\n+                    }\n+                    else\n+                    {\n+                        DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n+                        return projectRootElement;\n                     }\n                 }\n+            }\n \n-                if (projectRootElement == null && openProjectRootElement != null)\n-                {\n-                    projectRootElement = openProjectRootElement(projectFile, this);\n+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.\n+            if (projectRootElement == null || projectRootElementIsInvalid)\n+            {\n+                // We do not lock loading with common _locker of the cache, to avoid lock contention.\n+                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as\n+                // it is not likely that two threads would use Get function for the same project simulteniously and it is not a big deal if in some cases we load the same project twice.\n \n-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, \"projectRootElement\");\n-                    ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, \"Got project back with incorrect path\");\n-                    ErrorUtilities.VerifyThrow(_weakCache.Contains(projectFile), \"Open should have renamed into cache and boosted\");\n-                }\n-                else if (projectRootElement != null)\n-                {\n-                    DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n-                    BoostEntryInStrongCache(projectRootElement);\n-                }\n+                ProjectRootElement newProjectRootElement = openProjectRootElement(projectFile, this);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `projectRootElement = newProjectRootElement` doesn't have to run under the lock and `AddEntry` takes the lock internally, so this can be simplified to only call `AddEntry`.",
              "createdAt": "2021-07-21T11:28:24Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +209,91 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n+                if (projectRootElement != null)\n+                {\n+                    BoostEntryInStrongCache(projectRootElement);\n+\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n+                    {\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n+                    }\n+                }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n+\n                 if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n                     //  Cached project doesn't match preserveFormatting setting, so reload it\n                     projectRootElement.Reload(true, preserveFormatting);\n                 }\n+            }\n+\n+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);\n+            bool fromCacheOnly = openProjectRootElement == null;\n \n-                if (projectRootElement != null && _autoReloadFromDisk)\n+            lock (_locker)\n+            {\n+                if (projectRootElementIsInvalid)\n                 {\n-                    FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+                    DebugTraceCache(\"Not satisfied from cache: \", projectFile);\n+                    ForgetEntryIfExists(projectRootElement);\n+                }\n \n-                    // If the file doesn't exist on disk, go ahead and use the cached version.\n-                    // It's an in-memory project that hasn't been saved yet.\n-                    if (fileInfo != null)\n+                if (fromCacheOnly)\n+                {\n+                    if (projectRootElement == null || projectRootElementIsInvalid)\n                     {\n-                        bool forgetEntry = false;\n-\n-                        if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n-                        {\n-                            // File was changed on disk by external means. Cached version is no longer reliable. \n-                            // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file \n-                            // externally and load a new project over it to see the new content. So we dump it from the cache\n-                            // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n-                            // but clients ought not get themselves into such a state - and unless they save them to disk,\n-                            // it may not be a problem.  \n-                            forgetEntry = true;\n-                        }\n-                        else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n-                        {\n-                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n-                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n-                            // the cache as we get test coverage of the rest of the cache code.\n-                            XmlDocument document = new XmlDocument();\n-                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n-\n-                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n-                            {\n-                                document.Load(xtr.Reader);\n-                            }\n-\n-                            string diskContent = document.OuterXml;\n-                            string cacheContent = projectRootElement.XmlDocument.OuterXml;\n-\n-                            if (diskContent != cacheContent)\n-                            {\n-                                forgetEntry = true;\n-                            }\n-                        }\n-\n-                        if (forgetEntry)\n-                        {\n-                            ForgetEntry(projectRootElement);\n-\n-                            DebugTraceCache(\"Out of date dropped from XML cache: \", projectFile);\n-                            projectRootElement = null;\n-                        }\n+                        return null;\n+                    }\n+                    else\n+                    {\n+                        DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n+                        return projectRootElement;\n                     }\n                 }\n+            }\n \n-                if (projectRootElement == null && openProjectRootElement != null)\n-                {\n-                    projectRootElement = openProjectRootElement(projectFile, this);\n+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.\n+            if (projectRootElement == null || projectRootElementIsInvalid)\n+            {\n+                // We do not lock loading with common _locker of the cache, to avoid lock contention.\n+                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as\n+                // it is not likely that two threads would use Get function for the same project simulteniously and it is not a big deal if in some cases we load the same project twice.\n \n-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, \"projectRootElement\");\n-                    ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, \"Got project back with incorrect path\");\n-                    ErrorUtilities.VerifyThrow(_weakCache.Contains(projectFile), \"Open should have renamed into cache and boosted\");\n-                }\n-                else if (projectRootElement != null)\n-                {\n-                    DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n-                    BoostEntryInStrongCache(projectRootElement);\n-                }\n+                ProjectRootElement newProjectRootElement = openProjectRootElement(projectFile, this);\n+                ErrorUtilities.VerifyThrowInternalNull(newProjectRootElement, \"projectRootElement\");\n+                ErrorUtilities.VerifyThrow(newProjectRootElement.FullPath == projectFile, \"Got project back with incorrect path\");\n \n                 // An implicit load will never reset the explicit flag.\n-                if (projectRootElement != null && isExplicitlyLoaded)\n+                if (isExplicitlyLoaded)\n                 {\n-                    projectRootElement.MarkAsExplicitlyLoaded();\n+                    newProjectRootElement?.MarkAsExplicitlyLoaded();\n                 }\n \n-                return projectRootElement;\n+                lock (_locker)\n+                {\n+                    // Update cache element.\n+                    // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.\n+                    // And here its entry will be replaced with newProjectRootElement. This is fine:\n+                    // if newProjectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.\n+                    AddEntry(newProjectRootElement);\n+                    projectRootElement = newProjectRootElement;\n+                }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This environment variable check may be worth caching. Looking at the tests using it, it's unlikely they set it after this code has run.",
              "createdAt": "2021-07-21T11:33:06Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -131,15 +131,66 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             LoadProjectsReadOnly = loadProjectsReadOnly;\n         }\n \n+\n+        /// <summary>\n+        /// Returns true if given cache entry exists and is outdated.\n+        /// </summary>\n+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)\n+        {\n+            if (projectRootElement != null && _autoReloadFromDisk)\n+            {\n+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+\n+                // If the file doesn't exist on disk, go ahead and use the cached version.\n+                // It's an in-memory project that hasn't been saved yet.\n+                if (fileInfo != null)\n+                {\n+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n+                    {\n+                        // File was changed on disk by external means. Cached version is no longer valid.\n+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file\n+                        // externally and load a new project over it to see the new content. So we dump it from the cache\n+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n+                        // but clients ought not get themselves into such a state - and unless they save them to disk,\n+                        // it may not be a problem.\n+                        return true;\n+                    }\n+                    else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Only `ForgetEntryIfExists` needs to run under the lock, the rest of the statements do not. They are trivial or debug-only so it's a readability rather than perf suggestion. Since this is the only place calling `ForgetEntryIfExists`, you could also move the locking there or inline the method here. No strong opinion, though.",
              "createdAt": "2021-07-21T11:42:28Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +209,91 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n+                if (projectRootElement != null)\n+                {\n+                    BoostEntryInStrongCache(projectRootElement);\n+\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n+                    {\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n+                    }\n+                }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n+\n                 if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n                     //  Cached project doesn't match preserveFormatting setting, so reload it\n                     projectRootElement.Reload(true, preserveFormatting);\n                 }\n+            }\n+\n+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);\n+            bool fromCacheOnly = openProjectRootElement == null;\n \n-                if (projectRootElement != null && _autoReloadFromDisk)\n+            lock (_locker)\n+            {\n+                if (projectRootElementIsInvalid)\n                 {\n-                    FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+                    DebugTraceCache(\"Not satisfied from cache: \", projectFile);\n+                    ForgetEntryIfExists(projectRootElement);\n+                }\n \n-                    // If the file doesn't exist on disk, go ahead and use the cached version.\n-                    // It's an in-memory project that hasn't been saved yet.\n-                    if (fileInfo != null)\n+                if (fromCacheOnly)\n+                {\n+                    if (projectRootElement == null || projectRootElementIsInvalid)\n                     {\n-                        bool forgetEntry = false;\n-\n-                        if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n-                        {\n-                            // File was changed on disk by external means. Cached version is no longer reliable. \n-                            // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file \n-                            // externally and load a new project over it to see the new content. So we dump it from the cache\n-                            // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n-                            // but clients ought not get themselves into such a state - and unless they save them to disk,\n-                            // it may not be a problem.  \n-                            forgetEntry = true;\n-                        }\n-                        else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n-                        {\n-                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n-                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n-                            // the cache as we get test coverage of the rest of the cache code.\n-                            XmlDocument document = new XmlDocument();\n-                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n-\n-                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n-                            {\n-                                document.Load(xtr.Reader);\n-                            }\n-\n-                            string diskContent = document.OuterXml;\n-                            string cacheContent = projectRootElement.XmlDocument.OuterXml;\n-\n-                            if (diskContent != cacheContent)\n-                            {\n-                                forgetEntry = true;\n-                            }\n-                        }\n-\n-                        if (forgetEntry)\n-                        {\n-                            ForgetEntry(projectRootElement);\n-\n-                            DebugTraceCache(\"Out of date dropped from XML cache: \", projectFile);\n-                            projectRootElement = null;\n-                        }\n+                        return null;\n+                    }\n+                    else\n+                    {\n+                        DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n+                        return projectRootElement;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: The `?` is redundant, the variable will not be null here. It is checked on line 267 and the following line is unconditionally dereferencing it so even if `VerifyThrowInternalNull` didn't throw, it would have crashed there.",
              "createdAt": "2021-07-21T20:59:09Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -158,91 +209,82 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO\n             // Should already have been canonicalized\n             ErrorUtilities.VerifyThrowInternalRooted(projectFile);\n \n+            ProjectRootElement projectRootElement;\n             lock (_locker)\n             {\n-                ProjectRootElement projectRootElement;\n                 _weakCache.TryGetValue(projectFile, out projectRootElement);\n \n-                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n-                {\n-                    //  Cached project doesn't match preserveFormatting setting, so reload it\n-                    projectRootElement.Reload(true, preserveFormatting);\n-                }\n-\n-                if (projectRootElement != null && _autoReloadFromDisk)\n+                if (projectRootElement != null)\n                 {\n-                    FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);\n+                    BoostEntryInStrongCache(projectRootElement);\n \n-                    // If the file doesn't exist on disk, go ahead and use the cached version.\n-                    // It's an in-memory project that hasn't been saved yet.\n-                    if (fileInfo != null)\n+                    // An implicit load will never reset the explicit flag.\n+                    if (isExplicitlyLoaded)\n                     {\n-                        bool forgetEntry = false;\n-\n-                        if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)\n-                        {\n-                            // File was changed on disk by external means. Cached version is no longer reliable. \n-                            // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file \n-                            // externally and load a new project over it to see the new content. So we dump it from the cache\n-                            // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,\n-                            // but clients ought not get themselves into such a state - and unless they save them to disk,\n-                            // it may not be a problem.  \n-                            forgetEntry = true;\n-                        }\n-                        else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDCACHECHECKFILECONTENT\")))\n-                        {\n-                            // QA tests run too fast for the timestamp check to work. This environment variable is for their\n-                            // use: it checks the file content as well as the timestamp. That's better than completely disabling\n-                            // the cache as we get test coverage of the rest of the cache code.\n-                            XmlDocument document = new XmlDocument();\n-                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;\n-\n-                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))\n-                            {\n-                                document.Load(xtr.Reader);\n-                            }\n-\n-                            string diskContent = document.OuterXml;\n-                            string cacheContent = projectRootElement.XmlDocument.OuterXml;\n-\n-                            if (diskContent != cacheContent)\n-                            {\n-                                forgetEntry = true;\n-                            }\n-                        }\n-\n-                        if (forgetEntry)\n-                        {\n-                            ForgetEntry(projectRootElement);\n-\n-                            DebugTraceCache(\"Out of date dropped from XML cache: \", projectFile);\n-                            projectRootElement = null;\n-                        }\n+                        projectRootElement.MarkAsExplicitlyLoaded();\n                     }\n                 }\n+                else\n+                {\n+                    DebugTraceCache(\"Not found in cache: \", projectFile);\n+                }\n \n-                if (projectRootElement == null && openProjectRootElement != null)\n+                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)\n                 {\n-                    projectRootElement = openProjectRootElement(projectFile, this);\n+                    //  Cached project doesn't match preserveFormatting setting, so reload it\n+                    projectRootElement.Reload(true, preserveFormatting);\n+                }\n+            }\n \n-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, \"projectRootElement\");\n-                    ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, \"Got project back with incorrect path\");\n-                    ErrorUtilities.VerifyThrow(_weakCache.Contains(projectFile), \"Open should have renamed into cache and boosted\");\n+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);\n+            if (projectRootElementIsInvalid)\n+            {\n+                DebugTraceCache(\"Not satisfied from cache: \", projectFile);\n+                ForgetEntryIfExists(projectRootElement);\n+            }\n+\n+            if (openProjectRootElement == null)\n+            {\n+                if (projectRootElement == null || projectRootElementIsInvalid)\n+                {\n+                    return null;\n                 }\n-                else if (projectRootElement != null)\n+                else\n                 {\n                     DebugTraceCache(\"Satisfied from XML cache: \", projectFile);\n-                    BoostEntryInStrongCache(projectRootElement);\n+                    return projectRootElement;\n                 }\n+            }\n+\n+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.\n+            if (projectRootElement == null || projectRootElementIsInvalid)\n+            {\n+                // We do not lock loading with common _locker of the cache, to avoid lock contention.\n+                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as\n+                // it is not likely that two threads would use Get function for the same project simulteniously and it is not a big deal if in some cases we load the same project twice.\n+\n+                projectRootElement = openProjectRootElement(projectFile, this);\n+                ErrorUtilities.VerifyThrowInternalNull(projectRootElement, \"projectRootElement\");\n+                ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, \"Got project back with incorrect path\");\n \n                 // An implicit load will never reset the explicit flag.\n-                if (projectRootElement != null && isExplicitlyLoaded)\n+                if (isExplicitlyLoaded)\n                 {\n-                    projectRootElement.MarkAsExplicitlyLoaded();\n+                    projectRootElement?.MarkAsExplicitlyLoaded();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}