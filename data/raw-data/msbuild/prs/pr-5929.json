{
  "number": 5929,
  "title": "Optimize RAR's GetReferenceItems method",
  "body": "This change should not alter behavior other than changing casing on metadata (that should be case-insensitive), but it includes a series of changes (see individual commits) that simplify the code, correct typos, or prevent MSBuild from having to do unnecessary work. (Note that this means that most of the commits are expected to have no relevant impact on perf despite the title of this PR.) From building OrchardCore once with and once without this change, RAR's execution time declined by about 2.5% when there were no caches. This part of RAR does not rely on the caches, so this gain will not be wiped out by including caches.",
  "state": "MERGED",
  "createdAt": "2020-12-02T23:26:16Z",
  "updatedAt": "2021-02-06T21:07:03Z",
  "closedAt": "2021-02-06T21:07:02Z",
  "mergedAt": "2021-02-06T21:07:02Z",
  "additions": 145,
  "deletions": 110,
  "changedFiles": 4,
  "headRefName": "optimize-rar",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "cfe147c5748e49ffaf1af803c3d4d97c1b7425b3",
          "message": "Iterate over dictionary once",
          "committedDate": "2020-12-02T00:14:12Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "17015afb54add007a43a50171839485aaeb3fdd1",
          "message": "Avoid unnecessary initializations",
          "committedDate": "2020-12-02T00:14:35Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fec708e113e3866dd1969dae4c105021745bdea7",
          "message": "Set copy local more efficiently\n\nChanges \"true\" to \"True\" and \"false\" to \"False\", but that's ok because it should be case-insensitive.",
          "committedDate": "2020-12-02T00:15:16Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed2bc5cc377683d6960b80793cd780479099e908",
          "message": "referenceItem should have no metadata initially",
          "committedDate": "2020-12-02T00:16:44Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2fc517f63fc1392280bea20545c08e9b8f7bb4e7",
          "message": "Update larger metadata dictionary",
          "committedDate": "2020-12-02T01:39:57Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1dc3bc5263429ce036be28329793c16abba4af28",
          "message": "Set fusionName at end\n\nThis means we don't have to repeatedly unset it.",
          "committedDate": "2020-12-02T01:52:32Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "77b10382386eed3749de08f35e4c93941200303f",
          "message": "Slightly simplify referenceItem creation",
          "committedDate": "2020-12-02T01:57:00Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "507214d81e75fb767ea6de2433172ef46a61d58a",
          "message": "Fix typos",
          "committedDate": "2020-12-02T01:57:17Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4945ad2bfe1e5a311f269b9e96b08e3eaf120597",
          "message": "Addition to setting fusionName at end",
          "committedDate": "2020-12-02T19:48:22Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf314ab288f0969a0bf10869eda05d52a6801a70",
          "message": "Shift other types of removed metadata later so they only have to be removed once\n\nnonForwardableMetadata?.Remove(ItemMetadataNames.*) is used to prevent the correct metadata value from being overwritten when metadata are re-added from nonForwardableMetadata.",
          "committedDate": "2020-12-02T22:40:56Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7077b0e55fa04c1b0acb76c48775060d9211e95e",
          "message": "Tests should permit case-insensitive metadata checks",
          "committedDate": "2020-12-03T00:56:00Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "afe2cf0d3d71e1d1e9410fd98444f3df8c06f6f2",
          "message": "Use ternary operators",
          "committedDate": "2020-12-04T18:17:20Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9dccb269d29129eca97100e05b09902f27788b44",
          "message": "Set items as a group\n\nAlso, comparing to a null value apparently always returns false, so the check I was using was bogus. This fixes that.",
          "committedDate": "2020-12-04T19:53:13Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "147ef43b208a866ec5b0c62995e6346d1f8420a8",
          "message": "PR comments",
          "committedDate": "2020-12-04T22:42:36Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "290192974566c8d2722a233d00d93152fe724a54",
          "message": "Revert \"Tests should permit case-insensitive metadata checks\"\n\nThis reverts commit 7077b0e55fa04c1b0acb76c48775060d9211e95e.",
          "committedDate": "2020-12-04T22:42:40Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fd0a93d947564332cc53d593302e3964110e688c",
          "message": "PR comments",
          "committedDate": "2020-12-06T17:18:55Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "74cf67ca20b3442d08804f91516fe657bdbd1003",
          "message": "PR feedback",
          "committedDate": "2020-12-07T16:42:54Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a45a466f476f8369ff1825809688951ad5a69f1",
          "message": "Update src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2020-12-07T16:46:52Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2a8893ce0b0f8fea1eeeaba53b17173edc4103b3",
          "message": "Correct setting items",
          "committedDate": "2020-12-07T17:10:03Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "04e72edda9b5a4c18f108ea2d0efc848a5e7a1df",
          "message": "Make align with old way",
          "committedDate": "2021-01-26T00:21:20Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2bb3210ffa03068c454e3bff36737b6f0e4d5ce4",
          "message": "Use _metadata directly",
          "committedDate": "2021-02-01T22:18:01Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ff501aaab7e2cdd1253878588b5672fd91b6f15d",
          "message": "Merge https://github.com/dotnet/msbuild into optimize-rar",
          "committedDate": "2021-02-02T17:24:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f238083d4a1e9f8841b2b40039d4c059cce0e4b",
          "message": "Access remote metadata indirectly\n\nA TaskItem in AppDomain A is identical to a TaskItem in AppDomain B, but the TaskItems cannot access each other's fields, only their properties. This changes accessing a possibly remote TaskItem's _metadata field into accessing its Metadata property.",
          "committedDate": "2021-02-02T17:34:18Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I added one more commit that should make it do exactly what the previous code path had done in all cases. Rather than fully reverting that part, I left it in, although I don't expect that to be a perf optimization anymore, just a potential improvement for some customers. If you want me to fully revert it and just leave the other part, I can, but it feels wrong to undo something that could theoretically improve perf if I don't think it could worsen perf.",
        "createdAt": "2021-01-26T00:23:36Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you clarify the purpose of this change? Is this to optimistically optimize the case where you are copying metadata values that exactly match the destination (in value and count) - in this case the foreach here will not cause a \"copy\" of the dictionary because it will just be writing the same values? If that's the case, why not `destinationAsTaskItem.Metadata?.Count == _metadata?.Count`?",
              "createdAt": "2020-12-02T23:39:34Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,14 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata?.Count < _metadata?.Count)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    foreach (KeyValuePair<string, string> entry in destinationAsTaskItem.Metadata)\n+                    {\n+                        copiedMetadata[entry.Key] = entry.Value;",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "There was previously an optimization for if destinationAsTaskItem.Metadata was null, i.e., its count was 0, but there are also cases in which its count is small compared to _metadata?.Count. This is trying to improve that case, where there are a few metadata defined for destinationAsTaskItem but not as many as for the source. In that case, it's better to modify a clone of the source rather than modifying the destination directly.",
              "createdAt": "2020-12-03T00:51:16Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,14 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata?.Count < _metadata?.Count)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    foreach (KeyValuePair<string, string> entry in destinationAsTaskItem.Metadata)\n+                    {\n+                        copiedMetadata[entry.Key] = entry.Value;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be escaping, as on line 331? I'm not sure, but you'll want to make sure there's a test. IIRC, everything is always escaped when it enters the MSBuild engine, and unescaped on the way out.",
              "createdAt": "2020-12-02T23:40:27Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,14 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata?.Count < _metadata?.Count)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    foreach (KeyValuePair<string, string> entry in destinationAsTaskItem.Metadata)\n+                    {\n+                        copiedMetadata[entry.Key] = entry.Value;",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "This is copying metadata from a TaskItem to a TaskItem, so its escaped status should be the same in both cases. Just copying it over without escaping or unescaping it makes sense to me.\r\n\r\nLine 331 is for ITaskItems that are not ITaskItem2s, and this will always be an ITaskItem2, so if some escaping/unescaping is warranted, it should be replacing entry.Value with destinationAsTaskItem.GetMetadataValueEscaped(entry.Key), but that's less performant, and I don't understand why that would be warranted. Doesn't mean I'm right, though.",
              "createdAt": "2020-12-03T00:48:21Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,14 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata?.Count < _metadata?.Count)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    foreach (KeyValuePair<string, string> entry in destinationAsTaskItem.Metadata)\n+                    {\n+                        copiedMetadata[entry.Key] = entry.Value;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Convert to ternary operator",
              "createdAt": "2020-12-04T17:02:27Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2596,14 +2596,7 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n             referenceItem.SetMetadata(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);\n \n             // Set the CopyLocal metadata.\n-            if (reference.IsCopyLocal)\n-            {\n-                referenceItem.SetMetadata(ItemMetadataNames.copyLocal, \"true\");\n-            }\n-            else\n-            {\n-                referenceItem.SetMetadata(ItemMetadataNames.copyLocal, \"false\");\n-            }\n+            referenceItem.SetMetadata(ItemMetadataNames.copyLocal, reference.IsCopyLocal.ToString());",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Document the return value.",
              "createdAt": "2020-12-04T17:13:11Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2951,15 +2931,37 @@ internal static UInt16 ReadMachineTypeFromPEHeader(string dllPath)\n         /// <summary>\n         /// Some metadata should not be forwarded between the parent and child items.\n         /// </summary>\n-        private static void RemoveNonForwardableMetadata(ITaskItem item)\n+        private static Dictionary<string, string> RemoveNonForwardableMetadata(ITaskItem item)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment, please. And I think I personally would find it clearer if there were three explicit cases:\r\n\r\n1. Destination has no metadata.\r\n2. Destination has less metadata than source.\r\n3. Source has more metadata than destination.",
              "createdAt": "2020-12-04T20:29:47Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,23 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    if (destinationAsTaskItem.Metadata == null || destinationAsTaskItem.Metadata.Count < _metadata.Count)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Remove these comments please.",
              "createdAt": "2020-12-04T20:43:31Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2777,7 +2765,6 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 // Clone metadata.\n                 referenceItem.CopyMetadataTo(item);\n                 // We don't have a fusion name for scatter files.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does \"properly\" mean? In general, how do you know this is safe? Is the local variable `fusionName` guaranteed to be empty for all the paths where it was previously unset? How do you know?",
              "createdAt": "2020-12-04T20:45:06Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2798,6 +2785,9 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            // Set the FusionName metadata properly.\n+            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If any of reference.GetSourceItems() has a fusionName, or reference.PrimarySourceItem has one, fusionName may have been set to an invalid value at this point. We remove it before forwarding referenceItem's metadata to other items, but we still need to set it properly at the end, i.e., give it the right fusionName.",
              "createdAt": "2020-12-04T22:22:29Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2798,6 +2785,9 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            // Set the FusionName metadata properly.\n+            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Would you mind clarifying what you meant about fusionName being guaranteed to be empty? Previously, fusionName was set to a value near the top of this method, that value was passed on to a variety of \"relatedItems,\" \"satelliteItems,\" etc., and then it was unset from all of those other items. Here, instead, I'm unsetting it prior to using fusionName for any of those, and only giving it its value at the bottom, so CopyMetadataTo automatically skips fusionName.",
              "createdAt": "2020-12-04T22:26:52Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2798,6 +2785,9 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            // Set the FusionName metadata properly.\n+            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The meta comment is: \"properly\" is basically useless in a code comment. Comments describe what you want the code to do/why it's done, and of course you _want_ to do things \"properly\". Instead, describe details. Here, you might have a comment that `fusionName` should be set last, so that it doesn't get copied to the derived items but is still available on the primary item.",
              "createdAt": "2020-12-04T22:43:17Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2798,6 +2785,9 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            // Set the FusionName metadata properly.\n+            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is there a more descriptive name for this variable? `removedMetadata`?",
              "createdAt": "2020-12-04T20:53:55Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2919,15 +2931,37 @@ internal static UInt16 ReadMachineTypeFromPEHeader(string dllPath)\n         /// <summary>\n         /// Some metadata should not be forwarded between the parent and child items.\n         /// </summary>\n-        private static void RemoveNonForwardableMetadata(ITaskItem item)\n+        private static Dictionary<string, string> RemoveNonForwardableMetadata(ITaskItem item)\n         {\n-            item.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);\n-            item.RemoveMetadata(ItemMetadataNames.imageRuntime);\n-            item.RemoveMetadata(ItemMetadataNames.winMDFile);\n+            Dictionary<string, string> metadata = new Dictionary<string, string>();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since this one has to be next to the add to the new list, can you move the others to be next to their equivalents too?",
              "createdAt": "2020-12-04T20:54:27Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2919,15 +2931,37 @@ internal static UInt16 ReadMachineTypeFromPEHeader(string dllPath)\n         /// <summary>\n         /// Some metadata should not be forwarded between the parent and child items.\n         /// </summary>\n-        private static void RemoveNonForwardableMetadata(ITaskItem item)\n+        private static Dictionary<string, string> RemoveNonForwardableMetadata(ITaskItem item)\n         {\n-            item.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);\n-            item.RemoveMetadata(ItemMetadataNames.imageRuntime);\n-            item.RemoveMetadata(ItemMetadataNames.winMDFile);\n+            Dictionary<string, string> metadata = new Dictionary<string, string>();\n+            string meta = item.GetMetadata(ItemMetadataNames.winmdImplmentationFile);\n+            if (!String.IsNullOrEmpty(meta))\n+            {\n+                metadata.Add(ItemMetadataNames.winmdImplmentationFile, meta);\n+            }\n+            meta = item.GetMetadata(ItemMetadataNames.imageRuntime);\n+            if (!String.IsNullOrEmpty(meta))\n+            {\n+                metadata.Add(ItemMetadataNames.imageRuntime, meta);\n+            }\n+            meta = item.GetMetadata(ItemMetadataNames.winMDFile);\n+            if (!String.IsNullOrEmpty(meta))\n+            {\n+                metadata.Add(ItemMetadataNames.winMDFile, meta);\n+            }\n             if (!Traits.Instance.EscapeHatches.TargetPathForRelatedFiles)\n             {\n+                meta = item.GetMetadata(ItemMetadataNames.targetPath);\n+                if (!String.IsNullOrEmpty(meta))\n+                {\n+                    metadata.Add(ItemMetadataNames.targetPath, meta);\n+                }\n                 item.RemoveMetadata(ItemMetadataNames.targetPath);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "My gut feeling is that these will all be small enough that keeping them live all at once instead of in sequence won't be a memory problem. But do you have data on that?",
              "createdAt": "2020-12-04T20:57:02Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2715,55 +2683,58 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n             // Unset fusionName so we don't have to unset it later.\n             referenceItem.RemoveMetadata(ItemMetadataNames.fusionName);\n \n+            List<string> relatedFileExtensions = reference.GetRelatedFileExtensions();\n+            List<string> satellites = reference.GetSatelliteFiles();\n+            List<string> serializationAssemblyFiles = reference.GetSerializationAssemblyFiles();\n+            string[] scatterFiles = reference.GetScatterFiles();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Nope. How would I get such data? Build OrchardCore and...somehow check whether something is being paged out?",
              "createdAt": "2020-12-04T22:29:49Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2715,55 +2683,58 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n             // Unset fusionName so we don't have to unset it later.\n             referenceItem.RemoveMetadata(ItemMetadataNames.fusionName);\n \n+            List<string> relatedFileExtensions = reference.GetRelatedFileExtensions();\n+            List<string> satellites = reference.GetSatelliteFiles();\n+            List<string> serializationAssemblyFiles = reference.GetSerializationAssemblyFiles();\n+            string[] scatterFiles = reference.GetScatterFiles();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment please",
              "createdAt": "2020-12-04T20:58:13Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2783,9 +2754,50 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            if (reference.IsWinMDFile)\n+            {\n+                // The ImplementationAssembly is only set if the implementation file exits on disk\n+                if (reference.ImplementationAssembly != null)\n+                {\n+                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))\n+                    {\n+                        // Add the implementation item as a related file\n+                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);\n+                        // Clone metadata.\n+                        referenceItem.CopyMetadataTo(item);\n+\n+                        // Add the related item.\n+                        relatedItems.Add(item);\n+\n+                        referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));\n+                        nonForwardableMetadata?.Remove(ItemMetadataNames.winmdImplmentationFile);\n+                    }\n+                }\n+\n+                nonForwardableMetadata?.Remove(ItemMetadataNames.winMDFileType);\n+                if (reference.IsManagedWinMDFile)\n+                {\n+                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, \"Managed\");\n+                }\n+                else\n+                {\n+                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, \"Native\");\n+                }\n+                nonForwardableMetadata?.Remove(ItemMetadataNames.winMDFile);\n+                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, \"true\");\n+            }\n+\n             // Set the FusionName metadata properly.\n             referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);\n \n+            if (nonForwardableMetadata != null)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These inverted remove-from-the-removal-list things definitely need a comment please.",
              "createdAt": "2020-12-04T21:03:03Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2783,9 +2754,50 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            if (reference.IsWinMDFile)\n+            {\n+                // The ImplementationAssembly is only set if the implementation file exits on disk\n+                if (reference.ImplementationAssembly != null)\n+                {\n+                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))\n+                    {\n+                        // Add the implementation item as a related file\n+                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);\n+                        // Clone metadata.\n+                        referenceItem.CopyMetadataTo(item);\n+\n+                        // Add the related item.\n+                        relatedItems.Add(item);\n+\n+                        referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));\n+                        nonForwardableMetadata?.Remove(ItemMetadataNames.winmdImplmentationFile);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Revert all these please since you went back to the ternary.",
              "createdAt": "2020-12-04T21:04:07Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs",
              "diffHunk": "@@ -3455,7 +3455,7 @@ public void PrimaryFXAssemblyRefIsNotCopyLocal()\n \n             Assert.Single(t.ResolvedFiles);\n             Assert.Equal(Path.Combine(s_myVersion20Path, \"System.Data.dll\"), t.ResolvedFiles[0].ItemSpec);\n-            Assert.Equal(\"false\", t.ResolvedFiles[0].GetMetadata(\"CopyLocal\"));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This cast stands out. Should it be\r\n\r\n```suggestion\r\n                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, reference.IsRedistRoot == true ? \"true\" : \"false\");\r\n```",
              "createdAt": "2020-12-04T21:06:29Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2637,57 +2617,11 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 referenceItem.SetMetadata(ItemMetadataNames.imageRuntime, reference.ImageRuntime);\n             }\n \n-            if (reference.IsWinMDFile)\n-            {\n-                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, \"true\");\n-\n-                // The ImplementationAssembly is only set if the implementation file exits on disk\n-                if (reference.ImplementationAssembly != null)\n-                {\n-                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))\n-                    {\n-                        if (string.IsNullOrEmpty(referenceItem.GetMetadata(ItemMetadataNames.winmdImplmentationFile)))\n-                        {\n-                            referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));\n-                        }\n-\n-                        // Add the implementation item as a related file\n-                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);\n-                        // Clone metadata.\n-                        referenceItem.CopyMetadataTo(item);\n-                        // Related files don't have a fusion name.\n-                        item.SetMetadata(ItemMetadataNames.fusionName, \"\");\n-                        RemoveNonForwardableMetadata(item);\n-\n-                        // Add the related item.\n-                        relatedItems.Add(item);\n-                    }\n-                }\n-\n-                if (reference.IsManagedWinMDFile)\n-                {\n-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, \"Managed\");\n-                }\n-                else\n-                {\n-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, \"Native\");\n-                }\n-            }\n-\n-            // Set the IsRedistRoot metadata\n-            if (reference.IsRedistRoot == true)\n+            // The redist root is \"null\" when there was no IsRedistRoot flag in the Redist XML\n+            // (or there was no redist XML at all for this item).\n+            if (reference.IsRedistRoot != null)\n             {\n-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, \"true\");\n-            }\n-            else if (reference.IsRedistRoot == false)\n-            {\n-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, \"false\");\n-            }\n-            else\n-            {\n-                // This happens when the redist root is \"null\". This means there\n-                // was no IsRedistRoot flag in the Redist XML (or there was no \n-                // redist XML at all for this item).\n+                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? \"true\" : \"false\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Both ways work. We did a null check just before this, so it's either true or false.",
              "createdAt": "2020-12-04T22:35:56Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2637,57 +2617,11 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 referenceItem.SetMetadata(ItemMetadataNames.imageRuntime, reference.ImageRuntime);\n             }\n \n-            if (reference.IsWinMDFile)\n-            {\n-                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, \"true\");\n-\n-                // The ImplementationAssembly is only set if the implementation file exits on disk\n-                if (reference.ImplementationAssembly != null)\n-                {\n-                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))\n-                    {\n-                        if (string.IsNullOrEmpty(referenceItem.GetMetadata(ItemMetadataNames.winmdImplmentationFile)))\n-                        {\n-                            referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));\n-                        }\n-\n-                        // Add the implementation item as a related file\n-                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);\n-                        // Clone metadata.\n-                        referenceItem.CopyMetadataTo(item);\n-                        // Related files don't have a fusion name.\n-                        item.SetMetadata(ItemMetadataNames.fusionName, \"\");\n-                        RemoveNonForwardableMetadata(item);\n-\n-                        // Add the related item.\n-                        relatedItems.Add(item);\n-                    }\n-                }\n-\n-                if (reference.IsManagedWinMDFile)\n-                {\n-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, \"Managed\");\n-                }\n-                else\n-                {\n-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, \"Native\");\n-                }\n-            }\n-\n-            // Set the IsRedistRoot metadata\n-            if (reference.IsRedistRoot == true)\n+            // The redist root is \"null\" when there was no IsRedistRoot flag in the Redist XML\n+            // (or there was no redist XML at all for this item).\n+            if (reference.IsRedistRoot != null)\n             {\n-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, \"true\");\n-            }\n-            else if (reference.IsRedistRoot == false)\n-            {\n-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, \"false\");\n-            }\n-            else\n-            {\n-                // This happens when the redist root is \"null\". This means there\n-                // was no IsRedistRoot flag in the Redist XML (or there was no \n-                // redist XML at all for this item).\n+                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? \"true\" : \"false\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I was unsure between using Where or setting them one-by-one in this case. I did some benchmarking, and this is what I got:\r\n![image](https://user-images.githubusercontent.com/12969783/101220256-37f8fe00-363a-11eb-8eb1-cb279d03f3c1.png)\r\nNote that for each test case, I added `NumStrings / 10` items to an ImmutableDictionary with `NumStrings` items in it previously.\r\n\r\nYou can see that using Where had fewer allocations for all three sizes. (Base is creating but not combining the dictionaries, so Where actually allocated very little.) It lost on time, though, unless the dataset was large, and I don't have data as to whether that's expected sometimes, always, or never. Thoughts?",
              "createdAt": "2020-12-04T22:10:14Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,23 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    if (destinationAsTaskItem.Metadata == null || destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        if (destinationAsTaskItem.Metadata != null)\n+                        {\n+                            copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Can you instead do `copiedMetadata = Metadata.Clone().SetItems(destinationAsTaskItem.Metadata)`?",
              "createdAt": "2020-12-04T22:22:12Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,23 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    if (destinationAsTaskItem.Metadata == null || destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        if (destinationAsTaskItem.Metadata != null)\n+                        {\n+                            copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, and honestly, there are probably a lot of cases in which that would be better than what I currently have. What I'm trying to optimize for is adding metadata from a small dictionary to a large dictionary, and in that case, it would be better to add a few items individually rather than using SetItems to set a lot of items. I can run a test for that, though, and see if it's optimized nicely, in which case I'll switch to that.",
              "createdAt": "2020-12-04T22:41:28Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,23 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    if (destinationAsTaskItem.Metadata == null || destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        if (destinationAsTaskItem.Metadata != null)\n+                        {\n+                            copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It looks like doing it that way was 50-75% slower if the adding dictionary had 10x as many items. Next, trying it with a smaller ratio...",
              "createdAt": "2020-12-04T22:55:44Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,23 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    if (destinationAsTaskItem.Metadata == null || destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        if (destinationAsTaskItem.Metadata != null)\n+                        {\n+                            copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I tried comparing adding the larger dictionary to the smaller dictionary for ratios of 1, 2, 5, and 8, and it looks like setting with `Where` was faster for all but 1x size. I currently think that's the best option.\r\n![image](https://user-images.githubusercontent.com/12969783/101226494-7fd35180-3649-11eb-991d-f0f2b9dfcab1.png)\r\n",
              "createdAt": "2020-12-04T23:58:11Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -298,9 +298,23 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n             if (_metadata != null)\n             {\n                 // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    if (destinationAsTaskItem.Metadata == null || destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        if (destinationAsTaskItem.Metadata != null)\n+                        {\n+                            copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The original non-optimized code down in the `else` branch uses `string.IsNullOrEmpty(value)` to decide if the metadatum should be overwritten. It doesn't seem to match your new logic here - you only check if the key exists in the metadata dictionary.",
              "createdAt": "2020-12-07T09:16:47Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed, thanks!",
              "createdAt": "2020-12-07T16:42:26Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.ContainsKey(entry.Key)));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Refactor these statements into a local function to be called 4 times?",
              "createdAt": "2020-12-07T09:19:30Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2951,15 +2935,37 @@ internal static UInt16 ReadMachineTypeFromPEHeader(string dllPath)\n         /// <summary>\n         /// Some metadata should not be forwarded between the parent and child items.\n         /// </summary>\n-        private static void RemoveNonForwardableMetadata(ITaskItem item)\n+        private static Dictionary<string, string> RemoveNonForwardableMetadata(ITaskItem item)\n         {\n+            Dictionary<string, string> removedMetadata = new Dictionary<string, string>();\n+            string meta = item.GetMetadata(ItemMetadataNames.winmdImplmentationFile);\n+            if (!String.IsNullOrEmpty(meta))\n+            {\n+                removedMetadata.Add(ItemMetadataNames.winmdImplmentationFile, meta);\n+            }\n             item.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`SetItems` and `Where` will also need to be implemented on the .NET 3.5 version of `ImmutableDictionary` in C:\\src\\msbuild\\src\\MSBuildTaskHost\\Immutable\\ImmutableDictionary.cs.",
              "createdAt": "2020-12-07T10:03:45Z",
              "path": "src/Shared/CopyOnWriteDictionary.cs",
              "diffHunk": "@@ -227,6 +227,18 @@ public void Add(string key, V value)\n             _backing = _backing.SetItem(key, value);\n         }\n \n+        /// <summary>\n+        /// Adds several value to the dictionary.\n+        /// </summary>\n+        public void SetItems(IEnumerable<KeyValuePair<string, V>> items)\n+        {\n+            _backing = _backing.SetItems(items);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good catch! Why isn't `Where` implemented by LINQ as it is for most IEnumerables?",
              "createdAt": "2020-12-07T16:28:26Z",
              "path": "src/Shared/CopyOnWriteDictionary.cs",
              "diffHunk": "@@ -227,6 +227,18 @@ public void Add(string key, V value)\n             _backing = _backing.SetItem(key, value);\n         }\n \n+        /// <summary>\n+        /// Adds several value to the dictionary.\n+        /// </summary>\n+        public void SetItems(IEnumerable<KeyValuePair<string, V>> items)\n+        {\n+            _backing = _backing.SetItems(items);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Of course! I stand corrected, only `SetItems` is missing.",
              "createdAt": "2020-12-07T16:38:49Z",
              "path": "src/Shared/CopyOnWriteDictionary.cs",
              "diffHunk": "@@ -227,6 +227,18 @@ public void Add(string key, V value)\n             _backing = _backing.SetItem(key, value);\n         }\n \n+        /// <summary>\n+        /// Adds several value to the dictionary.\n+        /// </summary>\n+        public void SetItems(IEnumerable<KeyValuePair<string, V>> items)\n+        {\n+            _backing = _backing.SetItems(items);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n\r\n            return clone;\r\n        }\r\n```",
              "createdAt": "2020-12-07T16:45:50Z",
              "path": "src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs",
              "diffHunk": "@@ -138,6 +138,15 @@ private void CheckCopyToArguments(Array array, int arrayIndex)\n             return clone;\n         }\n \n+        internal ImmutableDictionary<K, V> SetItems(IEnumerable<KeyValuePair<K, V>> items)\n+        {\n+            var clone = new ImmutableDictionary<K, V>(_backing);\n+            foreach (KeyValuePair<K, V> item in items)\n+            {\n+                clone[item.Key] = item.Value;\n+            }\n+        }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `exits`.",
              "createdAt": "2020-12-08T13:52:58Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2818,6 +2747,61 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>\n                 }\n             }\n \n+            if (reference.IsWinMDFile)\n+            {\n+                // The ImplementationAssembly is only set if the implementation file exits on disk",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this is doing the same thing as the `else` right below. I would expect the `!IsNullOrEmpty` check here as well.\r\n\r\nThe else below:\r\n1. Take all of destination item's metadata.\r\n2. Overwrite with this item's metadata that are missing or empty on the destination item.\r\n\r\nThis block:\r\n1. Take all of this item's metadata.\r\n2. Overwrite with all of destination item's metadata.\r\n\r\nFor a missing destination metadatum this behaves the same, but for an empty one the `SetItem` call in this block will erroneously overwrite it with the empty value.",
              "createdAt": "2020-12-08T14:17:20Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "You're absolutely right. I'm wondering if we're going at this the wrong way, though, since that would mean we'd need another `Where` statement to filter out non-empty metadata, which would make this optimization noticeably less of an optimization. Empty metadata should be equivalent (in all cases) to missing metadata, I think. If that's true, it would probably be more efficient to maintain an invariant that TaskItems don't have empty metadata. The COW dictionary storing the metadata is private, so that isn't a problem, but it's theoretically a breaking change unless we keep a separate list for \"metadata added as empty\" for the unfortunately public MetadataNames (and MetadataCount). What do you think?",
              "createdAt": "2020-12-08T14:57:46Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I wouldn't go as far as to introduce a separate list for empty metadata unless it proves impactful. Can you measure how much this optimization is gaining us with and without handling empty?",
              "createdAt": "2020-12-08T15:43:17Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I measured 3 scenarios (building from a clean state (I appended /restore to the command line for this one), building with caches but not processes to connect to, and building with both) for 3 versions of TaskItem (as it is in master, with this change plus a Where statement on the else if branch, and with all the empty metadata stored in a HashSet once each for building OrchardCore. Note that I kept the other optimizations in this PR for all three versions of TaskItem. I used my computer instead of a VM, mostly because my VM seems to be slow...but I also tried to avoid doing anything too intense in the background. Note that I forgot to use `-m` for the first several tests, so I continued to not use it for the last few. If you want new results with having that enabled for all of them, I can do that.\r\n\r\nI have full results saved away if you want to look. My first takeaway was that caches _really matter_. It took more than twice as long to build in every case if I deleted them and restored them. In contrast, presumably because OrchardCore is big, and I neglected to enable -m, having processes already running only saved about 170ms on average.\r\n\r\nAs far as differences between the versions of TaskItem, here are some times for the entire build in ms:\r\nMSBuild execution times               |  Clean build  |  Process not running  |  Process running\r\n---------------------|---------------|-------------------------|----------------------\r\nMaster                    |  108475        |  49657                        |  49704\r\nWhere statements |  108253         |  48140                        |  47949\r\nEmpty HashSet      |  105464         |  49105                         |  48708\r\n\r\nSince it occurred to me that this has impacts outside RAR, I don't think just looking at RAR time makes sense. Are there other data you'd like to see? I'm not sure why the Where statements was so much worse than keeping an empty list for the clean state build\u2014it's possible that was an outlier, since I only ran each of these once.",
              "createdAt": "2020-12-08T19:19:44Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thank you. I was actually expecting you to measure this particular aspect with a microbenchmark. Basically, see if the `SetItems` call is helping (even with the `Where`) given the expected metadata count. I second Ben's question below about what the realistic number of metadata is. Maybe you could add a logging statement here while building OrchardCore and see where the breaking point is relative to the distribution of metadata count seen during the build. (Assuming there is a breaking point and the new code is actually a bit slower if the number of metadata is small.)\r\n\r\nMeasuring the entire build end-to-end would have to be repeated several times to get trustworthy results. As you wrote, it could have been an outlier and, honestly, this optimization is likely going to be well within noise when running the entire thing.",
              "createdAt": "2020-12-09T16:25:24Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "(Merging with @BenVillalobos's comment) I'm currently a bit confused by the results I got when I tried to test this. I put in a simple check of how many custom metadata each taskitem has when its metadata is copied over, as well as the amount of metadata on the destination. The answer seemed to be that the destination never had any custom metadata for either MSBuild.sln or OrchardCore.sln, in which case we would never hit the case I optimized, and the time would be almost identical between them unless the other changes I made (which could have a minor effect, but I didn't expect to be really relevant) had much more of a positive effect than I'd expected. The same test suggested that the source TaskItems had 20-50 pieces of metadata, of which 15 were not custom metadata, so these wouldn't be huge numbers, but this operation also got called a lot, which might mean that a small optimization could have somewhat noticeable effects. What do you make of that?",
              "createdAt": "2021-01-07T22:16:03Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Looks like a good argument against pursuing this optimization further. If you really wanted to be sure, you could run the build under a profiler to see how much time we're spending in this function - which would be the upper limit of what any micro-optimization here could give us.",
              "createdAt": "2021-01-08T14:55:48Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How likely are we to hit the case where `destinationAsTaskItem.Metadata.Count < _metadata.Count` and both metadata count are **very** large? I don't think I've seen items with a standout number of metadata, but MSBuild has surprised me before.\r\n\r\nDo we happen to have any idea of a \"realistic average\" number of metadata per TaskItem that comes through here? Something more detailed than just assuming it's the number of well-known metadata?",
              "createdAt": "2020-12-09T01:57:11Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Directly read `this._metadata` instead of calling the `this.Metadata` getter here for consistency with the `if` branches?",
              "createdAt": "2021-02-01T22:01:14Z",
              "path": "src/Utilities/TaskItem.cs",
              "diffHunk": "@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)\n \n             if (_metadata != null)\n             {\n-                // Avoid a copy if we can\n-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)\n+                if (destinationItem is TaskItem destinationAsTaskItem)\n                 {\n-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!\n+                    CopyOnWriteDictionary<string> copiedMetadata;\n+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.\n+                    if (destinationAsTaskItem.Metadata == null)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                    }\n+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)\n+                    {\n+                        copiedMetadata = _metadata.Clone(); // Copy on write!\n+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata.Where(entry => !String.IsNullOrEmpty(entry.Value)));\n+                    }\n+                    else\n+                    {\n+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();\n+                        copiedMetadata.SetItems(Metadata.Where(entry => !destinationAsTaskItem.Metadata.TryGetValue(entry.Key, out string val) || String.IsNullOrEmpty(val)));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}