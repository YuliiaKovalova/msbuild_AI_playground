{
  "number": 7540,
  "title": "[WIP-FEATURE] MSBuild client",
  "body": "Fixes #7374, #7373\r\n\r\nContext\r\nMSBuild client is a new code path that is triggered with opt-in env variable. It sends the build request for execution to the MSBuild server node. This approach avoids to do execute targets and tasks into a short-living process from CLI tools like .NET SDK and MSBuild.exe.\r\n\r\nChanges Made\r\nThis PR implements a new MSBuild client classes able to communicate with MSBuild server node via the named pipe. \r\n\r\nTesting\r\nManually tested. Automatic tests will be added in another PR.",
  "state": "MERGED",
  "createdAt": "2022-04-13T11:38:23Z",
  "updatedAt": "2022-04-28T11:19:15Z",
  "closedAt": "2022-04-28T11:19:15Z",
  "mergedAt": "2022-04-28T11:19:15Z",
  "additions": 1031,
  "deletions": 8,
  "changedFiles": 12,
  "headRefName": "msbuild-client",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3198270d5024aa62f50b6db68fb672a9786ddc85",
          "message": "Msbuild client: v1.",
          "committedDate": "2022-04-28T08:46:28Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "90b3e6fedd7d124c9bd16232d2656c02b59373cb",
          "message": "Addressing PR comments.\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2022-04-28T08:46:28Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3885cfdab44a4a6a6e467a61a2b439e0b77b107b",
          "message": "Renaming to ct to cancellationToken",
          "committedDate": "2022-04-28T08:46:28Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a16dc6968302795750289d68f7ad57f06a83114",
          "message": "Minor stylystics changes",
          "committedDate": "2022-04-28T08:46:29Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "91ba47324eebbca25d436ef5ce708518e272b059",
          "message": "Fix merge problems.",
          "committedDate": "2022-04-28T09:00:24Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d1b9eb9750a25e3076b5fe95bdad081a13192924",
          "message": "fix API",
          "committedDate": "2022-04-28T09:10:42Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: You can combine this `if` statement with the previous one (`!serverWasAlreadyRunning && !LaunchMSBuildServer()`). C# implements short-circuit evaluation, so the `LaunchMSBuildServer` will not be invoked when the left part is evaluated as `false`.",
              "createdAt": "2022-04-14T07:39:03Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: There is a convention that methods returning `bool` and not throwing exceptions are named with `Try` prefix.",
              "createdAt": "2022-04-14T07:44:25Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())\n+                {\n+                    // Failed to launch MSBuild server.\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!ConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            InitializeAsyncPacketThread();\n+\n+            var waitHandles = new WaitHandle[] {_packetPumpShutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        CommunicationsUtilities.Trace($\"MSBuild client error: packet pump unexpectedly shutted down.\");\n+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                        return _exitResult;\n+\n+                    case 1:\n+                        while (_receivedPacketsQueue.TryDequeue(out INodePacket? packet) && (!_buildFinished))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured. {ex.Message}\");\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    return _exitResult;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool LaunchMSBuildServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            }.ToArray();\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            // TODO: think of params? lowprio?\n+\n+            return new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                _msBuildLocation\n+            );\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    HandleServerNodeConsoleWrite((ServerNodeConsoleWrite)packet);\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace($\"Build response received: exit code {response.ExitCode}, exit type '{response.ExitType}'\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;\n+            _buildFinished = true;\n+\n+            // Terminate packet pump thread.\n+            _terminatePacketPumpEvent.Set();\n+        }\n+\n+#region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+#endregion\n+\n+#region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPacketsQueue.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+#endregion\n+\n+\n+#region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread and the supporting events as well as the packet queue.\n+        /// </summary>\n+        private void InitializeAsyncPacketThread()\n+        {\n+            _packetPump = new Thread(PacketPumpProc);\n+            _packetPump.IsBackground = true;\n+            _packetPump.Name = \"MSbuild Client Packet Pump\";\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPump.Start();\n+        }\n+\n+\n+        /// <summary>\n+        /// This method handles the asynchronous message pump.  It waits for messages to show up on the queue\n+        /// and calls FireDataAvailable for each such packet.  It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        private void PacketPumpProc()\n+        {\n+            ManualResetEvent localTerminatePacketPump = _terminatePacketPumpEvent;\n+            RunReadLoop(_nodeStream, localTerminatePacketPump);\n+        }\n+\n+        private void RunReadLoop(Stream localPipe, ManualResetEvent localTerminatePacketPump)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+            IAsyncResult result = localPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+            Task<int> readTask = CommunicationsUtilities.ReadAsync(localPipe, headerByte, headerByte.Length);\n+#endif\n+\n+            bool continueReading = true;\n+            do\n+            {\n+                // Ordering is important. \n+                WaitHandle[] handles = new WaitHandle[] {\n+#if FEATURE_APM\n+                            result.AsyncWaitHandle,\n+#else\n+                            ((IAsyncResult)readTask).AsyncWaitHandle,\n+#endif\n+                            localTerminatePacketPump };\n+\n+                int waitId = WaitHandle.WaitAny(handles);\n+                switch (waitId)\n+                {\n+                    case 0:\n+                        {\n+                            // Client recieved a packet header. Read the rest of a package.\n+                            int bytesRead = 0;\n+                            try\n+                            {\n+#if FEATURE_APM\n+                                bytesRead = localPipe.EndRead(result);\n+#else\n+                                bytesRead = readTask.Result;\n+#endif\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Lost communications.  Abort (but allow node reuse)\n+                                CommunicationsUtilities.Trace(\"Exception reading from server.  {0}\", e);\n+                                ExceptionHandling.DumpExceptionToFile(e);\n+\n+                                _packetPumpShutdownEvent.Set();\n+                                continueReading = false;\n+                                break;\n+                            }\n+\n+                            if (bytesRead != headerByte.Length)\n+                            {\n+                                // Incomplete read.  Abort.\n+                                if (bytesRead == 0)\n+                                {\n+                                    CommunicationsUtilities.Trace(\"Server disconnected abruptly\");\n+                                }\n+                                else\n+                                {\n+                                    CommunicationsUtilities.Trace(\"Incomplete header read from server.  {0} of {1} bytes read\", bytesRead, headerByte.Length);\n+                                }\n+\n+                                _packetPumpShutdownEvent.Set();\n+                                continueReading = false;\n+                                break;\n+                            }\n+\n+                            NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), headerByte[0]);\n+\n+                            try\n+                            {\n+                                _packetFactory.DeserializeAndRoutePacket(0, packetType, BinaryTranslator.GetReadTranslator(localPipe, _sharedReadBuffer));\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Error while deserializing or handling packet.  Abort.\n+                                CommunicationsUtilities.Trace(\"Packet factory failed to recieve package. Exception while deserializing packet {0}: {1}\", packetType, e);\n+                                ExceptionHandling.DumpExceptionToFile(e);\n+\n+                                _packetPumpShutdownEvent.Set();\n+                                continueReading = false;\n+                                break;\n+                            }\n+\n+                            // Start reading the next package header.\n+#if FEATURE_APM\n+                            result = localPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                            readTask = CommunicationsUtilities.ReadAsync(localPipe, headerByte, headerByte.Length);\n+#endif\n+                        }\n+\n+                        break;\n+\n+                    case 1:\n+                        // Fulfill the request for termination of the message pump.\n+                        CommunicationsUtilities.Trace(\"Terminate message pump thread.\");\n+                        continueReading = false;\n+                        break;\n+\n+                    default:\n+                        // Ignore unknown package.\n+                        ErrorUtilities.ThrowInternalError(\"waitId {0} out of range.\", waitId);\n+                        // TODO: cover this case with ETW.\n+                        break;\n+                }\n+            }\n+            while (continueReading);\n+\n+            CommunicationsUtilities.Trace(\"Ending read loop\");\n+        }\n+#endregion\n+\n+\n+        /// <summary>\n+        /// Connects to MSBuild server.\n+        /// </summary>\n+        /// <returns> Whether the client connected to MSBuild server successfully.</returns>\n+        private bool ConnectToServer(int timeout)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it necessary to invoke `ToArray` here? The result of `new[]` should already represent an array of strings.",
              "createdAt": "2022-04-14T07:57:58Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())\n+                {\n+                    // Failed to launch MSBuild server.\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!ConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            InitializeAsyncPacketThread();\n+\n+            var waitHandles = new WaitHandle[] {_packetPumpShutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        CommunicationsUtilities.Trace($\"MSBuild client error: packet pump unexpectedly shutted down.\");\n+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                        return _exitResult;\n+\n+                    case 1:\n+                        while (_receivedPacketsQueue.TryDequeue(out INodePacket? packet) && (!_buildFinished))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured. {ex.Message}\");\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    return _exitResult;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool LaunchMSBuildServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            }.ToArray();",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Not necessary, sure. Just some past code artifact.",
              "createdAt": "2022-04-14T14:24:57Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())\n+                {\n+                    // Failed to launch MSBuild server.\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!ConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            InitializeAsyncPacketThread();\n+\n+            var waitHandles = new WaitHandle[] {_packetPumpShutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        CommunicationsUtilities.Trace($\"MSBuild client error: packet pump unexpectedly shutted down.\");\n+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                        return _exitResult;\n+\n+                    case 1:\n+                        while (_receivedPacketsQueue.TryDequeue(out INodePacket? packet) && (!_buildFinished))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured. {ex.Message}\");\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    return _exitResult;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool LaunchMSBuildServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            }.ToArray();",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we need it. But @rokonec can provide more precise answer :)",
              "createdAt": "2022-04-14T11:10:08Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())\n+                {\n+                    // Failed to launch MSBuild server.\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!ConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            InitializeAsyncPacketThread();\n+\n+            var waitHandles = new WaitHandle[] {_packetPumpShutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        CommunicationsUtilities.Trace($\"MSBuild client error: packet pump unexpectedly shutted down.\");\n+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                        return _exitResult;\n+\n+                    case 1:\n+                        while (_receivedPacketsQueue.TryDequeue(out INodePacket? packet) && (!_buildFinished))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured. {ex.Message}\");\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    return _exitResult;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool LaunchMSBuildServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            }.ToArray();\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "MSBuild server should be started with same env variables as it would if was started as process from CLI.",
              "createdAt": "2022-04-20T12:31:37Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())\n+                {\n+                    // Failed to launch MSBuild server.\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!ConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            InitializeAsyncPacketThread();\n+\n+            var waitHandles = new WaitHandle[] {_packetPumpShutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        CommunicationsUtilities.Trace($\"MSBuild client error: packet pump unexpectedly shutted down.\");\n+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                        return _exitResult;\n+\n+                    case 1:\n+                        while (_receivedPacketsQueue.TryDequeue(out INodePacket? packet) && (!_buildFinished))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured. {ex.Message}\");\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    return _exitResult;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool LaunchMSBuildServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            }.ToArray();\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Do we need explicit interface implementation? I think the standard interface implementation is enough.",
              "createdAt": "2022-04-14T11:15:37Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block\n+            _receivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _terminatePacketPumpEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, this);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning)\n+            {\n+                if (!LaunchMSBuildServer())\n+                {\n+                    // Failed to launch MSBuild server.\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!ConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            InitializeAsyncPacketThread();\n+\n+            var waitHandles = new WaitHandle[] {_packetPumpShutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        CommunicationsUtilities.Trace($\"MSBuild client error: packet pump unexpectedly shutted down.\");\n+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                        return _exitResult;\n+\n+                    case 1:\n+                        while (_receivedPacketsQueue.TryDequeue(out INodePacket? packet) && (!_buildFinished))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured. {ex.Message}\");\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    return _exitResult;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool LaunchMSBuildServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            }.ToArray();\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            // TODO: think of params? lowprio?\n+\n+            return new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                _msBuildLocation\n+            );\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    HandleServerNodeConsoleWrite((ServerNodeConsoleWrite)packet);\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace($\"Build response received: exit code {response.ExitCode}, exit type '{response.ExitType}'\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;\n+            _buildFinished = true;\n+\n+            // Terminate packet pump thread.\n+            _terminatePacketPumpEvent.Set();\n+        }\n+\n+#region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Consider to make this type `sealed`.",
              "createdAt": "2022-04-14T11:17:39Z",
              "path": "src/Build/BackEnd/Node/MSBuildClientExitResult.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeffnamespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// Enumeration of the various ways in which the MSBuildClient execution can exit.\n+    /// </summary>\n+    public class MSBuildClientExitResult",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Also mark as experimental API",
              "createdAt": "2022-04-14T12:05:01Z",
              "path": "src/Build/BackEnd/Node/MSBuildClientExitResult.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeffnamespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// Enumeration of the various ways in which the MSBuildClient execution can exit.\n+    /// </summary>\n+    public class MSBuildClientExitResult",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "We will make this experimental in the next PR.",
              "createdAt": "2022-04-21T16:31:08Z",
              "path": "src/Build/BackEnd/Node/MSBuildClientExitResult.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeffnamespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// Enumeration of the various ways in which the MSBuildClient execution can exit.\n+    /// </summary>\n+    public class MSBuildClientExitResult",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NOT: word block is confusing (prohibit vs block-of-code). I recommend something like: Initialize packet pump",
              "createdAt": "2022-04-14T11:41:10Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,661 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+        #endregion\n+\n+        #region Message pump\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// Shared read buffer.\n+        /// </summary>\n+        private SharedReadBuffer _sharedReadBuffer;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPacketsQueue;\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"_receivedPacketsQueue\"/>.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// Set when the asynchronous packet pump should terminate.\n+        /// </summary>\n+        private ManualResetEvent _terminatePacketPumpEvent;\n+\n+        /// <summary>\n+        /// Set when we packet pump enexpectedly shutdown (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPump;\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+\n+            // Packet pump block",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we share creation of these mutexes names with server?",
              "createdAt": "2022-04-20T12:05:48Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I requested this change from the server side.",
              "createdAt": "2022-04-20T16:15:04Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Redundant comment",
              "createdAt": "2022-04-20T12:08:18Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "outdated comment",
              "createdAt": "2022-04-20T12:08:39Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: In our codebase we seems to prefer not to use backet in `(!predicate)` but using `!predicate` instead.\r\nPlease consider to change.",
              "createdAt": "2022-04-20T12:21:48Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I believe it would be better if server handles it. It is server responsibility to honor intent of `ServerNodeBuildCommand`",
              "createdAt": "2022-04-20T12:34:16Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.\n+            packetPump.Stop();\n+            Console.CancelKeyPress -= cancelHandler;\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Handler for when CTRL-C or CTRL-BREAK is called.\n+        /// </summary>\n+        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n+        {\n+            Console.WriteLine(\"Cancelling...\");\n+\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            _cts.Cancel();\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. ",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This env variable controls if we call the regular build execution or the client. It is processed in xmake and client. If we do not remove it and call any other process with propagation of this variable (node spawning processes, for example), they might run the client instead of doing what is needed. \r\nI want to keep processing of this variable close there and prevent such situations with certainty. We do not want to this variable propagate any further than current process. \r\nAlso, I am thinking on options in somehow other way switch between client and regular build.",
              "createdAt": "2022-04-20T16:34:14Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.\n+            packetPump.Stop();\n+            Console.CancelKeyPress -= cancelHandler;\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Handler for when CTRL-C or CTRL-BREAK is called.\n+        /// </summary>\n+        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n+        {\n+            Console.WriteLine(\"Cancelling...\");\n+\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            _cts.Cancel();\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. ",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't this message duplicated with what was received from server in `ServerNodeConsoleWrite` as reaction to standard MSBuild cancelation flow.",
              "createdAt": "2022-04-20T12:36:39Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.\n+            packetPump.Stop();\n+            Console.CancelKeyPress -= cancelHandler;\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Handler for when CTRL-C or CTRL-BREAK is called.\n+        /// </summary>\n+        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n+        {\n+            Console.WriteLine(\"Cancelling...\");\n+\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            _cts.Cancel();\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                _msBuildLocation\n+            );\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            Console.WriteLine(\"MSBuild client cancelled.\");",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Well, that depends. If the cancellation is gentle we might show all the messages received from server since then, then it would be a duplicate. If the cancellation is hard, we might not want wait for server to finish. Now only the hard one is implemented, because cancellation is not implemented on the server side.",
              "createdAt": "2022-04-20T16:41:14Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.\n+            packetPump.Stop();\n+            Console.CancelKeyPress -= cancelHandler;\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Handler for when CTRL-C or CTRL-BREAK is called.\n+        /// </summary>\n+        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n+        {\n+            Console.WriteLine(\"Cancelling...\");\n+\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            _cts.Cancel();\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                _msBuildLocation\n+            );\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            Console.WriteLine(\"MSBuild client cancelled.\");",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please consider to use standard `ErrorUtilities.VerifyThrow` instead",
              "createdAt": "2022-04-20T12:38:56Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.\n+            packetPump.Stop();\n+            Console.CancelKeyPress -= cancelHandler;\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Handler for when CTRL-C or CTRL-BREAK is called.\n+        /// </summary>\n+        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n+        {\n+            Console.WriteLine(\"Cancelling...\");\n+\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            _cts.Cancel();\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                _msBuildLocation\n+            );\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shutted down: {0}\", packetPump.PacketPumpException);\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    HandleServerNodeConsoleWrite((ServerNodeConsoleWrite)packet);\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is our take on regions. My opiniated point of view is more on the 'hate' side.",
              "createdAt": "2022-04-20T12:52:45Z",
              "path": "src/Build/BackEnd/Node/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,306 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Node\n+{\n+    internal class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        internal ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        internal AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        internal ManualResetEvent PacketPumpShutdownEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump enexpectedly terminates (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        internal ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump enexpectedly terminates.\n+        /// </summary>\n+        internal Exception? PacketPumpException { get; set; }\n+\n+        #region Private data",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I find them quite handy actually. Maybe Private data is not that needed, but when you implement multiple interfaces it groups the code well.",
              "createdAt": "2022-04-20T14:50:15Z",
              "path": "src/Build/BackEnd/Node/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,306 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Node\n+{\n+    internal class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        internal ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        internal AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        internal ManualResetEvent PacketPumpShutdownEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump enexpectedly terminates (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        internal ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump enexpectedly terminates.\n+        /// </summary>\n+        internal Exception? PacketPumpException { get; set; }\n+\n+        #region Private data",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: MSbuild => MSBuild",
              "createdAt": "2022-04-20T12:58:46Z",
              "path": "src/Build/BackEnd/Node/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,306 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Node\n+{\n+    internal class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        internal ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        internal AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        internal ManualResetEvent PacketPumpShutdownEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump enexpectedly terminates (due to connection problems or becuase of desearilization issues).\n+        /// </summary>\n+        internal ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump enexpectedly terminates.\n+        /// </summary>\n+        internal Exception? PacketPumpException { get; set; }\n+\n+        #region Private data\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        ITranslator _binaryReadTranslator;\n+\n+        /// <summary>\n+        /// Shared read buffer for binary reader.\n+        /// </summary>\n+        SharedReadBuffer _sharedReadBuffer;\n+        #endregion\n+\n+        internal MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpShutdownEvent = new ManualResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, _sharedReadBuffer);\n+       }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        internal void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc);\n+            _packetPumpThread.IsBackground = true;\n+            _packetPumpThread.Name = \"MSbuild Client Packet Pump\";",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please add `_packetMemoryStream.Position = 0;` line before `SetLength`",
              "createdAt": "2022-04-20T13:05:31Z",
              "path": "src/Build/BackEnd/Node/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,477 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.Execution.OutOfProcServerNode;\n+\n+namespace Microsoft.Build.Experimental.Client\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It processes\n+    /// command-line arguments and invokes the build engine.\n+    /// </summary>\n+    /// // TODO: Add argument/attribute saying that it is an experimental API\n+    public class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+#region Private fields\n+        /// <summary>\n+        /// Location of msbuild dll or exe.\n+        /// </summary>\n+        private string _msBuildLocation;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Cancel when handling Ctrl-C\n+        /// </summary>\n+        private readonly CancellationTokenSource _cts = new CancellationTokenSource();\n+        #endregion\n+\n+        // TODO: work on eleminating extra parameters or making them more clearly described at least.\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"msbuildLocation\">Location of msbuild dll or exe.</param>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string msbuildLocation, string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _msBuildLocation = msbuildLocation;\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine)\n+        {\n+            string serverRunningMutexName = $@\"Global\\server-running-{_pipeName}\";\n+            string serverBusyMutexName = $@\"Global\\server-busy-{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+\n+            // Build in client.\n+\n+            // Add cancellation handler function.\n+            ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;\n+            Console.CancelKeyPress += cancelHandler;\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            SendBuildCommand(commandLine, _nodeStream);\n+\n+            MSBuildClientPacketPump packetPump = new MSBuildClientPacketPump(_nodeStream);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+            (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+            packetPump.Start();\n+\n+            var waitHandles = new WaitHandle[] {\n+                _cts.Token.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (!_buildFinished)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        HandleCancellation();\n+                        break;\n+\n+                    case 1:\n+                        HandlePacketPumpError(packetPump);\n+                        break;\n+\n+                    case 2:\n+                        while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                            && (!_buildFinished)\n+                            && (!_cts.Token.IsCancellationRequested))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                try\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                                catch (Exception ex)\n+                                {\n+                                    CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+                                    _buildFinished = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // Stop packet pump.\n+            packetPump.Stop();\n+            Console.CancelKeyPress -= cancelHandler;\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        /// <summary>\n+        /// Handler for when CTRL-C or CTRL-BREAK is called.\n+        /// </summary>\n+        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n+        {\n+            Console.WriteLine(\"Cancelling...\");\n+\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            _cts.Cancel();\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            // TODO: do we really need to start msbuild server with these variables, performance-wise and theoretically thinking?\n+            // We are sending them in build command as well.\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");\n+        }\n+\n+\n+        private void SendBuildCommand(string commandLine, NamedPipeClientStream nodeStream)\n+        {\n+            ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+            WritePacket(_nodeStream, buildCommand);\n+            CommunicationsUtilities.Trace(\"Build command send...\");\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+\n+            Dictionary<string, string> envVars = new Dictionary<string, string>();\n+\n+            IDictionary environmentVariables = Environment.GetEnvironmentVariables();\n+            foreach (var key in environmentVariables.Keys)\n+            {\n+                envVars[(string)key] = (string) (environmentVariables[key] ?? \"\");\n+            }\n+\n+            foreach (var pair in ServerEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env MSBUILDRUNSERVERCLIENT that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[\"MSBUILDRUNSERVERCLIENT\"] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                _msBuildLocation\n+            );\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shutted down: {0}\", packetPump.PacketPumpException);\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    HandleServerNodeConsoleWrite((ServerNodeConsoleWrite)packet);\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace($\"Build response received: exit code {response.ExitCode}, exit type '{response.ExitType}'\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;\n+            _buildFinished = true;\n+        }\n+\n+\n+        /// <summary>\n+        /// Connects to MSBuild server.\n+        /// </summary>\n+        /// <returns> Whether the client connected to MSBuild server successfully.</returns>\n+        private bool TryConnectToServer(int timeout)\n+        {\n+            try\n+            {\n+                _nodeStream.Connect(timeout);\n+\n+                int[] handshakeComponents = _handshake.RetrieveHandshakeComponents();\n+                for (int i = 0; i < handshakeComponents.Length; i++)\n+                {\n+                    CommunicationsUtilities.Trace(\"Writing handshake part {0} ({1}) to pipe {2}\", i, handshakeComponents[i], _pipeName);\n+                    _nodeStream.WriteIntForHandshake(handshakeComponents[i]);\n+                }\n+\n+                // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.\n+                _nodeStream.WriteIntForHandshake(ServerNodeHandshake.EndOfHandshakeSignal);\n+\n+                CommunicationsUtilities.Trace(\"Reading handshake from pipe {0}\", _pipeName);\n+\n+#if NETCOREAPP2_1_OR_GREATER || MONO\n+                _nodeStream.ReadEndOfHandshakeSignal(false, 1000); \n+#else\n+                _nodeStream.ReadEndOfHandshakeSignal(false);\n+#endif\n+\n+                CommunicationsUtilities.Trace(\"Successfully connected to pipe {0}...!\", _pipeName);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to conect to server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private void WritePacket(Stream nodeStream, INodePacket packet)\n+        {\n+            MemoryStream memoryStream = _packetMemoryStream;\n+            memoryStream.SetLength(0);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need another env var when we have `MSBUILDRUNSERVERCLIENT`?",
              "createdAt": "2022-04-20T13:34:10Z",
              "path": "src/MSBuild/MSBuildClientApp.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Experimental.Client;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+using System.IO;\n+using System.Diagnostics;\n+#endif\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It\n+    /// 1. starts the MSBuild server in a separate process if it does not yet exist.\n+    /// 2. establishes a connection with MSBuild server and sends a build request.\n+    /// 3. if server is busy, it falls back to old build behavior.\n+    /// </summary>\n+    public static class MSBuildClientApp\n+    {\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <remark>\n+        /// The locations of msbuild exe/dll and dotnet.exe are automatically detected.\n+        /// </remark>\n+        /// <returns>0 on success, 1 on failure</returns>\n+        public static int Run(\n+#if !FEATURE_GET_COMMANDLINE\n+            string[] args\n+#endif\n+            )\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            string dllLocation = string.Empty;\n+            string exeLocation = string.Empty;\n+\n+            // TODO: check the detection.\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Run the child process with the same host as the currently-running process.\n+            // Mono automagically uses the current mono, to execute a managed assembly.\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // _exeFileLocation consists the msbuild dll instead.\n+                dllLocation = msBuildLocation;\n+                exeLocation = GetCurrentHost();\n+            }\n+            else\n+            {\n+                // _exeFileLocation consists the msbuild dll instead.\n+                exeLocation = msBuildLocation;\n+            }\n+#else\n+            exeLocation = msBuildLocation;\n+#endif\n+\n+            int exitCode = (Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                Environment.CommandLine,\n+#else\n+                ConstructArrayArg(args),\n+#endif\n+                msBuildLocation,\n+                exeLocation,\n+                dllLocation\n+            ) == MSBuildApp.ExitType.Success) ? 0 : 1;\n+            return exitCode;\n+        }\n+\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <returns>0 on success, 1 on failure</returns>\n+        public static int Run(\n+#if !FEATURE_GET_COMMANDLINE\n+            string[] args,\n+#endif\n+            string msbuildLocation,\n+            string exeLocation,\n+            string dllLocation\n+            )\n+        {\n+            int exitCode = (Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                Environment.CommandLine,\n+#else\n+                ConstructArrayArg(args),\n+#endif\n+                msbuildLocation,\n+                exeLocation,\n+                dllLocation\n+            ) == MSBuildApp.ExitType.Success) ? 0 : 1;\n+            return exitCode;\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the msbuild client, and is also responsible\n+        /// for escape hatches and fallbacks.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type MSBuildApp.ExitType that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public static MSBuildApp.ExitType Execute(\n+#if FEATURE_GET_COMMANDLINE\n+            string commandLine,\n+#else\n+            string[] commandLine,\n+#endif\n+            string msbuildLocation,\n+            string exeLocation,\n+            string dllLocation\n+            )\n+        {\n+            // Escape hatch to an old behavior.\n+            bool runMsbuildInServer = Environment.GetEnvironmentVariable(\"RUN_MSBUILD_IN_SERVER\") == \"1\";",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this a Debug session leftover?",
              "createdAt": "2022-04-20T13:35:31Z",
              "path": "src/MSBuild/MSBuildClientApp.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Experimental.Client;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+using System.IO;\n+using System.Diagnostics;\n+#endif\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It\n+    /// 1. starts the MSBuild server in a separate process if it does not yet exist.\n+    /// 2. establishes a connection with MSBuild server and sends a build request.\n+    /// 3. if server is busy, it falls back to old build behavior.\n+    /// </summary>\n+    public static class MSBuildClientApp\n+    {\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <remark>\n+        /// The locations of msbuild exe/dll and dotnet.exe are automatically detected.\n+        /// </remark>\n+        /// <returns>0 on success, 1 on failure</returns>\n+        public static int Run(\n+#if !FEATURE_GET_COMMANDLINE\n+            string[] args\n+#endif\n+            )\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            string dllLocation = string.Empty;\n+            string exeLocation = string.Empty;\n+\n+            // TODO: check the detection.\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Run the child process with the same host as the currently-running process.\n+            // Mono automagically uses the current mono, to execute a managed assembly.\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // _exeFileLocation consists the msbuild dll instead.\n+                dllLocation = msBuildLocation;\n+                exeLocation = GetCurrentHost();\n+            }\n+            else\n+            {\n+                // _exeFileLocation consists the msbuild dll instead.\n+                exeLocation = msBuildLocation;\n+            }\n+#else\n+            exeLocation = msBuildLocation;\n+#endif\n+\n+            int exitCode = (Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                Environment.CommandLine,\n+#else\n+                ConstructArrayArg(args),\n+#endif\n+                msBuildLocation,\n+                exeLocation,\n+                dllLocation\n+            ) == MSBuildApp.ExitType.Success) ? 0 : 1;\n+            return exitCode;\n+        }\n+\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <returns>0 on success, 1 on failure</returns>\n+        public static int Run(\n+#if !FEATURE_GET_COMMANDLINE\n+            string[] args,\n+#endif\n+            string msbuildLocation,\n+            string exeLocation,\n+            string dllLocation\n+            )\n+        {\n+            int exitCode = (Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                Environment.CommandLine,\n+#else\n+                ConstructArrayArg(args),\n+#endif\n+                msbuildLocation,\n+                exeLocation,\n+                dllLocation\n+            ) == MSBuildApp.ExitType.Success) ? 0 : 1;\n+            return exitCode;\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the msbuild client, and is also responsible\n+        /// for escape hatches and fallbacks.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type MSBuildApp.ExitType that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public static MSBuildApp.ExitType Execute(\n+#if FEATURE_GET_COMMANDLINE\n+            string commandLine,\n+#else\n+            string[] commandLine,\n+#endif\n+            string msbuildLocation,\n+            string exeLocation,\n+            string dllLocation\n+            )\n+        {\n+            // Escape hatch to an old behavior.\n+            bool runMsbuildInServer = Environment.GetEnvironmentVariable(\"RUN_MSBUILD_IN_SERVER\") == \"1\";\n+            if (!runMsbuildInServer)\n+            {\n+                return MSBuildApp.Execute(commandLine);\n+            }\n+\n+            // MSBuild client orchestration.\n+#if !FEATURE_GET_COMMANDLINE\n+            string commandLineString = string.Join(\" \", commandLine); \n+#else\n+            string commandLineString = commandLine;\n+#endif\n+            MSBuildClient msbuildClient = new MSBuildClient(msbuildLocation, exeLocation, dllLocation); \n+            MSBuildClientExitResult exitResult = msbuildClient.Execute(commandLineString);\n+\n+            if (exitResult.MSBuildClientExitType == MSBuildClientExitType.ServerBusy\n+                || exitResult.MSBuildClientExitType == MSBuildClientExitType.ConnectionError\n+            )\n+            {\n+                // TODO: debug, remove it.",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "yeah, already removed.",
              "createdAt": "2022-04-20T16:16:29Z",
              "path": "src/MSBuild/MSBuildClientApp.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Experimental.Client;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+using System.IO;\n+using System.Diagnostics;\n+#endif\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It\n+    /// 1. starts the MSBuild server in a separate process if it does not yet exist.\n+    /// 2. establishes a connection with MSBuild server and sends a build request.\n+    /// 3. if server is busy, it falls back to old build behavior.\n+    /// </summary>\n+    public static class MSBuildClientApp\n+    {\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <remark>\n+        /// The locations of msbuild exe/dll and dotnet.exe are automatically detected.\n+        /// </remark>\n+        /// <returns>0 on success, 1 on failure</returns>\n+        public static int Run(\n+#if !FEATURE_GET_COMMANDLINE\n+            string[] args\n+#endif\n+            )\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            string dllLocation = string.Empty;\n+            string exeLocation = string.Empty;\n+\n+            // TODO: check the detection.\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Run the child process with the same host as the currently-running process.\n+            // Mono automagically uses the current mono, to execute a managed assembly.\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // _exeFileLocation consists the msbuild dll instead.\n+                dllLocation = msBuildLocation;\n+                exeLocation = GetCurrentHost();\n+            }\n+            else\n+            {\n+                // _exeFileLocation consists the msbuild dll instead.\n+                exeLocation = msBuildLocation;\n+            }\n+#else\n+            exeLocation = msBuildLocation;\n+#endif\n+\n+            int exitCode = (Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                Environment.CommandLine,\n+#else\n+                ConstructArrayArg(args),\n+#endif\n+                msBuildLocation,\n+                exeLocation,\n+                dllLocation\n+            ) == MSBuildApp.ExitType.Success) ? 0 : 1;\n+            return exitCode;\n+        }\n+\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <returns>0 on success, 1 on failure</returns>\n+        public static int Run(\n+#if !FEATURE_GET_COMMANDLINE\n+            string[] args,\n+#endif\n+            string msbuildLocation,\n+            string exeLocation,\n+            string dllLocation\n+            )\n+        {\n+            int exitCode = (Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                Environment.CommandLine,\n+#else\n+                ConstructArrayArg(args),\n+#endif\n+                msbuildLocation,\n+                exeLocation,\n+                dllLocation\n+            ) == MSBuildApp.ExitType.Success) ? 0 : 1;\n+            return exitCode;\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the msbuild client, and is also responsible\n+        /// for escape hatches and fallbacks.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <returns>A value of type MSBuildApp.ExitType that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public static MSBuildApp.ExitType Execute(\n+#if FEATURE_GET_COMMANDLINE\n+            string commandLine,\n+#else\n+            string[] commandLine,\n+#endif\n+            string msbuildLocation,\n+            string exeLocation,\n+            string dllLocation\n+            )\n+        {\n+            // Escape hatch to an old behavior.\n+            bool runMsbuildInServer = Environment.GetEnvironmentVariable(\"RUN_MSBUILD_IN_SERVER\") == \"1\";\n+            if (!runMsbuildInServer)\n+            {\n+                return MSBuildApp.Execute(commandLine);\n+            }\n+\n+            // MSBuild client orchestration.\n+#if !FEATURE_GET_COMMANDLINE\n+            string commandLineString = string.Join(\" \", commandLine); \n+#else\n+            string commandLineString = commandLine;\n+#endif\n+            MSBuildClient msbuildClient = new MSBuildClient(msbuildLocation, exeLocation, dllLocation); \n+            MSBuildClientExitResult exitResult = msbuildClient.Execute(commandLineString);\n+\n+            if (exitResult.MSBuildClientExitType == MSBuildClientExitType.ServerBusy\n+                || exitResult.MSBuildClientExitType == MSBuildClientExitType.ConnectionError\n+            )\n+            {\n+                // TODO: debug, remove it.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "USEMSBUILDSERVER->MSBUILDUSESERVER",
              "createdAt": "2022-04-21T13:54:01Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -216,14 +221,30 @@ string[] args\n                 DumpCounters(true /* initialize only */);\n             }\n \n-            // return 0 on success, non-zero on failure\n-            int exitCode = ((s_initialized && Execute(\n+            int exitCode;\n+            if (Environment.GetEnvironmentVariable(\"USEMSBUILDSERVER\") == \"1\")",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch\");\r\n```",
              "createdAt": "2022-04-25T14:19:39Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,459 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"ct\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken ct)\n+        {\n+            string serverRunningMutexName = $@\"{ServerNamedMutex.RunningServerMutexNamePrefix}{_pipeName}\";\n+            string serverBusyMutexName = $@\"{ServerNamedMutex.BusyServerMutexNamePrefix}{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            if (!TrySendBuildCommand(commandLine, _nodeStream))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            MSBuildClientPacketPump? packetPump = null;\n+\n+            try\n+            {\n+\n+                // Start packet pump\n+                packetPump = new MSBuildClientPacketPump(_nodeStream);\n+                (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                var waitHandles = new WaitHandle[] {\n+                ct.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                                && !_buildFinished\n+                                && !ct.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+            finally\n+            {\n+                packetPump?.Stop();\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env USEMSBUILDSERVER that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"USEMSBUILDSERVER\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nice typo :)",
              "createdAt": "2022-04-26T08:20:23Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,459 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Node;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient \n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client prosess.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        public Dictionary<string, string> ServerEnvironmentVariables { get; set; }\n+\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private BinaryWriter _binaryWriter;\n+\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            ServerEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + _handshake.ComputeHash());\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"ct\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken ct)\n+        {\n+            string serverRunningMutexName = $@\"{ServerNamedMutex.RunningServerMutexNamePrefix}{_pipeName}\";\n+            string serverBusyMutexName = $@\"{ServerNamedMutex.BusyServerMutexNamePrefix}{_pipeName}\";\n+\n+            // Start server it if is not running.\n+            bool serverWasAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverWasAlreadyRunning && !TryLaunchServer())\n+            {\n+                return _exitResult;\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverWasAlreadyRunning && !serverWasBusy ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicklier deal with possible issues with connection to server.\n+            if (!TrySendBuildCommand(commandLine, _nodeStream))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            MSBuildClientPacketPump? packetPump = null;\n+\n+            try\n+            {\n+\n+                // Start packet pump\n+                packetPump = new MSBuildClientPacketPump(_nodeStream);\n+                (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                (packetPump as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                var waitHandles = new WaitHandle[] {\n+                ct.WaitHandle,\n+                packetPump.PacketPumpErrorEvent,\n+                packetPump.PacketReceivedEvent };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet)\n+                                && !_buildFinished\n+                                && !ct.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"MSBuild client error: problem during packet handling occured: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+            finally\n+            {\n+                packetPump?.Stop();\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_pipeName}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  ServerEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched.\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace($\"Failed to launch the msbuild server: {ex.Message}\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        { \n+            ProcessStartInfo processStartInfo = new ProcessStartInfo\n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env USEMSBUILDSERVER that might be equal to 1, so we do not get an infinite recursion here. \n+            processStartInfo.Environment[\"USEMSBUILDSERVER\"] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to lunch\");",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      }
    ]
  }
}