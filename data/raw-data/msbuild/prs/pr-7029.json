{
  "number": 7029,
  "title": "Throw exception or log warning upon drive enumeration glob anomaly detection",
  "body": "### Context\r\nGlob anomalies drive enumeration issue: https://github.com/dotnet/msbuild/issues/3642#issue-352653387. Properties that evaluate to empty result in drive enumeration.\r\n\r\n### Changes Made\r\nLogs an error via `ProjectFileErrorUtilities.ThrowInvalidProject(...)` with the resource name WildcardResultsInDriveEnumeration when `\\**`, `<drive>:\\**`, or `<drive>:<any number of slashes>**` are detected on the leftmost side while parsing and the environment variable `MSBUILDFAILONDRIVEENUMERATINGWILDCARD` is set to 1 (with the exception of one case listed in \"Notes\" below which simply logs an error). Note that a warning is logged (rather than an error) with the same resource name when the environment variable is set to 0.\r\n\r\nRegarding more recent changes, logging a warning/throwing an `InvalidProjectFileException` has become more unified and placed in EngineFileUtilities.cs. Logging a warning/throwing an exception with the resource name requires extra information, including a `SearchAction` and `ExcludeFileSpec`, which are returned from FileMatcher into various codepaths (CreateItem & EngineFileUtilities), which obtain additional parameters from other codepaths, such as Evaluator, Expander, ItemGroupIntrinsicTask, LazyItemEvaluator.IncludeOperation, etc., to better identify the logging mechanism and attributes that should be passed to EngineFileUtilities.cs upon logging a warning/throwing an exception. There is no custom exception that is caught and then converted into an `InvalidProjectFileException` (all of the functionality that came with a custom exception has been removed with a prior commit for these changes). When the env var is set to 1, a nearly immediate return from functions occurs, as we want the build to fail and throw upon detection of a drive enumerating wildcard.\r\n\r\n### Testing\r\nLarger integration tests with empty properties/imports were created to trigger the issue in targets. Smaller tests in FileMatcher_Tests.cs were created to check for particular wildcard patterns that should result in the custom exception being thrown.\r\n\r\nUnit tests were added to: FileMatcher_Tests.cs, ProjectItem_Tests.cs, CreateItem_Tests.cs, and ProjectItemInstance_Tests.cs.\r\n\r\n### Notes\r\n1. Uses `MSB5029` error code (see shared resx).\r\n2. For CreateItem, an error is logged instead of using `ProjectFileErrorUtilities.ThrowInvalidProject(...)`\r\n3. The resource name used was `WildcardResultsInDriveEnumeration` to pass on element locations to `InvalidProjectFileException.` ",
  "state": "MERGED",
  "createdAt": "2021-11-09T21:47:18Z",
  "updatedAt": "2023-01-23T09:06:13Z",
  "closedAt": "2022-03-11T21:58:23Z",
  "mergedAt": "2022-03-11T21:58:23Z",
  "additions": 1527,
  "deletions": 83,
  "changedFiles": 31,
  "headRefName": "dev/mruxmohan/addGlobAnomalyDiagnostics",
  "isDraft": false,
  "author": {
    "login": "mruxmohan4"
  },
  "milestone": {
    "title": "VS 17.2"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "cfd22c0b9a771f1e7dc17260e07c9cee043da8e9",
          "message": "Throw custom exception upon drive enumeration detection",
          "committedDate": "2022-03-02T18:50:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "83fe0dbdaf5247d2063385e96861ec3da723abb1",
          "message": "Log warning upon drive enumeration detection",
          "committedDate": "2022-03-02T18:50:42Z",
          "author": {
            "name": "Meera Ruxmohan",
            "email": "mruxmohan@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "afdbfc18c7e78c4d66af5c197a958b658ee76353",
          "message": "Addressed PR feedback",
          "committedDate": "2022-03-02T21:22:54Z",
          "author": {
            "name": "Meera Ruxmohan",
            "email": "mruxmohan@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "[![CLA assistant check](https://cla.dotnetfoundation.org/pull/badge/signed)](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7029) <br/>All CLA requirements met.",
        "createdAt": "2021-11-09T21:47:32Z",
        "author": {
          "login": "dnfadmin"
        }
      },
      {
        "body": "[![CLA assistant check](https://cla.dotnetfoundation.org/pull/badge/not_signed)](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7029) <br/>Thank you for your submission, we really appreciate it. Like many open source projects, we ask that you sign our [Contributor License Agreement](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7029) before we can accept your contribution.<br/><br/>:x: mruxmohan-msft [sign now](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7029)<br/><sub>You have signed the CLA already but the status is still pending? Let us [recheck](https://cla.dotnetfoundation.org/check/dotnet/msbuild?pullRequest=7029) it.</sub>",
        "createdAt": "2021-11-09T21:47:32Z",
        "author": {
          "login": "dnfadmin"
        }
      },
      {
        "body": "I hadn't really properly looked at what you were trying to do here before, but @ladipro made a similar PR [here](https://github.com/dotnet/msbuild/pull/5669) that prevented drive enumerations when the condition was false specifically. It would probably be easy to glom onto that to achieve what you're trying to do here\u2014but although drive enumerations are probably not intended, this might be a bit much of a breaking change for 17.1. Might be good enough with a change wave? Not sure.",
        "createdAt": "2021-11-11T19:10:30Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind @ladipro Right, that PR did alleviate drive enumerations, according to https://github.com/dotnet/msbuild/issues/3642#issuecomment-821142233, but this was an attempt to improve logging and surface an exception. Is this necessary given the following that was already completed in https://github.com/dotnet/msbuild/pull/5669, or does the existing logging below not surface all the way to the user?\r\n```\r\n                            if (MSBuildEventSource.Log.IsEnabled())\r\n                            {\r\n                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(\", \", excludePatternsForGlobs));\r\n                            }\r\n```",
        "createdAt": "2021-11-11T19:41:00Z",
        "author": {
          "login": "mruxmohan4"
        }
      },
      {
        "body": "Users can get that information, but they have to specifically ask for it and almost always will not. I doubt anyone would find it unless they specifically looked.",
        "createdAt": "2021-11-15T05:13:21Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@mruxmohan-msft I'm afraid that requiring an opt-in via the `MsBuildCheckWildcardDriveEnumeration` environment variable is not going to be very helpful. The user has to be notified even if they don't expect this issue, i.e. they have not explicitly opted in.\r\n\r\nWe should try to come up with a solution which we can enable by default, while causing little-to-no pain to users who enumerate full drives intentionally. Perhaps a build warning would be acceptable as along as it:\r\n- Is surfaced under default logging verbosity in both command line build (`msbuild` and `dotnet build`) and in Visual Studio.\r\n- Can be easily disabled.\r\n",
        "createdAt": "2021-11-15T14:52:18Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "Do you need to create a new type, with all its baggage? It seems its only purpose is to make the test slightly more specific, but adds more bulk. Why not use InvalidProjectFileException with a specific message, as is done in 500 other places?",
        "createdAt": "2021-12-16T00:00:15Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "Whenever I catch the custom exception, I use `ProjectErrorUtilities.ThrowInvalidProject` to throw an `InvalidProjectFileException` in multiple files. The exception is likely not meant to be accessible within FileMatcher.cs unless I'm misunderstanding. @danmoseley ",
        "createdAt": "2021-12-16T02:52:07Z",
        "author": {
          "login": "mruxmohan4"
        }
      },
      {
        "body": "I think by using `ProjectErrorUtilities.ThrowInvalidProject` in the right location, it's able to use `ElementLocation` for surfacing the appropriate line/column. Please let me know of any suggestions to reduce bulk. Thanks!",
        "createdAt": "2021-12-16T02:59:03Z",
        "author": {
          "login": "mruxmohan4"
        }
      },
      {
        "body": "@mruxmohan4 (note I'm not a project maintainer) my suggestion was to not add the new type DriveEnumerationWildcardException. MSBuild engine today only has ~10 exception types and generally they are for key functional purposes (eg., BuildAbortedException, CircularDependencyException, InvalidProjectException). A new type is bunch of bytes that has to ship to every customer for a relatively minor purpose. Why not just throw an InvalidProjectFileException in the first place? If there is a semantic reason, perhaps there is still some way to reuse that type. \r\n\r\nBTW the message wherever it is should be in the resx.",
        "createdAt": "2021-12-16T03:00:27Z",
        "author": {
          "login": "danmoseley"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "How should this exception be caught later and converted into an `InvalidProjectFileException`?",
              "createdAt": "2021-11-09T21:56:09Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -162,10 +162,9 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                                 expanded.Add(newItem);\n                             }\n                         }\n-                        catch (DriveEnumerationWildcardException ex)\n+                        catch (DriveEnumerationWildcardException)",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "Insert a catch wherever you want it caught and converted like:\r\n\r\n```C#\r\ncatch (DriveEnumerationWildcardException e)\r\n{\r\n    throw new InvalidProjectFileException(..., e);\r\n}",
              "createdAt": "2021-11-09T22:32:31Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -162,10 +162,9 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                                 expanded.Add(newItem);\n                             }\n                         }\n-                        catch (DriveEnumerationWildcardException ex)\n+                        catch (DriveEnumerationWildcardException)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This would mean that I need to either add the following in Microsoft.Build.Tasks.csproj & Microsoft.Build.Utilities.csproj and resolve the error below:\r\n```\r\n    <Compile Include=\"..\\Build\\Errors\\InvalidProjectFileException.cs\">\r\n      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>\r\n    </Compile>\r\n```\r\n`CS0433: The type 'InvalidProjectFileException' exists in both 'Microsoft.Build, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' and 'Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' Microsoft.Build.Engine.OM.UnitTests (net472), Microsoft.Build.Engine.OM.UnitTests (net6.0)\tc:\\src\\msbuild\\src\\Build.OM.UnitTests\\Definition\\ProjectItem_Tests.cs`\r\n\r\n\r\nOr add the exception to shared code (and `<Compile Include ... />` the shared exception class to both .csproj files). Initially, I was hoping to add `ProjectErrorUtilities.ThrowInvalidProject(...)` here, but that would require internals to be exposed and made public.",
              "createdAt": "2021-11-09T23:43:28Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -162,10 +162,9 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                                 expanded.Add(newItem);\n                             }\n                         }\n-                        catch (DriveEnumerationWildcardException ex)\n+                        catch (DriveEnumerationWildcardException)",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "I don't think the first would work. You'd have \"different\" InvalidProjectFileExceptions. You can make internals visible to other assemblies without making them public\u2014have you checked to make sure that isn't already true?",
              "createdAt": "2021-11-09T23:56:36Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -162,10 +162,9 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                                 expanded.Add(newItem);\n                             }\n                         }\n-                        catch (DriveEnumerationWildcardException ex)\n+                        catch (DriveEnumerationWildcardException)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is possible - see https://github.com/dotnet/msbuild/pull/7029#discussion_r746828081, but it is still necessary to add Microsoft.Build.csproj to Microsoft.Tasks.Build.csproj as a `ProjectReference`, which caused many errors/warnings. I'm not certain if it is okay to remove many of the `<Compile Include= ...>` statements in Microsoft.Tasks.Build.csproj to resolve this.",
              "createdAt": "2021-11-10T17:42:38Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -162,10 +162,9 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                                 expanded.Add(newItem);\n                             }\n                         }\n-                        catch (DriveEnumerationWildcardException ex)\n+                        catch (DriveEnumerationWildcardException)",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "Yes and no. It's actually good to get rid of as many of those unnecessary double compilations as you can. The risk is that if someone wants to load (in this case) the Tasks assembly without loading Microsoft.Build, that's no longer viable if their code goes down any of the relevant code paths. I'm not super confident in all the use cases in which you might want to, but I think most of the things Tasks rely on live in Framework and not Build, which means people who want to use one of our Tasks without using the rest of MSBuild would no longer be able to. I could be wrong about that if, for instance, all Tasks actually need Build, which also sounds very possible.",
              "createdAt": "2021-11-10T18:14:52Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -162,10 +162,9 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                                 expanded.Add(newItem);\n                             }\n                         }\n-                        catch (DriveEnumerationWildcardException ex)\n+                        catch (DriveEnumerationWildcardException)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Adding this assembly allowed `InvalidProjectFileException` to not receive any errors - however, adding Microsoft.Build.csproj as a `ProjectReference` to Microsoft.Build.Tasks.csproj (which seemed necessary) caused 393 import conflicts from many files-\r\n\r\nExample: `The type 'WindowsFileSystem' in 'c:\\src\\msbuild\\src\\Shared\\FileSystem\\WindowsFileSystem.cs' conflicts with the imported type 'WindowsFileSystem' in 'Microsoft.Build, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. Using the type defined in 'c:\\src\\msbuild\\src\\Shared\\FileSystem\\WindowsFileSystem.cs'.`\r\n\r\n\r\n",
              "createdAt": "2021-11-10T17:37:34Z",
              "path": "src/Build/AssemblyInfo.cs",
              "diffHunk": "@@ -20,6 +20,7 @@\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]\n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Tasks.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "I am moving `InvalidProjectFileException` to `Microsoft.Build.Framework` in #7016. Can you rebase on top of cbe523cf0ac25ad60cf29d00427256fa7bb70d13?",
              "createdAt": "2021-11-10T18:24:48Z",
              "path": "src/Build/AssemblyInfo.cs",
              "diffHunk": "@@ -20,6 +20,7 @@\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]\n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Tasks.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a workaround to avoid adding this `ProjectReference`?",
              "createdAt": "2021-11-10T17:40:04Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -987,6 +987,7 @@\n     <Reference Include=\"System.Xaml\" />\n   </ItemGroup>\n   <ItemGroup>\n+    <ProjectReference Include=\"..\\Build\\Microsoft.Build.csproj\" />",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This line never gets reached due to an `UnauthorizedAccessException` that occurs inside of `GetFilesRecursive()` (see CreateItem_Tests and ProjectItem_Tests). Should the `SearchAction` `ReturnLogDriveEnumerationWildcard` force an early return in `GetFilesImplementation()`, and if so, what exactly should be returned?",
              "createdAt": "2021-11-29T16:46:16Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2570,7 +2584,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                 ? listOfFiles.SelectMany(list => list).Where(f => !resultsToExclude.Contains(f)).ToArray()\n                 : listOfFiles.SelectMany(list => list).ToArray();\n \n-            return files;\n+            return (files, action);",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "Note: Have to do manual testing to get a proper output for testing logged warnings",
              "createdAt": "2021-12-01T19:21:20Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2570,7 +2584,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                 ? listOfFiles.SelectMany(list => list).Where(f => !resultsToExclude.Contains(f)).ToArray()\n                 : listOfFiles.SelectMany(list => list).ToArray();\n \n-            return files;\n+            return (files, action);",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure I understand the question, can you rephrase?",
              "createdAt": "2021-12-02T15:59:18Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2065,12 +2067,14 @@ private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnes\n             }\n         }\n \n-        enum SearchAction\n+        public enum SearchAction",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Accidentally deleted the original question -- I was not certain if there was a better way of doing this than just returning a tuple for a bunch of functions, but if I recall correctly, someone recommended doing it this way during the PR review.",
              "createdAt": "2021-12-06T20:38:30Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2065,12 +2067,14 @@ private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnes\n             }\n         }\n \n-        enum SearchAction\n+        public enum SearchAction",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I was not able to find an appropriate logger to log a warning in Expander.cs or in functions above in the call hierarchy. When should the warning be logged in this particular case?",
              "createdAt": "2021-11-29T16:53:02Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2245,10 +2245,12 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation\n                             string[] fileListEscaped = null;\n                             try\n                             {\n-                                fileListEscaped = EngineFileUtilities.GetFileListEscaped(\n+                                (fileListEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                                      item.ProjectDirectory,\n                                      item.EvaluatedIncludeEscaped,\n                                      forceEvaluate: true);\n+\n+                                // TODO: Log warning if return value is LogDriveEnumerationWildcard",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "TODO: Decide between `TargetLoggingContext`, `TaskLoggingHelper`, and `ILoggingService`",
              "createdAt": "2021-12-01T21:20:19Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2245,10 +2245,12 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation\n                             string[] fileListEscaped = null;\n                             try\n                             {\n-                                fileListEscaped = EngineFileUtilities.GetFileListEscaped(\n+                                (fileListEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                                      item.ProjectDirectory,\n                                      item.EvaluatedIncludeEscaped,\n                                      forceEvaluate: true);\n+\n+                                // TODO: Log warning if return value is LogDriveEnumerationWildcard",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "What's the scenario that hits this codepath? That might help understand.",
              "createdAt": "2021-12-02T15:57:27Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2245,10 +2245,12 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation\n                             string[] fileListEscaped = null;\n                             try\n                             {\n-                                fileListEscaped = EngineFileUtilities.GetFileListEscaped(\n+                                (fileListEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                                      item.ProjectDirectory,\n                                      item.EvaluatedIncludeEscaped,\n                                      forceEvaluate: true);\n+\n+                                // TODO: Log warning if return value is LogDriveEnumerationWildcard",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I am not certain how to hit this codepath. Should I remove this change?",
              "createdAt": "2021-12-09T17:36:46Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2245,10 +2245,12 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation\n                             string[] fileListEscaped = null;\n                             try\n                             {\n-                                fileListEscaped = EngineFileUtilities.GetFileListEscaped(\n+                                (fileListEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                                      item.ProjectDirectory,\n                                      item.EvaluatedIncludeEscaped,\n                                      forceEvaluate: true);\n+\n+                                // TODO: Log warning if return value is LogDriveEnumerationWildcard",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "TODO: Write test to reach this codepath",
              "createdAt": "2021-11-29T17:05:18Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -3474,7 +3474,11 @@ public string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamed\n \n                 var itemFactory = new ProjectItemFactory(Owner, renamedItemElement);\n \n-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, renamedItemElement, itemFactory, renamedItemElement.Include, _data.Expander);\n+                (List<ProjectItem> items, FileMatcher.SearchAction action, string fileSpecEscaped) = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, renamedItemElement, itemFactory, renamedItemElement.Include, _data.Expander);\n+                if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                {\n+                    LoggingService.LogWarning(s_buildEventContext, \"\", new BuildEventFileInfo(FullPath), \"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(fileSpecEscaped), XMakeAttributes.include, XMakeElements.itemGroup);",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Sealed?",
              "createdAt": "2021-11-30T15:48:47Z",
              "path": "src/Shared/DriveEnumerationWildcardException.cs",
              "diffHunk": "@@ -0,0 +1,34 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// Thrown in cases where a drive enumeration wildcard was encountered when finding files that match a given file spec.\n+    /// </summary>\n+    internal class DriveEnumerationWildcardException : Exception",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <FilesToCopy Include=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\*.pdb;$(Microsoft_WindowsAzure_EngSys)\\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\\Certificates\\**\\*\" />\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\n\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144299224-fc979fe8-67f1-4432-89a3-f65830bb3e63.png)\r\n\r\nI'm not certain as to why this would cause an internal error. Does `LoggingContext` require a resource name?\r\n",
              "createdAt": "2021-12-01T19:19:03Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -429,11 +429,16 @@ ISet<string> removeMetadata\n                     try\n                     {\n                         // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n-                        string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n+                        (string[] includeSplitFiles, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                             Project.Directory,\n                             includeSplit,\n                             excludes);\n \n+                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                        {\n+                            LoggingContext.LogWarning($\"Drive enumeration was detected during wildcard expansion, for the Include attribute, which relied on the file spec {includeSplit}.\");",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "It does, yeah. Let's put a pin in this one until the design is set.",
              "createdAt": "2021-12-02T15:50:50Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -429,11 +429,16 @@ ISet<string> removeMetadata\n                     try\n                     {\n                         // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n-                        string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n+                        (string[] includeSplitFiles, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                             Project.Directory,\n                             includeSplit,\n                             excludes);\n \n+                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                        {\n+                            LoggingContext.LogWarning($\"Drive enumeration was detected during wildcard expansion, for the Include attribute, which relied on the file spec {includeSplit}.\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Output with new changes --\r\n![image](https://user-images.githubusercontent.com/89041446/144509290-f057b831-8fb3-4884-b7d3-da3c02544291.png)\r\n",
              "createdAt": "2021-12-02T21:54:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -429,11 +429,16 @@ ISet<string> removeMetadata\n                     try\n                     {\n                         // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n-                        string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n+                        (string[] includeSplitFiles, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(\n                             Project.Directory,\n                             includeSplit,\n                             excludes);\n \n+                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                        {\n+                            LoggingContext.LogWarning($\"Drive enumeration was detected during wildcard expansion, for the Include attribute, which relied on the file spec {includeSplit}.\");",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"CreateItemTest\">\r\n        <CreateItem Include=\"\\**\\*.log\" />\r\n    </Target>\r\n </Project>\r\n```\r\n \r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144299417-fbb4b047-ed85-41f6-928e-03af5993117d.png)\r\n",
              "createdAt": "2021-12-01T19:20:44Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -59,8 +59,19 @@ public override bool Execute()\n             }\n \n             // Expand wild cards.\n-            Include = ExpandWildcards(Include);\n-            Exclude = ExpandWildcards(Exclude);\n+            (Include, FileMatcher.SearchAction includeAction, string includeFileSpec) = ExpandWildcards(Include);\n+            (Exclude, FileMatcher.SearchAction excludeAction, string excludeFileSpec) = ExpandWildcards(Exclude);\n+\n+            // Log potential drive enumeration glob anomalies when applicable.\n+            if (includeAction == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+            {\n+                Log.LogWarning($\"Drive enumeration was detected during wildcard expansion in CreateItem for Include attribute with the filespec {includeFileSpec}\");",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Import Project=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" />\r\n</Project>\r\n```\r\n\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144300100-06a3c2d1-c155-4301-8e67-d5682a88ea77.png)\r\n\r\n",
              "createdAt": "2021-12-01T19:24:41Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -2031,7 +2037,11 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)\n                     }\n \n                     // Expand the wildcards and provide an alphabetical order list of import statements.\n-                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);\n+                    (importFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);\n+                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                    {\n+                        _evaluationLoggingContext.LogWarning(\"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(importExpressionEscapedItem), XMakeAttributes.project, XMakeElements.import);",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <FilesToCopy Include=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\*.pdb;$(Microsoft_WindowsAzure_EngSys)\\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\\Certificates\\**\\*\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144302167-ca40da93-e580-42c1-8fab-b377a9691bc3.png)\r\n",
              "createdAt": "2021-12-01T19:39:21Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs",
              "diffHunk": "@@ -113,7 +113,11 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde\n                             {\n                                 using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n                                 {\n-                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    (includeSplitFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                                    {\n+                                        _lazyEvaluator._loggingContext.LogWarning(\"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup);",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "I think this looks good, but we'll have to pick a clearer error before it's ready.",
              "createdAt": "2021-12-02T15:54:34Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs",
              "diffHunk": "@@ -113,7 +113,11 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde\n                             {\n                                 using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n                                 {\n-                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    (includeSplitFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                                    {\n+                                        _lazyEvaluator._loggingContext.LogWarning(\"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "By the way, I think this is the most important case, useful by itself. Some of the other cases are good but probably not as useful. Let's focus on getting this part just right, then go back in and add some of the edge cases like `CreateItem` or `<Import Project=\"$(empty)\\**\" />`.",
              "createdAt": "2021-12-02T15:58:58Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs",
              "diffHunk": "@@ -113,7 +113,11 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde\n                             {\n                                 using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n                                 {\n-                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    (includeSplitFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                                    {\n+                                        _lazyEvaluator._loggingContext.LogWarning(\"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Msbuild runs into this error both with and without my changes. I think the test case is faulty, but I'm not certain how to hit this codepath otherwise.",
              "createdAt": "2021-12-06T20:36:57Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs",
              "diffHunk": "@@ -113,7 +113,11 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde\n                             {\n                                 using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n                                 {\n-                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    (includeSplitFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                                    {\n+                                        _lazyEvaluator._loggingContext.LogWarning(\"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup);",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "I think this serves as a better test case:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <ItemGroup>\r\n        <Compile Include=\"\\**\\*.cs\"/>\r\n    </ItemGroup>\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <Message Text=\"@(Compile->'%(Filename).cs')\"/>\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\n\r\nOutput (hits this LazyItemEvaluator codepath):\r\n![image](https://user-images.githubusercontent.com/89041446/145131302-93835b5a-4b8b-48f8-8572-5f98ab265510.png)\r\n",
              "createdAt": "2021-12-08T01:20:12Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs",
              "diffHunk": "@@ -113,7 +113,11 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde\n                             {\n                                 using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n                                 {\n-                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    (includeSplitFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                                    {\n+                                        _lazyEvaluator._loggingContext.LogWarning(\"InvalidAttributeValue\", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup);",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <FilesToCopy Include=\"$(Microsoft_WindowsAzure_EngSys)\\*.pdb\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" />\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\n\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144304995-f281fadc-46ec-472b-873e-89f8e9b0b042.png)\r\nIs this test case invalid, or is this an internal error that I should investigate further to debug this scenario?",
              "createdAt": "2021-12-01T20:00:48Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -552,7 +561,11 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification\n                     // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n                     // as literals. Everything else is safe to unescape at this point, since we're only matching\n                     // against the file system.\n-                    string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                    (string[] fileList, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                    {\n+                        LoggingContext.LogWarning($\"Drive enumeration was detected during wildcard expansion, for the Exclude attribute, which relied on the file spec {piece}.\");",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "This looks fishy to me, can you catch it in a debugger and see what's up?",
              "createdAt": "2021-12-02T15:52:54Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -552,7 +561,11 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification\n                     // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n                     // as literals. Everything else is safe to unescape at this point, since we're only matching\n                     // against the file system.\n-                    string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                    (string[] fileList, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                    {\n+                        LoggingContext.LogWarning($\"Drive enumeration was detected during wildcard expansion, for the Exclude attribute, which relied on the file spec {piece}.\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, with new changes, the following output appears for both the old and new test --\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <FilesToCopy Include=\"c:\\src\\*.log\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" />\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144509514-2e2a09ae-6d2f-4e73-9acb-095d4174435c.png)\r\n",
              "createdAt": "2021-12-02T21:56:17Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -552,7 +561,11 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification\n                     // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n                     // as literals. Everything else is safe to unescape at this point, since we're only matching\n                     // against the file system.\n-                    string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                    (string[] fileList, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                    {\n+                        LoggingContext.LogWarning($\"Drive enumeration was detected during wildcard expansion, for the Exclude attribute, which relied on the file spec {piece}.\");",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"CreateItemTest\">\r\n        <CreateItem Include=\"\\*.log\" Exclude=\"\\**\\*.log\"/>\r\n    </Target>\r\n </Project>\r\n```\r\n\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144305981-df54fb3b-0945-4a80-a7f0-23ba29b28c02.png)\r\n",
              "createdAt": "2021-12-01T20:06:46Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -59,8 +59,19 @@ public override bool Execute()\n             }\n \n             // Expand wild cards.\n-            Include = ExpandWildcards(Include);\n-            Exclude = ExpandWildcards(Exclude);\n+            (Include, FileMatcher.SearchAction includeAction, string includeFileSpec) = ExpandWildcards(Include);\n+            (Exclude, FileMatcher.SearchAction excludeAction, string excludeFileSpec) = ExpandWildcards(Exclude);\n+\n+            // Log potential drive enumeration glob anomalies when applicable.\n+            if (includeAction == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+            {\n+                Log.LogWarning($\"Drive enumeration was detected during wildcard expansion in CreateItem for Include attribute with the filespec {includeFileSpec}\");\n+            }\n+\n+            if (excludeAction == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+            {\n+                Log.LogWarning($\"Drive enumeration was detected during wildcard expansion in CreateItem for Exclude attribute with the filespec {excludeFileSpec}\");",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "TODO: Write test to reach this codepath",
              "createdAt": "2021-12-01T20:21:32Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -3534,7 +3538,11 @@ private List<ProjectItem> AddItemHelper(ProjectItemElement itemElement, string u\n             {\n                 var itemFactory = new ProjectItemFactory(Owner, itemElement);\n \n-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);\n+                (List<ProjectItem> items, FileMatcher.SearchAction action, string fileSpecEscaped) = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);\n+                if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                {",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "See ProjectItem_Tests.cs. Test case passes for exception, but results in UnauthorizedAccessException upon logging a warning (happens after calling `GetFilesRecursive(...)` in FileMatcher.cs)",
              "createdAt": "2021-12-02T17:50:44Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -3534,7 +3538,11 @@ private List<ProjectItem> AddItemHelper(ProjectItemElement itemElement, string u\n             {\n                 var itemFactory = new ProjectItemFactory(Owner, itemElement);\n \n-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);\n+                (List<ProjectItem> items, FileMatcher.SearchAction action, string fileSpecEscaped) = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);\n+                if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                {",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "TODO: Write test to reach this codepath",
              "createdAt": "2021-12-01T20:21:49Z",
              "path": "src/Utilities/TrackedDependencies/TrackedDependencies.cs",
              "diffHunk": "@@ -48,7 +49,11 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                         }\n                         else\n                         {\n-                            files = FileMatcher.Default.GetFiles(null, item.ItemSpec);\n+                            (files, FileMatcher.SearchAction action) = FileMatcher.Default.GetFiles(null, item.ItemSpec);\n+                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                            {\n+                                log.LogWarning($\"Drive enumeration was attempted while assisting with tracking dependencies during wildcard expansion, which relied on the item spec {item.ItemSpec}.\");",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "Removing this change, as this is likely a rare case.",
              "createdAt": "2021-12-09T17:35:45Z",
              "path": "src/Utilities/TrackedDependencies/TrackedDependencies.cs",
              "diffHunk": "@@ -48,7 +49,11 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                         }\n                         else\n                         {\n-                            files = FileMatcher.Default.GetFiles(null, item.ItemSpec);\n+                            (files, FileMatcher.SearchAction action) = FileMatcher.Default.GetFiles(null, item.ItemSpec);\n+                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                            {\n+                                log.LogWarning($\"Drive enumeration was attempted while assisting with tracking dependencies during wildcard expansion, which relied on the item spec {item.ItemSpec}.\");",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"CreateItemTest\">\r\n        <CreateItem Include=\"\\**\\*.log\" />\r\n    </Target>\r\n </Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144316384-ca22a1d4-bf28-4fd6-88ce-df54a2c48539.png)\r\n",
              "createdAt": "2021-12-01T21:26:38Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -142,22 +142,29 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                 {\n                     if (FileMatcher.HasWildcards(i.ItemSpec))\n                     {\n-                        string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);\n-                        foreach (string file in files)\n+                        try\n                         {\n-                            TaskItem newItem = new TaskItem(i) { ItemSpec = file };\n-\n-                            // Compute the RecursiveDir portion.\n-                            FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);\n-                            if (match.isLegalFileSpec && match.isMatch)\n+                            string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);\n+                            foreach (string file in files)\n                             {\n-                                if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))\n+                                TaskItem newItem = new TaskItem(i) { ItemSpec = file };\n+\n+                                // Compute the RecursiveDir portion.\n+                                FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);\n+                                if (match.isLegalFileSpec && match.isMatch)\n                                 {\n-                                    newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);\n+                                    if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))\n+                                    {\n+                                        newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);\n+                                    }\n                                 }\n-                            }\n \n-                            expanded.Add(newItem);\n+                                expanded.Add(newItem);\n+                            }\n+                        }\n+                        catch (DriveEnumerationWildcardException)\n+                        {\n+                            throw;",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "I believe the custom exception is caught/detected and I throw a new `InvalidProjectFileException` with the custom exception message in TaskBuilder.cs",
              "createdAt": "2021-12-01T21:27:10Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -142,22 +142,29 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n                 {\n                     if (FileMatcher.HasWildcards(i.ItemSpec))\n                     {\n-                        string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);\n-                        foreach (string file in files)\n+                        try\n                         {\n-                            TaskItem newItem = new TaskItem(i) { ItemSpec = file };\n-\n-                            // Compute the RecursiveDir portion.\n-                            FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);\n-                            if (match.isLegalFileSpec && match.isMatch)\n+                            string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);\n+                            foreach (string file in files)\n                             {\n-                                if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))\n+                                TaskItem newItem = new TaskItem(i) { ItemSpec = file };\n+\n+                                // Compute the RecursiveDir portion.\n+                                FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);\n+                                if (match.isLegalFileSpec && match.isMatch)\n                                 {\n-                                    newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);\n+                                    if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))\n+                                    {\n+                                        newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);\n+                                    }\n                                 }\n-                            }\n \n-                            expanded.Add(newItem);\n+                                expanded.Add(newItem);\n+                            }\n+                        }\n+                        catch (DriveEnumerationWildcardException)\n+                        {\n+                            throw;",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Import Project=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" />\r\n</Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144316866-35a89bc0-ad96-4e07-a9c5-5cede9f0979e.png)\r\n",
              "createdAt": "2021-12-01T21:29:02Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -2026,6 +2033,10 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)\n                     // Expand the wildcards and provide an alphabetical order list of import statements.\n                     importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);\n                 }\n+                catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <FilesToCopy Include=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\*.pdb;$(Microsoft_WindowsAzure_EngSys)\\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\\Certificates\\**\\*\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144317210-395edb6d-8d94-4ec8-81b4-42442a9de36e.png)\r\n",
              "createdAt": "2021-12-01T21:31:33Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs",
              "diffHunk": "@@ -108,23 +108,27 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde\n                             {\n                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(\", \", excludePatternsForGlobs));\n                             }\n-                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n-                            {\n-                                includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(\n-                                    _rootDirectory,\n-                                    glob,\n-                                    excludePatternsForGlobs,\n-                                    fileMatcher: FileMatcher\n-                                );\n-                            }\n-                            if (MSBuildEventSource.Log.IsEnabled())\n+\n+                            try\n                             {\n-                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(\", \", excludePatternsForGlobs));\n+                                using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))\n+                                {\n+                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);\n+                                }\n+\n+                                if (MSBuildEventSource.Log.IsEnabled())\n+                                {\n+                                    MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(\", \", excludePatternsForGlobs));\n+                                }\n+\n+                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                                {\n+                                    itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));\n+                                }\n                             }\n-\n-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                            catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <FilesToCopy Include=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\*.pdb;$(Microsoft_WindowsAzure_EngSys)\\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\\Certificates\\**\\*\" />\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144317494-9042f745-63b1-47a8-bb37-9ef9e2f9fe0d.png)\r\n",
              "createdAt": "2021-12-01T21:33:47Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -427,22 +426,29 @@ ISet<string> removeMetadata\n                 {\n                     // The expression is not of the form \"@(X)\". Treat as string\n \n-                    // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n-                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n-                        Project.Directory,\n-                        includeSplit,\n-                        excludes);\n+                    try\n+                    {\n+                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n+                        string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n+                            Project.Directory,\n+                            includeSplit,\n+                            excludes);\n \n-                    foreach (string includeSplitFile in includeSplitFiles)\n+                        foreach (string includeSplitFile in includeSplitFiles)\n+                        {\n+                            items.Add(new ProjectItemInstance(\n+                                Project,\n+                                originalItem.ItemType,\n+                                includeSplitFile,\n+                                includeSplit /* before wildcard expansion */,\n+                                null,\n+                                null,\n+                                originalItem.Location.File));\n+                        }\n+                    }\n+                    catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test:\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <FilesToCopy Include=\"$(Microsoft_WindowsAzure_EngSys)\\*.pdb\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" />\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\nOutput:\r\n![image](https://user-images.githubusercontent.com/89041446/144317746-80d2be93-6fcd-49af-97bb-d67b6a37e080.png)\r\nLooking into this error further...",
              "createdAt": "2021-12-01T21:36:18Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -534,17 +547,24 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification\n                 // wildcards.  Then loop through each file returned, and add it\n                 // to our hashtable.\n \n-                // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n-                // as literals. Everything else is safe to unescape at this point, since we're only matching\n-                // against the file system.\n-                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                try\n+                {\n+                    // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n+                    // as literals. Everything else is safe to unescape at this point, since we're only matching\n+                    // against the file system.\n+                    string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n \n-                foreach (string file in fileList)\n+                    foreach (string file in fileList)\n+                    {\n+                        // Now unescape everything, because this is the end of the road for this filename.\n+                        // We're just going to compare it to the unescaped include path to filter out the\n+                        // file excludes.\n+                        specificationsToFind.Add(EscapingUtilities.UnescapeAll(file));\n+                    }\n+                }\n+                catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "New test (following output appears for both new and old test):\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"TestTarget\">\r\n        <ItemGroup>\r\n            <FilesToCopy Include=\"c:\\src\\*.log\" Exclude=\"$(Microsoft_WindowsAzure_EngSys)\\**\\*\" />\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\nOutput with new changes:\r\n![image](https://user-images.githubusercontent.com/89041446/144525095-699ddd59-0f39-4ef0-a894-3bdc92e05056.png)\r\n",
              "createdAt": "2021-12-03T00:42:15Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -534,17 +547,24 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification\n                 // wildcards.  Then loop through each file returned, and add it\n                 // to our hashtable.\n \n-                // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n-                // as literals. Everything else is safe to unescape at this point, since we're only matching\n-                // against the file system.\n-                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n+                try\n+                {\n+                    // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them\n+                    // as literals. Everything else is safe to unescape at this point, since we're only matching\n+                    // against the file system.\n+                    string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);\n \n-                foreach (string file in fileList)\n+                    foreach (string file in fileList)\n+                    {\n+                        // Now unescape everything, because this is the end of the road for this filename.\n+                        // We're just going to compare it to the unescaped include path to filter out the\n+                        // file excludes.\n+                        specificationsToFind.Add(EscapingUtilities.UnescapeAll(file));\n+                    }\n+                }\n+                catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please move this exception to `Microsoft.Build.Framework` and put it in the Framework assembly, instead of in Shared. We're (slowly) getting rid of Shared (#6984) and should avoid adding more if possible.",
              "createdAt": "2021-12-02T15:56:06Z",
              "path": "src/Shared/DriveEnumerationWildcardException.cs",
              "diffHunk": "@@ -0,0 +1,34 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Shared",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This test case results in an `UnauthorizedAccessException` inside GetFilesRecursive(...) in FileMatcher.cs since it attempts to enumerate c drive. Is it possible to test this manually using xml?",
              "createdAt": "2021-12-02T17:48:57Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -754,6 +754,34 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(\n             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, \"\");\n         }\n \n+        /// <summary>\n+        /// Project getter that renames an item to a wildcard that results in drive enumeration exception.\n+        /// </summary>\n+        [Fact]\n+        public void ProjectGetterResultingInDriveEnumerationException()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                env.SetEnvironmentVariable(\"MsBuildCheckWildcardDriveEnumeration\", \"1\");\n+                Project project = new Project();\n+                Assert.Throws<InvalidProjectFileException>(() => { ProjectItem item = project.AddItem(\"i\", \"\\\\**\\\\*.log\")[0]; });\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Project getter that renames an item to a wildcard that results in logging a warning for attempted drive enumeration.\n+        /// </summary>\n+        [Fact]\n+        public void ProjectGetterResultingInDriveEnumerationWarning()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                env.SetEnvironmentVariable(\"MsBuildCheckWildcardDriveEnumeration\", \"0\");\n+                Project project = new Project();\n+                ProjectItem item = project.AddItem(\"i\", \"\\\\**\\\\*.log\")[0];",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Test case passes",
              "createdAt": "2021-12-02T21:37:41Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -754,6 +754,34 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(\n             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, \"\");\n         }\n \n+        /// <summary>\n+        /// Project getter that renames an item to a wildcard that results in drive enumeration exception.\n+        /// </summary>\n+        [Fact]\n+        public void ProjectGetterResultingInDriveEnumerationException()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                env.SetEnvironmentVariable(\"MsBuildCheckWildcardDriveEnumeration\", \"1\");\n+                Project project = new Project();\n+                Assert.Throws<InvalidProjectFileException>(() => { ProjectItem item = project.AddItem(\"i\", \"\\\\**\\\\*.log\")[0]; });",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A commented-out test has no effect. No one will ever look at it. The ideal test here is to mock file system calls so you don't have to worry about actual drive enumerations.\r\n\r\nAlso, if you set it to 0, it's supposed to warn? Is there a \"no warn/no error\" setting? (I think we might've talked about that in PR reviews, but it's been a while.)",
              "createdAt": "2021-12-17T16:35:11Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -753,6 +755,147 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(\n             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, \"\");\n         }\n \n+        /// <summary>\n+        /// Project getter that renames an item to a drive enumerating wildcard that results in an exception.\n+        /// </summary>\n+        [Fact]\n+        public void ProjectGetterResultsInDriveEnumerationException()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                ChangeWaves.ResetStateForTests();\n+                env.SetEnvironmentVariable(\"MSBUILDFAILONDRIVEENUMERATINGWILDCARD\", \"1\");\n+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();\n+\n+                Project project = new Project();\n+                Assert.Throws<InvalidProjectFileException>(() => { ProjectItem item = project.AddItem(\"i\", \"\\\\**\\\\*.log\")[0]; });\n+\n+                ChangeWaves.ResetStateForTests();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Will remove the commented-out tests once I get closer to finalizing these changes, as they are currently used to debug logged warnings. 0 = logging a warning, 1 = logging an error (for the CreateItem.cs codepath) or throwing an InvalidProjectFileException with a new resource name.",
              "createdAt": "2021-12-29T20:36:40Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -753,6 +755,147 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(\n             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, \"\");\n         }\n \n+        /// <summary>\n+        /// Project getter that renames an item to a drive enumerating wildcard that results in an exception.\n+        /// </summary>\n+        [Fact]\n+        public void ProjectGetterResultsInDriveEnumerationException()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                ChangeWaves.ResetStateForTests();\n+                env.SetEnvironmentVariable(\"MSBUILDFAILONDRIVEENUMERATINGWILDCARD\", \"1\");\n+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();\n+\n+                Project project = new Project();\n+                Assert.Throws<InvalidProjectFileException>(() => { ProjectItem item = project.AddItem(\"i\", \"\\\\**\\\\*.log\")[0]; });\n+\n+                ChangeWaves.ResetStateForTests();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Revert dotnet --> Microsoft",
              "createdAt": "2021-12-17T16:40:25Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -425,24 +424,46 @@ ISet<string> removeMetadata\n                 }\n                 else\n                 {\n-                    // The expression is not of the form \"@(X)\". Treat as string\n+                    try\n+                    {\n+                        // The expression is not of the form \"@(X)\". Treat as string\n \n-                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621\n-                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n-                        Project.Directory,\n-                        includeSplit,\n-                        excludes);\n+                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you have this option, why can't you take out the custom exception as danmoseley suggested? At lower levels, you should be able to return early, and you can check for this as you go along. If really necessary, you could add two new search actions instead of one: LogDriveEnumerationWildcard and LogErrorDriveEnumerationWildcard or something like that.",
              "createdAt": "2021-12-17T16:44:28Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -425,24 +424,46 @@ ISet<string> removeMetadata\n                 }\n                 else\n                 {\n-                    // The expression is not of the form \"@(X)\". Treat as string\n+                    try\n+                    {\n+                        // The expression is not of the form \"@(X)\". Treat as string\n \n-                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621\n-                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n-                        Project.Directory,\n-                        includeSplit,\n-                        excludes);\n+                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n+                        (string[] includeSplitFiles, FileMatcher.SearchAction action, string logExcludeSpec) = EngineFileUtilities.GetFileListEscaped(\n+                            Project.Directory,\n+                            includeSplit,\n+                            excludes);\n+\n+                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Removed the custom exception - as suggested, I used a results struct in FileMatcher.cs and pass that to various codepaths.",
              "createdAt": "2021-12-29T20:29:50Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -425,24 +424,46 @@ ISet<string> removeMetadata\n                 }\n                 else\n                 {\n-                    // The expression is not of the form \"@(X)\". Treat as string\n+                    try\n+                    {\n+                        // The expression is not of the form \"@(X)\". Treat as string\n \n-                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621\n-                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(\n-                        Project.Directory,\n-                        includeSplit,\n-                        excludes);\n+                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n+                        (string[] includeSplitFiles, FileMatcher.SearchAction action, string logExcludeSpec) = EngineFileUtilities.GetFileListEscaped(\n+                            Project.Directory,\n+                            includeSplit,\n+                            excludes);\n+\n+                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It seems like you're doing this in a lot of different places. Is there not one unified place for it?",
              "createdAt": "2021-12-17T16:53:41Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -372,20 +375,32 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem\n                     else\n                     {\n                         // The expression is not of the form \"@(X)\". Treat as string\n-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n-\n-                        if (includeSplitFilesEscaped.Length > 0)\n+                        try\n                         {\n-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                            string[] includeSplitFilesEscaped = null;\n+                            (includeSplitFilesEscaped, action, _) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n+                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                            {\n+                                fileSpecEscaped = includeSplitEscaped;\n+                            }\n+\n+                            if (includeSplitFilesEscaped.Length > 0)\n                             {\n-                                items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));\n+                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                                {\n+                                    items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));\n+                                }\n                             }\n                         }\n+                        catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Due to the different logging contexts and loggers used in various codepaths that lead to EngineFileUtilities, it makes it difficult to unify. By removing the custom exception and adding a struct, I removed several unnecessary try-catch blocks, but they're replaced by else if statements.",
              "createdAt": "2021-12-29T20:34:28Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -372,20 +375,32 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem\n                     else\n                     {\n                         // The expression is not of the form \"@(X)\". Treat as string\n-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n-\n-                        if (includeSplitFilesEscaped.Length > 0)\n+                        try\n                         {\n-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                            string[] includeSplitFilesEscaped = null;\n+                            (includeSplitFilesEscaped, action, _) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n+                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                            {\n+                                fileSpecEscaped = includeSplitEscaped;\n+                            }\n+\n+                            if (includeSplitFilesEscaped.Length > 0)\n                             {\n-                                items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));\n+                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                                {\n+                                    items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));\n+                                }\n                             }\n                         }\n+                        catch (DriveEnumerationWildcardException ex)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this is valid:\r\n```suggestion\r\n                            (string[] includeSplitFilesEscaped, action, _) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\r\n```",
              "createdAt": "2021-12-17T16:54:19Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -372,20 +375,32 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem\n                     else\n                     {\n                         // The expression is not of the form \"@(X)\". Treat as string\n-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n-\n-                        if (includeSplitFilesEscaped.Length > 0)\n+                        try\n                         {\n-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                            string[] includeSplitFilesEscaped = null;\n+                            (includeSplitFilesEscaped, action, _) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can't be the exclude spec?",
              "createdAt": "2021-12-17T16:54:31Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -372,20 +375,32 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem\n                     else\n                     {\n                         // The expression is not of the form \"@(X)\". Treat as string\n-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n-\n-                        if (includeSplitFilesEscaped.Length > 0)\n+                        try\n                         {\n-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                            string[] includeSplitFilesEscaped = null;\n+                            (includeSplitFilesEscaped, action, _) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n+                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                            {\n+                                fileSpecEscaped = includeSplitEscaped;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It says excludeSpecsEscaped: null -- I think Exclude would just be ignored in FileMatcher since there's a null check unless I'm mistaken.",
              "createdAt": "2021-12-29T22:40:30Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -372,20 +375,32 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem\n                     else\n                     {\n                         // The expression is not of the form \"@(X)\". Treat as string\n-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n-\n-                        if (includeSplitFilesEscaped.Length > 0)\n+                        try\n                         {\n-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)\n+                            string[] includeSplitFilesEscaped = null;\n+                            (includeSplitFilesEscaped, action, _) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);\n+                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+                            {\n+                                fileSpecEscaped = includeSplitEscaped;",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`.Item1` is a bit opaque. I think there's a way to give it a pretty name.",
              "createdAt": "2021-12-17T16:55:51Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2243,12 +2243,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation\n                     {\n                         if (Traits.Instance.UseLazyWildCardEvaluation)\n                         {\n-                            foreach (\n-                                var resultantItem in\n-                                EngineFileUtilities.GetFileListEscaped(\n-                                    item.ProjectDirectory,\n-                                    item.EvaluatedIncludeEscaped,\n-                                    forceEvaluate: true))\n+                            foreach (var resultantItem in EngineFileUtilities.GetFileListEscaped(item.ProjectDirectory, item.EvaluatedIncludeEscaped, forceEvaluate: true).Item1)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You can just make this one (long) line.\r\n\r\nAlso, since this looks like something you expect a user might see, it should be localized. Please put it in strings*.resx",
              "createdAt": "2021-12-17T16:57:56Z",
              "path": "src/Framework/DriveEnumerationWildcardException.cs",
              "diffHunk": "@@ -0,0 +1,46 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Thrown in cases where a drive enumeration wildcard was encountered when finding files that match a given file spec.\n+    /// </summary>\n+    internal sealed class DriveEnumerationWildcardException : Exception\n+    {\n+        // Set to true if Exclude attribute is detected\n+        public bool _excludeAttribute { get; private set; }\n+\n+        // Contains the file specification used for the Exclude attribute\n+        public string _excludeFileSpec { get; private set; }\n+\n+        public DriveEnumerationWildcardException()\n+        {\n+        }\n+\n+        public DriveEnumerationWildcardException(string projectDirectory, string wildcardEvaluation, bool excludeAttribute)\n+            : base(ConstructErrorMessage(projectDirectory, wildcardEvaluation, excludeAttribute))\n+        {\n+            _excludeAttribute = excludeAttribute;\n+            if (excludeAttribute)\n+            {\n+                _excludeFileSpec = wildcardEvaluation;\n+            }\n+        }\n+\n+        public DriveEnumerationWildcardException(string message, Exception innerException)\n+            : base(message, innerException)\n+        {\n+        }\n+\n+        private static string ConstructErrorMessage(string projectDirectory, string wildcardEvaluation, bool excludeAttribute)\n+        {\n+            string attributeType = excludeAttribute ? \"Exclude\" : \"Include\";\n+            return $\"Failed to find files in {projectDirectory} that matched the filespec {wildcardEvaluation} \" +",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should be inside the GetOrAdd call. Otherwise, there's no point in having a cache, since you'll recompute it every time anyway.",
              "createdAt": "2021-12-17T16:59:58Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1973,22 +1975,22 @@ internal string[] GetFiles\n                 {\n                     if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))\n                     {\n-                        files =\n-                            _cachedGlobExpansions.GetOrAdd(\n-                                enumerationKey,\n-                                (_) =>\n-                                    GetFilesImplementation(\n+                        (getFilesList, action, logExcludeSpec) = GetFilesImplementation(",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            bool logDriveEnumerationWildcard = IsDriveEnumeratingWildcardPattern(fixedDirectoryPart, wildcardDirectoryPart);\r\n            if (logDriveEnumerationWildcard && Traits.Instance.ThrowOnDriveEnumeratingWildcard)\r\n            {\r\n                return SearchAction.ReturnThrowOnDriveEnumerationWildcard;\r\n            }\r\n```",
              "createdAt": "2021-12-17T17:03:39Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2134,6 +2139,21 @@ enum SearchAction\n                 return SearchAction.ReturnEmptyList;\n             }\n \n+            /*\n+             * If a drive enumerating wildcard pattern is detected with the fixed directory and wildcard parts, then\n+             * this should either be logged or an exception should be thrown.\n+             */\n+            bool logDriveEnumerationWildcard = false;\n+            if (IsDriveEnumeratingWildcardPattern(fixedDirectoryPart, wildcardDirectoryPart))\n+            {\n+                if (Traits.Instance.ThrowOnDriveEnumeratingWildcard)\n+                {\n+                    return SearchAction.ReturnThrowOnDriveEnumerationWildcard;\n+                }\n+\n+                logDriveEnumerationWildcard = true;\n+            }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't you be able to handle any number of slashes before the **?\r\n\r\nAlso, I think ladipro implemented something like this. Can you use his code or is it too far away?",
              "createdAt": "2021-12-17T17:06:42Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2275,6 +2301,51 @@ private static int SkipSlashes(string aString, int startingIndex)\n             return index;\n         }\n \n+        /// <summary>\n+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.\n+        /// </summary>\n+        private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)\n+        {\n+            string combinedPart = Path.Combine(directoryPart, wildcardPart);\n+            int combinedPartLength = combinedPart.Length;\n+            if (combinedPartLength >= 7 &&                                                                  // Handles <drive letter>:\\\\** case\n+                IsDrivePatternWithoutSlash(combinedPart[0], combinedPart[1]) &&\n+                FileUtilities.IsAnySlash(combinedPart[2]) &&",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think his code might be too far away - I reviewed his changes and tried a slightly different way to handle any number of slashes. Is there a better way to achieve this?",
              "createdAt": "2021-12-29T20:28:17Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2275,6 +2301,51 @@ private static int SkipSlashes(string aString, int startingIndex)\n             return index;\n         }\n \n+        /// <summary>\n+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.\n+        /// </summary>\n+        private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)\n+        {\n+            string combinedPart = Path.Combine(directoryPart, wildcardPart);\n+            int combinedPartLength = combinedPart.Length;\n+            if (combinedPartLength >= 7 &&                                                                  // Handles <drive letter>:\\\\** case\n+                IsDrivePatternWithoutSlash(combinedPart[0], combinedPart[1]) &&\n+                FileUtilities.IsAnySlash(combinedPart[2]) &&",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Prefer Shouldly\r\n```suggestion\r\n                t.Execute().ShouldBeFalse();\r\n                engine.Errors.ShouldBe(1);\r\n```",
              "createdAt": "2021-12-17T17:11:01Z",
              "path": "src/Tasks.UnitTests/CreateItem_Tests.cs",
              "diffHunk": "@@ -259,6 +262,154 @@ public void AdditionalMetaDataOverwriteExisting()\n             Assert.True(success);\n             Assert.Equal(\"SomeOverwriteValue\", t.Include[0].GetMetadata(\"MyMetaData\"));\n         }\n+\n+        /// <summary>\n+        /// Logs error when encountering wildcard drive enumeration during task item creation.\n+        /// </summary>\n+        [Fact]\n+        public void WildcardDriveEnumerationTaskItemLogsError()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                ChangeWaves.ResetStateForTests();\n+                env.SetEnvironmentVariable(\"MSBUILDFAILONDRIVEENUMERATINGWILDCARD\", \"1\");\n+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();\n+\n+                MockEngine engine = new MockEngine();\n+                CreateItem t = new CreateItem()\n+                {\n+                    BuildEngine = engine,\n+                    Include = new ITaskItem[] { new TaskItem(@\"\\**\") },\n+                };\n+\n+                bool succeeded = t.Execute();\n+\n+                Assert.False(succeeded);\n+                Assert.Equal(1, engine.Errors);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it's a little better to return !Log.HasLoggedErrors \u2013 more future-proof.",
              "createdAt": "2021-12-17T17:29:04Z",
              "path": "src/Tasks/CreateItem.cs",
              "diffHunk": "@@ -126,46 +132,97 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab\n             return outputItems;\n         }\n \n+        /// <summary>\n+        /// Attempts to expand wildcards and logs warnings or errors for attempted drive enumeration.\n+        /// </summary>\n+        private bool TryExpandingWildcards(ITaskItem[] expand, bool includeAttribute)\n+        {\n+            const string CreateItemTask = \"CreateItem\";\n+            string attributeType;\n+            string fileSpec;\n+\n+            FileMatcher.SearchAction searchAction;\n+\n+            if (includeAttribute)\n+            {\n+                (Include, searchAction, fileSpec) = ExpandWildcards(expand);\n+                attributeType = XMakeAttributes.include;\n+            }\n+            else\n+            {\n+                (Exclude, searchAction, fileSpec) = ExpandWildcards(expand);\n+                attributeType = XMakeAttributes.exclude;\n+            }\n+\n+            // Log potential drive enumeration glob anomalies when applicable.\n+            if (searchAction == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n+            {\n+                Log.LogWarningWithCodeFromResources(\"WildcardResultsInDriveEnumeration\", EscapingUtilities.UnescapeAll(fileSpec), attributeType, CreateItemTask);\n+            }\n+            else if (searchAction == FileMatcher.SearchAction.ReturnThrowOnDriveEnumerationWildcard)\n+            {\n+                Log.LogErrorWithCodeFromResources(\"WildcardResultsInDriveEnumeration\", EscapingUtilities.UnescapeAll(fileSpec), attributeType, CreateItemTask);\n+                return false;\n+            }\n+\n+            return true;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "**Recent change:**\r\n\r\nThis is the results struct mentioned in the description, I have a few questions regarding this:\r\n1. Should I pass results in a different way?\r\n2. Should I reduce the number of items in this struct (they seem necessary to me, but I'm not certain if anything could be optimized further here)?\r\n3. I use `Default `wherever necessary in various codepaths since repeating constructors seemed redundant in certain areas. Should it be removed?",
              "createdAt": "2022-01-06T17:44:44Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2689,5 +2690,26 @@ private static bool DirectoryEndsWithPattern(string directoryPath, string patter\n         };\n \n         internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;\n+\n+        public struct GetFilesImplementationResults",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "**Recent change**:\r\n1. I know Ladi implemented something similar in his PR, but the code seemed further away and I needed a slightly separate way to ensure that drive enumeration could be detected using the `fixedDirectoryPart `and `wildcardDirectoryPart`. Is there a way to optimize this code-wise and performance-wise? I account for `\\**` and `<drive>:<any number of slashes>**` with this function.\r\n",
              "createdAt": "2022-01-06T17:48:15Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2306,23 +2301,25 @@ private static int SkipSlashes(string aString, int startingIndex)\n         /// </summary>\n         private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "Can you link to that other implementation?",
              "createdAt": "2022-01-11T15:42:49Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2306,23 +2301,25 @@ private static int SkipSlashes(string aString, int startingIndex)\n         /// </summary>\n         private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, it's the change in ItemSpec.cs here: https://github.com/dotnet/msbuild/pull/5669/files",
              "createdAt": "2022-01-11T16:18:56Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2306,23 +2301,25 @@ private static int SkipSlashes(string aString, int startingIndex)\n         /// </summary>\n         private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "**Recent change:**\r\n\r\n1. I added more tests for logging a warning. As Forgind suggested, should all of these commented out tests be completely removed as no one might look at them? Or should I work on mocking a filesystem (which might be a bit complicated considering how many codepaths lead to FileMatcher)?",
              "createdAt": "2022-01-06T17:50:24Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -780,30 +780,30 @@ public void ProjectGetterResultsInDriveEnumerationException()\n         /// on the command line for it to pass. Otherwise, the following test results in an\n         /// UnauthorizedAccessException while attempting to access the root of the drive.\n         /// </summary>\n-        //  [Fact]\n-        //  public void ProjectGetterResultsInDriveEnumerationWarning()\n-        //  {\n-        //      using (var env = TestEnvironment.Create())\n-        //      {\n-        //          ChangeWaves.ResetStateForTests();\n-        //          env.SetEnvironmentVariable(\"MSBUILDFAILONDRIVEENUMERATINGWILDCARD\", \"0\");\n-        //          BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();\n+        //[Fact]",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "**Recent change:**\r\n\r\n1. In many codepaths, including this one, I log a warning or error based on whether a drive enumerating pattern is detected. The reason it's hard to unify is because there are so many different loggers and logging contexts used (that are not unified). Is there a way to actually unify all of this so I can just log something within EngineFileUtilities instead of logging warnings and errors separately in 4-5 different codepaths?",
              "createdAt": "2022-01-06T17:53:32Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -424,47 +424,44 @@ ISet<string> removeMetadata\n                 }\n                 else\n                 {\n-                    try\n-                    {\n-                        // The expression is not of the form \"@(X)\". Treat as string\n-\n-                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n-                        (string[] includeSplitFiles, FileMatcher.SearchAction action, string logExcludeSpec) = EngineFileUtilities.GetFileListEscaped(\n-                            Project.Directory,\n-                            includeSplit,\n-                            excludes);\n+                    // The expression is not of the form \"@(X)\". Treat as string\n \n-                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n-                        {\n-                            if (string.IsNullOrWhiteSpace(logExcludeSpec))\n-                            {\n-                                LoggingContext.LogWarning(\"WildcardResultsInDriveEnumeration\", EscapingUtilities.UnescapeAll(includeSplit), XMakeAttributes.include, XMakeElements.itemGroup);\n-                            }\n-                        }\n+                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621\n+                    var getFilesResults = EngineFileUtilities.GetFileListEscaped(\n+                        Project.Directory,\n+                        includeSplit,\n+                        excludes);\n \n-                        foreach (string includeSplitFile in includeSplitFiles)\n+                    if (getFilesResults.Action == FileMatcher.SearchAction.LogDriveEnumeratingWildcard)\n+                    {\n+                        if (!getFilesResults.IsDriveEnumeratingExcludePattern)",
              "author": {
                "login": "mruxmohan4"
              }
            },
            {
              "body": "This is an excellent instinct but I'm not seeing one; `LoggingContext`, `ILoggingService`, and `IBuildEngine` are unfortunately pretty different. I suppose we could pass an `object LogThing` into `GetFileListEscaped` and do the three implementations in a switch there to at least keep them close together. That . . . may actually be an ok idea? What do you think?\r\n\r\nSpecifically, I think a question to ask here is: \"if we did that, would we need the `GetFilesImplementationResults` struct, or could it simplify to the existing calling pattern and hide all the complexity inside `GetFileListEscaped`?\" If it can hide the complexity and also reduce duplication that seems good.",
              "createdAt": "2022-01-11T15:23:33Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -424,47 +424,44 @@ ISet<string> removeMetadata\n                 }\n                 else\n                 {\n-                    try\n-                    {\n-                        // The expression is not of the form \"@(X)\". Treat as string\n-\n-                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621\n-                        (string[] includeSplitFiles, FileMatcher.SearchAction action, string logExcludeSpec) = EngineFileUtilities.GetFileListEscaped(\n-                            Project.Directory,\n-                            includeSplit,\n-                            excludes);\n+                    // The expression is not of the form \"@(X)\". Treat as string\n \n-                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)\n-                        {\n-                            if (string.IsNullOrWhiteSpace(logExcludeSpec))\n-                            {\n-                                LoggingContext.LogWarning(\"WildcardResultsInDriveEnumeration\", EscapingUtilities.UnescapeAll(includeSplit), XMakeAttributes.include, XMakeElements.itemGroup);\n-                            }\n-                        }\n+                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621\n+                    var getFilesResults = EngineFileUtilities.GetFileListEscaped(\n+                        Project.Directory,\n+                        includeSplit,\n+                        excludes);\n \n-                        foreach (string includeSplitFile in includeSplitFiles)\n+                    if (getFilesResults.Action == FileMatcher.SearchAction.LogDriveEnumeratingWildcard)\n+                    {\n+                        if (!getFilesResults.IsDriveEnumeratingExcludePattern)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I like having a singleton for a common case, but I don't intuitively understand what `Default` means. Would `Empty` be a good name?",
              "createdAt": "2022-01-11T15:01:04Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2603,5 +2690,26 @@ private static bool DirectoryEndsWithPattern(string directoryPath, string patter\n         };\n \n         internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;\n+\n+        public struct GetFilesImplementationResults\n+        {\n+            public static readonly GetFilesImplementationResults Default = new GetFilesImplementationResults(Array.Empty<string>(), SearchAction.None, string.Empty, false);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Removed struct functionality but will leave comments unresolved in case struct is preferred over current implementation.",
              "createdAt": "2022-01-20T19:57:14Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2603,5 +2690,26 @@ private static bool DirectoryEndsWithPattern(string directoryPath, string patter\n         };\n \n         internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;\n+\n+        public struct GetFilesImplementationResults\n+        {\n+            public static readonly GetFilesImplementationResults Default = new GetFilesImplementationResults(Array.Empty<string>(), SearchAction.None, string.Empty, false);",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this mention undefined properties?",
              "createdAt": "2022-01-11T15:02:04Z",
              "path": "src/Shared/Resources/Strings.shared.resx",
              "diffHunk": "@@ -278,10 +278,15 @@\n     <value>MSB5028: Solution filter file at \"{0}\" includes project \"{1}\" that is not in the solution file at \"{2}\".</value>\n     <comment>{StrBegin=\"MSB5028: \"}UE: The project filename is provided separately to loggers.</comment>\n   </data>\n+  <data name=\"WildcardResultsInDriveEnumeration\" xml:space=\"preserve\">\n+    <value>MSB5029: The value \"{0}\" of the \"{1}\" attribute in element &lt;{2}&gt; is an invalid wildcard that results in drive enumeration.</value>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It could suggest that this could occur due to an undefined property, but that may not always be the case -\r\n\r\nEx: \r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n    <Target Name=\"CreateItemTest\">\r\n        <CreateItem Include=\"\\*.log\" Exclude=\"\\**\\*.log\"/>\r\n    </Target>\r\n </Project>\r\n```",
              "createdAt": "2022-01-11T16:24:41Z",
              "path": "src/Shared/Resources/Strings.shared.resx",
              "diffHunk": "@@ -278,10 +278,15 @@\n     <value>MSB5028: Solution filter file at \"{0}\" includes project \"{1}\" that is not in the solution file at \"{2}\".</value>\n     <comment>{StrBegin=\"MSB5028: \"}UE: The project filename is provided separately to loggers.</comment>\n   </data>\n+  <data name=\"WildcardResultsInDriveEnumeration\" xml:space=\"preserve\">\n+    <value>MSB5029: The value \"{0}\" of the \"{1}\" attribute in element &lt;{2}&gt; is an invalid wildcard that results in drive enumeration.</value>",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would appreciate some doc comments on these.",
              "createdAt": "2022-01-11T15:07:47Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2603,5 +2690,26 @@ private static bool DirectoryEndsWithPattern(string directoryPath, string patter\n         };\n \n         internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;\n+\n+        public struct GetFilesImplementationResults\n+        {\n+            public static readonly GetFilesImplementationResults Default = new GetFilesImplementationResults(Array.Empty<string>(), SearchAction.None, string.Empty, false);\n+\n+            public GetFilesImplementationResults(string[] fileList, SearchAction action, string fileSpec, bool isDriveEnumeratingExcludePattern)\n+            {\n+                FileList = fileList;\n+                Action = action;\n+                FileSpec = fileSpec;\n+                IsDriveEnumeratingExcludePattern = isDriveEnumeratingExcludePattern;\n+            }\n+\n+            public string[] FileList { get; set; }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think I'm getting hung up on a naming thing: is `SearchAction` here really the _result_ of an enumeration? Like we do something and it's part of the results of that thing, indicating the combination of the state of the disk and the pattern?",
              "createdAt": "2022-01-11T15:08:34Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2603,5 +2690,26 @@ private static bool DirectoryEndsWithPattern(string directoryPath, string patter\n         };\n \n         internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;\n+\n+        public struct GetFilesImplementationResults\n+        {\n+            public static readonly GetFilesImplementationResults Default = new GetFilesImplementationResults(Array.Empty<string>(), SearchAction.None, string.Empty, false);\n+\n+            public GetFilesImplementationResults(string[] fileList, SearchAction action, string fileSpec, bool isDriveEnumeratingExcludePattern)\n+            {\n+                FileList = fileList;\n+                Action = action;\n+                FileSpec = fileSpec;\n+                IsDriveEnumeratingExcludePattern = isDriveEnumeratingExcludePattern;\n+            }\n+\n+            public string[] FileList { get; set; }\n+\n+            public SearchAction Action { get; set; }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Name seems wrong; should this be something like\r\n\r\n```suggestion\r\n        public void DriveEnumerationWildcardIsObserved()\r\n```\r\n\r\n?",
              "createdAt": "2022-01-11T15:10:06Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1373,6 +1372,49 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()\n             }\n         }\n \n+        [Fact]\n+        public void DriveEnumerationWildcardThrowsException()",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This might be a good opportunity to use a C# 9 [`record`](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/record), IMO. Though some of the immutability stuff isn't obvious to me from a functional + perf perspective.",
              "createdAt": "2022-01-11T15:17:12Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2603,5 +2690,26 @@ private static bool DirectoryEndsWithPattern(string directoryPath, string patter\n         };\n \n         internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;\n+\n+        public struct GetFilesImplementationResults",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since you were asking about high-performance implementations here, there are a few options besides this. It's not obvious to me what would be best, so I'm not telling you to change, but they might be interesting:\r\n\r\n1. Take `(string, startIndex)` instead of individual characters, and do lookups via offsets from the `startIndex`.\r\n2. Take `ReadOnlyMemory<char>` instead of individual characters, and do `AsMemory().Slice()` at the caller to pass just what to inspect. This is basically identical to the above but a bit more strongly typed (and on Framework it's a bit slower I think because of the lack of fast-span).",
              "createdAt": "2022-01-11T15:37:57Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2275,6 +2296,53 @@ private static int SkipSlashes(string aString, int startingIndex)\n             return index;\n         }\n \n+        /// <summary>\n+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.\n+        /// </summary>\n+        private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)\n+        {\n+            int directoryPartLength = directoryPart.Length;\n+            int wildcardPartLength = wildcardPart.Length;\n+            if (directoryPartLength >= 3 &&                                                                  // Handles <drive letter>:<slashes>** cases\n+                wildcardPartLength >= 2 &&\n+                IsDrivePatternWithoutSlash(directoryPart[0], directoryPart[1]))\n+            {\n+                for (int i = 2; i < directoryPartLength-1; i++)\n+                {\n+                    if (!FileUtilities.IsAnySlash(directoryPart[i]))\n+                    {\n+                        return false;\n+                    }\n+                }\n+\n+                return IsFullFileSystemScan(directoryPart[directoryPartLength - 1], wildcardPart[0], wildcardPart[1]);\n+            }\n+            else if (directoryPartLength == 1 &&                                                             // Handles \\** case\n+                     wildcardPartLength >= 2 &&\n+                     IsFullFileSystemScan(directoryPart[0], wildcardPart[0], wildcardPart[1]))\n+            {\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Returns true if given characters follow a drive pattern without the slash (ex: C:).\n+        /// </summary>\n+        private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a `////////**` case?",
              "createdAt": "2022-01-11T15:41:07Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2275,6 +2296,53 @@ private static int SkipSlashes(string aString, int startingIndex)\n             return index;\n         }\n \n+        /// <summary>\n+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.\n+        /// </summary>\n+        private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)\n+        {\n+            int directoryPartLength = directoryPart.Length;\n+            int wildcardPartLength = wildcardPart.Length;\n+            if (directoryPartLength >= 3 &&                                                                  // Handles <drive letter>:<slashes>** cases\n+                wildcardPartLength >= 2 &&\n+                IsDrivePatternWithoutSlash(directoryPart[0], directoryPart[1]))\n+            {\n+                for (int i = 2; i < directoryPartLength-1; i++)\n+                {\n+                    if (!FileUtilities.IsAnySlash(directoryPart[i]))\n+                    {\n+                        return false;\n+                    }\n+                }\n+\n+                return IsFullFileSystemScan(directoryPart[directoryPartLength - 1], wildcardPart[0], wildcardPart[1]);\n+            }\n+            else if (directoryPartLength == 1 &&                                                             // Handles \\** case",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Added a `c:////////**` case, but `////////**` does not result in drive enumeration (even when I manually test using current msbuild bits locally on my Windows m/c), unless I'm misunderstanding this case.",
              "createdAt": "2022-01-20T01:06:33Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2275,6 +2296,53 @@ private static int SkipSlashes(string aString, int startingIndex)\n             return index;\n         }\n \n+        /// <summary>\n+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.\n+        /// </summary>\n+        private static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)\n+        {\n+            int directoryPartLength = directoryPart.Length;\n+            int wildcardPartLength = wildcardPart.Length;\n+            if (directoryPartLength >= 3 &&                                                                  // Handles <drive letter>:<slashes>** cases\n+                wildcardPartLength >= 2 &&\n+                IsDrivePatternWithoutSlash(directoryPart[0], directoryPart[1]))\n+            {\n+                for (int i = 2; i < directoryPartLength-1; i++)\n+                {\n+                    if (!FileUtilities.IsAnySlash(directoryPart[i]))\n+                    {\n+                        return false;\n+                    }\n+                }\n+\n+                return IsFullFileSystemScan(directoryPart[directoryPartLength - 1], wildcardPart[0], wildcardPart[1]);\n+            }\n+            else if (directoryPartLength == 1 &&                                                             // Handles \\** case",
              "author": {
                "login": "mruxmohan4"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure whether a developer reading this will necessarily understand what drive enumeration is or why it is bad. Perhaps something like \"... that will result in enumerating all files on the drive, which was likely not intended.\"",
              "createdAt": "2022-01-11T17:45:32Z",
              "path": "src/Shared/Resources/Strings.shared.resx",
              "diffHunk": "@@ -278,10 +278,15 @@\n     <value>MSB5028: Solution filter file at \"{0}\" includes project \"{1}\" that is not in the solution file at \"{2}\".</value>\n     <comment>{StrBegin=\"MSB5028: \"}UE: The project filename is provided separately to loggers.</comment>\n   </data>\n+  <data name=\"WildcardResultsInDriveEnumeration\" xml:space=\"preserve\">\n+    <value>MSB5029: The value \"{0}\" of the \"{1}\" attribute in element &lt;{2}&gt; is an invalid wildcard that results in drive enumeration.</value>",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      }
    ]
  }
}