{
  "number": 7132,
  "title": "Taskhost issue",
  "body": "Fixes #6461\r\n\r\n### Context\r\n\r\n\r\n### Changes Made\r\nNo longer load an assembly if the user explicitly requests a TaskHostFactory. Use System.Reflection.Metadata to look at its properties instead and \"fake\" having loaded it.\r\n\r\n### Testing\r\n\r\n\r\n### Notes\r\n",
  "state": "CLOSED",
  "createdAt": "2021-12-08T00:41:32Z",
  "updatedAt": "2022-04-28T19:56:17Z",
  "closedAt": "2022-04-28T19:56:17Z",
  "mergedAt": null,
  "additions": 729,
  "deletions": 220,
  "changedFiles": 23,
  "headRefName": "taskhost-issue",
  "isDraft": true,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "88c5b5b85ac04467c94a4cafa9db4b8a67f36008",
          "message": "Create TypeInformation object and pass it around\n\nReplaces LoadedType for cases when we don't actually have a LoadedType. Loading the type requires loading (and locking) the assembly.",
          "committedDate": "2021-12-06T19:46:23Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a7857cddd70efc5eb3b05a439b76d08519e33f1",
          "message": "Find first five",
          "committedDate": "2021-12-06T23:52:30Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d0a7f422fb2cd661adf426041b0d42970eb1c78a",
          "message": "Complete (but incorrect) version",
          "committedDate": "2021-12-08T00:40:00Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b5c180e9baddc541a36ad7ce3bad194ae4cce30d",
          "message": "Checkpoint",
          "committedDate": "2021-12-21T23:04:47Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c379772eff10b830a62df51f367a32cc0e771721",
          "message": "Next checkpoint",
          "committedDate": "2021-12-23T01:04:13Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2682e4d484a339691377450491682b4521681225",
          "message": "Cache TypeInformation from SRM",
          "committedDate": "2021-12-23T22:25:13Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c8b1414ac16d547662cfa4924d49caaf77ffbdbf",
          "message": "Find path",
          "committedDate": "2021-12-27T19:32:38Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5061c0568239afebb5f6b6704d1c914b64a4b966",
          "message": "Unwrap \"Object Handle\"",
          "committedDate": "2021-12-27T19:32:46Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cbaac4d3394db2b5442792acc5a81fc96f226909",
          "message": "Refactor",
          "committedDate": "2021-12-27T19:32:50Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8df77ccdcd444ca358db6abbd16d54e1e3bb6dcd",
          "message": "Most recent changes",
          "committedDate": "2021-12-28T17:37:16Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0a9599f7a66329b944659ea3af460931af22631",
          "message": "Cleanup",
          "committedDate": "2021-12-29T17:36:08Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb471b5bce1c8f8f8e06a78da00e1e2be89ef137",
          "message": "Fixes",
          "committedDate": "2021-12-29T17:36:17Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a40d79187ecd8773fd6f615c7f9e9c59c1a970f",
          "message": "Implement task property types",
          "committedDate": "2022-01-06T00:43:59Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "701af8f1704f96166c21e996c5fe26797c636baf",
          "message": "Fix all but one test",
          "committedDate": "2022-01-12T23:25:47Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "129ea53c4d27a55670e22182552c4c7329010c3a",
          "message": "One failing test",
          "committedDate": "2022-01-13T21:19:59Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "827fe2a3e4185996be3bd7323dde5ef45013294f",
          "message": "Little things",
          "committedDate": "2022-01-14T01:27:35Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "548203590fd8fdca324f8e1f21e0786a4f7ef4d4",
          "message": "Merge https://github.com/dotnet/msbuild into taskhost-issue",
          "committedDate": "2022-01-14T01:30:36Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "caae7368ed084996a1121d9dc7dcc9ecb6b2e4b7",
          "message": "Passed ALL tests!",
          "committedDate": "2022-01-14T01:50:28Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8ea6b6ce509495123bdedd5e6b1c2f0fa0338797",
          "message": "Cleanup",
          "committedDate": "2022-01-14T21:57:15Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2372b028ef001e3b64d3eff2fb44916d8e5733ef",
          "message": "Assert that users should pass a path\n\nWhen they request a task host.",
          "committedDate": "2022-01-18T21:47:00Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e54de2676aa68012b2f97fadc8704ad060b6239",
          "message": "Allow M.B",
          "committedDate": "2022-01-19T01:01:47Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c80e662ea14d5d7f104cef1f9052356596fee4c6",
          "message": "Add back path finding logic",
          "committedDate": "2022-01-19T01:03:56Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I think this is ready for review.\r\n\r\nOutside my previous comments, the path calculation in TypeLoader may be problematic. rainersigwald told me the ALC part actually loads the assembly and doesn't let it go just because it's been unloaded, and all references to it have ceased to exist. It's possible running GC.Collect() right afterwards would be sufficient; otherwise, we may need a more complicated \"find assembly path\" method. The version in MSBuildLoadContext does not take into account .config files, codebases, or the GAC, and it assumes we already know the application base, though that should just be the current project, so maybe we do.",
        "createdAt": "2022-01-14T22:00:53Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure this find-path-if-null part is right. It needs a second look.",
              "createdAt": "2021-12-28T17:40:35Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -317,31 +327,190 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                         }\n                     }\n \n-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                    if (!taskHostFactoryExplicitlyRequested)\n                     {\n-                        lock (_lockObject)\n+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n                         {\n-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                            lock (_lockObject)\n                             {\n-                                ScanAssemblyForPublicTypes();\n-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                                {\n+                                    ScanAssemblyForPublicTypes();\n+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                }\n                             }\n                         }\n-                    }\n \n-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n-                    {\n-                        // if type matches partially on its name\n-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n                         {\n-                            return desiredTypeInAssembly.Value;\n+                            // if type matches partially on its name\n+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                            {\n+                                return new TypeInformation(new LoadedType(desiredTypeInAssembly.Value, _assemblyLoadInfo, _loadedAssembly));\n+                            }\n                         }\n                     }\n \n-                    return null;\n+                    return FindTypeInformationUsingSystemReflectionMetadata(typeName);\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return typeInfo;\n+            }\n+\n+            private TypeInformation FindTypeInformationUsingSystemReflectionMetadata(string typeName)\n+            {\n+                TypeInformation typeInformation = new();\n+                string path = _assemblyLoadInfo.AssemblyFile;\n+                if (path is null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It wasn't, but I think it works now.",
              "createdAt": "2022-01-13T21:22:32Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -317,31 +327,190 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                         }\n                     }\n \n-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                    if (!taskHostFactoryExplicitlyRequested)\n                     {\n-                        lock (_lockObject)\n+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n                         {\n-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                            lock (_lockObject)\n                             {\n-                                ScanAssemblyForPublicTypes();\n-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                                {\n+                                    ScanAssemblyForPublicTypes();\n+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                }\n                             }\n                         }\n-                    }\n \n-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n-                    {\n-                        // if type matches partially on its name\n-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n                         {\n-                            return desiredTypeInAssembly.Value;\n+                            // if type matches partially on its name\n+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                            {\n+                                return new TypeInformation(new LoadedType(desiredTypeInAssembly.Value, _assemblyLoadInfo, _loadedAssembly));\n+                            }\n                         }\n                     }\n \n-                    return null;\n+                    return FindTypeInformationUsingSystemReflectionMetadata(typeName);\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return typeInfo;\n+            }\n+\n+            private TypeInformation FindTypeInformationUsingSystemReflectionMetadata(string typeName)\n+            {\n+                TypeInformation typeInformation = new();\n+                string path = _assemblyLoadInfo.AssemblyFile;\n+                if (path is null)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "bytes isn't currently used. I need to get type information for each property, and that's unusually complicated in the general case because of generics and custom types. We may be able to get by without them because there are only so many things that can be passed as inputs/outputs from a task\u2014thoughts @rainersigwald? Do I need a custom SignatureDecoder? (I was also considering using propertyDefinition.DecodeSignature, but I wasn't sure what TType or TGenericContext would be.)",
              "createdAt": "2021-12-28T17:42:58Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -317,31 +327,190 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                         }\n                     }\n \n-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                    if (!taskHostFactoryExplicitlyRequested)\n                     {\n-                        lock (_lockObject)\n+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n                         {\n-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                            lock (_lockObject)\n                             {\n-                                ScanAssemblyForPublicTypes();\n-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                                {\n+                                    ScanAssemblyForPublicTypes();\n+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                }\n                             }\n                         }\n-                    }\n \n-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n-                    {\n-                        // if type matches partially on its name\n-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n                         {\n-                            return desiredTypeInAssembly.Value;\n+                            // if type matches partially on its name\n+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                            {\n+                                return new TypeInformation(new LoadedType(desiredTypeInAssembly.Value, _assemblyLoadInfo, _loadedAssembly));\n+                            }\n                         }\n                     }\n \n-                    return null;\n+                    return FindTypeInformationUsingSystemReflectionMetadata(typeName);\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return typeInfo;\n+            }\n+\n+            private TypeInformation FindTypeInformationUsingSystemReflectionMetadata(string typeName)\n+            {\n+                TypeInformation typeInformation = new();\n+                string path = _assemblyLoadInfo.AssemblyFile;\n+                if (path is null)\n+                {\n+#if NETFRAMEWORK\n+                    AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\");\n+                    path = appDomain.Load(new AssemblyName(_assemblyLoadInfo.AssemblyName)).Location;\n+                    AppDomain.Unload(appDomain);\n+#else\n+                    AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                    alc.LoadFromAssemblyName(new AssemblyName(_assemblyLoadInfo.AssemblyName));\n+                    path = alc.Assemblies.First().Location;\n+                    alc.Unload();\n+#endif\n+                }\n+\n+                using (FileStream stream = File.OpenRead(path))\n+                using (PEReader peFile = new(stream))\n+                {\n+                    MetadataReader metadataReader = peFile.GetMetadataReader();\n+                    AssemblyDefinition assemblyDef = metadataReader.GetAssemblyDefinition();\n+                    foreach (TypeDefinitionHandle typeDefHandle in metadataReader.TypeDefinitions)\n+                    {\n+                        TypeDefinition typeDef = metadataReader.GetTypeDefinition(typeDefHandle);\n+                        if (!typeDef.Attributes.HasFlag(TypeAttributes.Public) || !typeDef.Attributes.HasFlag(TypeAttributes.Class))\n+                        {\n+                            continue;\n+                        }\n+                        else\n+                        {\n+                            string currentTypeName = metadataReader.GetString(typeDef.Name);\n+                            if (currentTypeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(currentTypeName, typeName))\n+                            {\n+                                // We found the right type! Now get its information.\n+                                foreach (CustomAttributeHandle customAttrHandle in typeDef.GetCustomAttributes())\n+                                {\n+                                    CustomAttribute customAttribute = metadataReader.GetCustomAttribute(customAttrHandle);\n+                                    MemberReference constructorReference = metadataReader.GetMemberReference((MemberReferenceHandle)customAttribute.Constructor);\n+                                    if (constructorReference.Parent.Kind == HandleKind.TypeReference)\n+                                    {\n+                                        TypeReference typeReference = metadataReader.GetTypeReference((TypeReferenceHandle)constructorReference.Parent);\n+                                        string customAttributeName = metadataReader.GetString(typeReference.Name);\n+                                        switch (customAttributeName)\n+                                        {\n+                                            case \"RunInSTAAttribute\":\n+                                                typeInformation.HasSTAThreadAttribute = true;\n+                                                break;\n+                                            case \"LoadInSeparateAppDomainAttribute\":\n+                                                typeInformation.HasLoadInSeparateAppDomainAttribute = true;\n+                                                break;\n+                                        }\n+                                    }\n+                                }\n+\n+                                IEnumerable<PropertyDefinition> propertyDefinitions = typeDef.GetProperties().Select(prop => metadataReader.GetPropertyDefinition(prop));\n+                                List<TypeInformationPropertyInfo> typePropertyInfos = new();\n+                                foreach (PropertyDefinition propertyDefinition in propertyDefinitions)\n+                                {\n+                                    TypeInformationPropertyInfo toAdd = new();\n+                                    toAdd.Name = metadataReader.GetString(propertyDefinition.Name);\n+                                    byte[] bytes = metadataReader.GetBlobReader(propertyDefinition.Signature).ReadBytes(metadataReader.GetBlobReader(propertyDefinition.Signature).Length);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Specifically, acceptable types include value types, strings, ITaskItems, and arrays of any of those.",
              "createdAt": "2021-12-28T18:11:17Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -317,31 +327,190 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                         }\n                     }\n \n-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                    if (!taskHostFactoryExplicitlyRequested)\n                     {\n-                        lock (_lockObject)\n+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n                         {\n-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                            lock (_lockObject)\n                             {\n-                                ScanAssemblyForPublicTypes();\n-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                                {\n+                                    ScanAssemblyForPublicTypes();\n+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                }\n                             }\n                         }\n-                    }\n \n-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n-                    {\n-                        // if type matches partially on its name\n-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n                         {\n-                            return desiredTypeInAssembly.Value;\n+                            // if type matches partially on its name\n+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                            {\n+                                return new TypeInformation(new LoadedType(desiredTypeInAssembly.Value, _assemblyLoadInfo, _loadedAssembly));\n+                            }\n                         }\n                     }\n \n-                    return null;\n+                    return FindTypeInformationUsingSystemReflectionMetadata(typeName);\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return typeInfo;\n+            }\n+\n+            private TypeInformation FindTypeInformationUsingSystemReflectionMetadata(string typeName)\n+            {\n+                TypeInformation typeInformation = new();\n+                string path = _assemblyLoadInfo.AssemblyFile;\n+                if (path is null)\n+                {\n+#if NETFRAMEWORK\n+                    AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\");\n+                    path = appDomain.Load(new AssemblyName(_assemblyLoadInfo.AssemblyName)).Location;\n+                    AppDomain.Unload(appDomain);\n+#else\n+                    AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                    alc.LoadFromAssemblyName(new AssemblyName(_assemblyLoadInfo.AssemblyName));\n+                    path = alc.Assemblies.First().Location;\n+                    alc.Unload();\n+#endif\n+                }\n+\n+                using (FileStream stream = File.OpenRead(path))\n+                using (PEReader peFile = new(stream))\n+                {\n+                    MetadataReader metadataReader = peFile.GetMetadataReader();\n+                    AssemblyDefinition assemblyDef = metadataReader.GetAssemblyDefinition();\n+                    foreach (TypeDefinitionHandle typeDefHandle in metadataReader.TypeDefinitions)\n+                    {\n+                        TypeDefinition typeDef = metadataReader.GetTypeDefinition(typeDefHandle);\n+                        if (!typeDef.Attributes.HasFlag(TypeAttributes.Public) || !typeDef.Attributes.HasFlag(TypeAttributes.Class))\n+                        {\n+                            continue;\n+                        }\n+                        else\n+                        {\n+                            string currentTypeName = metadataReader.GetString(typeDef.Name);\n+                            if (currentTypeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(currentTypeName, typeName))\n+                            {\n+                                // We found the right type! Now get its information.\n+                                foreach (CustomAttributeHandle customAttrHandle in typeDef.GetCustomAttributes())\n+                                {\n+                                    CustomAttribute customAttribute = metadataReader.GetCustomAttribute(customAttrHandle);\n+                                    MemberReference constructorReference = metadataReader.GetMemberReference((MemberReferenceHandle)customAttribute.Constructor);\n+                                    if (constructorReference.Parent.Kind == HandleKind.TypeReference)\n+                                    {\n+                                        TypeReference typeReference = metadataReader.GetTypeReference((TypeReferenceHandle)constructorReference.Parent);\n+                                        string customAttributeName = metadataReader.GetString(typeReference.Name);\n+                                        switch (customAttributeName)\n+                                        {\n+                                            case \"RunInSTAAttribute\":\n+                                                typeInformation.HasSTAThreadAttribute = true;\n+                                                break;\n+                                            case \"LoadInSeparateAppDomainAttribute\":\n+                                                typeInformation.HasLoadInSeparateAppDomainAttribute = true;\n+                                                break;\n+                                        }\n+                                    }\n+                                }\n+\n+                                IEnumerable<PropertyDefinition> propertyDefinitions = typeDef.GetProperties().Select(prop => metadataReader.GetPropertyDefinition(prop));\n+                                List<TypeInformationPropertyInfo> typePropertyInfos = new();\n+                                foreach (PropertyDefinition propertyDefinition in propertyDefinitions)\n+                                {\n+                                    TypeInformationPropertyInfo toAdd = new();\n+                                    toAdd.Name = metadataReader.GetString(propertyDefinition.Name);\n+                                    byte[] bytes = metadataReader.GetBlobReader(propertyDefinition.Signature).ReadBytes(metadataReader.GetBlobReader(propertyDefinition.Signature).Length);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Should we really be accepting structs? Maybe we should require value types to be { integer, float, char, bool, nullable of one of those, or enum }?",
              "createdAt": "2021-12-28T18:20:52Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -317,31 +327,190 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                         }\n                     }\n \n-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                    if (!taskHostFactoryExplicitlyRequested)\n                     {\n-                        lock (_lockObject)\n+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n                         {\n-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                            lock (_lockObject)\n                             {\n-                                ScanAssemblyForPublicTypes();\n-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                                {\n+                                    ScanAssemblyForPublicTypes();\n+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                }\n                             }\n                         }\n-                    }\n \n-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n-                    {\n-                        // if type matches partially on its name\n-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n                         {\n-                            return desiredTypeInAssembly.Value;\n+                            // if type matches partially on its name\n+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                            {\n+                                return new TypeInformation(new LoadedType(desiredTypeInAssembly.Value, _assemblyLoadInfo, _loadedAssembly));\n+                            }\n                         }\n                     }\n \n-                    return null;\n+                    return FindTypeInformationUsingSystemReflectionMetadata(typeName);\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return typeInfo;\n+            }\n+\n+            private TypeInformation FindTypeInformationUsingSystemReflectionMetadata(string typeName)\n+            {\n+                TypeInformation typeInformation = new();\n+                string path = _assemblyLoadInfo.AssemblyFile;\n+                if (path is null)\n+                {\n+#if NETFRAMEWORK\n+                    AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\");\n+                    path = appDomain.Load(new AssemblyName(_assemblyLoadInfo.AssemblyName)).Location;\n+                    AppDomain.Unload(appDomain);\n+#else\n+                    AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                    alc.LoadFromAssemblyName(new AssemblyName(_assemblyLoadInfo.AssemblyName));\n+                    path = alc.Assemblies.First().Location;\n+                    alc.Unload();\n+#endif\n+                }\n+\n+                using (FileStream stream = File.OpenRead(path))\n+                using (PEReader peFile = new(stream))\n+                {\n+                    MetadataReader metadataReader = peFile.GetMetadataReader();\n+                    AssemblyDefinition assemblyDef = metadataReader.GetAssemblyDefinition();\n+                    foreach (TypeDefinitionHandle typeDefHandle in metadataReader.TypeDefinitions)\n+                    {\n+                        TypeDefinition typeDef = metadataReader.GetTypeDefinition(typeDefHandle);\n+                        if (!typeDef.Attributes.HasFlag(TypeAttributes.Public) || !typeDef.Attributes.HasFlag(TypeAttributes.Class))\n+                        {\n+                            continue;\n+                        }\n+                        else\n+                        {\n+                            string currentTypeName = metadataReader.GetString(typeDef.Name);\n+                            if (currentTypeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(currentTypeName, typeName))\n+                            {\n+                                // We found the right type! Now get its information.\n+                                foreach (CustomAttributeHandle customAttrHandle in typeDef.GetCustomAttributes())\n+                                {\n+                                    CustomAttribute customAttribute = metadataReader.GetCustomAttribute(customAttrHandle);\n+                                    MemberReference constructorReference = metadataReader.GetMemberReference((MemberReferenceHandle)customAttribute.Constructor);\n+                                    if (constructorReference.Parent.Kind == HandleKind.TypeReference)\n+                                    {\n+                                        TypeReference typeReference = metadataReader.GetTypeReference((TypeReferenceHandle)constructorReference.Parent);\n+                                        string customAttributeName = metadataReader.GetString(typeReference.Name);\n+                                        switch (customAttributeName)\n+                                        {\n+                                            case \"RunInSTAAttribute\":\n+                                                typeInformation.HasSTAThreadAttribute = true;\n+                                                break;\n+                                            case \"LoadInSeparateAppDomainAttribute\":\n+                                                typeInformation.HasLoadInSeparateAppDomainAttribute = true;\n+                                                break;\n+                                        }\n+                                    }\n+                                }\n+\n+                                IEnumerable<PropertyDefinition> propertyDefinitions = typeDef.GetProperties().Select(prop => metadataReader.GetPropertyDefinition(prop));\n+                                List<TypeInformationPropertyInfo> typePropertyInfos = new();\n+                                foreach (PropertyDefinition propertyDefinition in propertyDefinitions)\n+                                {\n+                                    TypeInformationPropertyInfo toAdd = new();\n+                                    toAdd.Name = metadataReader.GetString(propertyDefinition.Name);\n+                                    byte[] bytes = metadataReader.GetBlobReader(propertyDefinition.Signature).ReadBytes(metadataReader.GetBlobReader(propertyDefinition.Signature).Length);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@sharwell told me that Assembly.LoadFrom(bytes) doesn't lock the assembly. He suggested we could potentially load the relevant assembly into a byte array, then use Assembly.LoadFrom to get its full information without changing almost any other code. I'm guessing that would be a little less efficient, but if it can simply load the assembly, that may be worth it.",
              "createdAt": "2021-12-28T17:45:12Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -317,31 +327,190 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                         }\n                     }\n \n-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                    if (!taskHostFactoryExplicitlyRequested)\n                     {\n-                        lock (_lockObject)\n+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n                         {\n-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                            lock (_lockObject)\n                             {\n-                                ScanAssemblyForPublicTypes();\n-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)\n+                                {\n+                                    ScanAssemblyForPublicTypes();\n+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);\n+                                }\n                             }\n                         }\n-                    }\n \n-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n-                    {\n-                        // if type matches partially on its name\n-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)\n                         {\n-                            return desiredTypeInAssembly.Value;\n+                            // if type matches partially on its name\n+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))\n+                            {\n+                                return new TypeInformation(new LoadedType(desiredTypeInAssembly.Value, _assemblyLoadInfo, _loadedAssembly));\n+                            }\n                         }\n                     }\n \n-                    return null;\n+                    return FindTypeInformationUsingSystemReflectionMetadata(typeName);\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return typeInfo;\n+            }\n+\n+            private TypeInformation FindTypeInformationUsingSystemReflectionMetadata(string typeName)\n+            {",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We does this exist? I think it's fine to leave it essentially unchanged, since we don't need to worry about locking an assembly we need unlocked when the task host comes to load it in that task host, but should this whole thing be deleted in favor of the shared version?",
              "createdAt": "2022-01-14T21:43:03Z",
              "path": "src/MSBuildTaskHost/TypeLoader.cs",
              "diffHunk": "@@ -127,10 +127,11 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)\n         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type\n         /// found will be returned.\n         /// </summary>\n-        internal LoadedType Load",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}