{
  "number": 9811,
  "title": "[BuildCheck] Editor config support",
  "body": "First iteration of the code with latest merged changes from exp/build-analyzers. \r\n\r\nDesign capturing current implementation could be viewed here: https://github.com/dotnet/msbuild/tree/dev/f-alizada/support-editorconfig/src/Build/BuildCheck/Infrastructure/EditorConfig\r\n\r\nDiscussions:\r\n- Discuss the prefix for the rule in editorconfigfile - for now it will be left as it is and discussed solved in scope of this ticket: https://github.com/dotnet/msbuild/issues/9823\r\n\r\nCurrent implementation. \r\nThe editorConfig parsing functionality is being used by https://github.com/dotnet/msbuild/blob/dev/f-alizada/support-editorconfig/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs\r\nto fetch all configs from .editorconfig. \r\n\r\n- [x] Add comments on all public APIs\r\n- [x] Check the case sensitive key-values in cache\r\n- [x] Manual testing \r\n    - [x] unix\r\n    - [x] windows",
  "state": "MERGED",
  "createdAt": "2024-03-01T16:15:53Z",
  "updatedAt": "2024-05-20T15:50:29Z",
  "closedAt": "2024-05-20T15:50:28Z",
  "mergedAt": "2024-05-20T15:50:28Z",
  "additions": 3024,
  "deletions": 144,
  "changedFiles": 25,
  "headRefName": "dev/f-alizada/support-editorconfig",
  "isDraft": false,
  "author": {
    "login": "f-alizada"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "20db91ae4e13db7bd82f02a6f1d4b0645df09620",
          "message": "Initial codechanges of editorconfig support",
          "committedDate": "2024-03-01T16:09:51Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e010c367a3e2324ca83200d6cad88884c11ed91f",
          "message": "Build error fixes",
          "committedDate": "2024-03-04T09:52:11Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "44983c20724bbf335c71aaa3895d92c2ef2c082f",
          "message": "fix the configuration",
          "committedDate": "2024-03-04T10:27:15Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2a05ad8cbfa3769ffc93f7eb57e87f1f1b41364",
          "message": "Share the visibility of the Microsoft.Build for unit test purposes. Add Roslyn editorconfig tests for section matcher",
          "committedDate": "2024-03-04T13:32:23Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "af05c7f2048549cb3e370de1d686cf7b85b1a0ef",
          "message": "remote static from configurationProvider",
          "committedDate": "2024-03-04T15:10:33Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80620149bbbcd946e21ee22cc73749a28aa7258e",
          "message": "Copy the tests for config file parsing and adjust based on the current implementetion.",
          "committedDate": "2024-03-06T11:49:17Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cd2abde2a3cade3ec2cdb2b4e31b3bcb7d23df9a",
          "message": "Merge branch 'exp/build-analyzers' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-03-06T11:49:55Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "20433af0b9da1bfc921436d97647f4769b83503b",
          "message": "style fixes",
          "committedDate": "2024-03-06T14:54:24Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d94d09037a930c40e2be37423ef4d4dcbd8587c4",
          "message": "Remove the comments",
          "committedDate": "2024-03-06T14:55:49Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1e6386076ceda2053e70e46622b194062789a5ca",
          "message": "Handle caching properly",
          "committedDate": "2024-03-06T15:34:07Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8d8c1e9bc8d408299b03f65558666b1349b36b5a",
          "message": "Add custom configuration data implementation",
          "committedDate": "2024-03-06T16:07:42Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68a563e0483b32a81ac13aed565b0b1860317198",
          "message": "check for null ref in BuildAnalyzerConfiguration creation and cover logic by tests",
          "committedDate": "2024-03-07T10:14:40Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88160f1a6c97e6bb2d08d63c84d169a171d05483",
          "message": "remove interface, add tests on editorconfig discovery",
          "committedDate": "2024-03-11T09:27:48Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c88ec21af583418f5b8b83344ee9777eae4a3937",
          "message": "Make get custom config public only.",
          "committedDate": "2024-03-11T09:59:26Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "08219fa4281817a3d02be0cee6449b585056b8f9",
          "message": "Add success configuration tests and error scope for config exceptions",
          "committedDate": "2024-03-11T12:13:53Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "40af50e01f1f090868f3dcb05efb370edef85adb",
          "message": "Add more documentation",
          "committedDate": "2024-03-11T13:40:55Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e495070decfded42dbc866dd51e054bf010a944c",
          "message": "Merge branch 'exp/build-analyzers' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-03-18T14:36:25Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "709199f9ee57910cdf2fa36125e5f54f38a99ce7",
          "message": "Add exception on building the config instance",
          "committedDate": "2024-03-18T20:33:26Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dce803947e4678c324030c6b00fce46a91028b65",
          "message": "Update exceptions",
          "committedDate": "2024-03-19T09:19:53Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d7ba200c2828d248de9300ca61910f1fd8b70a2c",
          "message": "Merge branch 'exp/build-analyzers' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-03-19T13:16:02Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e27f899ed854a8c7ea7e2c284055d7908832728c",
          "message": "Fix merge conflicts",
          "committedDate": "2024-03-19T13:59:37Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d273404e1285b31eadc9b4a29fd555c88d048a92",
          "message": "Fix the naming",
          "committedDate": "2024-03-19T14:14:57Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "933aee181c43362efda8eb4f6f237235e679d063",
          "message": "rename to build_check",
          "committedDate": "2024-03-19T15:55:49Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0dfb8d1ce5fc1de5153e65ea04c66a6dcac6279",
          "message": "Leave todos for the next iteration or version",
          "committedDate": "2024-03-19T16:03:27Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ca3d5b78b5d3261ccdc50e1102c52a54cd6965b9",
          "message": "Add more info on usage of the introduced changes.",
          "committedDate": "2024-03-19T16:14:33Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "df1b64c365b7e7e3ab8f80d92c768390dd48fb22",
          "message": "address PR comments + compare custom configuration data",
          "committedDate": "2024-03-25T13:42:49Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3dd6ee4ebea71c730aab1d9f4e4b6d455b280d29",
          "message": "Add equals unit test",
          "committedDate": "2024-03-25T14:14:58Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "67162505a3383bc2ba41a13b9d192cd6872e2611",
          "message": "Merge branch 'exp/build-analyzers' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-02T09:27:29Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d659cad5e2d6bfd9fb25067dd311d95b8e6e08fa",
          "message": "Address formatting pr review comments",
          "committedDate": "2024-04-02T10:02:56Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee9eaafa28833226b5688da651de7d5da6ca90f9",
          "message": "Update the comparison logic",
          "committedDate": "2024-04-03T09:05:59Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5cb1c30c24081ff0c265accdc3d656a6ca712708",
          "message": "Address style issue/ null warnings",
          "committedDate": "2024-04-03T10:28:42Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7217b683085b2993c2102357f383a715ceb99e4b",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-16T13:08:39Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1bc3c68018bf05d905a4c721d9b814192d58f549",
          "message": "fixing merge conflicts",
          "committedDate": "2024-04-18T07:01:41Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3259876178e72ef05ceb1fc9cbd11cd5997963a0",
          "message": "Fix merged conflicts. Update tests",
          "committedDate": "2024-04-18T07:49:43Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "54a1a4d1ddaca95be1984c2fe3f327107670dece",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-18T07:50:23Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19115fbe9947b45f2ddb089aecd6b832f0a23f67",
          "message": "Fix differences",
          "committedDate": "2024-04-18T08:56:47Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "478087120843a18c2df865ce81fc4f209c6522a6",
          "message": "small fixes",
          "committedDate": "2024-04-18T09:25:07Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c593e385a1d3cf5095cb0c4fd3001deee632c4bd",
          "message": "empty lines (not-needed changes removed)",
          "committedDate": "2024-04-18T09:40:34Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68c8667b8863acd53590cf60bd21dfa3120d223a",
          "message": "Empty line",
          "committedDate": "2024-04-18T09:43:17Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "12f51677b772f55456330dafe12667cb18d2ac45",
          "message": "Address PR comments add more docs to the fields",
          "committedDate": "2024-04-18T13:35:14Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4b80888ceb0f3384a889873eb0f0ae7ffbb8cda0",
          "message": "Add comments",
          "committedDate": "2024-04-23T07:17:00Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a77f963cabe02438ac60eb23ff97431ebcdf3b7",
          "message": "Comparer specified",
          "committedDate": "2024-04-23T07:34:42Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2f796b671d1f9fd278b4d00ea0bd4fe655bc829",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-23T07:35:06Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68f9eeba12e5002ceb31a4c7892f03d5d08b2dea",
          "message": "Cover the case when the project config is not presented",
          "committedDate": "2024-04-23T10:24:53Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "76fa557a6a025c6473fd65e95dda8c66d7d58625",
          "message": "Address PR comments",
          "committedDate": "2024-04-23T12:11:28Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5ccdf6aba749214fa6b6e1c0e2e3f9afd02c002d",
          "message": "Address more comments",
          "committedDate": "2024-04-23T13:40:49Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92c5099ced556ac68a56fe9085cefc1d9b294f53",
          "message": "Add comment TODO",
          "committedDate": "2024-04-23T14:05:37Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c0fd21606ba9d0bef6df544fed96f83e36a9a647",
          "message": "Add comment to the configuration parameter",
          "committedDate": "2024-04-23T14:23:55Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "414854511b91ede9cfeccade11a3d1af6623a324",
          "message": "Add Concurrent Dictionary for thread safety of EditorConfigParser",
          "committedDate": "2024-04-23T17:47:06Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7b4bc4317ee563fd4bbb327129c4c991c87773e7",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-23T17:47:27Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b5fb7bc7ae8cbf04efaffc277b5685e46b1e1b36",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-24T16:14:04Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d33c02a5ec3627b2019b36634c04536f8195f498",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-28T07:52:35Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a91c971c2621ab09dd69a522ce6b6dea6794b72f",
          "message": "Fix merge conflicts",
          "committedDate": "2024-04-28T08:13:48Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c6eae873ae4b3120fd0fdf21ed58df94d8ae06c",
          "message": "Address PR review",
          "committedDate": "2024-04-28T10:26:35Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d465b98a7f97953e3144148900db5ede855c6ad",
          "message": "Add editorconfig with filescoped namespace warning enabled",
          "committedDate": "2024-04-28T11:25:22Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ac2984453c3def89f96d7178d1cb8ef1d4f5456d",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-04-30T05:30:45Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a15089ba487b399313a6fab67f21d7e01d39e251",
          "message": "remove implementation of the GetHashCode of CustomConfigdata",
          "committedDate": "2024-04-30T05:52:57Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4d0f1939edd7e58276d7707507d8cc4768917f1b",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-05-07T17:12:40Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb94e1954dfb15edd88afd36c07ee4fe7b5f2f3d",
          "message": "Fix warning",
          "committedDate": "2024-05-07T17:17:15Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3685179f76afa815c1fc2e72ee1b9228b3e4363e",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-05-14T07:05:18Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11fc46d5e015eba2ff3517c256c9a5ec7c7e3bc1",
          "message": "fix filescope namespace",
          "committedDate": "2024-05-14T07:05:57Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11dc94596b9ea3fae22bffee5f9225456d597f1b",
          "message": "Move to experimental",
          "committedDate": "2024-05-14T09:25:31Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "02f5ca35f319833569c9cd2e06b0f335e01b2e61",
          "message": "Update the documentation, update the configurationContext",
          "committedDate": "2024-05-17T08:42:40Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41ff1c5b8ea64f10ea365186946ea77f25c6d18b",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-05-17T08:43:05Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1753d41d548815bc9dfdd0b2b8a6fac57cfc697",
          "message": "Merge branch 'main' into dev/f-alizada/support-editorconfig",
          "committedDate": "2024-05-20T07:04:29Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d6381ce7b3b0ffcfc4c9ea4a0ffdd94d15e8ee5b",
          "message": "Address PR comments first iteration",
          "committedDate": "2024-05-20T08:17:46Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed6c50d723c1d3fbd668511128b516f7bfc569c1",
          "message": "Address PR comments",
          "committedDate": "2024-05-20T10:38:47Z",
          "author": {
            "name": "Farhad Alizada",
            "email": "falizada@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> Design capturing current implementation could be viewed here: https://github.com/dotnet/msbuild/tree/dev/f-alizada/support-editorconfig/src/Build/BuildCop/Infrastructure/EditorConfig\r\n\r\nCan you add to this doc some details about what the exposed interface to this stuff is? That is, what interfaces/whatever MSBuild code will be using to learn about editorconfig-driven configuration?\r\n\r\nAlso, does this PR introduce the patterns that we'll use to map (stuff in the .editorconfig) to (severity for rules), or is that coming later?",
        "createdAt": "2024-03-12T13:39:05Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> Can you add to this doc some details about what the exposed interface to this stuff is? That is, what interfaces/whatever MSBuild code will be using to learn about editorconfig-driven configuration?\r\n\r\nAdded example of the usage (API) and what it returns. \r\n\r\n> Also, does this PR introduce the patterns that we'll use to map (stuff in the .editorconfig) to (severity for rules), or is that coming later?\r\n\r\nThe PR introduced both -> .editorconfig parsing and mapping the configuration to the actual rules\r\n",
        "createdAt": "2024-03-19T16:17:23Z",
        "author": {
          "login": "f-alizada"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "We should probably define those strings as constants.\r\nOther option is to use `nameof` to get the same string as the property names in the target class.",
              "createdAt": "2024-03-01T17:08:10Z",
              "path": "src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +45,37 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(\"EvaluationAnalysisScope\", configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(\"severity\", configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(\"IsEnabled\", configDictionary, out bool test) ? test : null,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Seems like editrconfig parsing is flipping the keys to lowercase - should we have the extracted keys here in lowercase as well?",
              "createdAt": "2024-03-01T17:14:43Z",
              "path": "src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +45,37 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(\"EvaluationAnalysisScope\", configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(\"severity\", configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(\"IsEnabled\", configDictionary, out bool test) ? test : null,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "In first local test scenarios only  the Severity was working fine without respsecting IsEnabled property. Updated to usage of the nameof",
              "createdAt": "2024-03-04T13:37:13Z",
              "path": "src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +45,37 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(\"EvaluationAnalysisScope\", configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(\"severity\", configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(\"IsEnabled\", configDictionary, out bool test) ? test : null,",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The expected dictionary comparer should be documented here.",
              "createdAt": "2024-03-01T17:09:04Z",
              "path": "src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +45,37 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Documentation updated. Thank you",
              "createdAt": "2024-04-23T14:28:41Z",
              "path": "src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +45,37 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Let's turn this into an instance with exposed interface. This should make the testing of individual components easier.\r\n\r\n(btw. it was my mistake to left this as static from the prototyping phase)",
              "createdAt": "2024-03-01T17:12:39Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -19,56 +20,10 @@ namespace Microsoft.Build.BuildCop.Infrastructure;\n //  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n internal static class ConfigurationProvider",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Converted to the instance, interface removed for now, since we want to use the api internally for now.  ",
              "createdAt": "2024-03-11T11:57:56Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -19,56 +20,10 @@ namespace Microsoft.Build.BuildCop.Infrastructure;\n //  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n internal static class ConfigurationProvider",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    internal interface IEditorConfigParser\r\n```\r\n\r\nWe'll expose only the bare minimum that's needed for authoring cusom analyzers. Rest will remain internal.\r\nWhatever we'll expose, will need to be in `Microsoft.Build.Experimental.BuildCop` namespace - in order to be able to perform changes in the future.",
              "createdAt": "2024-03-01T17:23:10Z",
              "path": "src/Build/BuildCop/Infrastructure/EditorConfig/IEditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,16 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig\n+{\n+    public interface IEditorConfigParser",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Interface removed for now, discussed in later PR review",
              "createdAt": "2024-03-11T13:45:37Z",
              "path": "src/Build/BuildCop/Infrastructure/EditorConfig/IEditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,16 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig\n+{\n+    public interface IEditorConfigParser",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: static",
              "createdAt": "2024-03-01T17:25:33Z",
              "path": "src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Drawing.Design;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection.Metadata.Ecma335;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.BuildCop.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig\n+{\n+    public class EditorConfigParser : IEditorConfigParser\n+    {\n+        private const string EditorconfigFile = \".editorconfig\";\n+        private Dictionary<string, Dictionary<string, string>> filePathConfigCache;\n+\n+        internal EditorConfigParser()\n+        {\n+            filePathConfigCache = new Dictionary<string, Dictionary<string, string>>();\n+        }\n+\n+        public Dictionary<string, string> Parse(string filePath)\n+        {\n+            if (filePathConfigCache.ContainsKey(filePath))\n+            {\n+                return filePathConfigCache[filePath];\n+            }\n+\n+            var editorConfigDataFromFilesList = new List<EditorConfigFile>();\n+            var directoryOfTheProject = Path.GetDirectoryName(filePath);\n+            var editorConfigFile = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);\n+\n+            while (editorConfigFile != string.Empty)\n+            {\n+                var editorConfigData = EditorConfigFile.Parse(editorConfigFile);\n+                editorConfigDataFromFilesList.Add(editorConfigData);\n+\n+                if (editorConfigData.IsRoot)\n+                {\n+                    break;\n+                }\n+                else\n+                {\n+                    editorConfigFile = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFile)));\n+                }\n+            }\n+\n+            var resultingDictionary = new Dictionary<string, string>();\n+\n+            if (editorConfigDataFromFilesList.Any())\n+            {\n+                editorConfigDataFromFilesList.Reverse();\n+                \n+                foreach (var configData in editorConfigDataFromFilesList)\n+                {\n+                    foreach (var section in configData.NamedSections)\n+                    {\n+                        SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);\n+                        if (sectionNameMatcher != null)\n+                        {\n+                            if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))\n+                            {\n+                                foreach (var property in section.Properties)\n+                                {\n+                                    resultingDictionary[property.Key] = property.Value;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            filePathConfigCache[filePath] = resultingDictionary;\n+            return resultingDictionary;\n+        }\n+\n+        private string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Thank you updated.",
              "createdAt": "2024-03-04T13:34:32Z",
              "path": "src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Drawing.Design;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection.Metadata.Ecma335;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.BuildCop.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig\n+{\n+    public class EditorConfigParser : IEditorConfigParser\n+    {\n+        private const string EditorconfigFile = \".editorconfig\";\n+        private Dictionary<string, Dictionary<string, string>> filePathConfigCache;\n+\n+        internal EditorConfigParser()\n+        {\n+            filePathConfigCache = new Dictionary<string, Dictionary<string, string>>();\n+        }\n+\n+        public Dictionary<string, string> Parse(string filePath)\n+        {\n+            if (filePathConfigCache.ContainsKey(filePath))\n+            {\n+                return filePathConfigCache[filePath];\n+            }\n+\n+            var editorConfigDataFromFilesList = new List<EditorConfigFile>();\n+            var directoryOfTheProject = Path.GetDirectoryName(filePath);\n+            var editorConfigFile = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);\n+\n+            while (editorConfigFile != string.Empty)\n+            {\n+                var editorConfigData = EditorConfigFile.Parse(editorConfigFile);\n+                editorConfigDataFromFilesList.Add(editorConfigData);\n+\n+                if (editorConfigData.IsRoot)\n+                {\n+                    break;\n+                }\n+                else\n+                {\n+                    editorConfigFile = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFile)));\n+                }\n+            }\n+\n+            var resultingDictionary = new Dictionary<string, string>();\n+\n+            if (editorConfigDataFromFilesList.Any())\n+            {\n+                editorConfigDataFromFilesList.Reverse();\n+                \n+                foreach (var configData in editorConfigDataFromFilesList)\n+                {\n+                    foreach (var section in configData.NamedSections)\n+                    {\n+                        SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);\n+                        if (sectionNameMatcher != null)\n+                        {\n+                            if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))\n+                            {\n+                                foreach (var property in section.Properties)\n+                                {\n+                                    resultingDictionary[property.Key] = property.Value;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            filePathConfigCache[filePath] = resultingDictionary;\n+            return resultingDictionary;\n+        }\n+\n+        private string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Let's try to shoot for checking nullables in all new code",
              "createdAt": "2024-03-10T16:34:47Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "In case the null is met and not tested the test will fail, indicating something is wrong, do you think we need to cover this scenario in Tests as well? \r\n",
              "createdAt": "2024-03-11T11:31:57Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "@JanKrivanek  since the test will fail once the referenced object is null so author of PR will immedietly know that there is a problem. \r\nCould you please share your view on this?",
              "createdAt": "2024-03-18T14:58:20Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Which test do you have in mind? Can you mark it as accepting nullables?\r\n\r\nIf you want to bypass the static analysis check, you can allways stuff the null into nonullable variable via the \"`null!`\" - perfectly ok for the testing purposes.",
              "createdAt": "2024-03-18T16:34:41Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "All infra related tests are now fixed, however I didn't touch the tests that were copied from Roslyn implementation. ",
              "createdAt": "2024-03-18T20:43:59Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We probably should not silently ignore invalid values. We should either log the incompatible value, or throw configuration exception - both are fine. I'm slightly inclined to throwing (which will dismount the analyzer), but I'm not strongly opinionated about it.",
              "createdAt": "2024-03-10T16:40:44Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class BuildAnalyzerConfiguration_Test\n+    {\n+        [Fact]\n+        public void CreateWithNull_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(null);\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Fact]\n+        public void CreateWithEmpty_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Theory]\n+        [InlineData(\"error\", BuildAnalyzerResultSeverity.Error)]\n+        [InlineData(\"info\", BuildAnalyzerResultSeverity.Info)]\n+        [InlineData(\"warning\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"WARNING\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"non-existing-option\", null)]",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I'm not against throwing exception having that analyzer will be dismounted\r\n",
              "createdAt": "2024-03-11T10:43:36Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class BuildAnalyzerConfiguration_Test\n+    {\n+        [Fact]\n+        public void CreateWithNull_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(null);\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Fact]\n+        public void CreateWithEmpty_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Theory]\n+        [InlineData(\"error\", BuildAnalyzerResultSeverity.Error)]\n+        [InlineData(\"info\", BuildAnalyzerResultSeverity.Info)]\n+        [InlineData(\"warning\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"WARNING\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"non-existing-option\", null)]",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "It will",
              "createdAt": "2024-03-18T16:35:13Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class BuildAnalyzerConfiguration_Test\n+    {\n+        [Fact]\n+        public void CreateWithNull_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(null);\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Fact]\n+        public void CreateWithEmpty_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Theory]\n+        [InlineData(\"error\", BuildAnalyzerResultSeverity.Error)]\n+        [InlineData(\"info\", BuildAnalyzerResultSeverity.Info)]\n+        [InlineData(\"warning\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"WARNING\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"non-existing-option\", null)]",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Updated to raise the exception if it is not possible to parse the value. \r\nRelated only to the infra keys. ",
              "createdAt": "2024-03-18T20:42:40Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental.BuildCop;\n+using Shouldly;\n+using Xunit;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class BuildAnalyzerConfiguration_Test\n+    {\n+        [Fact]\n+        public void CreateWithNull_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(null);\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Fact]\n+        public void CreateWithEmpty_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());\n+            buildConfig.ShouldNotBeNull();\n+            buildConfig.Severity.ShouldBeNull();\n+            buildConfig.IsEnabled.ShouldBeNull();\n+            buildConfig.EvaluationAnalysisScope.ShouldBeNull();\n+        }\n+\n+        [Theory]\n+        [InlineData(\"error\", BuildAnalyzerResultSeverity.Error)]\n+        [InlineData(\"info\", BuildAnalyzerResultSeverity.Info)]\n+        [InlineData(\"warning\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"WARNING\", BuildAnalyzerResultSeverity.Warning)]\n+        [InlineData(\"non-existing-option\", null)]",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I suppose all the code here is just temporary copy and we eventually want to get rid of it - correct? In such case it would be good to have a tracking workitem for that.\r\n\r\nIf we want to keep the code longterm, than it would be good to get rid all the code around comparing - Shouldly can achieve this out of the box.",
              "createdAt": "2024-03-10T16:49:58Z",
              "path": "src/Analyzers.UnitTests/EditorConfig_Tests.cs",
              "diffHunk": "@@ -0,0 +1,1082 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BuildCop.Infrastructure.EditorConfig;\n+using Microsoft.Build.UnitTests;\n+using Xunit;\n+using static Microsoft.Build.BuildCop.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class EditorConfig_Tests\n+    {\n+\n+        #region AssertEqualityComparer<T>\n+        private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>\n+        {\n+            public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();\n+\n+            private static bool CanBeNull()\n+            {\n+                var type = typeof(T);\n+                return !type.GetTypeInfo().IsValueType ||\n+                    (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));\n+            }\n+\n+            public static bool IsNull(T @object)\n+            {\n+                if (!CanBeNull())\n+                {\n+                    return false;\n+                }\n+\n+                return object.Equals(@object, default(T));\n+            }\n+\n+            public static bool Equals(T left, T right)\n+            {\n+                return Instance.Equals(left, right);\n+            }\n+\n+            bool IEqualityComparer<T>.Equals(T x, T y)\n+            {\n+                if (CanBeNull())\n+                {\n+                    if (object.Equals(x, default(T)))\n+                    {\n+                        return object.Equals(y, default(T));\n+                    }\n+\n+                    if (object.Equals(y, default(T)))\n+                    {\n+                        return false;\n+                    }\n+                }\n+\n+                if (x.GetType() != y.GetType())\n+                {\n+                    return false;\n+                }\n+\n+                if (x is IEquatable<T> equatable)\n+                {\n+                    return equatable.Equals(y);\n+                }\n+\n+                if (x is IComparable<T> comparableT)\n+                {\n+                    return comparableT.CompareTo(y) == 0;\n+                }\n+\n+                if (x is IComparable comparable)\n+                {\n+                    return comparable.CompareTo(y) == 0;\n+                }\n+\n+                var enumerableX = x as IEnumerable;\n+                var enumerableY = y as IEnumerable;\n+\n+                if (enumerableX != null && enumerableY != null)\n+                {\n+                    var enumeratorX = enumerableX.GetEnumerator();\n+                    var enumeratorY = enumerableY.GetEnumerator();\n+\n+                    while (true)\n+                    {\n+                        bool hasNextX = enumeratorX.MoveNext();\n+                        bool hasNextY = enumeratorY.MoveNext();\n+\n+                        if (!hasNextX || !hasNextY)\n+                        {\n+                            return hasNextX == hasNextY;\n+                        }\n+\n+                        if (!Equals(enumeratorX.Current, enumeratorY.Current))\n+                        {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                return object.Equals(x, y);\n+            }\n+\n+            int IEqualityComparer<T>.GetHashCode(T obj)\n+            {\n+                throw new NotImplementedException();\n+            }\n+        }\n+\n+        #endregion\n+\n+        // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337\n+        #region Section Matching Tests\n+        [Fact]\n+        public void SimpleNameMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"abc\").Value;\n+            Assert.Equal(\"^.*/abc$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc\"));\n+            Assert.False(matcher.IsMatch(\"/aabc\"));\n+            Assert.False(matcher.IsMatch(\"/ abc\"));\n+            Assert.False(matcher.IsMatch(\"/cabc\"));\n+        }\n+\n+        [Fact]\n+        public void StarOnlyMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"*\").Value;\n+            Assert.Equal(\"^.*/[^/]*$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc\"));\n+            Assert.True(matcher.IsMatch(\"/123\"));\n+            Assert.True(matcher.IsMatch(\"/abc/123\"));\n+        }\n+\n+        [Fact]\n+        public void StarNameMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"*.cs\").Value;\n+            Assert.Equal(\"^.*/[^/]*\\\\.cs$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/123.cs\"));\n+            Assert.True(matcher.IsMatch(\"/dir/subpath.cs\"));\n+            // Only '/' is defined as a directory separator, so the caller\n+            // is responsible for converting any other machine directory\n+            // separators to '/' before matching\n+            Assert.True(matcher.IsMatch(\"/dir\\\\subpath.cs\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abc.vb\"));\n+        }\n+\n+        [Fact]\n+        public void StarStarNameMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"**.cs\").Value;\n+            Assert.Equal(\"^.*/.*\\\\.cs$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/dir/subpath.cs\"));\n+        }\n+\n+        [Fact]\n+        public void EscapeDot()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"...\").Value;\n+            Assert.Equal(\"^.*/\\\\.\\\\.\\\\.$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/...\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/...\"));\n+            Assert.False(matcher.IsMatch(\"/aaa\"));\n+            Assert.False(matcher.IsMatch(\"/???\"));\n+            Assert.False(matcher.IsMatch(\"/abc\"));\n+        }\n+\n+        [Fact]\n+        public void EndBackslashMatch()\n+        {\n+            SectionNameMatcher? matcher = TryCreateSectionNameMatcher(\"abc\\\\\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void QuestionMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab?def\").Value;\n+            Assert.Equal(\"^.*/ab.def$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abcdef\"));\n+            Assert.True(matcher.IsMatch(\"/ab?def\"));\n+            Assert.True(matcher.IsMatch(\"/abzdef\"));\n+            Assert.True(matcher.IsMatch(\"/ab/def\"));\n+            Assert.True(matcher.IsMatch(\"/ab\\\\def\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralBackslash()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab\\\\\\\\c\").Value;\n+            Assert.Equal(\"^.*/ab\\\\\\\\c$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/ab\\\\c\"));\n+            Assert.False(matcher.IsMatch(\"/ab/c\"));\n+            Assert.False(matcher.IsMatch(\"/ab\\\\\\\\c\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralStars()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"\\\\***\\\\*\\\\**\").Value;\n+            Assert.Equal(\"^.*/\\\\*.*\\\\*\\\\*[^/]*$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/*ab/cd**efg*\"));\n+            Assert.False(matcher.IsMatch(\"/ab/cd**efg*\"));\n+            Assert.False(matcher.IsMatch(\"/*ab/cd*efg*\"));\n+            Assert.False(matcher.IsMatch(\"/*ab/cd**ef/gh\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralQuestions()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"\\\\??\\\\?*\\\\??\").Value;\n+            Assert.Equal(\"^.*/\\\\?.\\\\?[^/]*\\\\?.$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/?a?cde?f\"));\n+            Assert.True(matcher.IsMatch(\"/???????f\"));\n+            Assert.False(matcher.IsMatch(\"/aaaaaaaa\"));\n+            Assert.False(matcher.IsMatch(\"/aa?cde?f\"));\n+            Assert.False(matcher.IsMatch(\"/?a?cdexf\"));\n+            Assert.False(matcher.IsMatch(\"/?axcde?f\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralBraces()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"abc\\\\{\\\\}def\").Value;\n+            Assert.Equal(@\"^.*/abc\\{}def$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc{}def\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc{}def\"));\n+            Assert.False(matcher.IsMatch(\"/abcdef\"));\n+            Assert.False(matcher.IsMatch(\"/abc}{def\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralComma()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"abc\\\\,def\").Value;\n+            Assert.Equal(\"^.*/abc,def$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc,def\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc,def\"));\n+            Assert.False(matcher.IsMatch(\"/abcdef\"));\n+            Assert.False(matcher.IsMatch(\"/abc\\\\,def\"));\n+            Assert.False(matcher.IsMatch(\"/abc`def\"));\n+        }\n+\n+        [Fact]\n+        public void SimpleChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"*.{cs,vb,fs}\").Value;\n+            Assert.Equal(\"^.*/[^/]*\\\\.(?:cs|vb|fs)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.vb\"));\n+            Assert.True(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc.vb\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc.fs\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abcxcs\"));\n+            Assert.False(matcher.IsMatch(\"/abcxvb\"));\n+            Assert.False(matcher.IsMatch(\"/abcxfs\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/abcxcs\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/abcxcb\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/abcxcs\"));\n+        }\n+\n+        [Fact]\n+        public void OneChoiceHasSlashes()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{*.cs,subdir/test.vb}\").Value;\n+            // This is an interesting case that may be counterintuitive.  A reasonable understanding\n+            // of the section matching could interpret the choice as generating multiple identical\n+            // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the\n+            // same properties in each section. This is somewhat true, but the rules of how the matching\n+            // prefixes are constructed violate this assumption because they are defined as whether or\n+            // not a section contains a slash, not whether any of the choices contain a slash. So while\n+            // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in\n+            // the second choice make this into '/*.cs', effectively matching only files in the root\n+            // directory of the match, instead of all subdirectories.\n+            Assert.Equal(\"^/(?:[^/]*\\\\.cs|subdir/test\\\\.vb)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.vb\"));\n+\n+            Assert.False(matcher.IsMatch(\"/subdir/test.cs\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/subdir/test.vb\"));\n+            Assert.False(matcher.IsMatch(\"/test.vb\"));\n+        }\n+\n+        [Fact]\n+        public void EmptyChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{}\").Value;\n+            Assert.Equal(\"^.*/(?:)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/\"));\n+            Assert.False(matcher.IsMatch(\"/.\"));\n+            Assert.False(matcher.IsMatch(\"/anything\"));\n+        }\n+\n+        [Fact]\n+        public void SingleChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{*.cs}\").Value;\n+            Assert.Equal(\"^.*/(?:[^/]*\\\\.cs)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.cs\"));\n+            Assert.False(matcher.IsMatch(\"test.vb\"));\n+            Assert.False(matcher.IsMatch(\"testxcs\"));\n+        }\n+\n+        [Fact]\n+        public void UnmatchedBraces()\n+        {\n+            SectionNameMatcher? matcher = TryCreateSectionNameMatcher(\"{{{{}}\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CommaOutsideBraces()\n+        {\n+            SectionNameMatcher? matcher = TryCreateSectionNameMatcher(\"abc,def\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void RecursiveChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{test{.cs,.vb},other.{a{bb,cc}}}\").Value;\n+            Assert.Equal(\"^.*/(?:test(?:\\\\.cs|\\\\.vb)|other\\\\.(?:a(?:bb|cc)))$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/test.vb\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.vb\"));\n+            Assert.True(matcher.IsMatch(\"/other.abb\"));\n+            Assert.True(matcher.IsMatch(\"/other.acc\"));\n+\n+            Assert.False(matcher.IsMatch(\"/test.fs\"));\n+            Assert.False(matcher.IsMatch(\"/other.bbb\"));\n+            Assert.False(matcher.IsMatch(\"/other.ccc\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/other.bbb\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/other.ccc\"));\n+        }\n+\n+        [Fact]\n+        public void DashChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab{-}cd{-,}ef\").Value;\n+            Assert.Equal(\"^.*/ab(?:-)cd(?:-|)ef$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/ab-cd-ef\"));\n+            Assert.True(matcher.IsMatch(\"/ab-cdef\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abcdef\"));\n+            Assert.False(matcher.IsMatch(\"/ab--cd-ef\"));\n+            Assert.False(matcher.IsMatch(\"/ab--cd--ef\"));\n+        }\n+\n+        [Fact]\n+        public void MiddleMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab{cs,vb,fs}cd\").Value;\n+            Assert.Equal(\"^.*/ab(?:cs|vb|fs)cd$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abcscd\"));\n+            Assert.True(matcher.IsMatch(\"/abvbcd\"));\n+            Assert.True(matcher.IsMatch(\"/abfscd\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abcs\"));\n+            Assert.False(matcher.IsMatch(\"/abcd\"));\n+            Assert.False(matcher.IsMatch(\"/vbcd\"));\n+        }\n+\n+        private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)\n+        {\n+            yield return (s1, s2);\n+            yield return (s2, s1);\n+        }\n+\n+        [Fact]\n+        public void NumberMatch()\n+        {\n+            foreach (var (i1, i2) in RangeAndInverse(\"0\", \"10\"))\n+            {\n+                var matcher = TryCreateSectionNameMatcher($\"{{{i1}..{i2}}}\").Value;\n+\n+                Assert.True(matcher.IsMatch(\"/0\"));\n+                Assert.True(matcher.IsMatch(\"/10\"));\n+                Assert.True(matcher.IsMatch(\"/5\"));\n+                Assert.True(matcher.IsMatch(\"/000005\"));\n+                Assert.False(matcher.IsMatch(\"/-1\"));\n+                Assert.False(matcher.IsMatch(\"/-00000001\"));\n+                Assert.False(matcher.IsMatch(\"/11\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void NumberMatchNegativeRange()\n+        {\n+            foreach (var (i1, i2) in RangeAndInverse(\"-10\", \"0\"))\n+            {\n+                var matcher = TryCreateSectionNameMatcher($\"{{{i1}..{i2}}}\").Value;\n+\n+                Assert.True(matcher.IsMatch(\"/0\"));\n+                Assert.True(matcher.IsMatch(\"/-10\"));\n+                Assert.True(matcher.IsMatch(\"/-5\"));\n+                Assert.False(matcher.IsMatch(\"/1\"));\n+                Assert.False(matcher.IsMatch(\"/-11\"));\n+                Assert.False(matcher.IsMatch(\"/--0\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void NumberMatchNegToPos()\n+        {\n+            foreach (var (i1, i2) in RangeAndInverse(\"-10\", \"10\"))\n+            {\n+                var matcher = TryCreateSectionNameMatcher($\"{{{i1}..{i2}}}\").Value;\n+\n+                Assert.True(matcher.IsMatch(\"/0\"));\n+                Assert.True(matcher.IsMatch(\"/-5\"));\n+                Assert.True(matcher.IsMatch(\"/5\"));\n+                Assert.True(matcher.IsMatch(\"/-10\"));\n+                Assert.True(matcher.IsMatch(\"/10\"));\n+                Assert.False(matcher.IsMatch(\"/-11\"));\n+                Assert.False(matcher.IsMatch(\"/11\"));\n+                Assert.False(matcher.IsMatch(\"/--0\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void MultipleNumberRanges()\n+        {\n+            foreach (var matchString in new[] { \"a{-10..0}b{0..10}\", \"a{0..-10}b{10..0}\" })\n+            {\n+                var matcher = TryCreateSectionNameMatcher(matchString).Value;\n+\n+                Assert.True(matcher.IsMatch(\"/a0b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-5b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-5b5\"));\n+                Assert.True(matcher.IsMatch(\"/a-5b10\"));\n+                Assert.True(matcher.IsMatch(\"/a-10b10\"));\n+                Assert.True(matcher.IsMatch(\"/a-10b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-0b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-0b-0\"));\n+\n+                Assert.False(matcher.IsMatch(\"/a-11b10\"));\n+                Assert.False(matcher.IsMatch(\"/a-11b10\"));\n+                Assert.False(matcher.IsMatch(\"/a-10b11\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void BadNumberRanges()\n+        {\n+            var matcherOpt = TryCreateSectionNameMatcher(\"{0..\");\n+\n+            Assert.Null(matcherOpt);\n+\n+            var matcher = TryCreateSectionNameMatcher(\"{0..}\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/0..\"));\n+            Assert.False(matcher.IsMatch(\"/0\"));\n+            Assert.False(matcher.IsMatch(\"/0.\"));\n+            Assert.False(matcher.IsMatch(\"/0abc\"));\n+\n+            matcher = TryCreateSectionNameMatcher(\"{0..A}\").Value;\n+            Assert.True(matcher.IsMatch(\"/0..A\"));\n+            Assert.False(matcher.IsMatch(\"/0\"));\n+            Assert.False(matcher.IsMatch(\"/0abc\"));\n+\n+            // The reference implementation uses atoi here so we can presume\n+            // numbers out of range of Int32 are not well supported\n+            matcherOpt = TryCreateSectionNameMatcher($\"{{0..{UInt32.MaxValue}}}\");\n+\n+            Assert.Null(matcherOpt);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassSimple()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"*.[cf]s\").Value;\n+            Assert.Equal(@\"^.*/[^/]*\\.[cf]s$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vs\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassNegative()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"*.[!cf]s\").Value;\n+            Assert.Equal(@\"^.*/[^/]*\\.[^cf]s$\", matcher.Regex.ToString());\n+\n+            Assert.False(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.vs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.xs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vxs\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassCaret()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"*.[^cf]s\").Value;\n+            Assert.Equal(@\"^.*/[^/]*\\.[\\^cf]s$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.^s\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.xs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vxs\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassRange()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[0-9]x\").Value;\n+            Assert.Equal(\"^.*/[0-9]x$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/0x\"));\n+            Assert.True(matcher.IsMatch(\"/1x\"));\n+            Assert.True(matcher.IsMatch(\"/9x\"));\n+            Assert.False(matcher.IsMatch(\"/yx\"));\n+            Assert.False(matcher.IsMatch(\"/00x\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassNegativeRange()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[!0-9]x\").Value;\n+            Assert.Equal(\"^.*/[^0-9]x$\", matcher.Regex.ToString());\n+\n+            Assert.False(matcher.IsMatch(\"/0x\"));\n+            Assert.False(matcher.IsMatch(\"/1x\"));\n+            Assert.False(matcher.IsMatch(\"/9x\"));\n+            Assert.True(matcher.IsMatch(\"/yx\"));\n+            Assert.False(matcher.IsMatch(\"/00x\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassRangeAndChoice()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[ab0-9]x\").Value;\n+            Assert.Equal(\"^.*/[ab0-9]x$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/ax\"));\n+            Assert.True(matcher.IsMatch(\"/bx\"));\n+            Assert.True(matcher.IsMatch(\"/0x\"));\n+            Assert.True(matcher.IsMatch(\"/1x\"));\n+            Assert.True(matcher.IsMatch(\"/9x\"));\n+            Assert.False(matcher.IsMatch(\"/yx\"));\n+            Assert.False(matcher.IsMatch(\"/0ax\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassOpenEnded()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEscapedOpenEnded()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[\\]\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEscapeAtEnd()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[\\\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassOpenBracketInside()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[[a]bc\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/abc\"));\n+            Assert.True(matcher.IsMatch(\"/[bc\"));\n+            Assert.False(matcher.IsMatch(\"/ab\"));\n+            Assert.False(matcher.IsMatch(\"/[b\"));\n+            Assert.False(matcher.IsMatch(\"/bc\"));\n+            Assert.False(matcher.IsMatch(\"/ac\"));\n+            Assert.False(matcher.IsMatch(\"/[c\"));\n+\n+            Assert.Equal(@\"^.*/[\\[a]bc$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassStartingDash()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[-ac]bd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/abd\"));\n+            Assert.True(matcher.IsMatch(\"/cbd\"));\n+            Assert.True(matcher.IsMatch(\"/-bd\"));\n+            Assert.False(matcher.IsMatch(\"/bbd\"));\n+            Assert.False(matcher.IsMatch(\"/-cd\"));\n+            Assert.False(matcher.IsMatch(\"/bcd\"));\n+\n+            Assert.Equal(@\"^.*/[-ac]bd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEndingDash()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[ac-]bd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/abd\"));\n+            Assert.True(matcher.IsMatch(\"/cbd\"));\n+            Assert.True(matcher.IsMatch(\"/-bd\"));\n+            Assert.False(matcher.IsMatch(\"/bbd\"));\n+            Assert.False(matcher.IsMatch(\"/-cd\"));\n+            Assert.False(matcher.IsMatch(\"/bcd\"));\n+\n+            Assert.Equal(@\"^.*/[ac-]bd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEndBracketAfter()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[ab]]cd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/a]cd\"));\n+            Assert.True(matcher.IsMatch(\"/b]cd\"));\n+            Assert.False(matcher.IsMatch(\"/acd\"));\n+            Assert.False(matcher.IsMatch(\"/bcd\"));\n+            Assert.False(matcher.IsMatch(\"/acd\"));\n+\n+            Assert.Equal(@\"^.*/[ab]]cd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEscapeBackslash()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[ab\\\\]cd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/acd\"));\n+            Assert.True(matcher.IsMatch(\"/bcd\"));\n+            Assert.True(matcher.IsMatch(\"/\\\\cd\"));\n+            Assert.False(matcher.IsMatch(\"/dcd\"));\n+            Assert.False(matcher.IsMatch(\"/\\\\\\\\cd\"));\n+            Assert.False(matcher.IsMatch(\"/cd\"));\n+\n+            Assert.Equal(@\"^.*/[ab\\\\]cd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void EscapeOpenBracket()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"ab\\[cd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/ab[cd\"));\n+            Assert.False(matcher.IsMatch(\"/ab[[cd\"));\n+            Assert.False(matcher.IsMatch(\"/abc\"));\n+            Assert.False(matcher.IsMatch(\"/abd\"));\n+\n+            Assert.Equal(@\"^.*/ab\\[cd$\", matcher.Regex.ToString());\n+        }\n+        #endregion\n+\n+        #region Parsing Tests\n+\n+        private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)\n+        {\n+            var expectedSet = new HashSet<T>(expected, comparer);\n+            var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);\n+            Assert.True(result, message);\n+        }\n+\n+        private static void Equal<T>(",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Ideally we will have the shared code: https://github.com/dotnet/roslyn/issues/72324 and the tests should be covered there, leaving msbuild to test integration part. ",
              "createdAt": "2024-03-11T10:39:15Z",
              "path": "src/Analyzers.UnitTests/EditorConfig_Tests.cs",
              "diffHunk": "@@ -0,0 +1,1082 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BuildCop.Infrastructure.EditorConfig;\n+using Microsoft.Build.UnitTests;\n+using Xunit;\n+using static Microsoft.Build.BuildCop.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class EditorConfig_Tests\n+    {\n+\n+        #region AssertEqualityComparer<T>\n+        private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>\n+        {\n+            public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();\n+\n+            private static bool CanBeNull()\n+            {\n+                var type = typeof(T);\n+                return !type.GetTypeInfo().IsValueType ||\n+                    (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));\n+            }\n+\n+            public static bool IsNull(T @object)\n+            {\n+                if (!CanBeNull())\n+                {\n+                    return false;\n+                }\n+\n+                return object.Equals(@object, default(T));\n+            }\n+\n+            public static bool Equals(T left, T right)\n+            {\n+                return Instance.Equals(left, right);\n+            }\n+\n+            bool IEqualityComparer<T>.Equals(T x, T y)\n+            {\n+                if (CanBeNull())\n+                {\n+                    if (object.Equals(x, default(T)))\n+                    {\n+                        return object.Equals(y, default(T));\n+                    }\n+\n+                    if (object.Equals(y, default(T)))\n+                    {\n+                        return false;\n+                    }\n+                }\n+\n+                if (x.GetType() != y.GetType())\n+                {\n+                    return false;\n+                }\n+\n+                if (x is IEquatable<T> equatable)\n+                {\n+                    return equatable.Equals(y);\n+                }\n+\n+                if (x is IComparable<T> comparableT)\n+                {\n+                    return comparableT.CompareTo(y) == 0;\n+                }\n+\n+                if (x is IComparable comparable)\n+                {\n+                    return comparable.CompareTo(y) == 0;\n+                }\n+\n+                var enumerableX = x as IEnumerable;\n+                var enumerableY = y as IEnumerable;\n+\n+                if (enumerableX != null && enumerableY != null)\n+                {\n+                    var enumeratorX = enumerableX.GetEnumerator();\n+                    var enumeratorY = enumerableY.GetEnumerator();\n+\n+                    while (true)\n+                    {\n+                        bool hasNextX = enumeratorX.MoveNext();\n+                        bool hasNextY = enumeratorY.MoveNext();\n+\n+                        if (!hasNextX || !hasNextY)\n+                        {\n+                            return hasNextX == hasNextY;\n+                        }\n+\n+                        if (!Equals(enumeratorX.Current, enumeratorY.Current))\n+                        {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                return object.Equals(x, y);\n+            }\n+\n+            int IEqualityComparer<T>.GetHashCode(T obj)\n+            {\n+                throw new NotImplementedException();\n+            }\n+        }\n+\n+        #endregion\n+\n+        // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337\n+        #region Section Matching Tests\n+        [Fact]\n+        public void SimpleNameMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"abc\").Value;\n+            Assert.Equal(\"^.*/abc$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc\"));\n+            Assert.False(matcher.IsMatch(\"/aabc\"));\n+            Assert.False(matcher.IsMatch(\"/ abc\"));\n+            Assert.False(matcher.IsMatch(\"/cabc\"));\n+        }\n+\n+        [Fact]\n+        public void StarOnlyMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"*\").Value;\n+            Assert.Equal(\"^.*/[^/]*$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc\"));\n+            Assert.True(matcher.IsMatch(\"/123\"));\n+            Assert.True(matcher.IsMatch(\"/abc/123\"));\n+        }\n+\n+        [Fact]\n+        public void StarNameMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"*.cs\").Value;\n+            Assert.Equal(\"^.*/[^/]*\\\\.cs$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/123.cs\"));\n+            Assert.True(matcher.IsMatch(\"/dir/subpath.cs\"));\n+            // Only '/' is defined as a directory separator, so the caller\n+            // is responsible for converting any other machine directory\n+            // separators to '/' before matching\n+            Assert.True(matcher.IsMatch(\"/dir\\\\subpath.cs\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abc.vb\"));\n+        }\n+\n+        [Fact]\n+        public void StarStarNameMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"**.cs\").Value;\n+            Assert.Equal(\"^.*/.*\\\\.cs$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/dir/subpath.cs\"));\n+        }\n+\n+        [Fact]\n+        public void EscapeDot()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"...\").Value;\n+            Assert.Equal(\"^.*/\\\\.\\\\.\\\\.$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/...\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/...\"));\n+            Assert.False(matcher.IsMatch(\"/aaa\"));\n+            Assert.False(matcher.IsMatch(\"/???\"));\n+            Assert.False(matcher.IsMatch(\"/abc\"));\n+        }\n+\n+        [Fact]\n+        public void EndBackslashMatch()\n+        {\n+            SectionNameMatcher? matcher = TryCreateSectionNameMatcher(\"abc\\\\\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void QuestionMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab?def\").Value;\n+            Assert.Equal(\"^.*/ab.def$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abcdef\"));\n+            Assert.True(matcher.IsMatch(\"/ab?def\"));\n+            Assert.True(matcher.IsMatch(\"/abzdef\"));\n+            Assert.True(matcher.IsMatch(\"/ab/def\"));\n+            Assert.True(matcher.IsMatch(\"/ab\\\\def\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralBackslash()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab\\\\\\\\c\").Value;\n+            Assert.Equal(\"^.*/ab\\\\\\\\c$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/ab\\\\c\"));\n+            Assert.False(matcher.IsMatch(\"/ab/c\"));\n+            Assert.False(matcher.IsMatch(\"/ab\\\\\\\\c\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralStars()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"\\\\***\\\\*\\\\**\").Value;\n+            Assert.Equal(\"^.*/\\\\*.*\\\\*\\\\*[^/]*$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/*ab/cd**efg*\"));\n+            Assert.False(matcher.IsMatch(\"/ab/cd**efg*\"));\n+            Assert.False(matcher.IsMatch(\"/*ab/cd*efg*\"));\n+            Assert.False(matcher.IsMatch(\"/*ab/cd**ef/gh\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralQuestions()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"\\\\??\\\\?*\\\\??\").Value;\n+            Assert.Equal(\"^.*/\\\\?.\\\\?[^/]*\\\\?.$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/?a?cde?f\"));\n+            Assert.True(matcher.IsMatch(\"/???????f\"));\n+            Assert.False(matcher.IsMatch(\"/aaaaaaaa\"));\n+            Assert.False(matcher.IsMatch(\"/aa?cde?f\"));\n+            Assert.False(matcher.IsMatch(\"/?a?cdexf\"));\n+            Assert.False(matcher.IsMatch(\"/?axcde?f\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralBraces()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"abc\\\\{\\\\}def\").Value;\n+            Assert.Equal(@\"^.*/abc\\{}def$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc{}def\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc{}def\"));\n+            Assert.False(matcher.IsMatch(\"/abcdef\"));\n+            Assert.False(matcher.IsMatch(\"/abc}{def\"));\n+        }\n+\n+        [Fact]\n+        public void LiteralComma()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"abc\\\\,def\").Value;\n+            Assert.Equal(\"^.*/abc,def$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc,def\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc,def\"));\n+            Assert.False(matcher.IsMatch(\"/abcdef\"));\n+            Assert.False(matcher.IsMatch(\"/abc\\\\,def\"));\n+            Assert.False(matcher.IsMatch(\"/abc`def\"));\n+        }\n+\n+        [Fact]\n+        public void SimpleChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"*.{cs,vb,fs}\").Value;\n+            Assert.Equal(\"^.*/[^/]*\\\\.(?:cs|vb|fs)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.vb\"));\n+            Assert.True(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc.vb\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/abc.fs\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abcxcs\"));\n+            Assert.False(matcher.IsMatch(\"/abcxvb\"));\n+            Assert.False(matcher.IsMatch(\"/abcxfs\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/abcxcs\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/abcxcb\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/abcxcs\"));\n+        }\n+\n+        [Fact]\n+        public void OneChoiceHasSlashes()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{*.cs,subdir/test.vb}\").Value;\n+            // This is an interesting case that may be counterintuitive.  A reasonable understanding\n+            // of the section matching could interpret the choice as generating multiple identical\n+            // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the\n+            // same properties in each section. This is somewhat true, but the rules of how the matching\n+            // prefixes are constructed violate this assumption because they are defined as whether or\n+            // not a section contains a slash, not whether any of the choices contain a slash. So while\n+            // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in\n+            // the second choice make this into '/*.cs', effectively matching only files in the root\n+            // directory of the match, instead of all subdirectories.\n+            Assert.Equal(\"^/(?:[^/]*\\\\.cs|subdir/test\\\\.vb)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.vb\"));\n+\n+            Assert.False(matcher.IsMatch(\"/subdir/test.cs\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/subdir/test.vb\"));\n+            Assert.False(matcher.IsMatch(\"/test.vb\"));\n+        }\n+\n+        [Fact]\n+        public void EmptyChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{}\").Value;\n+            Assert.Equal(\"^.*/(?:)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/\"));\n+            Assert.False(matcher.IsMatch(\"/.\"));\n+            Assert.False(matcher.IsMatch(\"/anything\"));\n+        }\n+\n+        [Fact]\n+        public void SingleChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{*.cs}\").Value;\n+            Assert.Equal(\"^.*/(?:[^/]*\\\\.cs)$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.cs\"));\n+            Assert.False(matcher.IsMatch(\"test.vb\"));\n+            Assert.False(matcher.IsMatch(\"testxcs\"));\n+        }\n+\n+        [Fact]\n+        public void UnmatchedBraces()\n+        {\n+            SectionNameMatcher? matcher = TryCreateSectionNameMatcher(\"{{{{}}\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CommaOutsideBraces()\n+        {\n+            SectionNameMatcher? matcher = TryCreateSectionNameMatcher(\"abc,def\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void RecursiveChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"{test{.cs,.vb},other.{a{bb,cc}}}\").Value;\n+            Assert.Equal(\"^.*/(?:test(?:\\\\.cs|\\\\.vb)|other\\\\.(?:a(?:bb|cc)))$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/test.vb\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.cs\"));\n+            Assert.True(matcher.IsMatch(\"/subdir/test.vb\"));\n+            Assert.True(matcher.IsMatch(\"/other.abb\"));\n+            Assert.True(matcher.IsMatch(\"/other.acc\"));\n+\n+            Assert.False(matcher.IsMatch(\"/test.fs\"));\n+            Assert.False(matcher.IsMatch(\"/other.bbb\"));\n+            Assert.False(matcher.IsMatch(\"/other.ccc\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/other.bbb\"));\n+            Assert.False(matcher.IsMatch(\"/subdir/other.ccc\"));\n+        }\n+\n+        [Fact]\n+        public void DashChoice()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab{-}cd{-,}ef\").Value;\n+            Assert.Equal(\"^.*/ab(?:-)cd(?:-|)ef$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/ab-cd-ef\"));\n+            Assert.True(matcher.IsMatch(\"/ab-cdef\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abcdef\"));\n+            Assert.False(matcher.IsMatch(\"/ab--cd-ef\"));\n+            Assert.False(matcher.IsMatch(\"/ab--cd--ef\"));\n+        }\n+\n+        [Fact]\n+        public void MiddleMatch()\n+        {\n+            SectionNameMatcher matcher = TryCreateSectionNameMatcher(\"ab{cs,vb,fs}cd\").Value;\n+            Assert.Equal(\"^.*/ab(?:cs|vb|fs)cd$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abcscd\"));\n+            Assert.True(matcher.IsMatch(\"/abvbcd\"));\n+            Assert.True(matcher.IsMatch(\"/abfscd\"));\n+\n+            Assert.False(matcher.IsMatch(\"/abcs\"));\n+            Assert.False(matcher.IsMatch(\"/abcd\"));\n+            Assert.False(matcher.IsMatch(\"/vbcd\"));\n+        }\n+\n+        private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)\n+        {\n+            yield return (s1, s2);\n+            yield return (s2, s1);\n+        }\n+\n+        [Fact]\n+        public void NumberMatch()\n+        {\n+            foreach (var (i1, i2) in RangeAndInverse(\"0\", \"10\"))\n+            {\n+                var matcher = TryCreateSectionNameMatcher($\"{{{i1}..{i2}}}\").Value;\n+\n+                Assert.True(matcher.IsMatch(\"/0\"));\n+                Assert.True(matcher.IsMatch(\"/10\"));\n+                Assert.True(matcher.IsMatch(\"/5\"));\n+                Assert.True(matcher.IsMatch(\"/000005\"));\n+                Assert.False(matcher.IsMatch(\"/-1\"));\n+                Assert.False(matcher.IsMatch(\"/-00000001\"));\n+                Assert.False(matcher.IsMatch(\"/11\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void NumberMatchNegativeRange()\n+        {\n+            foreach (var (i1, i2) in RangeAndInverse(\"-10\", \"0\"))\n+            {\n+                var matcher = TryCreateSectionNameMatcher($\"{{{i1}..{i2}}}\").Value;\n+\n+                Assert.True(matcher.IsMatch(\"/0\"));\n+                Assert.True(matcher.IsMatch(\"/-10\"));\n+                Assert.True(matcher.IsMatch(\"/-5\"));\n+                Assert.False(matcher.IsMatch(\"/1\"));\n+                Assert.False(matcher.IsMatch(\"/-11\"));\n+                Assert.False(matcher.IsMatch(\"/--0\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void NumberMatchNegToPos()\n+        {\n+            foreach (var (i1, i2) in RangeAndInverse(\"-10\", \"10\"))\n+            {\n+                var matcher = TryCreateSectionNameMatcher($\"{{{i1}..{i2}}}\").Value;\n+\n+                Assert.True(matcher.IsMatch(\"/0\"));\n+                Assert.True(matcher.IsMatch(\"/-5\"));\n+                Assert.True(matcher.IsMatch(\"/5\"));\n+                Assert.True(matcher.IsMatch(\"/-10\"));\n+                Assert.True(matcher.IsMatch(\"/10\"));\n+                Assert.False(matcher.IsMatch(\"/-11\"));\n+                Assert.False(matcher.IsMatch(\"/11\"));\n+                Assert.False(matcher.IsMatch(\"/--0\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void MultipleNumberRanges()\n+        {\n+            foreach (var matchString in new[] { \"a{-10..0}b{0..10}\", \"a{0..-10}b{10..0}\" })\n+            {\n+                var matcher = TryCreateSectionNameMatcher(matchString).Value;\n+\n+                Assert.True(matcher.IsMatch(\"/a0b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-5b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-5b5\"));\n+                Assert.True(matcher.IsMatch(\"/a-5b10\"));\n+                Assert.True(matcher.IsMatch(\"/a-10b10\"));\n+                Assert.True(matcher.IsMatch(\"/a-10b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-0b0\"));\n+                Assert.True(matcher.IsMatch(\"/a-0b-0\"));\n+\n+                Assert.False(matcher.IsMatch(\"/a-11b10\"));\n+                Assert.False(matcher.IsMatch(\"/a-11b10\"));\n+                Assert.False(matcher.IsMatch(\"/a-10b11\"));\n+            }\n+        }\n+\n+        [Fact]\n+        public void BadNumberRanges()\n+        {\n+            var matcherOpt = TryCreateSectionNameMatcher(\"{0..\");\n+\n+            Assert.Null(matcherOpt);\n+\n+            var matcher = TryCreateSectionNameMatcher(\"{0..}\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/0..\"));\n+            Assert.False(matcher.IsMatch(\"/0\"));\n+            Assert.False(matcher.IsMatch(\"/0.\"));\n+            Assert.False(matcher.IsMatch(\"/0abc\"));\n+\n+            matcher = TryCreateSectionNameMatcher(\"{0..A}\").Value;\n+            Assert.True(matcher.IsMatch(\"/0..A\"));\n+            Assert.False(matcher.IsMatch(\"/0\"));\n+            Assert.False(matcher.IsMatch(\"/0abc\"));\n+\n+            // The reference implementation uses atoi here so we can presume\n+            // numbers out of range of Int32 are not well supported\n+            matcherOpt = TryCreateSectionNameMatcher($\"{{0..{UInt32.MaxValue}}}\");\n+\n+            Assert.Null(matcherOpt);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassSimple()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"*.[cf]s\").Value;\n+            Assert.Equal(@\"^.*/[^/]*\\.[cf]s$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vs\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassNegative()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"*.[!cf]s\").Value;\n+            Assert.Equal(@\"^.*/[^/]*\\.[^cf]s$\", matcher.Regex.ToString());\n+\n+            Assert.False(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.vs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.xs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vxs\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassCaret()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"*.[^cf]s\").Value;\n+            Assert.Equal(@\"^.*/[^/]*\\.[\\^cf]s$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/abc.cs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.fs\"));\n+            Assert.True(matcher.IsMatch(\"/abc.^s\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.xs\"));\n+            Assert.False(matcher.IsMatch(\"/abc.vxs\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassRange()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[0-9]x\").Value;\n+            Assert.Equal(\"^.*/[0-9]x$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/0x\"));\n+            Assert.True(matcher.IsMatch(\"/1x\"));\n+            Assert.True(matcher.IsMatch(\"/9x\"));\n+            Assert.False(matcher.IsMatch(\"/yx\"));\n+            Assert.False(matcher.IsMatch(\"/00x\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassNegativeRange()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[!0-9]x\").Value;\n+            Assert.Equal(\"^.*/[^0-9]x$\", matcher.Regex.ToString());\n+\n+            Assert.False(matcher.IsMatch(\"/0x\"));\n+            Assert.False(matcher.IsMatch(\"/1x\"));\n+            Assert.False(matcher.IsMatch(\"/9x\"));\n+            Assert.True(matcher.IsMatch(\"/yx\"));\n+            Assert.False(matcher.IsMatch(\"/00x\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassRangeAndChoice()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[ab0-9]x\").Value;\n+            Assert.Equal(\"^.*/[ab0-9]x$\", matcher.Regex.ToString());\n+\n+            Assert.True(matcher.IsMatch(\"/ax\"));\n+            Assert.True(matcher.IsMatch(\"/bx\"));\n+            Assert.True(matcher.IsMatch(\"/0x\"));\n+            Assert.True(matcher.IsMatch(\"/1x\"));\n+            Assert.True(matcher.IsMatch(\"/9x\"));\n+            Assert.False(matcher.IsMatch(\"/yx\"));\n+            Assert.False(matcher.IsMatch(\"/0ax\"));\n+        }\n+\n+        [Fact]\n+        public void CharacterClassOpenEnded()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(\"[\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEscapedOpenEnded()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[\\]\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEscapeAtEnd()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[\\\");\n+            Assert.Null(matcher);\n+        }\n+\n+        [Fact]\n+        public void CharacterClassOpenBracketInside()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[[a]bc\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/abc\"));\n+            Assert.True(matcher.IsMatch(\"/[bc\"));\n+            Assert.False(matcher.IsMatch(\"/ab\"));\n+            Assert.False(matcher.IsMatch(\"/[b\"));\n+            Assert.False(matcher.IsMatch(\"/bc\"));\n+            Assert.False(matcher.IsMatch(\"/ac\"));\n+            Assert.False(matcher.IsMatch(\"/[c\"));\n+\n+            Assert.Equal(@\"^.*/[\\[a]bc$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassStartingDash()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[-ac]bd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/abd\"));\n+            Assert.True(matcher.IsMatch(\"/cbd\"));\n+            Assert.True(matcher.IsMatch(\"/-bd\"));\n+            Assert.False(matcher.IsMatch(\"/bbd\"));\n+            Assert.False(matcher.IsMatch(\"/-cd\"));\n+            Assert.False(matcher.IsMatch(\"/bcd\"));\n+\n+            Assert.Equal(@\"^.*/[-ac]bd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEndingDash()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[ac-]bd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/abd\"));\n+            Assert.True(matcher.IsMatch(\"/cbd\"));\n+            Assert.True(matcher.IsMatch(\"/-bd\"));\n+            Assert.False(matcher.IsMatch(\"/bbd\"));\n+            Assert.False(matcher.IsMatch(\"/-cd\"));\n+            Assert.False(matcher.IsMatch(\"/bcd\"));\n+\n+            Assert.Equal(@\"^.*/[ac-]bd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEndBracketAfter()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[ab]]cd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/a]cd\"));\n+            Assert.True(matcher.IsMatch(\"/b]cd\"));\n+            Assert.False(matcher.IsMatch(\"/acd\"));\n+            Assert.False(matcher.IsMatch(\"/bcd\"));\n+            Assert.False(matcher.IsMatch(\"/acd\"));\n+\n+            Assert.Equal(@\"^.*/[ab]]cd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void CharacterClassEscapeBackslash()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"[ab\\\\]cd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/acd\"));\n+            Assert.True(matcher.IsMatch(\"/bcd\"));\n+            Assert.True(matcher.IsMatch(\"/\\\\cd\"));\n+            Assert.False(matcher.IsMatch(\"/dcd\"));\n+            Assert.False(matcher.IsMatch(\"/\\\\\\\\cd\"));\n+            Assert.False(matcher.IsMatch(\"/cd\"));\n+\n+            Assert.Equal(@\"^.*/[ab\\\\]cd$\", matcher.Regex.ToString());\n+        }\n+\n+        [Fact]\n+        public void EscapeOpenBracket()\n+        {\n+            var matcher = TryCreateSectionNameMatcher(@\"ab\\[cd\").Value;\n+\n+            Assert.True(matcher.IsMatch(\"/ab[cd\"));\n+            Assert.False(matcher.IsMatch(\"/ab[[cd\"));\n+            Assert.False(matcher.IsMatch(\"/abc\"));\n+            Assert.False(matcher.IsMatch(\"/abd\"));\n+\n+            Assert.Equal(@\"^.*/ab\\[cd$\", matcher.Regex.ToString());\n+        }\n+        #endregion\n+\n+        #region Parsing Tests\n+\n+        private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)\n+        {\n+            var expectedSet = new HashSet<T>(expected, comparer);\n+            var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);\n+            Assert.True(result, message);\n+        }\n+\n+        private static void Equal<T>(",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Discussed offline - exception will be wrapped and propagated up the stack",
              "createdAt": "2024-03-10T16:56:04Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +115,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);\n+        }\n+        catch (Exception ex)\n+        {\n+            // Note: catch any exception, we do not want to break because of the failed operation with parsing the editorconfig.\n+            Debug.WriteLine(ex);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Updated the code thank you ",
              "createdAt": "2024-03-11T12:14:55Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +115,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);\n+        }\n+        catch (Exception ex)\n+        {\n+            // Note: catch any exception, we do not want to break because of the failed operation with parsing the editorconfig.\n+            Debug.WriteLine(ex);",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is fine as it is now. Going forward we'll likely need to reintroduce the interface - as in future iterations of binlog replay analysis (https://github.com/dotnet/msbuild/issues/9760) we'll need to read editorconfigs from binlog (so from a zipstream).\r\n\r\nFYI @surayya-MS ",
              "createdAt": "2024-03-11T09:49:15Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -19,7 +19,7 @@ namespace Microsoft.Build.BuildCop.Infrastructure;\n // TODO: https://github.com/dotnet/msbuild/issues/9628\n internal class ConfigurationProvider\n {\n-    private IEditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Closing for now, @surayya-MS FYI. ",
              "createdAt": "2024-04-02T10:11:05Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -19,7 +19,7 @@ namespace Microsoft.Build.BuildCop.Infrastructure;\n // TODO: https://github.com/dotnet/msbuild/issues/9628\n internal class ConfigurationProvider\n {\n-    private IEditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Keep the exception as InnerException (ctor will need to be added), indicate the scope of the error by additional enum - e.g.:\r\n\r\n```\r\ninternal enum ConfigurationErrorScope\r\n{\r\n    SingleRule,\r\n    EntireConfiguration\r\n}\r\n```\r\n\r\n`SingleRule` can be default.\r\nBut here we need to indicate to the infra that configuration is busted, so anlysis should be dismounted altogther",
              "createdAt": "2024-03-11T09:58:25Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -126,6 +129,7 @@ public void CheckCustomConfigurationDataValidity(string projectFullPath, string\n         {\n             // Note: catch any exception, we do not want to break because of the failed operation with parsing the editorconfig.\n             Debug.WriteLine(ex);\n+            throw new BuildCopConfigurationException($\"Fetchin editorConfig data failed: {ex.Message}\");",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added Error scope property, thank you. ",
              "createdAt": "2024-03-18T20:41:28Z",
              "path": "src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -126,6 +129,7 @@ public void CheckCustomConfigurationDataValidity(string projectFullPath, string\n         {\n             // Note: catch any exception, we do not want to break because of the failed operation with parsing the editorconfig.\n             Debug.WriteLine(ex);\n+            throw new BuildCopConfigurationException($\"Fetchin editorConfig data failed: {ex.Message}\");",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)\r\n```\r\n\r\nThere are couple other cases where [B|b]uildCop was left in place.",
              "createdAt": "2024-03-19T15:23:37Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs",
              "diffHunk": "@@ -15,7 +15,16 @@ internal class BuildCheckConfigurationException : Exception\n     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.\n     /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).\n     /// </summary>\n-    public BuildCheckConfigurationException(string message) : base(message)\n+    ///\n+    internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;\n+\n+    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCopConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Agree, updated :) ",
              "createdAt": "2024-03-19T16:04:06Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs",
              "diffHunk": "@@ -15,7 +15,16 @@ internal class BuildCheckConfigurationException : Exception\n     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.\n     /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).\n     /// </summary>\n-    public BuildCheckConfigurationException(string message) : base(message)\n+    ///\n+    internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;\n+\n+    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCopConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            build_check.BC0101.IsEnabled=true\r\n```",
              "createdAt": "2024-03-19T15:28:24Z",
              "path": "src/Analyzers.UnitTests/EndToEndTests.cs",
              "diffHunk": "@@ -80,36 +80,26 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)\n                     <Target Name=\"Hello\">\n                     <Message Importance=\"High\" Condition=\"$(Test2) == true\" Text=\"XYZABC\" />\n                     </Target>\n-                                   \n                 </Project>\n                 \"\"\";\n             TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);\n             TransientTestFile projectFile = _env.CreateFile(workFolder, \"FooBar.csproj\", contents);\n             TransientTestFile projectFile2 = _env.CreateFile(workFolder, \"FooBar-Copy.csproj\", contents2);\n+            TransientTestFile config = _env.CreateFile(workFolder, \".editorconfig\",\n+            \"\"\"\n+            root=true\n \n-            // var cache = new SimpleProjectRootElementCache();\n-            // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);\n+            [*.csproj]\n+            msbuild_analyzer.BC0101.IsEnabled=true",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Thank you updated. ",
              "createdAt": "2024-03-19T16:03:55Z",
              "path": "src/Analyzers.UnitTests/EndToEndTests.cs",
              "diffHunk": "@@ -80,36 +80,26 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)\n                     <Target Name=\"Hello\">\n                     <Message Importance=\"High\" Condition=\"$(Test2) == true\" Text=\"XYZABC\" />\n                     </Target>\n-                                   \n                 </Project>\n                 \"\"\";\n             TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);\n             TransientTestFile projectFile = _env.CreateFile(workFolder, \"FooBar.csproj\", contents);\n             TransientTestFile projectFile2 = _env.CreateFile(workFolder, \"FooBar-Copy.csproj\", contents2);\n+            TransientTestFile config = _env.CreateFile(workFolder, \".editorconfig\",\n+            \"\"\"\n+            root=true\n \n-            // var cache = new SimpleProjectRootElementCache();\n-            // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);\n+            [*.csproj]\n+            msbuild_analyzer.BC0101.IsEnabled=true",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@JanKrivanek FYI this one is left, hence the validaty of the custom configuration per file is not checked at the moment. ",
              "createdAt": "2024-03-19T16:26:18Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -58,7 +68,11 @@ public override bool Equals(object? obj)\n         return Equals((CustomConfigurationData)obj);\n     }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+    protected bool Equals(CustomConfigurationData other) {\n+        // TODO: update the comparison: Compare ruleID, and exact match of the configuration data",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "I'll add this in the next iterations of the review process. The test is prepared :) ",
              "createdAt": "2024-03-19T16:28:05Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -58,7 +68,11 @@ public override bool Equals(object? obj)\n         return Equals((CustomConfigurationData)obj);\n     }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+    protected bool Equals(CustomConfigurationData other) {\n+        // TODO: update the comparison: Compare ruleID, and exact match of the configuration data",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Update the Equals logic + added testing ",
              "createdAt": "2024-03-25T14:18:28Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -58,7 +68,11 @@ public override bool Equals(object? obj)\n         return Equals((CustomConfigurationData)obj);\n     }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+    protected bool Equals(CustomConfigurationData other) {\n+        // TODO: update the comparison: Compare ruleID, and exact match of the configuration data",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could we make this internal for testing instead?",
              "createdAt": "2024-03-22T13:48:08Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs",
              "diffHunk": "@@ -0,0 +1,615 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+// Note:\n+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs\n+// with some changes to make it quicker to integrate into the MSBuild.\n+// Changes:\n+//  1. ArrayBuilder was replaced with List.\n+//  2. Exceptions. Wrap in try/catch blocks for proper reporting\n+\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Text.RegularExpressions;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig\n+{\n+    internal class EditorConfigGlobsMatcher\n+    {\n+        internal readonly struct SectionNameMatcher\n+        {\n+            private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;\n+            // public for testing\n+            public Regex Regex { get; }",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "Agree! Thank you!  updated",
              "createdAt": "2024-03-25T14:17:48Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs",
              "diffHunk": "@@ -0,0 +1,615 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+// Note:\n+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs\n+// with some changes to make it quicker to integrate into the MSBuild.\n+// Changes:\n+//  1. ArrayBuilder was replaced with List.\n+//  2. Exceptions. Wrap in try/catch blocks for proper reporting\n+\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Text.RegularExpressions;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig\n+{\n+    internal class EditorConfigGlobsMatcher\n+    {\n+        internal readonly struct SectionNameMatcher\n+        {\n+            private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;\n+            // public for testing\n+            public Regex Regex { get; }",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is calling a nullable-aware API and passing null to a non-nullable parameter. It looks inconsistent. If null is a supported value, then the parameter should be declared nullable. Or if null really isn't supported, then the API should throw `ArgumentNullException` and this should be a negative test case.",
              "createdAt": "2024-03-25T13:23:01Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,119 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection.Metadata;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BuildCheck.Infrastructure;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class BuildAnalyzerConfiguration_Test\n+    {\n+        [Fact]\n+        public void CreateWithNull_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(null!);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated to accept null as a values. Thank you for pointing out to the inconsistency. ",
              "createdAt": "2024-04-03T10:29:43Z",
              "path": "src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs",
              "diffHunk": "@@ -0,0 +1,119 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection.Metadata;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BuildCheck.Infrastructure;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.Analyzers.UnitTests\n+{\n+    public class BuildAnalyzerConfiguration_Test\n+    {\n+        [Fact]\n+        public void CreateWithNull_ReturnsObjectWithNullValues()\n+        {\n+            var buildConfig = BuildAnalyzerConfiguration.Create(null!);",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Empty line.",
              "createdAt": "2024-03-25T14:31:00Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))\n+        {\n+            if (bool.TryParse(config[key], out bool boolValue))\n+            {\n+                value = (T)(object)boolValue;\n+                isParsed = true;\n+            }\n+        }\n+        else if(typeof(T).IsEnum)\n+        {\n+            ",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:17:24Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))\n+        {\n+            if (bool.TryParse(config[key], out bool boolValue))\n+            {\n+                value = (T)(object)boolValue;\n+                isParsed = true;\n+            }\n+        }\n+        else if(typeof(T).IsEnum)\n+        {\n+            ",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n        if (config == null || !config.TryGetValue(key, out string stringValue))\r\n```\r\n\r\nand `stringValue` can be used below without reading the dictionary one more time.",
              "createdAt": "2024-03-25T14:33:17Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This one updated, thank you! ",
              "createdAt": "2024-04-03T10:30:22Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Missing empty line between the field and the constructor.",
              "createdAt": "2024-03-25T14:36:27Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs",
              "diffHunk": "@@ -15,6 +15,12 @@ namespace Microsoft.Build.BuildCheck.Infrastructure;\n /// </summary>\n internal sealed class BuildCheckCentralContext\n {\n+    private readonly ConfigurationProvider _configurationProvider;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "updated thank you.",
              "createdAt": "2024-04-02T10:14:19Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs",
              "diffHunk": "@@ -15,6 +15,12 @@ namespace Microsoft.Build.BuildCheck.Infrastructure;\n /// </summary>\n internal sealed class BuildCheckCentralContext\n {\n+    private readonly ConfigurationProvider _configurationProvider;",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Formatting\r\n```suggestion\r\n        else if (typeof(T).IsEnum)\r\n```",
              "createdAt": "2024-03-25T14:36:47Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))\n+        {\n+            if (bool.TryParse(config[key], out bool boolValue))\n+            {\n+                value = (T)(object)boolValue;\n+                isParsed = true;\n+            }\n+        }\n+        else if(typeof(T).IsEnum)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "thank you, changed tha approach to overloading. ",
              "createdAt": "2024-04-18T10:27:12Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))\n+        {\n+            if (bool.TryParse(config[key], out bool boolValue))\n+            {\n+                value = (T)(object)boolValue;\n+                isParsed = true;\n+            }\n+        }\n+        else if(typeof(T).IsEnum)",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Extra empty line.",
              "createdAt": "2024-03-25T14:38:42Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n ",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:18:07Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n ",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can be `sealed`.",
              "createdAt": "2024-03-25T14:39:28Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:18:15Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can be an array, which has a slightly smaller overhead.\r\n\r\n```suggestion\r\n    private readonly string[] _infrastructureConfigurationKeys = new List[] {\r\n```",
              "createdAt": "2024-03-25T14:41:12Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider\n {\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n     // TODO: This module should have a mechanism for removing unneeded configurations\n     //  (disabled rules and analyzers that need to run in different node)\n-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();\n-\n-    // This is just a testing implementation for quicker unblock of testing.\n-    // Real implementation will use .editorconfig file.\n-    // Sample json:\n-    /////*lang=json,strict*/\n-    ////\"\"\"\n-    ////    {\n-    ////        \"ABC123\": {\n-    ////            \"IsEnabled\": true,\n-    ////            \"Severity\": \"Info\"\n-    ////        },\n-    ////        \"COND0543\": {\n-    ////            \"IsEnabled\": false,\n-    ////            \"Severity\": \"Error\",\n-    ////    \t\t\"EvaluationAnalysisScope\": \"AnalyzedProjectOnly\",\n-    ////    \t\t\"CustomSwitch\": \"QWERTY\"\n-    ////        },\n-    ////        \"BLA\": {\n-    ////            \"IsEnabled\": false\n-    ////        }\n-    ////    }\n-    ////    \"\"\"\n-    //\n-    // Plus there will need to be a mechanism of distinguishing different configs in different folders\n-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?\n-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()\n-    {\n-        const string configFileName = \"editorconfig.json\";\n-        string configPath = configFileName;\n-\n-        if (!File.Exists(configPath))\n-        {\n-            // TODO: pass the current project path\n-            var dir = Environment.CurrentDirectory;\n-            configPath = Path.Combine(dir, configFileName);\n+    private readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = new Dictionary<string, BuildAnalyzerConfiguration>();\n \n-            if (!File.Exists(configPath))\n-            {\n-                return new Dictionary<string, BuildAnalyzerConfiguration>();\n-            }\n-        }\n+    private readonly Dictionary<string, CustomConfigurationData> _customConfigurationData = new Dictionary<string, CustomConfigurationData>();\n \n-        var json = File.ReadAllText(configPath);\n-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };\n-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??\n-               new Dictionary<string, BuildAnalyzerConfiguration>();\n-    }\n+    private readonly List<string> _infrastructureConfigurationKeys = new List<string>() {",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:18:55Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider\n {\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n     // TODO: This module should have a mechanism for removing unneeded configurations\n     //  (disabled rules and analyzers that need to run in different node)\n-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();\n-\n-    // This is just a testing implementation for quicker unblock of testing.\n-    // Real implementation will use .editorconfig file.\n-    // Sample json:\n-    /////*lang=json,strict*/\n-    ////\"\"\"\n-    ////    {\n-    ////        \"ABC123\": {\n-    ////            \"IsEnabled\": true,\n-    ////            \"Severity\": \"Info\"\n-    ////        },\n-    ////        \"COND0543\": {\n-    ////            \"IsEnabled\": false,\n-    ////            \"Severity\": \"Error\",\n-    ////    \t\t\"EvaluationAnalysisScope\": \"AnalyzedProjectOnly\",\n-    ////    \t\t\"CustomSwitch\": \"QWERTY\"\n-    ////        },\n-    ////        \"BLA\": {\n-    ////            \"IsEnabled\": false\n-    ////        }\n-    ////    }\n-    ////    \"\"\"\n-    //\n-    // Plus there will need to be a mechanism of distinguishing different configs in different folders\n-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?\n-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()\n-    {\n-        const string configFileName = \"editorconfig.json\";\n-        string configPath = configFileName;\n-\n-        if (!File.Exists(configPath))\n-        {\n-            // TODO: pass the current project path\n-            var dir = Environment.CurrentDirectory;\n-            configPath = Path.Combine(dir, configFileName);\n+    private readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = new Dictionary<string, BuildAnalyzerConfiguration>();\n \n-            if (!File.Exists(configPath))\n-            {\n-                return new Dictionary<string, BuildAnalyzerConfiguration>();\n-            }\n-        }\n+    private readonly Dictionary<string, CustomConfigurationData> _customConfigurationData = new Dictionary<string, CustomConfigurationData>();\n \n-        var json = File.ReadAllText(configPath);\n-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };\n-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??\n-               new Dictionary<string, BuildAnalyzerConfiguration>();\n-    }\n+    private readonly List<string> _infrastructureConfigurationKeys = new List<string>() {",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Formatting\r\n\r\n```suggestion\r\n        foreach (var infraConfigurationKey in _infrastructureConfigurationKeys)\r\n```",
              "createdAt": "2024-03-25T14:41:57Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This is updated, thank you! ",
              "createdAt": "2024-04-02T13:29:21Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can just call `Remove` to reduce the number of dictionary accesses.\r\n\r\n```suggestion\r\n            configuration.Remove(infraConfigurationKey);\r\n```",
              "createdAt": "2024-03-25T14:44:21Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:19:03Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can be one dictionary access.\r\n\r\n```suggestion\r\n        if (_customConfigurationData.TryGetValue(ruleId, out var storedConfiguration))\r\n        {\r\n```",
              "createdAt": "2024-03-25T14:48:25Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;\n     }\n \n     /// <summary>\n-    /// \n+    /// Verifies if previously fetched custom configurations are equal to current one. \n     /// </summary>\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <throws><see cref=\"BuildCheckConfigurationException\"/> If CustomConfigurationData differs in a build for a same ruleId</throws>\n     /// <returns></returns>\n-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n     {\n-        // TBD\n+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);\n+\n+        if (_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            var storedConfiguration = _customConfigurationData[ruleId];",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Agree, thank you, updated",
              "createdAt": "2024-04-18T10:48:00Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;\n     }\n \n     /// <summary>\n-    /// \n+    /// Verifies if previously fetched custom configurations are equal to current one. \n     /// </summary>\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <throws><see cref=\"BuildCheckConfigurationException\"/> If CustomConfigurationData differs in a build for a same ruleId</throws>\n     /// <returns></returns>\n-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n     {\n-        // TBD\n+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);\n+\n+        if (_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            var storedConfiguration = _customConfigurationData[ruleId];",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If there is already an entry for `ruleId` in the dictionary we leave it there, but we return something else. Is this really intended?",
              "createdAt": "2024-03-25T14:51:01Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yes. \r\nThis implementation was intended to be that way, to have possibility validate the uniquness of custom config data between projects. \r\nThe logic: Save the first custom config data fetched ->Save it. While fetching any other validate that they are equal with the first fetched. ",
              "createdAt": "2024-04-03T12:12:50Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Is the `While fetching any other validate that they are equal with the first fetched.` part in this code?",
              "createdAt": "2024-04-04T16:42:03Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Discussed offline: \r\nWhile we are initiating the analyzers for projects and rules we are also validating if the custom configuration were presented and is equal to the first fetched one. ",
              "createdAt": "2024-04-23T12:25:22Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: `keyToSearch` ?",
              "createdAt": "2024-03-25T14:52:14Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);\n+        }\n+        catch (Exception exception)\n+        {\n+            throw new BuildCheckConfigurationException($\"Parsing editorConfig data failed\", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);\n+        }\n+\n+        var keyTosearch = $\"build_check.{ruleId}.\";",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:19:10Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);\n+        }\n+        catch (Exception exception)\n+        {\n+            throw new BuildCheckConfigurationException($\"Parsing editorConfig data failed\", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);\n+        }\n+\n+        var keyTosearch = $\"build_check.{ruleId}.\";",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It would be more performant to do:\r\n```suggestion\r\n                var newKey = kv.Key.Substring(keyTosearch.Length);\r\n```",
              "createdAt": "2024-03-25T14:54:18Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);\n+        }\n+        catch (Exception exception)\n+        {\n+            throw new BuildCheckConfigurationException($\"Parsing editorConfig data failed\", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);\n+        }\n+\n+        var keyTosearch = $\"build_check.{ruleId}.\";\n+        var dictionaryConfig = new Dictionary<string, string>();\n+\n+        foreach (var kv in config)\n+        {\n+            if (kv.Key.StartsWith(keyTosearch, StringComparison.OrdinalIgnoreCase))\n+            {\n+                var newKey = kv.Key.Replace(keyTosearch.ToLower(), \"\");",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This is updated, thank you! ",
              "createdAt": "2024-04-02T13:31:25Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);\n+        }\n+        catch (Exception exception)\n+        {\n+            throw new BuildCheckConfigurationException($\"Parsing editorConfig data failed\", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);\n+        }\n+\n+        var keyTosearch = $\"build_check.{ruleId}.\";\n+        var dictionaryConfig = new Dictionary<string, string>();\n+\n+        foreach (var kv in config)\n+        {\n+            if (kv.Key.StartsWith(keyTosearch, StringComparison.OrdinalIgnoreCase))\n+            {\n+                var newKey = kv.Key.Replace(keyTosearch.ToLower(), \"\");",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like this is needed only if `config` returned from `GetConfiguration` is empty. Should it move down to an else branch?",
              "createdAt": "2024-03-25T14:58:56Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -150,13 +173,24 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)\n+    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)\n     {\n-        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))\n+        var cacheKey = $\"{ruleId}-{projectFullPath}\";\n+\n+        if (!_editorConfig.TryGetValue(cacheKey, out BuildAnalyzerConfiguration? editorConfig))\n         {\n             editorConfig = BuildAnalyzerConfiguration.Null;\n         }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Code is updated, closing the comment with respect to the latest review. ",
              "createdAt": "2024-04-23T13:41:12Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -150,13 +173,24 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)\n+    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)\n     {\n-        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))\n+        var cacheKey = $\"{ruleId}-{projectFullPath}\";\n+\n+        if (!_editorConfig.TryGetValue(cacheKey, out BuildAnalyzerConfiguration? editorConfig))\n         {\n             editorConfig = BuildAnalyzerConfiguration.Null;\n         }",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Formatting\r\n```suggestion\r\n        var customConfigObj = (CustomConfigurationData)obj;\r\n\r\n        if (customConfigObj.RuleId != RuleId)\r\n```",
              "createdAt": "2024-03-25T15:01:22Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:19:21Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Formatting\r\n```suggestion\r\n        }\r\n        else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)\r\n```",
              "createdAt": "2024-03-25T15:01:54Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }\n+        }else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Another option:\r\n```suggestion\r\n        }\r\n        else\r\n        {\r\n            return customConfigObj.ConfigurationData == null && ConfigurationData == null;\r\n        }\r\n```\r\nto replace all the `return true` / `return false` below.",
              "createdAt": "2024-03-25T15:10:35Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }\n+        }else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed the formatting . Thank you ",
              "createdAt": "2024-04-03T10:30:55Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }\n+        }else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't look correct. I don't think the order of enumeration of `Keys` is defined.",
              "createdAt": "2024-03-25T15:08:29Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thank you for catching it. Added test to verify it: TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()\r\nand updated the implementation. ",
              "createdAt": "2024-04-03T10:33:00Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo \"Configration\".",
              "createdAt": "2024-03-25T15:11:26Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/README.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+\ufeff# EditorConfigParser\n+\n+Logic of parsing and matching copied from Roslyn implementation.\n+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324\n+\n+\n+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. \n+\n+Configration divided into two categories: ",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:19:46Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/README.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+\ufeff# EditorConfigParser\n+\n+Logic of parsing and matching copied from Roslyn implementation.\n+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324\n+\n+\n+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. \n+\n+Configration divided into two categories: ",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo \"configration\".",
              "createdAt": "2024-03-25T15:11:55Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/README.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+\ufeff# EditorConfigParser\n+\n+Logic of parsing and matching copied from Roslyn implementation.\n+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324\n+\n+\n+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. \n+\n+Configration divided into two categories: \n+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope\n+- Custom configuration, any other config specified by user for this particular rule\n+\n+### Example \n+For the file/folder structure: \n+```\n+\u251c\u2500\u2500 folder1/\n+\u2502   \u2514\u2500\u2500 .editorconfig\n+\u2502   \u2514\u2500\u2500 folder2/\n+        \u251c\u2500\u2500 folder3/\n+        \u2502   \u2514\u2500\u2500 .editorconfig\n+        \u2502   \u2514\u2500\u2500 test.proj\n+        \u2514\u2500\u2500 .editorconfig\n+```\n+\n+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj \n+\n+Infra related and custom configration flows have one common logic: Fetching the configs from editorconfig",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:19:53Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/README.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+\ufeff# EditorConfigParser\n+\n+Logic of parsing and matching copied from Roslyn implementation.\n+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324\n+\n+\n+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. \n+\n+Configration divided into two categories: \n+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope\n+- Custom configuration, any other config specified by user for this particular rule\n+\n+### Example \n+For the file/folder structure: \n+```\n+\u251c\u2500\u2500 folder1/\n+\u2502   \u2514\u2500\u2500 .editorconfig\n+\u2502   \u2514\u2500\u2500 folder2/\n+        \u251c\u2500\u2500 folder3/\n+        \u2502   \u2514\u2500\u2500 .editorconfig\n+        \u2502   \u2514\u2500\u2500 test.proj\n+        \u2514\u2500\u2500 .editorconfig\n+```\n+\n+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj \n+\n+Infra related and custom configration flows have one common logic: Fetching the configs from editorconfig",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `BuildConfigInstance`? (capitalization)",
              "createdAt": "2024-03-25T15:12:38Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/README.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+\ufeff# EditorConfigParser\n+\n+Logic of parsing and matching copied from Roslyn implementation.\n+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324\n+\n+\n+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. \n+\n+Configration divided into two categories: \n+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope\n+- Custom configuration, any other config specified by user for this particular rule\n+\n+### Example \n+For the file/folder structure: \n+```\n+\u251c\u2500\u2500 folder1/\n+\u2502   \u2514\u2500\u2500 .editorconfig\n+\u2502   \u2514\u2500\u2500 folder2/\n+        \u251c\u2500\u2500 folder3/\n+        \u2502   \u2514\u2500\u2500 .editorconfig\n+        \u2502   \u2514\u2500\u2500 test.proj\n+        \u2514\u2500\u2500 .editorconfig\n+```\n+\n+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj \n+\n+Infra related and custom configration flows have one common logic: Fetching the configs from editorconfig\n+\n+```\n+while(editorConfig is not root && parent directory exists){\n+        collect, parse editorconfigs \n+}\n+\n+list<editorConfig>{\n+    folder1/folder2/folder3/.editorconfig\n+    folder1/folder2/.editorconfig\n+    folder1/.editorconfig\n+}\n+```\n+Reverse the order and collect all matching section key-value pairs into new dictionary\n+Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)\n+\n+The implementation differs depending on category: \n+ - Infra related config: Merges the configuration retrieved from configration module with default values (respecting the specified configs in editorconfig) \n+ - Custom configuration: Remove all infra related keys from dictionary\n+\n+Two levels of cache introduced: \n+- When retrieving and parsing the editor config -> Parsed results are saved into dictionary: editorconfigPath = ParsedEditorConfig\n+- When retrieving Infra related config: ruleId-projectPath = BuildconfigInstance",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:20:04Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/README.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+\ufeff# EditorConfigParser\n+\n+Logic of parsing and matching copied from Roslyn implementation.\n+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324\n+\n+\n+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. \n+\n+Configration divided into two categories: \n+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope\n+- Custom configuration, any other config specified by user for this particular rule\n+\n+### Example \n+For the file/folder structure: \n+```\n+\u251c\u2500\u2500 folder1/\n+\u2502   \u2514\u2500\u2500 .editorconfig\n+\u2502   \u2514\u2500\u2500 folder2/\n+        \u251c\u2500\u2500 folder3/\n+        \u2502   \u2514\u2500\u2500 .editorconfig\n+        \u2502   \u2514\u2500\u2500 test.proj\n+        \u2514\u2500\u2500 .editorconfig\n+```\n+\n+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj \n+\n+Infra related and custom configration flows have one common logic: Fetching the configs from editorconfig\n+\n+```\n+while(editorConfig is not root && parent directory exists){\n+        collect, parse editorconfigs \n+}\n+\n+list<editorConfig>{\n+    folder1/folder2/folder3/.editorconfig\n+    folder1/folder2/.editorconfig\n+    folder1/.editorconfig\n+}\n+```\n+Reverse the order and collect all matching section key-value pairs into new dictionary\n+Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)\n+\n+The implementation differs depending on category: \n+ - Infra related config: Merges the configuration retrieved from configration module with default values (respecting the specified configs in editorconfig) \n+ - Custom configuration: Remove all infra related keys from dictionary\n+\n+Two levels of cache introduced: \n+- When retrieving and parsing the editor config -> Parsed results are saved into dictionary: editorconfigPath = ParsedEditorConfig\n+- When retrieving Infra related config: ruleId-projectPath = BuildconfigInstance",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I think this would better be done by overload resolution at compile-time. The logic in this method is simple and run-time type checks like this one are in this case unnecessary. Instead of a generic method with a `struct` constraint, please consider having two overloads. One taking `out bool value`, another taking `out T value` with the `struct, System.Enum` constraint.",
              "createdAt": "2024-03-26T08:24:12Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This is updated and switched to the overloading, thank you for the suggestion! ",
              "createdAt": "2024-04-18T13:36:06Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: The exception message could also contain the value.",
              "createdAt": "2024-03-26T08:25:26Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))\n+        {\n+            if (bool.TryParse(config[key], out bool boolValue))\n+            {\n+                value = (T)(object)boolValue;\n+                isParsed = true;\n+            }\n+        }\n+        else if(typeof(T).IsEnum)\n+        {\n+            \n+            isParsed = Enum.TryParse(config[key], true, out value);\n+        }\n+\n+        if (!isParsed)\n+        {\n+            throw new BuildCheckConfigurationException(\n+                $\"Incorrect value provided in config for key {key}\",",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you! \r\nNew format: $\"Incorrect value provided in config for key {key}: '{value}'\",",
              "createdAt": "2024-04-03T10:33:46Z",
              "path": "src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs",
              "diffHunk": "@@ -42,4 +46,55 @@ public class BuildAnalyzerConfiguration\n     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.\n     /// </summary>\n     public bool? IsEnabled { get; internal init; }\n+\n+    /// <summary>\n+    /// Creates a <see cref=\"BuildAnalyzerConfiguration\"/> object based on the provided configuration dictionary.\n+    /// If key, equals to the name of the property in lowercase, exists in the dictionary => the value is parsed and assigned to the instance property value.\n+    /// </summary>\n+    /// <param name=\"configDictionary\">The configuration dictionary containing the settings for the build analyzer.</param>\n+    /// <returns>A new instance of <see cref=\"BuildAnalyzerConfiguration\"/> with the specified settings.</returns>\n+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)\n+    {\n+        return new()\n+        {\n+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope).ToLower(), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,\n+            Severity = TryExtractValue(nameof(Severity).ToLower(), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,\n+            IsEnabled = TryExtractValue(nameof(IsEnabled).ToLower(), configDictionary, out bool isEnabled) ? isEnabled : null,\n+        };\n+    }\n+\n+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct\n+    {\n+        value = default;\n+\n+        if (config == null || !config.ContainsKey(key))\n+        {\n+            return false;\n+        }\n+\n+        bool isParsed = false;\n+\n+        if (typeof(T) == typeof(bool))\n+        {\n+            if (bool.TryParse(config[key], out bool boolValue))\n+            {\n+                value = (T)(object)boolValue;\n+                isParsed = true;\n+            }\n+        }\n+        else if(typeof(T).IsEnum)\n+        {\n+            \n+            isParsed = Enum.TryParse(config[key], true, out value);\n+        }\n+\n+        if (!isParsed)\n+        {\n+            throw new BuildCheckConfigurationException(\n+                $\"Incorrect value provided in config for key {key}\",",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can be `readonly`.",
              "createdAt": "2024-03-26T08:28:49Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider\n {\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:20:46Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider\n {\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is an unnecessary allocation.\r\n\r\n```suggestion\r\n        Dictionary<string, string> config;\r\n```",
              "createdAt": "2024-03-26T08:35:48Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Updated, thank you ",
              "createdAt": "2024-04-02T10:37:16Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: It's faster to enumerate key-value pairs.\r\n\r\n```suggestion\r\n            foreach (var kvp in customConfigObj.ConfigurationData)\r\n            {\r\n                if (kvp.Value != ConfigurationData[kvp.Key])\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n```",
              "createdAt": "2024-03-26T08:41:48Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "this is updated, thank you! ",
              "createdAt": "2024-04-03T10:34:14Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`GetHashCode` should use all instance data to calculate the code. More importantly, instances that are considered equal per the `Equals` implementation must have the same hash code. Note that `Dictionary<K,V>` doesn't override `GetHashCode` so the value you are returning here is _not_ derived from the contents of the dictionary.\r\n\r\nThis snippet demonstrates the issue:\r\nhttps://dotnetfiddle.net/Y8k7Cm",
              "createdAt": "2024-03-26T08:52:53Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }\n+        }else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)\n+        {\n+            return true;\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n \n     public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Agree, I'll update the implementation for future usage (in case will be needed). \r\nSince the custom configuration data is not used in the Dictionary in a 'key'  role this is not reflected anyhow in the tests. \r\n",
              "createdAt": "2024-04-02T15:05:39Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }\n+        }else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)\n+        {\n+            return true;\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n \n     public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Implementation updated. ",
              "createdAt": "2024-04-03T10:35:02Z",
              "path": "src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs",
              "diffHunk": "@@ -55,10 +65,40 @@ public override bool Equals(object? obj)\n             return false;\n         }\n \n-        return Equals((CustomConfigurationData)obj);\n-    }\n+        var customConfigObj = (CustomConfigurationData) obj;\n+\n+        if(customConfigObj.RuleId != RuleId)\n+        {\n+            return false;\n+        }\n \n-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);\n+        // validate keys and values\n+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null)\n+        {\n+            if (!customConfigObj.ConfigurationData.Keys.SequenceEqual(ConfigurationData.Keys))\n+            {\n+                return false;\n+            }\n+\n+            var keys = customConfigObj.ConfigurationData.Keys;\n+            foreach (var key in keys)\n+            {\n+                if (customConfigObj.ConfigurationData[key] != ConfigurationData[key])\n+                {\n+                    return false;\n+                }\n+            }\n+        }else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)\n+        {\n+            return true;\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n \n     public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't fully understand the purpose of this field. Can you please add a comment? It looks like a cache but it's not used outside of the validity check.",
              "createdAt": "2024-03-26T09:35:03Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider\n {\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n     // TODO: This module should have a mechanism for removing unneeded configurations\n     //  (disabled rules and analyzers that need to run in different node)\n-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();\n-\n-    // This is just a testing implementation for quicker unblock of testing.\n-    // Real implementation will use .editorconfig file.\n-    // Sample json:\n-    /////*lang=json,strict*/\n-    ////\"\"\"\n-    ////    {\n-    ////        \"ABC123\": {\n-    ////            \"IsEnabled\": true,\n-    ////            \"Severity\": \"Info\"\n-    ////        },\n-    ////        \"COND0543\": {\n-    ////            \"IsEnabled\": false,\n-    ////            \"Severity\": \"Error\",\n-    ////    \t\t\"EvaluationAnalysisScope\": \"AnalyzedProjectOnly\",\n-    ////    \t\t\"CustomSwitch\": \"QWERTY\"\n-    ////        },\n-    ////        \"BLA\": {\n-    ////            \"IsEnabled\": false\n-    ////        }\n-    ////    }\n-    ////    \"\"\"\n-    //\n-    // Plus there will need to be a mechanism of distinguishing different configs in different folders\n-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?\n-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()\n-    {\n-        const string configFileName = \"editorconfig.json\";\n-        string configPath = configFileName;\n-\n-        if (!File.Exists(configPath))\n-        {\n-            // TODO: pass the current project path\n-            var dir = Environment.CurrentDirectory;\n-            configPath = Path.Combine(dir, configFileName);\n+    private readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = new Dictionary<string, BuildAnalyzerConfiguration>();\n \n-            if (!File.Exists(configPath))\n-            {\n-                return new Dictionary<string, BuildAnalyzerConfiguration>();\n-            }\n-        }\n+    private readonly Dictionary<string, CustomConfigurationData> _customConfigurationData = new Dictionary<string, CustomConfigurationData>();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "The purpose of the _customConfigurationData is to save the first custom data for specific rule. \r\nSince there could be different configurations based on the editorconfig and project file, we want to make sure that the custom data between different projects are the same.   ",
              "createdAt": "2024-04-02T14:47:49Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,27 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n \n // TODO: https://github.com/dotnet/msbuild/issues/9628\n-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-internal static class ConfigurationProvider\n+internal class ConfigurationProvider\n {\n+    private EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n     // TODO: This module should have a mechanism for removing unneeded configurations\n     //  (disabled rules and analyzers that need to run in different node)\n-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();\n-\n-    // This is just a testing implementation for quicker unblock of testing.\n-    // Real implementation will use .editorconfig file.\n-    // Sample json:\n-    /////*lang=json,strict*/\n-    ////\"\"\"\n-    ////    {\n-    ////        \"ABC123\": {\n-    ////            \"IsEnabled\": true,\n-    ////            \"Severity\": \"Info\"\n-    ////        },\n-    ////        \"COND0543\": {\n-    ////            \"IsEnabled\": false,\n-    ////            \"Severity\": \"Error\",\n-    ////    \t\t\"EvaluationAnalysisScope\": \"AnalyzedProjectOnly\",\n-    ////    \t\t\"CustomSwitch\": \"QWERTY\"\n-    ////        },\n-    ////        \"BLA\": {\n-    ////            \"IsEnabled\": false\n-    ////        }\n-    ////    }\n-    ////    \"\"\"\n-    //\n-    // Plus there will need to be a mechanism of distinguishing different configs in different folders\n-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?\n-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()\n-    {\n-        const string configFileName = \"editorconfig.json\";\n-        string configPath = configFileName;\n-\n-        if (!File.Exists(configPath))\n-        {\n-            // TODO: pass the current project path\n-            var dir = Environment.CurrentDirectory;\n-            configPath = Path.Combine(dir, configFileName);\n+    private readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = new Dictionary<string, BuildAnalyzerConfiguration>();\n \n-            if (!File.Exists(configPath))\n-            {\n-                return new Dictionary<string, BuildAnalyzerConfiguration>();\n-            }\n-        }\n+    private readonly Dictionary<string, CustomConfigurationData> _customConfigurationData = new Dictionary<string, CustomConfigurationData>();",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Related to the comment on `_customConfigurationData `, is the side effect of creating the configuration intended here? The first time this is called for the given arguments, `GetCustomConfiguration` creates the thing and puts it in the dictionary. Then we fetch it from the dictionary here and compare with itself. Why?",
              "createdAt": "2024-03-26T09:41:47Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;\n     }\n \n     /// <summary>\n-    /// \n+    /// Verifies if previously fetched custom configurations are equal to current one. \n     /// </summary>\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <throws><see cref=\"BuildCheckConfigurationException\"/> If CustomConfigurationData differs in a build for a same ruleId</throws>\n     /// <returns></returns>\n-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n     {\n-        // TBD\n+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "In case the rule id and its customc configuration yes we will compare the same configuration, however in case the custom config is different between the project files we will report the issue. \r\n_customConfigurationData contains only one/first value of custom configuration fetched per rule. \r\nDoes it answer the question, or am I missing something? ",
              "createdAt": "2024-04-03T11:00:11Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -80,47 +43,80 @@ internal static class ConfigurationProvider\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <returns></returns>\n-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)\n     {\n-        return CustomConfigurationData.Null;\n+        var configuration = GetConfiguration(projectFullPath, ruleId);\n+\n+        if (configuration is null || !configuration.Any())\n+        {\n+            return CustomConfigurationData.Null;\n+        }\n+\n+        // remove the infrastructure owned key names\n+        foreach(var infraConfigurationKey in _infrastructureConfigurationKeys)\n+        {\n+            if (configuration.ContainsKey(infraConfigurationKey))\n+            {\n+                configuration.Remove(infraConfigurationKey);\n+            }\n+        }\n+\n+        var data = new CustomConfigurationData(ruleId, configuration);\n+\n+        if (!_customConfigurationData.ContainsKey(ruleId))\n+        {\n+            _customConfigurationData[ruleId] = data;\n+        }\n+\n+        return data;\n     }\n \n     /// <summary>\n-    /// \n+    /// Verifies if previously fetched custom configurations are equal to current one. \n     /// </summary>\n     /// <param name=\"projectFullPath\"></param>\n     /// <param name=\"ruleId\"></param>\n     /// <throws><see cref=\"BuildCheckConfigurationException\"/> If CustomConfigurationData differs in a build for a same ruleId</throws>\n     /// <returns></returns>\n-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)\n     {\n-        // TBD\n+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This appears to be called in a loop - for each analyzer, for each rule -  and it is an expensive operation. We are basically initializing a dictionary with _all_ rules applicable to the given project file over and over again. Would it make sense to make this call only once for the given project file, filter the result to rules starting with `build_check.`, and then for each analyzer / for each rule search this smaller cached dictionary?",
              "createdAt": "2024-03-26T09:54:59Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -140,6 +136,33 @@ public static void CheckCustomConfigurationDataValidity(string projectFullPath,\n         return configurations;\n     }\n \n+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)\n+    {\n+        var config = new Dictionary<string, string>();\n+        try\n+        {\n+            config = s_editorConfigParser.Parse(projectFullPath);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like a merge issue - I suspect git casing issue on windows (the file was renamed to BootStrapM**s**Build.props - lower 's' - in PR merged to main).\r\n\r\ntl;dr; just delete this\r\n\r\nIt's likely similar for all the other changes in eng\\ folder in this PR",
              "createdAt": "2024-04-17T12:00:02Z",
              "path": "eng/BootStrapMSBuild.props",
              "diffHunk": "",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "This is resolved. thank you",
              "createdAt": "2024-04-18T10:31:34Z",
              "path": "eng/BootStrapMSBuild.props",
              "diffHunk": "",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@JanKrivanek could you please share the use case of that? \r\nCurrently the advantage I see is to reduce amount of memory used by the chace mechanism of the configuration provider, is there anything additionally to that? \r\nThank you in advance! ",
              "createdAt": "2024-04-18T14:04:47Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,37 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n-\n-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-// Tracked via: https://github.com/dotnet/msbuild/issues/9828\n-internal static class ConfigurationProvider\n+internal sealed class ConfigurationProvider\n {\n-    // We might want to have a mechanism for removing unneeded configurations\n+    private readonly EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n+    // TODO: This module should have a mechanism for removing unneeded configurations",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "It's more about perf - bet let's leave it for once it's really needed. Let's skip now",
              "createdAt": "2024-04-18T17:32:04Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,37 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n-\n-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-// Tracked via: https://github.com/dotnet/msbuild/issues/9828\n-internal static class ConfigurationProvider\n+internal sealed class ConfigurationProvider\n {\n-    // We might want to have a mechanism for removing unneeded configurations\n+    private readonly EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n+    // TODO: This module should have a mechanism for removing unneeded configurations",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Thank you for clarifications! Closing for now, having that TODO commented",
              "createdAt": "2024-04-23T17:49:09Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,37 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n-\n-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-// Tracked via: https://github.com/dotnet/msbuild/issues/9828\n-internal static class ConfigurationProvider\n+internal sealed class ConfigurationProvider\n {\n-    // We might want to have a mechanism for removing unneeded configurations\n+    private readonly EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n+    // TODO: This module should have a mechanism for removing unneeded configurations",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "We can even remove the comment",
              "createdAt": "2024-04-26T08:53:58Z",
              "path": "src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs",
              "diffHunk": "@@ -11,64 +11,37 @@\n using System.Text.Json;\n using Microsoft.Build.Experimental.BuildCheck;\n using System.Configuration;\n+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n \n-\n-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)\n-// Tracked via: https://github.com/dotnet/msbuild/issues/9828\n-internal static class ConfigurationProvider\n+internal sealed class ConfigurationProvider\n {\n-    // We might want to have a mechanism for removing unneeded configurations\n+    private readonly EditorConfigParser s_editorConfigParser = new EditorConfigParser();\n+\n+    // TODO: This module should have a mechanism for removing unneeded configurations",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: `sealed`",
              "createdAt": "2024-04-23T09:35:40Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,111 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Drawing.Design;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection.Metadata.Ecma335;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig\n+{\n+    internal class EditorConfigParser",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: `readonly`",
              "createdAt": "2024-04-23T09:36:09Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,111 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Drawing.Design;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection.Metadata.Ecma335;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig\n+{\n+    internal class EditorConfigParser\n+    {\n+        private const string EditorconfigFile = \".editorconfig\";\n+        private Dictionary<string, EditorConfigFile> editorConfigFileCache;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                if (!editorConfigFileCache.TryGetValue(editorConfigFilePath, out editorConfig))\r\n```",
              "createdAt": "2024-04-23T09:38:35Z",
              "path": "src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs",
              "diffHunk": "@@ -0,0 +1,111 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Drawing.Design;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection.Metadata.Ecma335;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Shared;\n+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;\n+\n+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig\n+{\n+    internal class EditorConfigParser\n+    {\n+        private const string EditorconfigFile = \".editorconfig\";\n+        private Dictionary<string, EditorConfigFile> editorConfigFileCache;\n+\n+        internal EditorConfigParser()\n+        {\n+            editorConfigFileCache = new Dictionary<string, EditorConfigFile>();\n+        }\n+\n+        internal Dictionary<string, string> Parse(string filePath)\n+        {\n+            var editorConfigs = EditorConfigFileDiscovery(filePath);\n+            return MergeEditorConfigFiles(editorConfigs, filePath);\n+        }\n+\n+        /// <summary>\n+        /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.\n+        /// </summary>\n+        /// <param name=\"filePath\"></param>\n+        internal IEnumerable<EditorConfigFile> EditorConfigFileDiscovery(string filePath)\n+        {\n+            var editorConfigDataFromFilesList = new List<EditorConfigFile>();\n+\n+            var directoryOfTheProject = Path.GetDirectoryName(filePath);\n+            var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);\n+\n+            while (editorConfigFilePath != string.Empty)\n+            {\n+                EditorConfigFile editorConfig;\n+\n+                if (editorConfigFileCache.ContainsKey(editorConfigFilePath))\n+                {\n+                    editorConfig = editorConfigFileCache[editorConfigFilePath];\n+                }\n+                else",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}