{
  "number": 10955,
  "title": "Add 'Prefer Project Reference' Check",
  "body": "Fixes #9888\r\n\r\n### Context\r\nThis adds a Check that warns from adding a `Reference` to a project output, that could be referenced via `ProjectReference`\r\n\r\n### Testing\r\nAdded tailored test\r\n\r\n### Notes\r\nThis builds upon https://github.com/dotnet/msbuild/pull/10932",
  "state": "MERGED",
  "createdAt": "2024-11-08T10:17:07Z",
  "updatedAt": "2024-11-21T15:49:04Z",
  "closedAt": "2024-11-21T15:49:02Z",
  "mergedAt": "2024-11-21T15:49:02Z",
  "additions": 334,
  "deletions": 151,
  "changedFiles": 57,
  "headRefName": "proto/buildcheck-prefer-projref",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "ff2853ffc8c72272f7b51dc2394b3f163e6a24ee",
          "message": "Add EvaluatedItemCheckData",
          "committedDate": "2024-11-04T20:24:51Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fd106955726acba234beda6a787c4983408d8482",
          "message": "Fix build",
          "committedDate": "2024-11-05T11:16:52Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c6ce66e8562d956b7aced85baa45f37886e61e9",
          "message": "Add 'Prefer Project Reference' Check",
          "committedDate": "2024-11-08T10:14:39Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9e645f2170f5aad6a0af54bb18065304f29a22a7",
          "message": "Remove extra code",
          "committedDate": "2024-11-08T14:56:17Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9d8684928072091ece1b419b5c001e223eb2a031",
          "message": "Fix typo",
          "committedDate": "2024-11-08T14:58:50Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "47f597491ae29f001ef7a926676e00cf3596c28f",
          "message": "Update Codes.md",
          "committedDate": "2024-11-12T16:30:03Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a4db9712cec0d204c7a1f4294257cc86c662a9d2",
          "message": "Update documentation/specs/BuildCheck/Codes.md\n\nCo-authored-by: Chet Husk <baronfel@users.noreply.github.com>",
          "committedDate": "2024-11-14T13:32:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5bdaed268fc8f3a55126a3d454d94dea22bca1d",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Jan Provazn\u00edk <janprovaznik@microsoft.com>",
          "committedDate": "2024-11-21T08:57:25Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2116e0036820664ebc98c91efcce69cf3da311ed",
          "message": "Reflect PR suggestions",
          "committedDate": "2024-11-21T09:06:19Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "52b503a72b0ec9e8d442ec6e34126222bf80cd86",
          "message": "Merge branch 'proto/buildcheck-prefer-projref' of https://github.com/dotnet/msbuild into proto/buildcheck-prefer-projref",
          "committedDate": "2024-11-21T09:06:24Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c533c8eee9d7e6260c85af4d79a522d61c277f93",
          "message": "Reflected PR comments",
          "committedDate": "2024-11-21T11:12:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2813efd1d2e7eb2450ecbefdda2b69a4af0fcc14",
          "message": "Merge branch 'main' into proto/buildcheck-prefer-projref",
          "committedDate": "2024-11-21T14:06:39Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n| Diagnostic&nbsp;Code | Default Severity | Default Scope | Available from SDK | Reason |\r\n|:-----|-------|-------|-------|----------|\r\n| [BC0101](#bc0101---shared-output-path) | Warning | Project | 9.0.100 | Shared output path. |\r\n| [BC0102](#bc0102---double-writes) | Warning | Project | 9.0.100 | Double writes. |\r\n| [BC0103](#bc0103---used-environment-variable) | Suggestion | Project | 9.0.100 | Used environment variable. |\r\n| [BC0104](#bc0104---projectreference-is-prefered-to-reference) | Warning | Project | 9.0.200 | ProjectReference is prefered to Reference. |\r\n| [BC0201](#bc0201---usage-of-undefined-property) | Warning | Project | 9.0.100 | Usage of undefined property. |\r\n| [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Project | 9.0.100 | Property first declared after it was used. |\r\n| [BC0203](#bc0203----property-declared-but-never-used) | Suggestion | Project | 9.0.100 | Property declared but never used. |\r\n```",
              "createdAt": "2024-11-14T10:13:05Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -2,14 +2,15 @@\n \n Report codes are chosen to conform to suggested guidelines. Those guidelines are currently in revew: https://github.com/dotnet/msbuild/pull/10088\n \n-| Diagnostic&nbsp;Code | Default Severity | Reason |\n-|:-----|-------|----------|\n-| [BC0101](#bc0101---shared-output-path) | Warning | Shared output path. |\n-| [BC0102](#bc0102---double-writes) | Warning | Double writes. |\n-| [BC0103](#bc0103---used-environment-variable) | Suggestion | Used environment variable. |\n-| [BC0201](#bc0201---usage-of-undefined-property) | Warning | Usage of undefined property. |\n-| [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Property first declared after it was used. |\n-| [BC0203](#bc0203----property-declared-but-never-used) | Suggestion | Property declared but never used. |\n+| Diagnostic&nbsp;Code | Default Severity | Default Scope | Available from | Reason |\n+|:-----|-------|-------|-------|----------|\n+| [BC0101](#bc0101---shared-output-path) | Warning | Project | 9.0.0 | Shared output path. |\n+| [BC0102](#bc0102---double-writes) | Warning | Project | 9.0.0 | Double writes. |\n+| [BC0103](#bc0103---used-environment-variable) | Suggestion | Project | 9.0.0 | Used environment variable. |\n+| [BC0104](#bc0104---projectreference-is-prefered-to-reference) | Warning | Project | 9.0.2 | ProjectReference is prefered to Reference. |\n+| [BC0201](#bc0201---usage-of-undefined-property) | Warning | Project | 9.0.0 | Usage of undefined property. |\n+| [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Project | 9.0.0 | Property first declared after it was used. |\n+| [BC0203](#bc0203----property-declared-but-never-used) | Suggestion | Project | 9.0.0 | Property declared but never used. |",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n| [BC0104](#bc0104---projectreference-is-preferred-to-reference) | Warning | Project | 9.0.200 | ProjectReference is preferred to Reference. |\r\n```\r\ngrammar: the adjective is \"preferred\"",
              "createdAt": "2024-11-18T14:33:23Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -2,14 +2,15 @@\n \n Report codes are chosen to conform to suggested guidelines. Those guidelines are currently in revew: https://github.com/dotnet/msbuild/pull/10088\n \n-| Diagnostic&nbsp;Code | Default Severity | Reason |\n-|:-----|-------|----------|\n-| [BC0101](#bc0101---shared-output-path) | Warning | Shared output path. |\n-| [BC0102](#bc0102---double-writes) | Warning | Double writes. |\n-| [BC0103](#bc0103---used-environment-variable) | Suggestion | Used environment variable. |\n-| [BC0201](#bc0201---usage-of-undefined-property) | Warning | Usage of undefined property. |\n-| [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Property first declared after it was used. |\n-| [BC0203](#bc0203----property-declared-but-never-used) | Suggestion | Property declared but never used. |\n+| Diagnostic&nbsp;Code | Default Severity | Default Scope | Available from SDK | Reason |\n+|:-----|-------|-------|-------|----------|\n+| [BC0101](#bc0101---shared-output-path) | Warning | Project | 9.0.100 | Shared output path. |\n+| [BC0102](#bc0102---double-writes) | Warning | Project | 9.0.100 | Double writes. |\n+| [BC0103](#bc0103---used-environment-variable) | Suggestion | Project | 9.0.100 | Used environment variable. |\n+| [BC0104](#bc0104---projectreference-is-prefered-to-reference) | Warning | Project | 9.0.200 | ProjectReference is prefered to Reference. |",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n## BC0104 - ProjectReference is preferred to Reference.\r\n```",
              "createdAt": "2024-11-18T14:33:51Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -48,6 +49,15 @@ Relying on environment variables introduces variability and unpredictability, as\n \n This practice can result in inconsistent build outcomes and makes debugging difficult, since environment variables are external to project files and build scripts. To ensure consistent and reproducible builds, avoid using environment variables. Instead, explicitly pass properties using the /p option, which offers better control and traceability.\n \n+<a name=\"BC0104\"></a>\n+## BC0104 - ProjectReference is prefered to Reference.",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This field is not very readable. Could the tuple be a record with a name what clarifying what it represents? I'd appreciate a comment what each dimension of the 2d array represents.",
              "createdAt": "2024-11-20T09:52:39Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -135,6 +136,7 @@ private static readonly (string[] ruleIds, bool defaultEnablement, CheckFactory\n             // BuildCheckDataSource.EventArgs\n             [\n                 ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),\n+                ([PreferProjectReferenceCheck.SupportedRule.Id], PreferProjectReferenceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<PreferProjectReferenceCheck>),",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "I agree a typed record struct will be better here - adding it.\r\n(btw. the fieldnames are 5 lines above - but again - record is superior here)",
              "createdAt": "2024-11-21T09:05:12Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -135,6 +136,7 @@ private static readonly (string[] ruleIds, bool defaultEnablement, CheckFactory\n             // BuildCheckDataSource.EventArgs\n             [\n                 ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),\n+                ([PreferProjectReferenceCheck.SupportedRule.Id], PreferProjectReferenceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<PreferProjectReferenceCheck>),",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why is it `using Microsoft.Build.BuildCheck.Checks;` while in other places there is namespace `Microsoft.Build.Experimental.BuildCheck.Infrastructure;` shouldn't everything be experimental/nonexperimental?\r\n\r\n",
              "createdAt": "2024-11-20T09:56:42Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,119 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BuildCheck.Checks;",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "we do the same in a different check\r\nhttps://github.com/dotnet/msbuild/blob/9c89563239bd60739920991211649d899b32ecb4/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs#L76\r\n\r\ncan we reuse/unify it?",
              "createdAt": "2024-11-21T09:14:34Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? targetPath;\n+\n+        context.Data.EvaluatedProperties.TryGetValue(\"TargetPath\", out targetPath);\n+\n+        if (string.IsNullOrEmpty(targetPath))\n+        {\n+            return;\n+        }\n+\n+        targetPath = RootEvaluatedPath(targetPath, context.Data.ProjectFilePath);\n+\n+        _projectsPerOutputPath[targetPath] = context.Data.ProjectFilePath;\n+\n+        (string, string) projectProducingOutput;\n+        if (_projectsPerReferencPath.TryGetValue(targetPath, out projectProducingOutput))\n+        {\n+            context.ReportResult(BuildCheckResult.Create(\n+                SupportedRule,\n+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                ElementLocation.EmptyLocation,\n+                Path.GetFileName(context.Data.ProjectFilePath),\n+                Path.GetFileName(projectProducingOutput.Item1),\n+                projectProducingOutput.Item2));\n+        }\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        if (!_projects.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        foreach (ItemData itemData in context.Data.EnumerateItemsOfType(\"Reference\"))\n+        {\n+            string evaluatedReferencePath = itemData.EvaluatedInclude;\n+            string referenceFullPath = RootEvaluatedPath(evaluatedReferencePath, context.Data.ProjectFilePath);\n+\n+            _projectsPerReferencPath[referenceFullPath] = (context.Data.ProjectFilePath, evaluatedReferencePath);\n+            string? projectReferencedViaOutput;\n+            if (_projectsPerOutputPath.TryGetValue(referenceFullPath, out projectReferencedViaOutput))\n+            {\n+                context.ReportResult(BuildCheckResult.Create(\n+                    SupportedRule,\n+                    // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                    ElementLocation.EmptyLocation,\n+                    Path.GetFileName(projectReferencedViaOutput),\n+                    Path.GetFileName(context.Data.ProjectFilePath),\n+                    evaluatedReferencePath));\n+            }\n+        }\n+    }\n+\n+    private static string RootEvaluatedPath(string path, string projectFilePath)\n+    {\n+        if (!Path.IsPathRooted(path))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Done",
              "createdAt": "2024-11-21T11:11:54Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? targetPath;\n+\n+        context.Data.EvaluatedProperties.TryGetValue(\"TargetPath\", out targetPath);\n+\n+        if (string.IsNullOrEmpty(targetPath))\n+        {\n+            return;\n+        }\n+\n+        targetPath = RootEvaluatedPath(targetPath, context.Data.ProjectFilePath);\n+\n+        _projectsPerOutputPath[targetPath] = context.Data.ProjectFilePath;\n+\n+        (string, string) projectProducingOutput;\n+        if (_projectsPerReferencPath.TryGetValue(targetPath, out projectProducingOutput))\n+        {\n+            context.ReportResult(BuildCheckResult.Create(\n+                SupportedRule,\n+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                ElementLocation.EmptyLocation,\n+                Path.GetFileName(context.Data.ProjectFilePath),\n+                Path.GetFileName(projectProducingOutput.Item1),\n+                projectProducingOutput.Item2));\n+        }\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        if (!_projects.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        foreach (ItemData itemData in context.Data.EnumerateItemsOfType(\"Reference\"))\n+        {\n+            string evaluatedReferencePath = itemData.EvaluatedInclude;\n+            string referenceFullPath = RootEvaluatedPath(evaluatedReferencePath, context.Data.ProjectFilePath);\n+\n+            _projectsPerReferencPath[referenceFullPath] = (context.Data.ProjectFilePath, evaluatedReferencePath);\n+            string? projectReferencedViaOutput;\n+            if (_projectsPerOutputPath.TryGetValue(referenceFullPath, out projectReferencedViaOutput))\n+            {\n+                context.ReportResult(BuildCheckResult.Create(\n+                    SupportedRule,\n+                    // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                    ElementLocation.EmptyLocation,\n+                    Path.GetFileName(projectReferencedViaOutput),\n+                    Path.GetFileName(context.Data.ProjectFilePath),\n+                    evaluatedReferencePath));\n+            }\n+        }\n+    }\n+\n+    private static string RootEvaluatedPath(string path, string projectFilePath)\n+    {\n+        if (!Path.IsPathRooted(path))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "typo `Referenc`",
              "createdAt": "2024-11-21T09:15:05Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? targetPath;\n+\n+        context.Data.EvaluatedProperties.TryGetValue(\"TargetPath\", out targetPath);\n+\n+        if (string.IsNullOrEmpty(targetPath))\n+        {\n+            return;\n+        }\n+\n+        targetPath = RootEvaluatedPath(targetPath, context.Data.ProjectFilePath);\n+\n+        _projectsPerOutputPath[targetPath] = context.Data.ProjectFilePath;\n+\n+        (string, string) projectProducingOutput;\n+        if (_projectsPerReferencPath.TryGetValue(targetPath, out projectProducingOutput))\n+        {\n+            context.ReportResult(BuildCheckResult.Create(\n+                SupportedRule,\n+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                ElementLocation.EmptyLocation,\n+                Path.GetFileName(context.Data.ProjectFilePath),\n+                Path.GetFileName(projectProducingOutput.Item1),\n+                projectProducingOutput.Item2));\n+        }\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        if (!_projects.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        foreach (ItemData itemData in context.Data.EnumerateItemsOfType(\"Reference\"))\n+        {\n+            string evaluatedReferencePath = itemData.EvaluatedInclude;\n+            string referenceFullPath = RootEvaluatedPath(evaluatedReferencePath, context.Data.ProjectFilePath);\n+\n+            _projectsPerReferencPath[referenceFullPath] = (context.Data.ProjectFilePath, evaluatedReferencePath);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "not very clear what you do here -why do you rely on EvaluatedItemsAction? Please explain",
              "createdAt": "2024-11-21T09:28:57Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Clarified",
              "createdAt": "2024-11-21T11:11:42Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "unused refs",
              "createdAt": "2024-11-21T09:33:23Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I added `IDE0005` for BuildCheck code - so that this is enforced in the whole project going forward",
              "createdAt": "2024-11-21T11:11:30Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can we move string to the const field?",
              "createdAt": "2024-11-21T09:34:32Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? targetPath;\n+\n+        context.Data.EvaluatedProperties.TryGetValue(\"TargetPath\", out targetPath);\n+\n+        if (string.IsNullOrEmpty(targetPath))\n+        {\n+            return;\n+        }\n+\n+        targetPath = RootEvaluatedPath(targetPath, context.Data.ProjectFilePath);\n+\n+        _projectsPerOutputPath[targetPath] = context.Data.ProjectFilePath;\n+\n+        (string, string) projectProducingOutput;\n+        if (_projectsPerReferencPath.TryGetValue(targetPath, out projectProducingOutput))\n+        {\n+            context.ReportResult(BuildCheckResult.Create(\n+                SupportedRule,\n+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                ElementLocation.EmptyLocation,\n+                Path.GetFileName(context.Data.ProjectFilePath),\n+                Path.GetFileName(projectProducingOutput.Item1),\n+                projectProducingOutput.Item2));\n+        }\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        if (!_projects.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        foreach (ItemData itemData in context.Data.EnumerateItemsOfType(\"Reference\"))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Created `ItemNames` reusable holder for those (similarly to existing `ItemMetadataNames`).\r\nPlus fixed same as well for the \"TargetPath\" above",
              "createdAt": "2024-11-21T11:10:46Z",
              "path": "src/Build/BuildCheck/Checks/PreferProjectReferenceCheck.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class PreferProjectReferenceCheck : Check\n+{\n+    private const string RuleId = \"BC0104\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"PreferProjectReference\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0104_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = \"BC0104\", Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.PreferProjectReferenceCheck\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly Dictionary<string, (string, string)> _projectsPerReferencPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private readonly HashSet<string> _projects = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Just check - do not add yet - it'll be done by EvaluatedItemsAction\n+        if (_projects.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? targetPath;\n+\n+        context.Data.EvaluatedProperties.TryGetValue(\"TargetPath\", out targetPath);\n+\n+        if (string.IsNullOrEmpty(targetPath))\n+        {\n+            return;\n+        }\n+\n+        targetPath = RootEvaluatedPath(targetPath, context.Data.ProjectFilePath);\n+\n+        _projectsPerOutputPath[targetPath] = context.Data.ProjectFilePath;\n+\n+        (string, string) projectProducingOutput;\n+        if (_projectsPerReferencPath.TryGetValue(targetPath, out projectProducingOutput))\n+        {\n+            context.ReportResult(BuildCheckResult.Create(\n+                SupportedRule,\n+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732\n+                ElementLocation.EmptyLocation,\n+                Path.GetFileName(context.Data.ProjectFilePath),\n+                Path.GetFileName(projectProducingOutput.Item1),\n+                projectProducingOutput.Item2));\n+        }\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        if (!_projects.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        foreach (ItemData itemData in context.Data.EnumerateItemsOfType(\"Reference\"))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "we use the same id in 4 diff places per CheckRule definition.\r\nThough it's not directly connected to your changes, but could you please move it to fields and reuse?",
              "createdAt": "2024-11-21T09:42:30Z",
              "path": "src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs",
              "diffHunk": "@@ -19,17 +19,17 @@ internal class PropertiesUsageCheck : InternalCheck\n     private static readonly CheckRule _usedBeforeInitializedRule = new CheckRule(\"BC0201\", \"PropertyUsedBeforeDeclared\",\n         ResourceUtilities.GetResourceString(\"BuildCheck_BC0201_Title\")!,\n         ResourceUtilities.GetResourceString(\"BuildCheck_BC0201_MessageFmt\")!,\n-        new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });\n+        new CheckConfiguration() { RuleId = \"BC0201\", Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "This was oversight - the const was already defined, but not used here. Fixed",
              "createdAt": "2024-11-21T11:09:44Z",
              "path": "src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs",
              "diffHunk": "@@ -19,17 +19,17 @@ internal class PropertiesUsageCheck : InternalCheck\n     private static readonly CheckRule _usedBeforeInitializedRule = new CheckRule(\"BC0201\", \"PropertyUsedBeforeDeclared\",\n         ResourceUtilities.GetResourceString(\"BuildCheck_BC0201_Title\")!,\n         ResourceUtilities.GetResourceString(\"BuildCheck_BC0201_MessageFmt\")!,\n-        new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });\n+        new CheckConfiguration() { RuleId = \"BC0201\", Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "if we operate under Experimental namespace, why we couldn't just remove it?",
              "createdAt": "2024-11-21T09:44:41Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs",
              "diffHunk": "@@ -23,7 +23,10 @@ public BuildCheckCentralContext(IConfigurationProvider configurationProvider, Ac\n \n     private record CallbackRegistry(\n         List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,\n+#pragma warning disable CS0618 // Type or member is obsolete\n         List<(CheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "It is possible. Though I want to be a bit more gracefull to prevent impression that it's not a good idea to author extensions yet",
              "createdAt": "2024-11-21T11:13:14Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs",
              "diffHunk": "@@ -23,7 +23,10 @@ public BuildCheckCentralContext(IConfigurationProvider configurationProvider, Ac\n \n     private record CallbackRegistry(\n         List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,\n+#pragma warning disable CS0618 // Type or member is obsolete\n         List<(CheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}