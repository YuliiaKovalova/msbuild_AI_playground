{
  "number": 8779,
  "title": "Relay remoted exceptions",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/8786\r\n\r\n### Context\r\nBinaryFormatSerializer is going to be deprecated (https://aka.ms/binaryformatter) - as a result we should not be using our `SerializeDotNet` function.\r\nThis PR is tackling one of the remaining usages - (de)serialization of Exceptions.\r\n\r\n### Changes Made\r\n* Introduced base type for MSBuild exceptions\r\n* Added serialization ctors and state flushing/initialization methods (`InternalLoggerException` doesn have the `BuildEventArgs` argument preserved during remoting - as it doesn't have straightforward to/from string representations)\r\n* All exceptions loaded into default appdomain during the time of serialization that inherit from said base are going to be transfered preserving the original type\r\n* All other exceptions are relayed via single artifical exception type\r\n* Added option to have Exceptions not inherited from same root (just same named base) - which unfortunately relies more heavily on reflection. This is needed to facilitate nuget.exe scenarios (older versions do not explicitly load Microsoft.Build.Framework as is done now: https://github.com/dotnet/dotnet/blob/60d62c7e343ac99313ccf14f75d84be631b4df5d/src/nuget-client/src/NuGet.Clients/NuGet.CommandLine/Common/MSBuildUser.cs#LL42C9-L42C9)\r\n\r\n\r\n### Unrelated Issues Workarounded Or Addressed\r\n * Altered ChangeWaves left behind after ChangeWaves altering tests (fixed https://github.com/dotnet/msbuild/pull/8779/files#diff-11f9e8c3bfb7730d6acb8bbef56e104192d1f0d8093d3248e7af77f179550457R99)\r\n * NuGet.CommandLine not properly loading dependencies of Microsoft.Build (first workarounded, then increased lowest supported version - https://github.com/dotnet/msbuild/pull/8779/files#diff-bae89a962ea7165bed3085d30d75bdfdff3e414f619de684bd90a3712b188d34R19)\r\n * ApiCompat check wrongly flaging introduction of extended base type (added temporary supression: https://github.com/dotnet/msbuild/pull/8779/files#diff-6c2861bebb30e66967638b5067f5b31dbb49f09794fd749db5a8f48d68c440a8R1-R39)\r\n\r\n### Testing\r\n* Testing remoting of all internally supported types (iterating over their all public properties of primitive types)\r\n\r\n\\+ manual test described in the bug\r\n\r\n_Prior fix:_\r\n\r\n```\r\nbinaryFormatterBrokenBuild.csproj(6,17): error MSB4113: Specified condition \"''\" evaluates to \"\" instead of a boolean.\r\nMSBUILD : error MSB4166: Child node \"2\" exited prematurely. Shutting down. Diagnostic information may be found in files in\r\n\"C:\\Users\\jankrivanek\\AppData\\Local\\Temp\\MSBuildTempjankrivanek\\\" and will be named MSBuild_*.failure.txt. This location ca\r\nn be changed by setting the MSBUILDDEBUGPATH environment variable to a different directory.\r\nMSBUILD : error MSB4166: C:\\Users\\jankrivanek\\AppData\\Local\\Temp\\MSBuildTempjankrivanek\\MSBuild_pid-25752_9a55230dad3b41b09\r\n1eb48954483f835.failure.txt:\r\nMSBUILD : error MSB4166: UNHANDLED EXCEPTIONS FROM PROCESS 25752:\r\nMSBUILD : error MSB4166: =====================\r\nMSBUILD : error MSB4166: 5/22/2023 11:10:07 AM\r\nMSBUILD : error MSB4166: System.NotSupportedException: BinaryFormatter serialization and deserialization are disabled withi\r\nn this application. See https://aka.ms/binaryformatter for more information.\r\nMSBUILD : error MSB4166:    at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializatio\r\nnStream, Object graph)\r\nMSBUILD : error MSB4166:    at Microsoft.Build.Execution.BuildResult.Microsoft.Build.BackEnd.ITranslatable.Translate(ITrans\r\nlator translator)\r\nMSBUILD : error MSB4166:    at Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase.RunReadLoop(Stream localReadPipe, Stream l\r\nocalWritePipe, ConcurrentQueue`1 localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacket\r\nPump)\r\nMSBUILD : error MSB4166: ===================\r\nMSBUILD : error MSB4166:\r\nMSBUILD : error MSB4166:\r\n    0 Warning(s)\r\n    2 Error(s)\r\n```\r\n\r\n_After fix:_\r\n\r\n```\r\nbinaryFormatterBrokenBuild.csproj(6,17): error MSB4113: Specified condition \"''\" evaluates to \"\" instead of a boolean.\r\n    0 Warning(s)\r\n    1 Error(s)\r\n```\r\n\r\n-----------------\r\n**Edit 01:**\r\n* Conditioned behind changewave (However TaskHost has this always enabled as it doesn't currently use ChangeWaves)\r\n* Message, Type nonullable now; HResult transfered if on NET4.5 and above (the constract still respect situation where one side is not on the version)\r\n* Tests added\r\n\r\n**Edit 02:**\r\n* Moved remoting related utils to Framework\r\n\r\n**Edit 03:**\r\n* Introduced internal exceptions hierarchy and type preserving de/serialization\r\n* **This fixes the SDK regression repro**\r\n\r\n**Edit 04:**\r\n* Introduced more reflection - allowing to use exception types not inheriting from common root base\r\n* **This fixes the failing nuget.exe test**\r\n\r\n**Edit 05:**\r\n* Introduced fixed serialization whitelist - this is needed to prevent deserialization exploit similar to BinaryFormatter attack\r\n\r\n**Edit 06:**\r\n* Increased version of NuGet.CommandLine supported by MSBuild and removed all workaround code that was needed to facilitate it",
  "state": "MERGED",
  "createdAt": "2023-05-19T16:58:55Z",
  "updatedAt": "2023-06-20T14:33:11Z",
  "closedAt": "2023-06-20T14:32:55Z",
  "mergedAt": "2023-06-20T14:32:55Z",
  "additions": 1037,
  "deletions": 96,
  "changedFiles": 54,
  "headRefName": "proto/serialize-exc",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a398b48c4ba91ebf15a6907a9b6b848e828c31d5",
          "message": "Relay remoted exceptions over to single squashed exception type",
          "committedDate": "2023-05-19T16:55:21Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b0963ceedba08184ea41ad811858fdaef41ca01",
          "message": "Reflect PR suggestions",
          "committedDate": "2023-05-22T10:50:04Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d2213d95597f0176654560dcbb3cfcf484733ed",
          "message": "Reset changewaves after testenv cleanup",
          "committedDate": "2023-05-22T15:17:45Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbe8161f0637a49330fe6642c4b8de84f880490c",
          "message": "Refactor - move translator types closure into Framework",
          "committedDate": "2023-05-23T13:05:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c0ea58e3f24a6f3d67bd81537123c54bb5a8a41b",
          "message": "Fix styling",
          "committedDate": "2023-05-23T15:42:23Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a5f6f85fa71ad9402f4b94b79bb05bc8106577c",
          "message": "Introduce internal exceptions hierarchy and type preserving remoting",
          "committedDate": "2023-05-23T20:35:55Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c6ef17ce7c9ac2e0547ebd85f148d5497fd3c1d",
          "message": "Merge remote-tracking branch 'upstream/main' into proto/serialize-exc",
          "committedDate": "2023-05-24T09:36:37Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "32f11ac59f272faef4162bbde89cc562ee583da9",
          "message": "Refactor build transfering to accomodate nuget.exe type loading limitations",
          "committedDate": "2023-05-24T19:57:59Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d7cfe0ab897660762ea50f6acb8b25e90dbbdbfd",
          "message": "Fix styling",
          "committedDate": "2023-05-24T20:04:24Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "90bf24694d61de35f8a6c5321d2064139594514f",
          "message": "Whitelist supported exception types",
          "committedDate": "2023-05-26T12:52:52Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3c5a33bbd12a50dcd310d505287b5a4ce1a8debf",
          "message": "Support proper exceptions serialization initialization for all msbuild invocation ways",
          "committedDate": "2023-05-26T14:03:22Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7d91933ba4d30b4c222dd17867b15f6179a70e50",
          "message": "Exclude TaskHost types from automated discovery in tests",
          "committedDate": "2023-05-26T15:53:38Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1b9f2a0a3d6949cdb5485b2d00058778ab3f07fa",
          "message": "Make BuildExceptionBase unextensible",
          "committedDate": "2023-05-26T16:28:14Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0478b785e06e2b3eeefbc20beebd78bc13614140",
          "message": "Suppress the api compat check errors",
          "committedDate": "2023-05-30T11:16:26Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0b1319edc75db670eb226319d1fbe9d9b9dac7f6",
          "message": "Mention AppCompat limitation requiring suppression",
          "committedDate": "2023-05-31T09:30:38Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f12e99a336bf7af2d132c769802a09aa249ecaf8",
          "message": "Remove workarounds facilitating support of legacy nuget.commandline",
          "committedDate": "2023-05-31T14:27:36Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "31ef5118ad87b1401e72df45d78a25924a9f8584",
          "message": "Extend suppression",
          "committedDate": "2023-05-31T15:15:42Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e7c8707152fec8463c3f940920d59fb9dfa327a3",
          "message": "Unblock failing test - remove nuget copying condition",
          "committedDate": "2023-06-02T16:27:32Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "09d8c227605f3e43bff2b6553afb01961f7a976a",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-06-12T13:07:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39ee061b011d80733f3c5ff355793fe78c884cd1",
          "message": "Apply code review suggestions",
          "committedDate": "2023-06-12T13:56:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c172dd8978fb0d68d9de8a90916a48c3944647b",
          "message": "Decoupling Build.Framework from StringTools",
          "committedDate": "2023-06-12T15:32:20Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8cc1a75ddced9295389b6be5dda1332693a662ea",
          "message": "Replace reflection with factories",
          "committedDate": "2023-06-12T16:37:11Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80e0df6fc0cdabb876ecffa37028db3e6c601673",
          "message": "Rename SharedReadBuffer->BinaryReaderFactory",
          "committedDate": "2023-06-14T16:42:19Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7867f14d1b33f5a0752b423de3ca0d9935e68312",
          "message": "Apply code review suggestions",
          "committedDate": "2023-06-20T12:39:23Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@danmoseley Thanks for a detailed look! Second look would be very appreciated (I attempted to address all resolved comments; the unresolved one might need clarification)",
        "createdAt": "2023-05-22T10:57:03Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> This doesn't fully resolve the crash in the repro from [#6215 (comment)](https://github.com/dotnet/msbuild/issues/6215#issuecomment-1553276894):\r\n> \r\n> ```\r\n> \u276f dotnet msbuild -nr:false .\\error.proj\r\n> MSBuild version 17.7.0-dev-23272-01+2b0963cee for .NET\r\n> S:\\repro\\dotnet\\msbuild\\issues\\6215\\error.proj(2,20): error MSB4113: Specified condition \"''\" evaluates to \"\" instead of a boolean.\r\n> MSBUILD : error MSB1025: An internal failure occurred while running MSBuild.\r\n> This is an unhandled exception in MSBuild -- PLEASE OPEN A BUG AGAINST THE MSBUILD TEAM.\r\n> Microsoft.Build.Exceptions.InvalidProjectFileException->Microsoft.Build.BackEnd.BuildTransferredException: Specified condition \"''\" evaluates to \"\" instead of a boolean.  S:\\repro\\dotnet\\msbuild\\issues\\6215\\error.proj\r\n>    at Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject(String errorSubCategoryResourceName, IElementLocation elementLocation, String resourceName, Object[] args) in S:\\msbuild\\src\\Shared\\ProjectErrorUtilities.cs:line 373\r\n> ...\r\n> ```\r\n> \r\n> I think our internal exception types need to be serialized in a type-preserving way.\r\n\r\nThanks for pointing!\r\nOn it",
        "createdAt": "2023-05-22T14:37:12Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "How do we indicate the API change is intended? (increasing `PackageValidationBaselineVersion` to current breaks as such version is not yet in package feed)\r\n\r\n```\r\nType 'Microsoft.Build.Exceptions.BuildAbortedException' does not inherit from base type 'System.Exception' on ref/net472/Microsoft.Build.dll but it does on [Baseline]\r\n```",
        "createdAt": "2023-05-26T16:32:37Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "It is possible to [suppress package validation errors](https://learn.microsoft.com/dotnet/fundamentals/package-validation/overview#suppress-compatibility-errors), but that change feels like a pretty big break. Is it not possible to maintain inheritance from `System.Exception`?",
        "createdAt": "2023-05-26T16:45:34Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> It is possible to [suppress package validation errors](https://learn.microsoft.com/dotnet/fundamentals/package-validation/overview#suppress-compatibility-errors), but that change feels like a pretty big break. Is it not possible to maintain inheritance from `System.Exception`?\r\n\r\nThank you @rainersigwald for pointing me there!\r\nI've added a suppression file to unblock the build now (and to see there are no other roadblocks) - but let's see whether that's the right approach:\r\n\r\n**What:**\r\n\r\nwas:\r\n`<Our Exceptions> --> System.Exception`\r\nproposed:\r\n`<Our Exceptions> --> Microsoft.Build.BackEnd.BuildExceptionBase --> System.Exception`\r\n\r\nSo our exceptions still derive from `System.Exception`, the comon inheritance hierarchy type is added.\r\n\r\n**Why:**\r\n\r\nThis is needed so that we can properly override stack trace (and hence deserialize it) and so that we can set the protected members without reflection (reflection was partly added in later commits to facilitate nuget scenario - which might not be necessary - remains to be confirmed)\r\n\r\nAs side effect this as well alows unified handling of excpetions\r\n\r\n**What it can break:**\r\n\r\nThat's where I'm puzzled - I cannot imagine sane code that would be broken by this change - as the `System.Exception` base is still there. Not sure what could rely on exact inheritance chain levels",
        "createdAt": "2023-05-30T12:01:13Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> That's where I'm puzzled - I cannot imagine sane code that would be broken by this change - as the System.Exception base is still there. Not sure what could rely on exact inheritance chain levels\r\n\r\nI can look up the details later if you're interested, but I remember that when I was working with System.Reflection.MetadataLoadContext and System.Reflection.Metadata, it was very easy to write code that looks right but only looks one level deep\u2014that is, code that will notice and be able to react to the parent of a type but not any of its ancestors beyond that.\r\n\r\nSo the scenario that I can imagine being broken is in which you have a collection of various MSBuild-y things you got out of the API, and then you filter to types where the parent type has some specific attribute that happens to be on Exception but not (directly) on the new BuildExceptionBase. Your filter now misses exceptions.\r\n\r\nThis is a bug in user code, and they should fix it. All they have to do is make a loop that goes from parent to grandparent, etc. and checks each. But although it's very specific, I could imagine a reasonable user doing it, so I wanted to bring it up.",
        "createdAt": "2023-05-30T15:27:14Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "We generally consider this non-breaking\r\n\r\nhttps://github.com/dotnet/runtime/blob/3747edb1812106f0b88a42b724c3e44b69dc79c4/docs/coding-guidelines/breaking-change-rules.md#L50\r\nhttps://github.com/dotnet/runtime/blob/3747edb1812106f0b88a42b724c3e44b69dc79c4/docs/coding-guidelines/breaking-change-rules.md#L139\r\n\r\n@ericstj where do we open bugs against the package validation tool? (unless perhaps this is by design)",
        "createdAt": "2023-05-30T15:35:29Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "cc @ViktorHofer \r\nInserting a base type is allowed.  I do recall ensuring we test for this, here's a test that covers it: \r\nhttps://github.com/dotnet/sdk/blob/0ba7aa399bfc0f5394d0f0a2fabe7c1093e49825/src/Tests/Microsoft.DotNet.ApiCompatibility.Tests/Rules/CannotRemoveBaseTypeOrInterfaceTests.cs#L19-L52\r\nPerhaps there's an issue with references being followed in this comparison where it isn't able to traverse the inheritance hierarchy.  \ud83e\udd14 \r\nIssues should be filed here: https://github.com/dotnet/sdk/issues?q=is%3Aopen+is%3Aissue+label%3AArea-ApiCompat",
        "createdAt": "2023-05-30T18:36:42Z",
        "author": {
          "login": "ericstj"
        }
      },
      {
        "body": "Thanks @danmoseley and @ericstj for the help!\r\nThe new base exception type is not flagged in the assembly that is defining the new base type, t is only flagged in assembly that is referencing it - so your theory @ericstj might be right. The dependency is properly declared - si it still feels as a bug.\r\nIssue created: https://github.com/dotnet/sdk/issues/32922",
        "createdAt": "2023-05-31T09:27:27Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I did a root cause investigation and shared my finding in https://github.com/dotnet/sdk/issues/32922. Also submitted a fix for it: https://github.com/dotnet/sdk/pull/32930. As we just branched, the fix will likely not be available before Preview 6. While you could use APICompat's nuget package to immediately receive the fix, IMO it's fine to keep this baselined until the repository uses the P6 SDK.\r\n\r\nI tested my changes on top of your PR and the errors are gone. From that point of view, your changes are correct \ud83d\udc4d ",
        "createdAt": "2023-05-31T13:50:08Z",
        "author": {
          "login": "ViktorHofer"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this be in Framework instead so we only JIT it once?",
              "createdAt": "2023-05-19T17:03:43Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'd love to have it there - but it's needed in `MSBuildTaskHost` as well - and that's not currently referencing Framework.\r\nNot sure if there is an easy way out - I'm open to any suggestions (as I hate current repetitive pulling of files to build, instead of binary sharing, situation)",
              "createdAt": "2023-05-22T14:35:46Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "We have done some sneaky things in the past like:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/d077d294fa30f3ce8a8eda70f4630234a8f6c4c9/src/MSBuildTaskHost/MSBuildTaskHost.csproj#L120\r\n\r\nThen it's not shared for the main part of modern MSBuild but can be shared for TaskHost only.",
              "createdAt": "2023-05-22T14:43:29Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Perfect! Will do that! As I'll likely anyway need to setup exceptions hierarchy - so FW seems a best destiantion for that. Sneaky think isolated to TaskHost sounds very acceptable",
              "createdAt": "2023-05-22T17:04:58Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why are typeName and message optional?",
              "createdAt": "2023-05-19T17:13:06Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Adjusted to make both available",
              "createdAt": "2023-05-22T10:15:14Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This method already exists, albeit not here...think maybe you could unify the implementations?",
              "createdAt": "2023-05-19T17:15:29Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));\n+        }\n+\n+        private static string? ReadOptionalString(BinaryReader reader)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "tl;dr;: true, but out of scope.\r\n\r\nThe `ReadOptionalString`, `WriteOptionalString` helpers are part of `Microsoft.Build.Framework assembly`, which makes them unavailable for `MSBuildTaskHost` assembly.\r\nI'd need to extract them to a shared file that is build imported by each project separately - this makes developer life a misery and I do not want to spread this technique any further :-) However I do not have capacity to tackle this more systematically as part of this PR. So I decide to just copy those few lines of code",
              "createdAt": "2023-05-22T10:20:33Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));\n+        }\n+\n+        private static string? ReadOptionalString(BinaryReader reader)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I'll actually try to use technique suggested by @rainersigwald below (common utils in FW, linked into TaskHost) - hold on :-)",
              "createdAt": "2023-05-22T17:06:05Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));\n+        }\n+\n+        private static string? ReadOptionalString(BinaryReader reader)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Hresult is sometimes important, helplink and to a lesser extent source are almost never useful.",
              "createdAt": "2023-05-19T17:22:51Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Keeping all for now (added HResult per suggestion below) - as this is not a hot path, so extra diagnostic info can always be handy",
              "createdAt": "2023-05-22T10:55:51Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why string empty here and optional string for the others? Both achieve the same result.",
              "createdAt": "2023-05-19T17:25:09Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "in fact, I think WriteOptionalString could just write null for missing, not bother with the 0/1 at all.",
              "createdAt": "2023-05-19T17:38:55Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I might be misunderstanding here.\r\n`BinaryWriter.Write(string)` [throws on null`](https://github.com/dotnet/runtime/blob/1f15489cfd27ce490b53434420a3727931136e59/src/libraries/System.Private.CoreLib/src/System/IO/BinaryWriter.cs#L346-L348) - so the null must be somehow explicitly indicated",
              "createdAt": "2023-05-22T10:28:25Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "suggest writing it for higher versions (either x-targeting or with reflection). The real one, not GetHRForException, which tells you nothing you can't get from calling it on your own machine later.",
              "createdAt": "2023-05-19T17:31:58Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not seeing where you write this boolean - missing test I guess",
              "createdAt": "2023-05-19T17:32:53Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Seems to be written here <https://github.com/dotnet/msbuild/blob/a398b48c4ba91ebf15a6907a9b6b848e828c31d5/src/Shared/BuildTransferredException.cs#L53>",
              "createdAt": "2023-05-22T10:37:40Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "Still good point on explicit test(s) - adding those",
              "createdAt": "2023-05-22T10:44:20Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "needs to be optional -- stack trace can be null\r\nhttps://github.com/dotnet/runtime/blob/3747edb1812106f0b88a42b724c3e44b69dc79c4/src/libraries/System.Private.CoreLib/src/System/Exception.cs#L143",
              "createdAt": "2023-05-19T17:36:02Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`realTypeName` ? ",
              "createdAt": "2023-05-19T17:36:23Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "assert if exception.Data is not null, to alert that data is being lost? I agree it's probably not worth adding here, but maybe some case will pop up where you do want to add it later.",
              "createdAt": "2023-05-19T17:37:42Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));\n+        }",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "exception.Data typically is an empty dictionary, not null.",
              "createdAt": "2023-05-22T10:44:06Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));\n+        }",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "right, I should have said assert it's empty.",
              "createdAt": "2023-05-23T17:17:48Z",
              "path": "src/Shared/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string? _typeName;\n+\n+        public BuildTransferredException(\n+            string? message,\n+            Exception? inner,\n+            string? typeName,\n+            string deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _typeName = typeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_typeName ?? \"Unknown\"}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string? message = ReadOptionalString(reader);\n+            string? typeName = ReadOptionalString(reader);\n+            string deserializedStackTrace = reader.ReadString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = ReadOptionalString(reader),\n+                HelpLink = ReadOptionalString(reader),\n+                // HResult = reader.ReadInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            WriteOptionalString(writer, exception.Message);\n+            WriteOptionalString(writer, exception.GetType().FullName);\n+            writer.Write(exception.StackTrace ?? string.Empty);\n+            WriteOptionalString(writer, exception.Source);\n+            WriteOptionalString(writer, exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+            // writer.Write(System.Runtime.InteropServices.Marshal.GetHRForException(exception));\n+        }",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            // HResult is completely protected up till net4.5\r\n#if NET || NET45_OR_GREATER\r\n            int? hresult = exception.HResult;\r\n#else\r\n            int? hresult = null;\r\n#endif\r\n            writer.WriteOptionalInt32(hresult);\r\n```\r\nputs it next to ReadOptionalInt32, otherwise the contract is split.",
              "createdAt": "2023-05-23T17:21:42Z",
              "path": "src/Framework/BuildTransferredException.cs",
              "diffHunk": "@@ -0,0 +1,77 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class BuildTransferredException : Exception\n+    {\n+        private readonly string _originalTypeName;\n+\n+        public BuildTransferredException(\n+            string message,\n+            Exception? inner,\n+            string originalTypeName,\n+            string? deserializedStackTrace)\n+            : base(message, inner)\n+        {\n+            _originalTypeName = originalTypeName;\n+            StackTrace = deserializedStackTrace;\n+        }\n+\n+        public override string? StackTrace { get; }\n+\n+        public override string ToString() => $\"{_originalTypeName}->{base.ToString()}\";\n+\n+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)\n+        {\n+            BinaryReader reader = translator.Reader;\n+            Exception? innerException = null;\n+            if (reader.ReadBoolean())\n+            {\n+                innerException = ReadExceptionFromTranslator(translator);\n+            }\n+\n+            string message = reader.ReadString();\n+            string typeName = reader.ReadString();\n+            string? deserializedStackTrace = reader.ReadOptionalString();\n+            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)\n+            {\n+                Source = reader.ReadOptionalString(),\n+                HelpLink = reader.ReadOptionalString(),\n+                HResult = reader.ReadOptionalInt32(),\n+            };\n+\n+            return exception;\n+        }\n+\n+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)\n+        {\n+            BinaryWriter writer = translator.Writer;\n+            writer.Write(exception.InnerException != null);\n+            if (exception.InnerException != null)\n+            {\n+                WriteExceptionToTranslator(translator, exception.InnerException);\n+            }\n+            writer.Write(exception.Message);\n+            writer.Write(exception.GetType().FullName ?? exception.GetType().ToString());\n+            writer.WriteOptionalString(exception.StackTrace);\n+            writer.WriteOptionalString(exception.Source);\n+            writer.WriteOptionalString(exception.HelpLink);\n+            // HResult is completely protected up till net4.5\n+#if NET || NET45_OR_GREATER\n+            writer.Write((byte)1);\n+            writer.Write(exception.HResult);\n+#else\n+            writer.Write((byte)0);\n+#endif",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "test aggregate exception (with multiple inner exceptions) is producing reasonable result, with everything transmitted? they do go in Message and ToString. but, you're not relying on those to preserve InnerException singular.",
              "createdAt": "2023-05-23T17:23:40Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -201,6 +201,40 @@ public void TestSerializeDotNetNull()\n             Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));\n         }\n \n+        [Fact]\n+        public void TestSerializeException()\n+        {\n+            Exception value = new ArgumentNullException(\"The argument was null\");\n+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);\n+\n+            Exception deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);\n+\n+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));\n+        }\n+\n+        [Fact]\n+        public void TestSerializeException_NestedWithStack()\n+        {\n+            Exception value = null;\n+            try\n+            {\n+                // Intentionally throw a nested exception with a stack trace.\n+                value = value.InnerException;\n+            }\n+            catch (Exception e)\n+            {\n+                value = new ArgumentNullException(\"The argument was null\", e);\n+            }\n+\n+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);\n+\n+            Exception deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);\n+\n+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));\n+        }\n+",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Added data driven test enumerating all supported exception types and for those recursively enumerating all primitive type properties (pre- and post- serialization)",
              "createdAt": "2023-05-24T19:57:45Z",
              "path": "src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs",
              "diffHunk": "@@ -201,6 +201,40 @@ public void TestSerializeDotNetNull()\n             Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));\n         }\n \n+        [Fact]\n+        public void TestSerializeException()\n+        {\n+            Exception value = new ArgumentNullException(\"The argument was null\");\n+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);\n+\n+            Exception deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);\n+\n+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));\n+        }\n+\n+        [Fact]\n+        public void TestSerializeException_NestedWithStack()\n+        {\n+            Exception value = null;\n+            try\n+            {\n+                // Intentionally throw a nested exception with a stack trace.\n+                value = value.InnerException;\n+            }\n+            catch (Exception e)\n+            {\n+                value = new ArgumentNullException(\"The argument was null\", e);\n+            }\n+\n+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);\n+\n+            Exception deserializedValue = null;\n+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);\n+\n+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));\n+        }\n+",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should actually be populated on-demand, rather then prefetched - this way we can prevent problematic situations with lately loaded assemblies.\r\nIn order to load on-demand on the receiving side, we'll need to send type FQDN.",
              "createdAt": "2023-05-25T19:14:19Z",
              "path": "src/Framework/BuildException/BuildExceptionSerializationHelper.cs",
              "diffHunk": "@@ -0,0 +1,273 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Reflection;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class BuildExceptionSerializationHelper\n+    {\n+        private class BuildExceptionConstructionCallbacks\n+        {\n+            public BuildExceptionConstructionCallbacks(\n+                Func<string, Exception?, Exception> factory,\n+                Action<Exception, BuildExceptionRemoteState> instnaceInitializer,\n+                Func<Exception, IDictionary<string, string?>?> remoteStateExtractor)\n+            {\n+                Factory = factory;\n+                InstnaceInitializer = instnaceInitializer;\n+                RemoteStateExtractor = remoteStateExtractor;\n+            }\n+\n+            internal Func<string, Exception?, Exception> Factory { get; }\n+            internal Action<Exception, BuildExceptionRemoteState> InstnaceInitializer { get; }\n+            internal Func<Exception, IDictionary<string, string?>?> RemoteStateExtractor { get; }\n+        }\n+\n+        private static readonly Dictionary<string, BuildExceptionConstructionCallbacks> s_exceptionFactories = FetchExceptionsConstructors();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "spelling RegisterExceptions",
              "createdAt": "2023-05-26T16:46:18Z",
              "path": "src/MSBuild/SerializationContractInitializer.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Reflection;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.SdkResolution;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Experimental.ProjectCache;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal static class SerializationContractInitializer\n+    {\n+        internal static void RegisterExcpetions()",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you use this enough to want to check it in? I basically never use a `.slnf` and have devolved to always using `MSBuild.sln`. If you use it, I don't have a strong objection--just a desire to reduce clutter in our repo root.",
              "createdAt": "2023-06-08T20:18:29Z",
              "path": "MSBuild.TaskHost.slnf",
              "diffHunk": "@@ -0,0 +1,9 @@\n+{\n+  \"solution\": {\n+    \"path\": \"MSBuild.sln\",\n+    \"projects\": [\n+      \"src\\\\MSBuildTaskHost\\\\MSBuildTaskHost.csproj\",",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I agree - I haven't come accross need of this outside of experimenting on this PR. Removing..",
              "createdAt": "2023-06-12T13:11:00Z",
              "path": "MSBuild.TaskHost.slnf",
              "diffHunk": "@@ -0,0 +1,9 @@\n+{\n+  \"solution\": {\n+    \"path\": \"MSBuild.sln\",\n+    \"projects\": [\n+      \"src\\\\MSBuildTaskHost\\\\MSBuildTaskHost.csproj\",",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- [New serialization approach for transferring build exceptions between processes](https://github.com/dotnet/msbuild/pull/8779)\r\n```",
              "createdAt": "2023-06-08T20:19:45Z",
              "path": "documentation/wiki/ChangeWaves.md",
              "diffHunk": "@@ -22,11 +22,11 @@ A wave of features is set to \"rotate out\" (i.e. become standard functionality) t\n # Change Waves & Associated Features\n \n ## Current Rotation of Change Waves\n-### 17.8\n-- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)\n \n ### 17.8\n+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)\n - [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)\n+- [Relay remoted exceptions over to single squashed exception type](https://github.com/dotnet/msbuild/pull/8779)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this the oldest version that works with this change? I was hoping to still see it at something like 4.9, which looks like the oldest version that might be in wide use (thanks to https://github.com/microsoft/azure-pipelines-tasks/blob/7acfb8e566d01fc5c4da820b93a38e59e84e80f2/Tasks/NuGetToolInstallerV1/nugettoolinstaller.ts#L8).",
              "createdAt": "2023-06-09T14:27:22Z",
              "path": "src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj",
              "diffHunk": "@@ -15,8 +15,9 @@\n   </PropertyGroup>\n \n   <PropertyGroup>\n-    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>\n-</PropertyGroup>\n+    <!-- Managed manually since PackageDownload is not supported by dependabot https://github.com/dependabot/dependabot-core/issues/2920 -->\n+    <NuGetCommandLinePackageVersion>6.5.0</NuGetCommandLinePackageVersion>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is not - this was bit more aggressive :-)\r\nDowngrading..",
              "createdAt": "2023-06-12T13:12:55Z",
              "path": "src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj",
              "diffHunk": "@@ -15,8 +15,9 @@\n   </PropertyGroup>\n \n   <PropertyGroup>\n-    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>\n-</PropertyGroup>\n+    <!-- Managed manually since PackageDownload is not supported by dependabot https://github.com/dependabot/dependabot-core/issues/2920 -->\n+    <NuGetCommandLinePackageVersion>6.5.0</NuGetCommandLinePackageVersion>",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": ". . . how was this not here before? \ud83e\udd26\ud83c\udffb",
              "createdAt": "2023-06-09T14:29:02Z",
              "path": "src/Shared/UnitTests/TestEnvironment.cs",
              "diffHunk": "@@ -95,6 +96,7 @@ private void Cleanup()\n                 }\n \n                 SetEnvironmentVariable(\"MSBUILDDISABLEFEATURESFROMVERSION\", \"\");\n+                ChangeWaves.ResetStateForTests();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you change this to match where it's living?\r\n\r\n```suggestion\r\nnamespace Microsoft.Build.Framework;\r\n```",
              "createdAt": "2023-06-09T15:10:18Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Bah. It actually is now, partially\r\n\r\nhttps://github.com/dotnet/msbuild/blob/c6daff1259eb3c2a42d53f664f82c3c8a66c6166/src/Framework/ErrorUtilities.cs#L63-L69\r\n\r\nAnd we should standardize there, because putting it in Traits is ridiculous. But you don't have to clean up my mess right now :)",
              "createdAt": "2023-06-09T15:17:07Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -474,15 +475,15 @@ public enum SdkReferencePropertyExpansionMode\n         /// then we can give them this undocumented environment variable as an immediate workaround.\n         /// </summary>\n         /// <remarks>\n-        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.\n+        /// Clone from ErrorUtilities which isn't available in Framework.\n         /// </remarks>\n         private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDDONOTTHROWINTERNAL\"));\n \n         /// <summary>\n         /// Throws InternalErrorException.\n         /// </summary>\n         /// <remarks>\n-        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.\n+        /// Clone of ErrorUtilities.ThrowInternalError which isn't available in Framework.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good point. Should be moved. https://github.com/dotnet/msbuild/issues/8871",
              "createdAt": "2023-06-12T13:26:28Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -474,15 +475,15 @@ public enum SdkReferencePropertyExpansionMode\n         /// then we can give them this undocumented environment variable as an immediate workaround.\n         /// </summary>\n         /// <remarks>\n-        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.\n+        /// Clone from ErrorUtilities which isn't available in Framework.\n         /// </remarks>\n         private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDDONOTTHROWINTERNAL\"));\n \n         /// <summary>\n         /// Throws InternalErrorException.\n         /// </summary>\n         /// <remarks>\n-        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.\n+        /// Clone of ErrorUtilities.ThrowInternalError which isn't available in Framework.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    // This is needed to allow opting back in to BinaryFormatter serialization\r\n```\r\n\r\n?",
              "createdAt": "2023-06-09T15:23:36Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd;\n+\n+public abstract class BuildExceptionBase : Exception\n+{\n+    private string? _remoteTypeName;\n+    private string? _remoteStackTrace;\n+\n+    private protected BuildExceptionBase()\n+        : base()\n+    { }\n+\n+    private protected BuildExceptionBase(string message)\n+        : base(message)\n+    { }\n+\n+    private protected BuildExceptionBase(\n+        string message,\n+        Exception? inner)\n+        : base(message, inner)\n+    { }\n+\n+    // This is needed as soon as we allow opt out of the non-BinaryFormatter serialization",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Make this a doc comment\r\n```suggestion\r\n    /// <summary>\r\n    /// Override this method to recover subtype-specific state from the remote exception.\r\n    /// </summary>\r\n    protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)\r\n    { }\r\n```",
              "createdAt": "2023-06-09T15:25:54Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd;\n+\n+public abstract class BuildExceptionBase : Exception\n+{\n+    private string? _remoteTypeName;\n+    private string? _remoteStackTrace;\n+\n+    private protected BuildExceptionBase()\n+        : base()\n+    { }\n+\n+    private protected BuildExceptionBase(string message)\n+        : base(message)\n+    { }\n+\n+    private protected BuildExceptionBase(\n+        string message,\n+        Exception? inner)\n+        : base(message, inner)\n+    { }\n+\n+    // This is needed as soon as we allow opt out of the non-BinaryFormatter serialization\n+    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)\n+        : base(info, context)\n+    { }\n+\n+    public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;\n+\n+    public override string ToString() => string.IsNullOrEmpty(_remoteTypeName) ? base.ToString() : $\"{_remoteTypeName}->{base.ToString()}\";\n+\n+    protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)\n+    { /* This is it. Override for exceptions with custom state */ }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    /// <summary>\r\n    /// Override this method to provide subtype-specific state to be serialized.\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    protected virtual IDictionary<string, string?>? FlushCustomState()\r\n    {\r\n        return null;\r\n    }\r\n```",
              "createdAt": "2023-06-09T15:26:50Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd;\n+\n+public abstract class BuildExceptionBase : Exception\n+{\n+    private string? _remoteTypeName;\n+    private string? _remoteStackTrace;\n+\n+    private protected BuildExceptionBase()\n+        : base()\n+    { }\n+\n+    private protected BuildExceptionBase(string message)\n+        : base(message)\n+    { }\n+\n+    private protected BuildExceptionBase(\n+        string message,\n+        Exception? inner)\n+        : base(message, inner)\n+    { }\n+\n+    // This is needed as soon as we allow opt out of the non-BinaryFormatter serialization\n+    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)\n+        : base(info, context)\n+    { }\n+\n+    public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;\n+\n+    public override string ToString() => string.IsNullOrEmpty(_remoteTypeName) ? base.ToString() : $\"{_remoteTypeName}->{base.ToString()}\";\n+\n+    protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)\n+    { /* This is it. Override for exceptions with custom state */ }\n+\n+    protected virtual IDictionary<string, string?>? FlushCustomState()\n+    {\n+        /* This is it. Override for exceptions with custom state */\n+        return null;\n+    }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels a bit weird to me. Why not add a new `TranslateBuildException` in this class/`ITranslator`?",
              "createdAt": "2023-06-09T15:31:39Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -1100,7 +1110,18 @@ public void TranslateDotNet<T>(ref T value)\n \n             public void TranslateException(ref Exception value)\n             {\n-                TranslateDotNet<Exception>(ref value);\n+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))\n+                {\n+                    TranslateDotNet<Exception>(ref value);\n+                    return;\n+                }\n+\n+                if (!TranslateNullable(value))\n+                {\n+                    return;\n+                }\n+\n+                BuildExceptionBase.WriteExceptionToTranslator(this, value);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was deciding between 3 options how to facilitate access to the inner state of the exceptions during de/serialization:\r\n* Reflection (and lost easily navigability between the methods and their usage)\r\n* Open internal access to the methods facilitationg access - so that those can be used outside of the declaring type\r\n* Add the de/serialization utils into the base - so that they have access to privates and protected\r\n\r\nI choosed the last one - as it was the same choice taken by the FW `Serializable` support of exceptions.\r\n\r\nI'm not strongly opinionated about this though ",
              "createdAt": "2023-06-12T13:33:08Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -1100,7 +1110,18 @@ public void TranslateDotNet<T>(ref T value)\n \n             public void TranslateException(ref Exception value)\n             {\n-                TranslateDotNet<Exception>(ref value);\n+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))\n+                {\n+                    TranslateDotNet<Exception>(ref value);\n+                    return;\n+                }\n+\n+                if (!TranslateNullable(value))\n+                {\n+                    return;\n+                }\n+\n+                BuildExceptionBase.WriteExceptionToTranslator(this, value);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this necessary over \"types that derive from our new base type\"?",
              "createdAt": "2023-06-09T15:44:42Z",
              "path": "src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs",
              "diffHunk": "@@ -0,0 +1,42 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.BackEnd.SdkResolution;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Experimental.ProjectCache;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class SerializationContractInitializer\n+    {\n+        public static void Initialize()\n+        {\n+            RegisterExceptions();\n+            // reserved for future usage - BuildEventArgs, etc.\n+        }\n+\n+        private static void RegisterExceptions()\n+        {\n+            // Any exception not contained int this list will be transferred as a GenericBuildTransferredException\n+            BuildExceptionSerializationHelper.InitializeSerializationContract(",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This absolutely prevents the possibility of someone sneakily deriving from our base (despite it having `private protected` ctors - but I guess reflection/codegen tricks still can be employed) and hence allowing them to execute their code.\r\n\r\nI'm bit strongly opinionated here :-), but maybe too unnecessary - If there is sufficient guarantee that class with `private protected` ctors only cannot be inherited beyond the assembly internals visibility closure - then I'm opened to make this dynamic",
              "createdAt": "2023-06-12T13:51:16Z",
              "path": "src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs",
              "diffHunk": "@@ -0,0 +1,42 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.BackEnd.SdkResolution;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Experimental.ProjectCache;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class SerializationContractInitializer\n+    {\n+        public static void Initialize()\n+        {\n+            RegisterExceptions();\n+            // reserved for future usage - BuildEventArgs, etc.\n+        }\n+\n+        private static void RegisterExceptions()\n+        {\n+            // Any exception not contained int this list will be transferred as a GenericBuildTransferredException\n+            BuildExceptionSerializationHelper.InitializeSerializationContract(",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Always prefer this naming convention\r\n```suggestion\r\n        internal static void InitializeSerializationContract(params Type[] exceptionTypesAllowlist)\r\n```",
              "createdAt": "2023-06-09T15:54:50Z",
              "path": "src/Framework/BuildException/BuildExceptionSerializationHelper.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Reflection;\n+using System.Threading;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class BuildExceptionSerializationHelper\n+    {\n+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;\n+\n+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =\n+            (message, innerException) => new GenericBuildTransferredException(message, innerException);\n+\n+        internal static bool IsSupportedExceptionType(Type type)\n+        {\n+            return type.IsClass &&\n+                   !type.IsAbstract &&\n+                   type.IsSubclassOf(typeof(Exception)) &&\n+                   type.IsSubclassOf(typeof(BuildExceptionBase));\n+        }\n+\n+        internal static void InitializeSerializationContract(params Type[] exceptionTypesWhitelist)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There are few enough MSBuild exception types, added rarely enough, that I wonder if we could avoid reflection entirely and dispatch on known types with known constructors--that would reduce a bunch of the complexity here, I think.",
              "createdAt": "2023-06-09T15:57:35Z",
              "path": "src/Framework/BuildException/BuildExceptionSerializationHelper.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Reflection;\n+using System.Threading;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class BuildExceptionSerializationHelper\n+    {\n+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;\n+\n+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =\n+            (message, innerException) => new GenericBuildTransferredException(message, innerException);\n+\n+        internal static bool IsSupportedExceptionType(Type type)\n+        {\n+            return type.IsClass &&\n+                   !type.IsAbstract &&\n+                   type.IsSubclassOf(typeof(Exception)) &&\n+                   type.IsSubclassOf(typeof(BuildExceptionBase));\n+        }\n+\n+        internal static void InitializeSerializationContract(params Type[] exceptionTypesWhitelist)\n+        {\n+            InitializeSerializationContract((IEnumerable<Type>)exceptionTypesWhitelist);\n+        }\n+\n+        internal static void InitializeSerializationContract(IEnumerable<Type> exceptionTypesWhitelist)\n+        {\n+            if (s_exceptionFactories != null)\n+            {\n+                return;\n+            }\n+\n+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();\n+\n+            foreach (Type exceptionType in exceptionTypesWhitelist)\n+            {\n+                if (!IsSupportedExceptionType(exceptionType))\n+                {\n+                    EscapeHatches.ThrowInternalError($\"Type {exceptionType.FullName} is not recognized as a build exception type.\");\n+                }\n+\n+                // First try to find a static method CreateFromRemote\n+                //   - to be used when exception has custom constructor logic (e.g. altering messages)\n+                MethodInfo? methodInfo = exceptionType.GetMethod(\n+                    \"CreateFromRemote\",\n+                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic,\n+                    null,\n+                    new[] { typeof(string), typeof(Exception) },\n+                    null);\n+\n+                if (methodInfo != null)\n+                {\n+                    string key = GetExceptionSerializationKey(exceptionType);\n+                    var value = (Func<string, Exception?, BuildExceptionBase>)Delegate.CreateDelegate(typeof(Func<string, Exception?, BuildExceptionBase>), methodInfo);\n+\n+                    exceptionFactories[key] = value;\n+                    continue;\n+                }\n+\n+                // Otherwise use the constructor that accepts inner exception and a message\n+                ConstructorInfo? ctorInfo = exceptionType.GetConstructor(\n+                    BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance,\n+                    null,\n+                    new[] { typeof(string), typeof(Exception) },\n+                    null);\n+\n+                if (ctorInfo != null)\n+                {\n+                    string key = GetExceptionSerializationKey(exceptionType);\n+                    Func<string, Exception?, BuildExceptionBase> value = (message, innerException) =>\n+                        (BuildExceptionBase)ctorInfo.Invoke(new object?[] { message, innerException });\n+\n+                    exceptionFactories[key] = value;\n+                }\n+                else\n+                {\n+                    Debug.Fail($\"Unable to find a factory for exception type {exceptionType.FullName}\");\n+                }\n+            }\n+\n+            if (Interlocked.Exchange(ref s_exceptionFactories, exceptionFactories) != null)\n+            {\n+                EscapeHatches.ThrowInternalError(\"Serialization contract was already initialized.\");\n+            }\n+        }\n+\n+        internal static string GetExceptionSerializationKey(Type exceptionType)\n+        {\n+            return exceptionType.FullName ?? exceptionType.ToString();\n+        }\n+\n+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good suggestion!\r\n\r\nI originaly didn't used the constructor constraint since there were couple existing exceptions overwriting messages within constructor. But I guess I can just introduce new constructor (with dummy extra member) which would help avoiding the ugly reflection... lm do it! (separate commit though...)",
              "createdAt": "2023-06-12T13:53:16Z",
              "path": "src/Framework/BuildException/BuildExceptionSerializationHelper.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Reflection;\n+using System.Threading;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class BuildExceptionSerializationHelper\n+    {\n+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;\n+\n+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =\n+            (message, innerException) => new GenericBuildTransferredException(message, innerException);\n+\n+        internal static bool IsSupportedExceptionType(Type type)\n+        {\n+            return type.IsClass &&\n+                   !type.IsAbstract &&\n+                   type.IsSubclassOf(typeof(Exception)) &&\n+                   type.IsSubclassOf(typeof(BuildExceptionBase));\n+        }\n+\n+        internal static void InitializeSerializationContract(params Type[] exceptionTypesWhitelist)\n+        {\n+            InitializeSerializationContract((IEnumerable<Type>)exceptionTypesWhitelist);\n+        }\n+\n+        internal static void InitializeSerializationContract(IEnumerable<Type> exceptionTypesWhitelist)\n+        {\n+            if (s_exceptionFactories != null)\n+            {\n+                return;\n+            }\n+\n+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();\n+\n+            foreach (Type exceptionType in exceptionTypesWhitelist)\n+            {\n+                if (!IsSupportedExceptionType(exceptionType))\n+                {\n+                    EscapeHatches.ThrowInternalError($\"Type {exceptionType.FullName} is not recognized as a build exception type.\");\n+                }\n+\n+                // First try to find a static method CreateFromRemote\n+                //   - to be used when exception has custom constructor logic (e.g. altering messages)\n+                MethodInfo? methodInfo = exceptionType.GetMethod(\n+                    \"CreateFromRemote\",\n+                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic,\n+                    null,\n+                    new[] { typeof(string), typeof(Exception) },\n+                    null);\n+\n+                if (methodInfo != null)\n+                {\n+                    string key = GetExceptionSerializationKey(exceptionType);\n+                    var value = (Func<string, Exception?, BuildExceptionBase>)Delegate.CreateDelegate(typeof(Func<string, Exception?, BuildExceptionBase>), methodInfo);\n+\n+                    exceptionFactories[key] = value;\n+                    continue;\n+                }\n+\n+                // Otherwise use the constructor that accepts inner exception and a message\n+                ConstructorInfo? ctorInfo = exceptionType.GetConstructor(\n+                    BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance,\n+                    null,\n+                    new[] { typeof(string), typeof(Exception) },\n+                    null);\n+\n+                if (ctorInfo != null)\n+                {\n+                    string key = GetExceptionSerializationKey(exceptionType);\n+                    Func<string, Exception?, BuildExceptionBase> value = (message, innerException) =>\n+                        (BuildExceptionBase)ctorInfo.Invoke(new object?[] { message, innerException });\n+\n+                    exceptionFactories[key] = value;\n+                }\n+                else\n+                {\n+                    Debug.Fail($\"Unable to find a factory for exception type {exceptionType.FullName}\");\n+                }\n+            }\n+\n+            if (Interlocked.Exchange(ref s_exceptionFactories, exceptionFactories) != null)\n+            {\n+                EscapeHatches.ThrowInternalError(\"Serialization contract was already initialized.\");\n+            }\n+        }\n+\n+        internal static string GetExceptionSerializationKey(Type exceptionType)\n+        {\n+            return exceptionType.FullName ?? exceptionType.ToString();\n+        }\n+\n+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Applied here: https://github.com/dotnet/msbuild/pull/8779/commits/8cc1a75ddced9295389b6be5dda1332693a662ea\r\n\r\nI must agree it definitely looks better! Thanks!",
              "createdAt": "2023-06-12T16:39:16Z",
              "path": "src/Framework/BuildException/BuildExceptionSerializationHelper.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Reflection;\n+using System.Threading;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal static class BuildExceptionSerializationHelper\n+    {\n+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;\n+\n+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =\n+            (message, innerException) => new GenericBuildTransferredException(message, innerException);\n+\n+        internal static bool IsSupportedExceptionType(Type type)\n+        {\n+            return type.IsClass &&\n+                   !type.IsAbstract &&\n+                   type.IsSubclassOf(typeof(Exception)) &&\n+                   type.IsSubclassOf(typeof(BuildExceptionBase));\n+        }\n+\n+        internal static void InitializeSerializationContract(params Type[] exceptionTypesWhitelist)\n+        {\n+            InitializeSerializationContract((IEnumerable<Type>)exceptionTypesWhitelist);\n+        }\n+\n+        internal static void InitializeSerializationContract(IEnumerable<Type> exceptionTypesWhitelist)\n+        {\n+            if (s_exceptionFactories != null)\n+            {\n+                return;\n+            }\n+\n+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();\n+\n+            foreach (Type exceptionType in exceptionTypesWhitelist)\n+            {\n+                if (!IsSupportedExceptionType(exceptionType))\n+                {\n+                    EscapeHatches.ThrowInternalError($\"Type {exceptionType.FullName} is not recognized as a build exception type.\");\n+                }\n+\n+                // First try to find a static method CreateFromRemote\n+                //   - to be used when exception has custom constructor logic (e.g. altering messages)\n+                MethodInfo? methodInfo = exceptionType.GetMethod(\n+                    \"CreateFromRemote\",\n+                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic,\n+                    null,\n+                    new[] { typeof(string), typeof(Exception) },\n+                    null);\n+\n+                if (methodInfo != null)\n+                {\n+                    string key = GetExceptionSerializationKey(exceptionType);\n+                    var value = (Func<string, Exception?, BuildExceptionBase>)Delegate.CreateDelegate(typeof(Func<string, Exception?, BuildExceptionBase>), methodInfo);\n+\n+                    exceptionFactories[key] = value;\n+                    continue;\n+                }\n+\n+                // Otherwise use the constructor that accepts inner exception and a message\n+                ConstructorInfo? ctorInfo = exceptionType.GetConstructor(\n+                    BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance,\n+                    null,\n+                    new[] { typeof(string), typeof(Exception) },\n+                    null);\n+\n+                if (ctorInfo != null)\n+                {\n+                    string key = GetExceptionSerializationKey(exceptionType);\n+                    Func<string, Exception?, BuildExceptionBase> value = (message, innerException) =>\n+                        (BuildExceptionBase)ctorInfo.Invoke(new object?[] { message, innerException });\n+\n+                    exceptionFactories[key] = value;\n+                }\n+                else\n+                {\n+                    Debug.Fail($\"Unable to find a factory for exception type {exceptionType.FullName}\");\n+                }\n+            }\n+\n+            if (Interlocked.Exchange(ref s_exceptionFactories, exceptionFactories) != null)\n+            {\n+                EscapeHatches.ThrowInternalError(\"Serialization contract was already initialized.\");\n+            }\n+        }\n+\n+        internal static string GetExceptionSerializationKey(Type exceptionType)\n+        {\n+            return exceptionType.FullName ?? exceptionType.ToString();\n+        }\n+\n+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I wanted to avoid this with [`ExceptionDispatchInfo.SetRemoteStackTrace`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.exceptionservices.exceptiondispatchinfo.setremotestacktrace) but it's net6.0+ :(",
              "createdAt": "2023-06-09T16:00:41Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd;\n+\n+public abstract class BuildExceptionBase : Exception\n+{\n+    private string? _remoteTypeName;\n+    private string? _remoteStackTrace;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I wanted to avoid this with [`ExceptionDispatchInfo.SetRemoteStackTrace`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.exceptionservices.exceptiondispatchinfo.setremotestacktrace) but it's net6.0+ :(",
              "createdAt": "2023-06-09T16:01:01Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd;\n+\n+public abstract class BuildExceptionBase : Exception\n+{\n+    private string? _remoteTypeName;\n+    private string? _remoteStackTrace;\n+\n+    private protected BuildExceptionBase()\n+        : base()\n+    { }\n+\n+    private protected BuildExceptionBase(string message)\n+        : base(message)\n+    { }\n+\n+    private protected BuildExceptionBase(\n+        string message,\n+        Exception? inner)\n+        : base(message, inner)\n+    { }\n+\n+    // This is needed as soon as we allow opt out of the non-BinaryFormatter serialization\n+    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)\n+        : base(info, context)\n+    { }\n+\n+    public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a bit worrisome. We haven't had any dependencies for Framework, and that's a very nice property to have. Single-instancing `BinaryTranslator` is also nice, but I'm a bit worried it's not worth the risk (folks using Framework without the full set of binding redirects/related assemblies full MSBuild needs).",
              "createdAt": "2023-06-09T16:07:33Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -11,6 +11,10 @@\n     <EnablePackageValidation>true</EnablePackageValidation>\n   </PropertyGroup>\n \n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Gotcha.\r\nThere must be a way how to cleanly untangle those types - lm try that.",
              "createdAt": "2023-06-12T14:17:21Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -11,6 +11,10 @@\n     <EnablePackageValidation>true</EnablePackageValidation>\n   </PropertyGroup>\n \n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "This commit should achieve that: https://github.com/dotnet/msbuild/pull/8779/commits/4c172dd8978fb0d68d9de8a90916a48c3944647b\r\n\r\n@ladipro I moved from static `BinaryReader InterningBinaryReader.Create(Stream stream, SharedReadBuffer sharedBuffer)` to abstract `BinaryReader SharedReadBuffer.Create(Stream stream)` - I believe this should not have any impact at all, since it should be called just couple times per build... But I believe you've been touching this code quite bit so you might have some important thought",
              "createdAt": "2023-06-12T14:49:33Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -11,6 +11,10 @@\n     <EnablePackageValidation>true</EnablePackageValidation>\n   </PropertyGroup>\n \n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I'm not completely up to date on this PR but I agree that adding a dependency to `Microsoft.Build.Framework` should be avoided. The workaround looks ok. Maybe renaming `SharedReadBuffer` -> `BinaryReaderFactory` would make the intent clearer for me.",
              "createdAt": "2023-06-12T21:04:44Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -11,6 +11,10 @@\n     <EnablePackageValidation>true</EnablePackageValidation>\n   </PropertyGroup>\n \n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good point - renamed",
              "createdAt": "2023-06-13T13:37:46Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -11,6 +11,10 @@\n     <EnablePackageValidation>true</EnablePackageValidation>\n   </PropertyGroup>\n \n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Delete 'em :)",
              "createdAt": "2023-06-12T22:06:56Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -41,6 +41,20 @@\n     <Compile Include=\"..\\Shared\\BinaryWriterExtensions.cs\">\n       <Link>Shared\\BinaryWriterExtensions.cs</Link>\n     </Compile>\n+    <!--",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You should probably disregard this comment, but I was rethinking the structure of all this serialization logic, specifically regarding what third parties are supposed to do if they have custom BuildEventArgs they want properly serialized across nodes. We don't have that part implemented yet, but I'm wondering if we could've made that, then had a nice interface for serializing exceptions\u2014after all, exceptions are just messages with some shared specific payloads. It would also be useful as a robust proof-of-concept that the custom serialization we provide is usable and provide a template for others to follow.\r\n\r\nI think it's too late to try to do any of that for this PR, since that would be a nontrivial refactoring, and this change is too important and too time-sensitive for that, but I think it reasonable to consider doing some of that refactoring when that other change comes in \ud83d\ude42",
              "createdAt": "2023-06-19T19:06:45Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,154 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework.BuildException;\n+\n+public abstract class BuildExceptionBase : Exception",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is bit loaded topic :-) tl;dr; We wanted exceptions to be special to minimize possible disruption to existing control flows.\r\n\r\nIn more details:\r\n * Ideally the remoting is as easy as transfering a string (which can be handled on receiving side however they want) - as you mentioned. This is what we want for the CustomBuildEventArgs.\r\n * We initially approached this route with Exceptions as well - transfered all the excpetions as a single type - this blew up as there are cases where we rely on specific types of exceptions (e.g. `InvalidProjectFileException`) - so we needed to preserve types - this already complicates the situation quite a bit\r\n * Extensibility is problematic in case you want to preserve types - as then it leads to the same traps that caught `BinaryFormatter` (dynamically resolving types and calling their constructors) - so for Excpetions we explicitly disallowed extending via having the base constructors `private protected`, plus only explicitly allowed types within our code are going to be transfered with preserved type.\r\n * For CustomEvents - we can just simplify the istuation to a single (or few?) fixed event type - no custom inheritance allowed.\r\n\r\n",
              "createdAt": "2023-06-20T12:48:39Z",
              "path": "src/Framework/BuildException/BuildExceptionBase.cs",
              "diffHunk": "@@ -0,0 +1,154 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework.BuildException;\n+\n+public abstract class BuildExceptionBase : Exception",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why can't these be compiled into Framework rather than copying them?",
              "createdAt": "2023-06-19T19:10:19Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -491,5 +492,66 @@ internal static void ThrowInternalError(string message)\n                 throw new InternalErrorException(message);\n             }\n         }\n+\n+        /// <summary>\n+        /// Throws InternalErrorException.\n+        /// This is only for situations that would mean that there is a bug in MSBuild itself.\n+        /// </summary>\n+        /// <remarks>\n+        /// Clone from ErrorUtilities which isn't available in Framework.\n+        /// </remarks>\n+        internal static void ThrowInternalError(string message, params object[] args)\n+        {\n+            if (s_throwExceptions)\n+            {\n+                throw new InternalErrorException(FormatString(message, args));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Formats the given string using the variable arguments passed in.\n+        /// \n+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for\n+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios\n+        /// \n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"unformatted\">The string to format.</param>\n+        /// <param name=\"args\">Optional arguments for formatting the given string.</param>\n+        /// <returns>The formatted string.</returns>\n+        /// <remarks>\n+        /// Clone from ResourceUtilities which isn't available in Framework.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It should - https://github.com/dotnet/msbuild/issues/8871 \r\nJust bit more spanning change that should be logically separated from this one.",
              "createdAt": "2023-06-20T12:32:02Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -491,5 +492,66 @@ internal static void ThrowInternalError(string message)\n                 throw new InternalErrorException(message);\n             }\n         }\n+\n+        /// <summary>\n+        /// Throws InternalErrorException.\n+        /// This is only for situations that would mean that there is a bug in MSBuild itself.\n+        /// </summary>\n+        /// <remarks>\n+        /// Clone from ErrorUtilities which isn't available in Framework.\n+        /// </remarks>\n+        internal static void ThrowInternalError(string message, params object[] args)\n+        {\n+            if (s_throwExceptions)\n+            {\n+                throw new InternalErrorException(FormatString(message, args));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Formats the given string using the variable arguments passed in.\n+        /// \n+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for\n+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios\n+        /// \n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"unformatted\">The string to format.</param>\n+        /// <param name=\"args\">Optional arguments for formatting the given string.</param>\n+        /// <returns>The formatted string.</returns>\n+        /// <remarks>\n+        /// Clone from ResourceUtilities which isn't available in Framework.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels wrong...we can't disable versions on task hosts? Perhaps we haven't needed to before, but if we translate exceptions (or expect different translations), wouldn't that lead to bugs here whenever someone uses a task host? I looked at the ChangeWaves class, and it should be able to be compiled into MSBuildTaskHost with just one little helper method for Version.TryParse, something like:\r\n\r\n```C#\r\n        private static bool TryParseVersion(string stringVersion, out Version version)\r\n        {\r\n#if FEATURE_NET35_TASKHOST\r\n            try\r\n            {\r\n                version = new Version(stringVersion);\r\n                return true;\r\n            }\r\n            catch (Exception)\r\n            {\r\n                version = null;\r\n                return false;\r\n            }\r\n#else\r\n            return Version.TryParse(stringVersion, out version);\r\n#endif\r\n        }\r\n```\r\n\r\nThat's about the same amount of code as this but cleaner and more correct as far as I can tell. Can we do that instead?",
              "createdAt": "2023-06-19T19:30:01Z",
              "path": "src/MSBuildTaskHost/ChangeWavesStub.cs",
              "diffHunk": "@@ -0,0 +1,18 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Stub implementation of ChangeWaves, that always returns true for AreFeaturesEnabled.\n+    /// It is used to stub out the real ChangeWaves class, which is not available in the TaskHost.\n+    /// </summary>\n+    internal static class ChangeWaves",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Great idea, ready-made code to apply ... well - I love this suggestion! :-) Thanks!",
              "createdAt": "2023-06-20T12:38:40Z",
              "path": "src/MSBuildTaskHost/ChangeWavesStub.cs",
              "diffHunk": "@@ -0,0 +1,18 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Stub implementation of ChangeWaves, that always returns true for AreFeaturesEnabled.\n+    /// It is used to stub out the real ChangeWaves class, which is not available in the TaskHost.\n+    /// </summary>\n+    internal static class ChangeWaves",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}