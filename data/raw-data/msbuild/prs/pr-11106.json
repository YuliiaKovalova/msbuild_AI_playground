{
  "number": 11106,
  "title": "Extend property assignment event (The feature is opted-out by default)",
  "body": "Fixes #2711\r\nand connected to https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/839\r\n\r\n## Context\r\n**The feature is opted-out by default due to perf considerations !**\r\nThis implementation covers cases:\r\n\r\n- property coming from a command-line argument (e.g. /p:) (previously had a `Global` source) \r\n- as an output of a target\r\n- as an output of a task\r\n- exact property location if it comes from xml during evaluation\r\n\r\nAlso, the message formatting logic was changed for `PropertyReassignmentEventArgs`, `PropertyInitialValueSetEventArgs`, `UninitializedPropertyReadEventArgs` to have it optimized for existing deduplication logic (message is not passed as a part of event).\r\nThe event save all the unique data and format it on the receiving side (e.g. LogViewer).\r\n\r\nThe measurements were taken for the latest [OrchardCode](https://devdiv.visualstudio.com/Pkgs/_git/VS.TestAssets.OrchardCore.Fork?_a=history)\r\n| Metric | Before (No Property Logging) | Before (With Property Logging) | After (With Property Logging) |\r\n|--------|:-------------------:|:--------------------:|:-------------------:|\r\n| Size | 129.720 (unit not specified) | 173.779 KB | 178.054 KB (please note that now we emit more events!) |\r\n| Total Opening Time | 1:30.515 | 2:58.457 | 2:07.049 |\r\n| Loading Time | 37.367 s | 1:18.232 | 1:05.392 |\r\n| Analyzing Time | 6.080 s | 11.716 s | 6.962 s |\r\n| Indexing Time | 39.882 s | 1:15.502 | 44.836 s |\r\n| Reading Files | 414 ms | 675 ms | 786 ms |\r\n| Memory Allocated | 29,386,403,792 bytes | 29,372,422,344 bytes | 33,422,660,680 bytes |\r\n| Nodes | 176,726,969 | 168,309,467 | 168,759,551 |\r\n| Strings Count | 339,168 | 355,202 | 365,081 |\r\n| Strings Total Size | 53,796,282 | 28,819,213 | 24,279,588 |\r\n| Strings Largest | 79,623 | 64,035 | 74,163 |",
  "state": "MERGED",
  "createdAt": "2024-12-06T16:15:02Z",
  "updatedAt": "2025-02-13T12:20:01Z",
  "closedAt": "2025-02-13T12:20:01Z",
  "mergedAt": "2025-02-13T12:20:01Z",
  "additions": 412,
  "deletions": 90,
  "changedFiles": 20,
  "headRefName": "dev/ykovalova/property_assignment",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d9f7791af662a3171b73bc3135698f707801b902",
          "message": "add location to the initial property assignment event and tracking props in targets/tasks",
          "committedDate": "2024-12-06T15:41:09Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1988391696802bfbe6b50601bc321698171febf9",
          "message": "extend condition",
          "committedDate": "2024-12-06T15:50:40Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c034187eb020b4541e112fd30d57b06db27db793",
          "message": "fix typo",
          "committedDate": "2024-12-06T16:02:33Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9de0ce2d8e79f2b4cd156c172200758b98669f5a",
          "message": "add separate categorization of properties specified in command line",
          "committedDate": "2024-12-09T13:50:18Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1ed4a411b4555fb3be05aea8948019203db970e",
          "message": "fix null ref exception",
          "committedDate": "2024-12-09T14:49:53Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9bd143ea087b294ff303eb6acf8641311a75fcff",
          "message": "fix invalid condition for property source",
          "committedDate": "2024-12-09T15:52:35Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "923e833a855933156882c719471ad6f76ab40cf6",
          "message": "change the event content to get dedupe functionality",
          "committedDate": "2024-12-10T20:05:02Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bf379227390ba4d97619e0bea626a950670de5b9",
          "message": "add extra ctor to PropertyReassignmentEventArgs to improve parsing logic on bin log side",
          "committedDate": "2024-12-10T21:46:15Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7da96c34e7eae1596bd86a05dce7c691f361b11d",
          "message": "change location formatting",
          "committedDate": "2024-12-10T22:04:49Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e7f4df1e927667442944dbd84774629b08c71864",
          "message": "adjust the tests to the code changes",
          "committedDate": "2024-12-11T09:48:02Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "047bd55f6d6cce43f9469dd809dd72122cb3ba35",
          "message": "remove extra using",
          "committedDate": "2024-12-11T15:40:42Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b81fac73a155dda39e1ad13e0c87509a399afcfe",
          "message": "Merge branch 'dotnet:main' into dev/ykovalova/property_assignment",
          "committedDate": "2025-01-02T12:45:16Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ed8628e116e97c737848bc24b5db474b5579c08",
          "message": "Update src/Build/Evaluation/Evaluator.cs\n\nCo-authored-by: Jan Krivanek <jankrivanek@microsoft.com>",
          "committedDate": "2025-01-06T11:55:53Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "05dad6d2a6122fd92971f9f3b434f061266e80ef",
          "message": "Merge branch 'dotnet:main' into dev/ykovalova/property_assignment",
          "committedDate": "2025-01-21T08:47:09Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9964cb96f44f5352e76683108506e4653d513668",
          "message": "remove changewave check and enumutils",
          "committedDate": "2025-01-22T10:15:31Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "75fe7843e1afe61b434319b12497b3718610aa9e",
          "message": "fix review comments",
          "committedDate": "2025-01-27T11:16:57Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa62e8cdd84f4f53a1376a0ea36f02e5b65b80df",
          "message": "fix the test",
          "committedDate": "2025-01-27T20:47:22Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee58f1899d03d702f531bd53e4ec9a45c8eef596",
          "message": "apply message optimization for UninitializedPropertyRead",
          "committedDate": "2025-01-28T10:42:05Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a5ad3ced31fc69bb0f366f8fb73db03848dc130",
          "message": "fix review comments",
          "committedDate": "2025-01-31T15:03:31Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "48107543350750cc1faab0f9965602c1051a81ce",
          "message": "fix review comments",
          "committedDate": "2025-02-07T09:10:50Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f6f2b20cdf467f66d6626879034eea9cc555cee3",
          "message": "fix review comments",
          "committedDate": "2025-02-10T09:59:55Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d51cfc7ae59e485a4d025221c67f6808baa4df89",
          "message": "fix review comments",
          "committedDate": "2025-02-10T10:46:41Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80beaa6b26389d5e34a11b19c9aa30aee8a9bbae",
          "message": "fix review comments",
          "committedDate": "2025-02-12T12:46:35Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bdadaea8aa91de921767a5686592dfd86d62c299",
          "message": "change PropertiesFromCommandLine population",
          "committedDate": "2025-02-12T12:52:40Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a7cd552859efc75a758227a84b5aaa150486c46",
          "message": "fix the missed case with command line",
          "committedDate": "2025-02-13T10:33:01Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "78eaf82cbb02639688f0e236b1f719cfe07bb7ec",
          "message": "undo change of change wave",
          "committedDate": "2025-02-13T10:57:29Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "152ceb23e79cc60be0112cca6782d276b3841277",
          "message": "add doc about property assignment",
          "committedDate": "2025-02-13T11:15:14Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "How do I enable the feature for testing? What setting value did you use for perf testing?",
        "createdAt": "2025-01-22T02:27:06Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm seeing something weird, and it's not because of your PR.\r\n\r\nLocation for property reassignment is being logged as null, so the property reassignment messages end up looking like this:\r\n\r\n![image](https://github.com/user-attachments/assets/d889560c-dd68-4458-8c7b-1c8f794a02d3)\r\n\r\nBut with your PR the location is there:\r\n![image](https://github.com/user-attachments/assets/193229cc-1122-4531-90b6-f48fa2466b94)\r\n\r\nI don't understand what's going on.",
        "createdAt": "2025-01-22T02:50:47Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "There are two things I did to investigate the binlog size increase:\r\n\r\n1. use File -> Statistics in the viewer, then right-click on the Statistics node (the last one in the tree) and click Copy children, then diff for an old binlog and new binlog\r\n2. under Statistics -> Strings, expand and select the only node under Strings, then press Space (this will view all the strings in the text editor) - diff those, I notice a lot of new strings with this change (primarily strings for file, line and column appended) - these shouldn't be added\r\n\r\nFor diffing, pick a simple console application, and do an incremental build (not clean build), setting MsBuildLogPropertyTracking to the right value. What is the default value for it currently? Why are property reassignment messages even logged when the value is 0 (the current default)?",
        "createdAt": "2025-01-22T02:58:30Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Ah, I see:\r\nhttps://github.com/dotnet/msbuild/blob/404236379df1389c0988adca6c1f8cc0e1ef1011/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L320-L323",
        "createdAt": "2025-01-22T03:07:40Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm not quite sure, but I think we might have lost the location for property reassignment with https://github.com/dotnet/msbuild/pull/10102 (FYI @JanKrivanek)",
        "createdAt": "2025-01-22T03:17:59Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "MSBuild 17.12 (the one I use) doesn't log PropertyReassignmentEventArgs, it logs a message, which the viewer than parses, and there is no location there",
        "createdAt": "2025-01-22T03:19:04Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Wait, no, I'm super confused. The location was only null for properties coming from toolset. For properties coming from XML the location is there and was passed as a string argument (one of 4 args). This is good, we have an opportunity to be better than the current state.",
        "createdAt": "2025-01-22T03:23:04Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> Wait, no, I'm super confused. The location was only null for properties coming from toolset. For properties coming from XML the location is there and was passed as a string argument (one of 4 args). This is good, we have an opportunity to be better than the current state.\r\n\r\nDid we have the location for props comming from toolset before? Or is that regression?",
        "createdAt": "2025-01-22T07:34:47Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> How do I enable the feature for testing? What setting value did you use for perf testing?\r\n\r\nplease set MsBuildLogPropertyTracking=15",
        "createdAt": "2025-01-22T10:09:55Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "I think it's mostly in a good shape, I left some minor comments. Since we're not changing the default mainline scenario I'm not worried about perf (which we can always tune in a separate PR).",
        "createdAt": "2025-02-09T02:01:12Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                  _ = _data.SetProperty(\r\n                          globalProperty.Name,\r\n                          ((IProperty)globalProperty).EvaluatedValueEscaped,\r\n                          isGlobalProperty: true /* it is a global property, but it comes from command line and is tracked separately */,\r\n                          false /* may NOT be a reserved name */,\r\n                          loggingContext: _evaluationLoggingContext,\r\n                          isCommandLineProperty: _propertiesFromCommandLine.Contains(globalProperty.Name) /* IS coming from command line argument */);\r\n```",
              "createdAt": "2025-01-06T11:11:47Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1251,7 +1259,25 @@ private int AddGlobalProperties()\n \n             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)\n             {\n-                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);\n+                if ( _propertiesFromCommandLine.Contains(globalProperty.Name))\n+                {\n+                    _ = _data.SetProperty(\n+                            globalProperty.Name,\n+                            ((IProperty)globalProperty).EvaluatedValueEscaped,\n+                            isGlobalProperty: true /* it is a global property, but it comes from command line and is tracked separately */,\n+                            false /* may NOT be a reserved name */,\n+                            loggingContext: _evaluationLoggingContext,\n+                            isCommandLineProperty: true /* IS coming from command line argument */);\n+                }\n+                else\n+                {\n+                    _ = _data.SetProperty(\n+                            globalProperty.Name,\n+                            ((IProperty)globalProperty).EvaluatedValueEscaped,\n+                            isGlobalProperty: true /* IS global property */,\n+                            false /* may NOT be a reserved name */,\n+                            loggingContext: _evaluationLoggingContext);\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I have very split feelings about it.\r\nWaring - following is very opinionated:\r\n * If we do not want to optimise - then we should not and just use the ToString\r\n * If we DO want to optimise (very likely the case here) - then we should create a simple efficient targetted switch method or compile-time initialized array - but just for that single enum type.\r\n * Throwing everything in a singe global singleton might perform very great initially, but if it starts to be used on multiple places - then it can start to suffer. So why creating a catch-all singleton if we actually do not want to use it that much?",
              "createdAt": "2025-01-06T11:26:52Z",
              "path": "src/Shared/EnumUtilities.cs",
              "diffHunk": "@@ -0,0 +1,25 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    public static class EnumUtilities\n+    {\n+        private static readonly Dictionary<Enum, string> _enumStringCache = [];\n+\n+        public static string GetEnumString(Enum value)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I considered it from the standpoint that msbuild generates plenty of events and it can be useful for cases when enum is used as a part of message (property assignment happens a lot of times)\r\n",
              "createdAt": "2025-01-06T16:24:27Z",
              "path": "src/Shared/EnumUtilities.cs",
              "diffHunk": "@@ -0,0 +1,25 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    public static class EnumUtilities\n+    {\n+        private static readonly Dictionary<Enum, string> _enumStringCache = [];\n+\n+        public static string GetEnumString(Enum value)",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I'd say don't add this class at all. Especially not as new public API.",
              "createdAt": "2025-01-22T03:29:29Z",
              "path": "src/Shared/EnumUtilities.cs",
              "diffHunk": "@@ -0,0 +1,25 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    public static class EnumUtilities\n+    {\n+        private static readonly Dictionary<Enum, string> _enumStringCache = [];\n+\n+        public static string GetEnumString(Enum value)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This change now is targetting 17.14 - so `ChangeWaves.Wave17_10` technically won't be already available at that time.\r\n\r\nSo either change to 17_14, or just remove completely",
              "createdAt": "2025-01-06T11:33:34Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -111,6 +117,51 @@ internal override void ExecuteTask(Lookup lookup)\n             }\n         }\n \n+        /// <summary>\n+        /// Logs property assignment information during target execution, providing detailed tracking of property value changes.\n+        /// </summary>\n+        /// <param name=\"property\">The property instance being assigned or modified.</param>\n+        /// <param name=\"evaluatedValue\">The new evaluated value of the property.</param>\n+        private void LogPropertyInTargetAssignment(ProjectPropertyGroupTaskPropertyInstance property, string evaluatedValue)\n+        {\n+            if (_propertyTrackingSettings == 0 || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In the Reader we can't change the logic without also checking the version. Because if we're reading an old binlog, this is going to read corrupt data.\r\n\r\nYou can add if (version >= 25) ... read new stuff, otherwise leave the current logic",
              "createdAt": "2025-01-22T02:39:19Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -1176,7 +1176,9 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()\n                 propertyName,\n                 previousValue,\n                 newValue,\n-                location,\n+                fields.File,",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "You changed the reader to read the File, Line and Column separately, but the writer still writes Location as a single string",
              "createdAt": "2025-01-22T02:39:53Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -1176,7 +1176,9 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()\n                 propertyName,\n                 previousValue,\n                 newValue,\n-                location,\n+                fields.File,",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why is this changing to true? ",
              "createdAt": "2025-01-22T02:40:21Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -567,11 +567,12 @@ private BinaryLogRecordKind Write(CriticalBuildMessageEventArgs e)\n \n         private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e)\n         {\n-            WriteMessageFields(e, writeMessage: false, writeImportance: true);\n+            WriteMessageFields(e, writeMessage: true, writeImportance: true);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "previously, the message was provided by logviewer resources.\r\nIn this PR I attempted to pass a localized Message from MSBuild",
              "createdAt": "2025-01-22T10:06:41Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -567,11 +567,12 @@ private BinaryLogRecordKind Write(CriticalBuildMessageEventArgs e)\n \n         private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e)\n         {\n-            WriteMessageFields(e, writeMessage: false, writeImportance: true);\n+            WriteMessageFields(e, writeMessage: true, writeImportance: true);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why do we need this? I think we can leave the message null.\r\n\r\nEven if we needed this, we could call GetResourceString once and cache it, since it never changes, and it's pretty expensive.",
              "createdAt": "2025-01-22T03:25:28Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -323,11 +336,13 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat\n                 (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))\n             {\n                 var args = new PropertyReassignmentEventArgs(\n-                        property.Name,\n-                        oldValue,\n-                        newValue,\n-                        location,\n-                        message: null)\n+                    property.Name,\n+                    oldValue,\n+                    newValue,\n+                    location?.File,\n+                    location?.Line ?? 0,\n+                    location?.Column ?? 0,\n+                    message: ResourceUtilities.GetResourceString(\"PropertyReassignment\"))",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I agree with Jan, I would not introduce EnumUtilities at all, and just have a method with a switch expression that returns the right string from the enum.",
              "createdAt": "2025-01-22T03:26:51Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -278,19 +285,25 @@ private void TrackPropertyWrite(\n         /// </summary>\n         /// <param name=\"property\">The property being set.</param>\n         /// <param name=\"source\">The source of the property.</param>\n-        private void TrackPropertyInitialValueSet(P property, PropertySource source)\n+        /// <param name=\"location\">The exact location of the property. Can be null if comes not form xml.</param>\n+        private void TrackPropertyInitialValueSet(P property, PropertySource source, IElementLocation? location)\n         {\n             if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet)\n             {\n                 return;\n             }\n \n             var args = new PropertyInitialValueSetEventArgs(\n-                    property.Name,\n-                    property.EvaluatedValue,\n-                    source.ToString(),\n-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"PropertyAssignment\", property.Name, property.EvaluatedValue, source));\n-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;\n+                property.Name,\n+                property.EvaluatedValue,\n+\n+                // If the property is from XML, we don't need property source since a full location is available.\n+                location == null ? EnumUtilities.GetEnumString(source) : string.Empty,",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd avoid getting this string at all.",
              "createdAt": "2025-01-22T03:27:06Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -278,19 +285,25 @@ private void TrackPropertyWrite(\n         /// </summary>\n         /// <param name=\"property\">The property being set.</param>\n         /// <param name=\"source\">The source of the property.</param>\n-        private void TrackPropertyInitialValueSet(P property, PropertySource source)\n+        /// <param name=\"location\">The exact location of the property. Can be null if comes not form xml.</param>\n+        private void TrackPropertyInitialValueSet(P property, PropertySource source, IElementLocation? location)\n         {\n             if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet)\n             {\n                 return;\n             }\n \n             var args = new PropertyInitialValueSetEventArgs(\n-                    property.Name,\n-                    property.EvaluatedValue,\n-                    source.ToString(),\n-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"PropertyAssignment\", property.Name, property.EvaluatedValue, source));\n-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;\n+                property.Name,\n+                property.EvaluatedValue,\n+\n+                // If the property is from XML, we don't need property source since a full location is available.\n+                location == null ? EnumUtilities.GetEnumString(source) : string.Empty,\n+                location?.File,\n+                location?.Line ?? 0,\n+                location?.Column ?? 0,\n+                ResourceUtilities.GetResourceString(\"PropertyAssignment\"))",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "we probably want to cache this in case Message gets called multiple times, need to see what other EventArgs classes do when they override Message",
              "createdAt": "2025-01-22T03:28:04Z",
              "path": "src/Framework/PropertyInitialValueSetEventArgs.cs",
              "diffHunk": "@@ -59,6 +91,15 @@ public PropertyInitialValueSetEventArgs(\n         /// </summary>\n         public string PropertySource { get; set; }\n \n+        public override string Message\n+        {\n+            get\n+            {\n+                var formattedSource = File != null ? $\"{File} ({LineNumber},{ColumnNumber})\" : PropertySource;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "We could get the string from resources here, since we know what string we want.",
              "createdAt": "2025-01-22T03:28:34Z",
              "path": "src/Framework/PropertyInitialValueSetEventArgs.cs",
              "diffHunk": "@@ -59,6 +91,15 @@ public PropertyInitialValueSetEventArgs(\n         /// </summary>\n         public string PropertySource { get; set; }\n \n+        public override string Message\n+        {\n+            get\n+            {\n+                var formattedSource = File != null ? $\"{File} ({LineNumber},{ColumnNumber})\" : PropertySource;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same, look into caching the formatted result and look into getting the resource string here.",
              "createdAt": "2025-01-22T03:29:01Z",
              "path": "src/Framework/PropertyReassignmentEventArgs.cs",
              "diffHunk": "@@ -73,12 +105,8 @@ public override string Message\n         {\n             get\n             {\n-                if (RawMessage == null)\n-                {\n-                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword(\"PropertyReassignment\", PropertyName, NewValue, PreviousValue, Location);\n-                }\n-\n-                return RawMessage;\n+                string formattedLocation = File != null ? $\"{File} ({LineNumber},{ColumnNumber})\" : Location;\n+                return string.Format(RawMessage, PropertyName, NewValue, PreviousValue, formattedLocation);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why an explicit backing field rather than an autoproperty?",
              "createdAt": "2025-01-30T20:24:27Z",
              "path": "src/Build/Definition/ProjectCollection.cs",
              "diffHunk": "@@ -148,6 +148,11 @@ public class ProjectCollection : IToolsetProvider, IBuildComponent, IDisposable\n         /// </summary>\n         private readonly PropertyDictionary<ProjectPropertyInstance> _globalProperties;\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        private readonly HashSet<string> _propertiesFromCommandLine;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: compare against enum values for readability here:\r\n\r\n```suggestion\r\n            if (_propertyTrackingSettings == PropertyTrackingSetting.None)\r\n```",
              "createdAt": "2025-01-30T20:25:58Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1582,12 +1586,59 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou\n                             }\n                         }\n \n+                        LogPropertyInTaskAssignment(outputTargetName, outputString, parameterLocation);\n                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));\n                     }\n                 }\n             }\n         }\n \n+        /// <summary>\n+        /// Logs property assignment information during task execution, based on configured property tracking settings.\n+        /// </summary>\n+        /// <param name=\"propertyName\">The name of the property being assigned or reassigned.</param>\n+        /// <param name=\"propertyValue\">The new value being assigned to the property.</param>\n+        /// <param name=\"location\">The source location where the property assignment occurs.</param>\n+        private void LogPropertyInTaskAssignment(string propertyName, string propertyValue, IElementLocation location)\n+        {\n+            if (_propertyTrackingSettings == 0)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the difference between Global and CommandLine? What do we log for API uses that set global properties?",
              "createdAt": "2025-01-30T20:30:26Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +388,32 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "We log \"Global\" for API uses\r\nhttps://github.com/dotnet/msbuild/blob/7e539c169a657040eeb768e8115c44f1780e59df/src/Build/Evaluation/Evaluator.cs#L1254",
              "createdAt": "2025-01-31T14:29:51Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +388,32 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Do we need a distinct labeling for property set within a script - e.g. call to MSBuild task allows to set additional global properties. This is the question about the TargetFramework global property in inner build that I've asked somewhere above. \r\nThat's currently just 'global'. Here it's used to distinct that the property was set within the common targets via outer-inner build call, rather then in the script as part of regular PropertyGroup: https://github.com/dotnet/msbuild/blob/90c5d64f0280e31077a0f395bd328d4a06fb1f36/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs#L48-L50\r\n\r\ntl;dr; How is the initial set of TargetFramework of inner build labeled?",
              "createdAt": "2025-02-06T21:31:58Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +388,32 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Currently it's labeled from the script:\r\n\r\n![{16B6CB47-8AAE-4D28-9B56-504B922D7EDA}](https://github.com/user-attachments/assets/26c33153-08bf-438a-b04b-c4a1a9dded7d)\r\n",
              "createdAt": "2025-02-07T09:24:55Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +388,32 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Sorry for confusing question.\r\n\r\nWhat I meant is \"How is the 'TargetFramework' initial assignemnet property reported when user sets 'TargetFrameworks' (plural) in their project file?\"\r\n\r\nCan you possibly share screenshot of that?",
              "createdAt": "2025-02-12T11:55:19Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +388,32 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "![{B137F366-BA94-4EF6-A99A-DAB0134C0F13}](https://github.com/user-attachments/assets/1af55293-bae9-45ab-89d9-c46ddffe219a)\r\nhere you go",
              "createdAt": "2025-02-12T12:19:10Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +388,32 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not 100% sure I understand the removal of the changewave check here; can you elaborate?",
              "createdAt": "2025-01-30T20:32:35Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -319,15 +332,17 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat\n \n             // Either we want to specifically track property reassignments\n             // or we do not want to track nothing - in which case the prop reassignment is enabled by default.\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||\n-                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I should have changed it to Wave17_14 (due to Wave17_10 deprecation) instead of removal, fixed",
              "createdAt": "2025-01-31T11:36:46Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -319,15 +332,17 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat\n \n             // Either we want to specifically track property reassignments\n             // or we do not want to track nothing - in which case the prop reassignment is enabled by default.\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||\n-                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ah, I think this isn't quite what we want, instead we want \"global properties set for the whole build\", independent of whether that's through the API or command line args.",
              "createdAt": "2025-01-30T20:35:25Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -472,6 +479,11 @@ public IDictionary<string, string> GlobalProperties\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine => _propertiesFromCommandLine;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think we already have it, don't we ?\r\nhttps://github.com/dotnet/msbuild/blob/0d310deb955150d91a86b43af9e0cd1690d51690/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L90C78-L90C94\r\n\r\nI was adding it to fulfill this requirement\r\nhttps://github.com/dotnet/msbuild/issues/2711#:~:text=have%20it%20already)%3A-,property,-coming%20from%20a\r\n\r\n",
              "createdAt": "2025-01-31T11:35:59Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -472,6 +479,11 @@ public IDictionary<string, string> GlobalProperties\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine => _propertiesFromCommandLine;",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "could you please clarify if we need this additional classification or not?",
              "createdAt": "2025-01-31T14:25:07Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -472,6 +479,11 @@ public IDictionary<string, string> GlobalProperties\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine => _propertiesFromCommandLine;",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "This feels as helpful distinction.\r\nE.g. - if we build multitargeted project (e.g. net9,net472) from commandline, while passing some onrelate property via /p:a=b, then in the inner build for specific tfm (e.g. net9) - we'll have global property set during the build (TargetFramework=net9), while as well from commandline (a=b) - correct?\r\nBtw. related to this example - will we be able to see where/how the TargetFramework was set within the multitargeted build (it's being set as part of target execution)",
              "createdAt": "2025-02-06T21:02:46Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -472,6 +479,11 @@ public IDictionary<string, string> GlobalProperties\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine => _propertiesFromCommandLine;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "yes, it's correct \r\n![{91DC0745-6498-4D7F-B82E-335397FD8C4C}](https://github.com/user-attachments/assets/5039ce10-345f-404e-a1c9-9e45a773e686)\r\n",
              "createdAt": "2025-02-07T09:26:16Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -472,6 +479,11 @@ public IDictionary<string, string> GlobalProperties\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine => _propertiesFromCommandLine;",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "We shouldn't expose `HashSet<T>` in public API. If we're adding a new public API here, what are the usages? Could it be just an `ICollection<T>`? `ISet<T>`? Where is this used? Does this need to be new public API?",
              "createdAt": "2025-02-09T01:38:25Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -472,6 +479,11 @@ public IDictionary<string, string> GlobalProperties\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine => _propertiesFromCommandLine;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can you use the enum directly instead of taking an int here and casting?",
              "createdAt": "2025-01-30T20:37:31Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -25,17 +25,21 @@ internal class PropertyGroupIntrinsicTask : IntrinsicTask\n         /// </summary>\n         private ProjectPropertyGroupTaskInstance _taskInstance;\n \n+        private readonly PropertyTrackingSetting _propertyTrackingSettings;\n+\n         /// <summary>\n         /// Create a new PropertyGroup task.\n         /// </summary>\n         /// <param name=\"taskInstance\">The task instance data</param>\n         /// <param name=\"loggingContext\">The logging context</param>\n         /// <param name=\"projectInstance\">The project instance</param>\n         /// <param name=\"logTaskInputs\">Flag to determine whether or not to log task inputs.</param>\n-        public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs)\n+        /// <param name=\"settingValue\">Flag to determine whether or not property tracking enabled.</param>\n+        public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs, int settingValue)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oh is this because the enum isn't in Framework so it's hard to cast to it at assignment time? Hm.\r\n\r\nNot a huge deal, just wish it was cleaner?",
              "createdAt": "2025-01-30T20:43:55Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -25,17 +25,21 @@ internal class PropertyGroupIntrinsicTask : IntrinsicTask\n         /// </summary>\n         private ProjectPropertyGroupTaskInstance _taskInstance;\n \n+        private readonly PropertyTrackingSetting _propertyTrackingSettings;\n+\n         /// <summary>\n         /// Create a new PropertyGroup task.\n         /// </summary>\n         /// <param name=\"taskInstance\">The task instance data</param>\n         /// <param name=\"loggingContext\">The logging context</param>\n         /// <param name=\"projectInstance\">The project instance</param>\n         /// <param name=\"logTaskInputs\">Flag to determine whether or not to log task inputs.</param>\n-        public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs)\n+        /// <param name=\"settingValue\">Flag to determine whether or not property tracking enabled.</param>\n+        public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs, int settingValue)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "cleaned up, makes perfect sense ",
              "createdAt": "2025-01-31T14:16:20Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -25,17 +25,21 @@ internal class PropertyGroupIntrinsicTask : IntrinsicTask\n         /// </summary>\n         private ProjectPropertyGroupTaskInstance _taskInstance;\n \n+        private readonly PropertyTrackingSetting _propertyTrackingSettings;\n+\n         /// <summary>\n         /// Create a new PropertyGroup task.\n         /// </summary>\n         /// <param name=\"taskInstance\">The task instance data</param>\n         /// <param name=\"loggingContext\">The logging context</param>\n         /// <param name=\"projectInstance\">The project instance</param>\n         /// <param name=\"logTaskInputs\">Flag to determine whether or not to log task inputs.</param>\n-        public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs)\n+        /// <param name=\"settingValue\">Flag to determine whether or not property tracking enabled.</param>\n+        public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs, int settingValue)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Possible to abstract these checks so you don't have to repeat this code?",
              "createdAt": "2025-01-30T20:38:17Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -111,6 +117,52 @@ internal override void ExecuteTask(Lookup lookup)\n             }\n         }\n \n+        /// <summary>\n+        /// Logs property assignment information during target execution, providing detailed tracking of property value changes.\n+        /// </summary>\n+        /// <param name=\"property\">The property instance being assigned or modified.</param>\n+        /// <param name=\"evaluatedValue\">The new evaluated value of the property.</param>\n+        private void LogPropertyInTargetAssignment(ProjectPropertyGroupTaskPropertyInstance property, string evaluatedValue)\n+        {\n+            if (_propertyTrackingSettings == 0)\n+            {\n+                return;\n+            }\n+\n+            var previousPropertyValue = Project.GetProperty(property.Name)?.EvaluatedValue;\n+\n+            if (previousPropertyValue == null\n+                && (_propertyTrackingSettings & PropertyTrackingSetting.PropertyInitialValueSet) == PropertyTrackingSetting.PropertyInitialValueSet)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "still validate the source? or does it not make sense now?",
              "createdAt": "2025-01-30T20:42:51Z",
              "path": "src/Build.UnitTests/Evaluation/Evaluator_Tests.cs",
              "diffHunk": "@@ -4829,23 +4829,23 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()\n \n                     // Verify logging of property initial values.\n                     propertyInitialValueMap.ShouldContainKey(\"Prop\");\n-                    propertyInitialValueMap[\"Prop\"].PropertySource.ShouldBe(\"Xml\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't pass the source if File path is known. It seems to be excessive now.",
              "createdAt": "2025-01-31T08:57:46Z",
              "path": "src/Build.UnitTests/Evaluation/Evaluator_Tests.cs",
              "diffHunk": "@@ -4829,23 +4829,23 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()\n \n                     // Verify logging of property initial values.\n                     propertyInitialValueMap.ShouldContainKey(\"Prop\");\n-                    propertyInitialValueMap[\"Prop\"].PropertySource.ShouldBe(\"Xml\");",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Lesftover?",
              "createdAt": "2025-02-06T21:03:18Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs",
              "diffHunk": "@@ -6,6 +6,7 @@\n using System.Reflection;\n using Microsoft.Build.BackEnd.Logging;\n using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should we use the `_taskLoggingContext` here?\r\nThe more specific context, the more appropriate hierarchical location in viewer.",
              "createdAt": "2025-02-06T21:12:18Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1582,12 +1586,60 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou\n                             }\n                         }\n \n+                        PropertyTrackingUtils.LogPropertyAssignment(_propertyTrackingSettings, outputTargetName, outputString, parameterLocation, _projectInstance.GetProperty(outputTargetName)?.EvaluatedValue ?? null, _targetLoggingContext);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The if-else conditions doesn't seem to be right here - we can enter the else even with `previousPropertyValue` being null - which isn't reassigment.",
              "createdAt": "2025-02-06T21:15:08Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1582,12 +1586,60 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou\n                             }\n                         }\n \n+                        PropertyTrackingUtils.LogPropertyAssignment(_propertyTrackingSettings, outputTargetName, outputString, parameterLocation, _projectInstance.GetProperty(outputTargetName)?.EvaluatedValue ?? null, _targetLoggingContext);\n+\n                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));\n                     }\n                 }\n             }\n         }\n \n+        /// <summary>\n+        /// Logs property assignment information during task execution, based on configured property tracking settings.\n+        /// </summary>\n+        /// <param name=\"propertyName\">The name of the property being assigned or reassigned.</param>\n+        /// <param name=\"propertyValue\">The new value being assigned to the property.</param>\n+        /// <param name=\"location\">The source location where the property assignment occurs.</param>\n+        private void LogPropertyInTaskAssignment(string propertyName, string propertyValue, IElementLocation location)\n+        {\n+            if (_propertyTrackingSettings == PropertyTrackingSetting.None)\n+            {\n+                return;\n+            }\n+\n+            var previousPropertyValue = _projectInstance.GetProperty(propertyName)?.EvaluatedValue;\n+\n+            if (previousPropertyValue == null && PropertyTrackingUtils.IsPropertyTrackingEnabled(_propertyTrackingSettings, PropertyTrackingSetting.PropertyInitialValueSet))\n+            {\n+                var args = new PropertyInitialValueSetEventArgs(\n+                    propertyName,\n+                    propertyValue,\n+                    propertySource: string.Empty,\n+                    location.File,\n+                    location.Line,\n+                    location.Column,\n+                    message: null)\n+                { BuildEventContext = _targetLoggingContext.BuildEventContext };\n+\n+                _targetLoggingContext.LogBuildEvent(args);\n+            }\n+            else if (PropertyTrackingUtils.IsPropertyTrackingEnabled(_propertyTrackingSettings, PropertyTrackingSetting.PropertyReassignment))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be `_taskLoggingContext`? (and similarly in other cases, where we know what task is being executed?)",
              "createdAt": "2025-02-06T21:16:18Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1582,12 +1586,60 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou\n                             }\n                         }\n \n+                        PropertyTrackingUtils.LogPropertyAssignment(_propertyTrackingSettings, outputTargetName, outputString, parameterLocation, _projectInstance.GetProperty(outputTargetName)?.EvaluatedValue ?? null, _targetLoggingContext);\n+\n                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));\n                     }\n                 }\n             }\n         }\n \n+        /// <summary>\n+        /// Logs property assignment information during task execution, based on configured property tracking settings.\n+        /// </summary>\n+        /// <param name=\"propertyName\">The name of the property being assigned or reassigned.</param>\n+        /// <param name=\"propertyValue\">The new value being assigned to the property.</param>\n+        /// <param name=\"location\">The source location where the property assignment occurs.</param>\n+        private void LogPropertyInTaskAssignment(string propertyName, string propertyValue, IElementLocation location)\n+        {\n+            if (_propertyTrackingSettings == PropertyTrackingSetting.None)\n+            {\n+                return;\n+            }\n+\n+            var previousPropertyValue = _projectInstance.GetProperty(propertyName)?.EvaluatedValue;\n+\n+            if (previousPropertyValue == null && PropertyTrackingUtils.IsPropertyTrackingEnabled(_propertyTrackingSettings, PropertyTrackingSetting.PropertyInitialValueSet))\n+            {\n+                var args = new PropertyInitialValueSetEventArgs(\n+                    propertyName,\n+                    propertyValue,\n+                    propertySource: string.Empty,\n+                    location.File,\n+                    location.Line,\n+                    location.Column,\n+                    message: null)\n+                { BuildEventContext = _targetLoggingContext.BuildEventContext };\n+\n+                _targetLoggingContext.LogBuildEvent(args);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What if 'previousPropertyValue == null', but PropertyTrackingSetting.PropertyInitialValueSet is not set?",
              "createdAt": "2025-02-06T21:33:34Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +387,101 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,\n         }\n \n-        [Flags]\n-        private enum PropertyTrackingSetting\n+        private static string GetPropertySourceName(PropertySource source) => source switch\n         {\n-            None = 0,\n+            PropertySource.Xml => \"XML\",\n+            PropertySource.BuiltIn => \"BuiltIn\",\n+            PropertySource.Global => \"Global\",\n+            PropertySource.Toolset => \"Toolset\",\n+            PropertySource.EnvironmentVariable => \"EnvironmentVariable\",\n+            PropertySource.CommandLine => \"CommandLine\",\n+            _ => throw new ArgumentOutOfRangeException(nameof(source), source, null)\n+        };\n+    }\n+\n+    [Flags]\n+    internal enum PropertyTrackingSetting\n+    {\n+        None = 0,\n \n-            PropertyReassignment = 1,\n-            PropertyInitialValueSet = 1 << 1,\n-            EnvironmentVariableRead = 1 << 2,\n-            UninitializedPropertyRead = 1 << 3,\n+        PropertyReassignment = 1,\n+        PropertyInitialValueSet = 1 << 1,\n+        EnvironmentVariableRead = 1 << 2,\n+        UninitializedPropertyRead = 1 << 3,\n \n-            All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead\n+        All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead\n+    }\n+\n+    internal class PropertyTrackingUtils\n+    {\n+        /// <summary>\n+        /// Determines if a specific property tracking setting is enabled within the provided settings configuration.\n+        /// </summary>\n+        /// <param name=\"settings\">The combined property tracking settings value to check against.</param>\n+        /// <param name=\"currentTrackingSetting\">The specific tracking setting to verify.</param>\n+        /// <returns>true if the specified tracking setting is enabled in the settings configuration.</returns>\n+        internal static bool IsPropertyTrackingEnabled(PropertyTrackingSetting settings, PropertyTrackingSetting currentTrackingSetting) => (settings & currentTrackingSetting) == currentTrackingSetting;\n+\n+        /// <summary>\n+        /// Logs property assignment information during execution, providing detailed tracking of property value changes.\n+        /// This internal method handles two scenarios:\n+        /// 1. Initial property value assignment (when previousPropertyValue is null)\n+        /// 2. Property value reassignment (when previousPropertyValue has a value)\n+        /// If property tracking is disabled (PropertyTrackingSetting.None), no logging occurs.\n+        /// </summary>\n+        /// <param name=\"settings\">Controls what types of property assignments should be tracked.</param>\n+        /// <param name=\"propertyName\">Name of the property being modified.</param>\n+        /// <param name=\"propertyValue\">New value being assigned to the property.</param>\n+        /// <param name=\"location\">Source location information (file, line, column).</param>\n+        /// <param name=\"previousPropertyValue\">Previous value of the property, null if this is initial assignment.</param>\n+        /// <param name=\"loggingContext\">Context for logging build events.</param>\n+        internal static void LogPropertyAssignment(\n+            PropertyTrackingSetting settings,\n+            string propertyName,\n+            string propertyValue,\n+            IElementLocation location,\n+            string? previousPropertyValue,\n+            LoggingContext loggingContext)\n+        {\n+            if (settings == PropertyTrackingSetting.None)\n+            {\n+                return;\n+            }\n+\n+            if (previousPropertyValue == null && IsPropertyTrackingEnabled(settings, PropertyTrackingSetting.PropertyInitialValueSet))\n+            {\n+                var args = new PropertyInitialValueSetEventArgs(\n+                    propertyName,\n+                    propertyValue,\n+                    propertySource: string.Empty,\n+                    location.File,\n+                    location.Line,\n+                    location.Column,\n+                    message: null)\n+                { BuildEventContext = loggingContext.BuildEventContext };\n+\n+                loggingContext.LogBuildEvent(args);\n+            }\n+            else if (IsPropertyTrackingEnabled(settings, PropertyTrackingSetting.PropertyReassignment)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "maybe use StringComparer.OrdinalIgnoreCase? so that it's not case-sensitive",
              "createdAt": "2025-02-09T01:36:33Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -279,6 +285,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)\n             _environmentProperties = other._environmentProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._environmentProperties) : null;\n             _forwardingLoggers = other._forwardingLoggers != null ? new List<ForwardingLoggerRecord>(other._forwardingLoggers) : null;\n             _globalProperties = other._globalProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._globalProperties) : null;\n+            _propertiesFromCommandLine = other._propertiesFromCommandLine != null ? new HashSet<string>(other._propertiesFromCommandLine) : null;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "when we're passing 4 or more arguments that result in a long line of text, let's wrap each argument on a new line, like this:\r\n```\r\nLogPropertyAssignment(\r\n   arg1,\r\n   arg2,\r\n   arg3,\r\n   arg4);\r\n```",
              "createdAt": "2025-02-09T01:40:22Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs",
              "diffHunk": "@@ -85,6 +88,8 @@ internal override void ExecuteTask(Lookup lookup)\n                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);\n                             bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);\n \n+                            PropertyTrackingUtils.LogPropertyAssignment(_propertyTrackingSettings, property.Name, evaluatedValue, property.Location, Project.GetProperty(property.Name)?.EvaluatedValue ?? null, LoggingContext);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "note that we will call into `GetProperty()` even if tracking is turned off completely. This may result in paying the perf cost even if it's not needed. Perhaps surround in an if statement.",
              "createdAt": "2025-02-09T01:41:51Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1582,6 +1586,8 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou\n                             }\n                         }\n \n+                        PropertyTrackingUtils.LogPropertyAssignment(_propertyTrackingSettings, outputTargetName, outputString, parameterLocation, _projectInstance.GetProperty(outputTargetName)?.EvaluatedValue ?? null, _taskLoggingContext);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think `ICollection<T>` should be sufficient since we only call `.Contains`\r\n\r\nAlways limit the interface to the minimal API surface you're actually going to need.\r\n\r\nHere I'd perhaps even consider `Func<string> IsPropertyFromCommandLine` and pass around a delegate. But may be less intuitive than `ICollection<T>` which seems just right.",
              "createdAt": "2025-02-09T01:48:09Z",
              "path": "src/Build/Definition/ProjectCollection.cs",
              "diffHunk": "@@ -497,6 +500,11 @@ public static string DisplayVersion\n             }\n         }\n \n+        /// <summary>\n+        /// Properties passed from the command line (e.g. by using /p:).\n+        /// </summary>\n+        public HashSet<string> PropertiesFromCommandLine { get; }",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "add the argument name with a colon so it's easier to know which parameter it is",
              "createdAt": "2025-02-09T01:49:09Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1251,7 +1259,13 @@ private int AddGlobalProperties()\n \n             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)\n             {\n-                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);\n+                _ = _data.SetProperty(\n+                    globalProperty.Name,\n+                    ((IProperty)globalProperty).EvaluatedValueEscaped,\n+                    isGlobalProperty: true /* it is a global property, but it comes from command line and is tracked separately */,\n+                    false /* may NOT be a reserved name */,",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should perhaps match the casing of the enum name? `Xml` vs. `XML`",
              "createdAt": "2025-02-09T01:52:24Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +386,107 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,\n         }\n \n-        [Flags]\n-        private enum PropertyTrackingSetting\n+        private static string GetPropertySourceName(PropertySource source) => source switch\n         {\n-            None = 0,\n+            PropertySource.Xml => \"XML\",",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Hmm, do we even need to increment the file format version any more?\r\n\r\nI'm not 100% but I don't think so. Since the reader will correctly read the Message, File, Line and Column whether they are present or not (it will read the Flags and then read the fields based on the flags).\r\n\r\nWe should think about two scenarios:\r\n 1. new reader reading an older binlog (written before this PR)\r\n 2. old reader reading a newer binlog (written after this PR)\r\n\r\nIf both of these scenarios work fine, then we don't need to increment the version.",
              "createdAt": "2025-02-09T01:58:04Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -80,6 +80,8 @@ public sealed class BinaryLogger : ILogger\n         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent\n         // version 24:\n         //    - new record kind: BuildCanceledEventArgs\n+        // version 25:",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I think I still need this version increase due to a different way  of formatting location.\r\nPreviously, I was passed as a LocationString, now I format this on the receiving side:\r\nhttps://github.com/KirillOsenkov/MSBuildStructuredLog/blob/9bc29f2684c57a5424827d590f8b180c46905c89/src/StructuredLogger/BinaryLogger/BuildEventArgsReader.cs#L1430\r\n\r\nor on message read\r\nhttps://github.com/dotnet/msbuild/blob/48107543350750cc1faab0f9965602c1051a81ce/src/Framework/UninitializedPropertyReadEventArgs.cs#L62\r\n",
              "createdAt": "2025-02-10T09:58:22Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -80,6 +80,8 @@ public sealed class BinaryLogger : ILogger\n         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent\n         // version 24:\n         //    - new record kind: BuildCanceledEventArgs\n+        // version 25:",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "OK then always better to increment the version to be safe",
              "createdAt": "2025-02-10T16:38:06Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -80,6 +80,8 @@ public sealed class BinaryLogger : ILogger\n         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent\n         // version 24:\n         //    - new record kind: BuildCanceledEventArgs\n+        // version 25:",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm a slow thinker - so it's not clear to me, why there cannot be any global properties set either from API or from call to MSBuild task with explicit specification of global props (ot not sure if there is yet another way to set global properties) - can you make sure it's really just from commandline and possibly add the reasoning in the comment?",
              "createdAt": "2025-02-12T12:08:43Z",
              "path": "src/Build/Definition/ProjectCollection.cs",
              "diffHunk": "@@ -341,6 +341,9 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab\n                 {\n                     _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalProperties.Count);\n \n+                    // at this stage globalProperties collection contains entries passed from command line (e.g. /p:foo=bar).",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Maybe I am wrong here and don't know about the cases you listed above, but I considered this as an entry point to MsBuild\r\nhttps://github.com/dotnet/msbuild/blob/0b44ec8b09d2b53ef021618fb57526ded656a4fc/src/MSBuild/XMake.cs#L647\r\n\r\nglobal property collection is initialized and populated here\r\nhttps://github.com/dotnet/msbuild/blob/0b44ec8b09d2b53ef021618fb57526ded656a4fc/src/MSBuild/XMake.cs#L747\r\n\r\nand goes to without adding any new values\r\nhttps://github.com/dotnet/msbuild/blob/0b44ec8b09d2b53ef021618fb57526ded656a4fc/src/MSBuild/XMake.cs#L836\r\n\r\n",
              "createdAt": "2025-02-12T12:37:53Z",
              "path": "src/Build/Definition/ProjectCollection.cs",
              "diffHunk": "@@ -341,6 +341,9 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab\n                 {\n                     _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalProperties.Count);\n \n+                    // at this stage globalProperties collection contains entries passed from command line (e.g. /p:foo=bar).",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is just refactoring with no functional change - correct?\r\nThen the changewave value should have had stayed as it is - shouldn't it? Basically very soon we want the property reassignment tracking to be a default thing. Or do we want to push out that point in time more into the future?",
              "createdAt": "2025-02-12T12:19:04Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -318,16 +328,19 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat\n             }\n \n             // Either we want to specifically track property reassignments\n-            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||\n-                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))\n+            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.    \n+            if (PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.PropertyReassignment)\n+                || (_settings == PropertyTrackingSetting.None && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14)))",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I changed a changewave due to your comment above https://github.com/dotnet/msbuild/pull/11106#discussion_r1904045137\r\n:)",
              "createdAt": "2025-02-12T12:22:32Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -318,16 +328,19 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat\n             }\n \n             // Either we want to specifically track property reassignments\n-            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.\n-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||\n-                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))\n+            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.    \n+            if (PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.PropertyReassignment)\n+                || (_settings == PropertyTrackingSetting.None && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14)))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This function is called only when 'settings != PropertyTrackingSetting.None' - while here it feels we want to track in such case.\r\nCan we pull the condition inside this helper, so that the intention is more clear?",
              "createdAt": "2025-02-12T12:23:04Z",
              "path": "src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs",
              "diffHunk": "@@ -373,20 +386,103 @@ private enum PropertySource\n             BuiltIn,\n             Global,\n             Toolset,\n-            EnvironmentVariable\n+            EnvironmentVariable,\n+            CommandLine,\n         }\n \n-        [Flags]\n-        private enum PropertyTrackingSetting\n+        private static string GetPropertySourceName(PropertySource source) => source switch\n         {\n-            None = 0,\n+            PropertySource.Xml => \"Xml\",\n+            PropertySource.BuiltIn => \"BuiltIn\",\n+            PropertySource.Global => \"Global\",\n+            PropertySource.Toolset => \"Toolset\",\n+            PropertySource.EnvironmentVariable => \"EnvironmentVariable\",\n+            PropertySource.CommandLine => \"CommandLine\",\n+            _ => throw new ArgumentOutOfRangeException(nameof(source), source, null)\n+        };\n+    }\n \n-            PropertyReassignment = 1,\n-            PropertyInitialValueSet = 1 << 1,\n-            EnvironmentVariableRead = 1 << 2,\n-            UninitializedPropertyRead = 1 << 3,\n+    [Flags]\n+    internal enum PropertyTrackingSetting\n+    {\n+        None = 0,\n+\n+        PropertyReassignment = 1,\n+        PropertyInitialValueSet = 1 << 1,\n+        EnvironmentVariableRead = 1 << 2,\n+        UninitializedPropertyRead = 1 << 3,\n+\n+        All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead\n+    }\n \n-            All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead\n+    internal class PropertyTrackingUtils\n+    {\n+        /// <summary>\n+        /// Determines if a specific property tracking setting is enabled within the provided settings configuration.\n+        /// </summary>\n+        /// <param name=\"settings\">The combined property tracking settings value to check against.</param>\n+        /// <param name=\"currentTrackingSetting\">The specific tracking setting to verify.</param>\n+        /// <returns>true if the specified tracking setting is enabled in the settings configuration.</returns>\n+        internal static bool IsPropertyTrackingEnabled(PropertyTrackingSetting settings, PropertyTrackingSetting currentTrackingSetting) => (settings & currentTrackingSetting) == currentTrackingSetting;\n+\n+        /// <summary>\n+        /// Logs property assignment information during execution, providing detailed tracking of property value changes.\n+        /// This internal method handles two scenarios:\n+        /// 1. Initial property value assignment (when previousPropertyValue is null)\n+        /// 2. Property value reassignment (when previousPropertyValue has a value)\n+        /// If property tracking is disabled (PropertyTrackingSetting.None), no logging occurs.\n+        /// </summary>\n+        /// <param name=\"settings\">Controls what types of property assignments should be tracked.</param>\n+        /// <param name=\"propertyName\">Name of the property being modified.</param>\n+        /// <param name=\"propertyValue\">New value being assigned to the property.</param>\n+        /// <param name=\"location\">Source location information (file, line, column).</param>\n+        /// <param name=\"previousPropertyValue\">Previous value of the property, null if this is initial assignment.</param>\n+        /// <param name=\"loggingContext\">Context for logging build events.</param>\n+        internal static void LogPropertyAssignment(\n+            PropertyTrackingSetting settings,\n+            string propertyName,\n+            string propertyValue,\n+            IElementLocation location,\n+            string? previousPropertyValue,\n+            LoggingContext loggingContext)\n+        {\n+            if (previousPropertyValue == null)\n+            {\n+                if (IsPropertyTrackingEnabled(settings, PropertyTrackingSetting.PropertyInitialValueSet))\n+                {\n+                    var args = new PropertyInitialValueSetEventArgs(\n+                        propertyName,\n+                        propertyValue,\n+                        propertySource: string.Empty,\n+                        location.File,\n+                        location.Line,\n+                        location.Column,\n+                        message: null) { BuildEventContext = loggingContext.BuildEventContext };\n+\n+                    loggingContext.LogBuildEvent(args);\n+                }\n+            }\n+            else\n+            {\n+                if (IsPropertyTrackingEnabled(settings, PropertyTrackingSetting.PropertyReassignment)\n+                    || (settings == PropertyTrackingSetting.None && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14)))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}