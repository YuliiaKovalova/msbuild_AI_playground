{
  "number": 11765,
  "title": "Add the merge logic to BuildResult for handling RequestedProjectState, BuildFlags and ProjectInstance reliably ",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/11701\r\n\r\n### Context\r\nThe PR addresses an issue where Visual Studio hangs during build operations, due to inconsistent project state merging after build operations. The root cause appears to be how `BuildResult` instances handle merging of project state when multiple build operations are combined (per the same `ConfigurationId`).\r\n\r\n#### Why These Changes Were Made\r\nThe core issue appears to be inconsistent handling of project state during build operations, particularly when:\r\n\r\n- Multiple build operations need to be merged\r\n- Different build operations request different subsets of project state\r\n- The merge operation doesn't preserve all necessary metadata, properties, or flags\r\nPrior to this change, when build results were merged using the MergeResults method, the logic didn't properly handle the merging of project state after build. \r\nThe new implementation explicitly merges:\r\n\r\n        - The project properties\r\n        - The project items and their metadata\r\n        - The requested state filters\r\n        - The build flags\r\n\r\n### Changes Made\r\n\r\n1. Two significant methods were added to BuildResult:\r\n`MergeProjectStateAfterBuildInstances`: This method properly merges project instances, including their properties, items, and requested state filters. It handles cases where instances might be null, or when one instance has a full project state versus a partial state.\r\n`MergeBuildFlags`: This method provides explicit control over how build flags are merged, with special handling for the `ProvideProjectStateAfterBuild` and `ProvideSubsetOfStateAfterBuild` flags.\r\n2. Enhanced `RequestedProjectState` with Merge Capability\r\nAdded a new `Merge()` method to `RequestedProjectState` that properly combines property filters and item filters from two different instances.\r\nImplemented sophisticated merging logic for item filters that preserves metadata from both sources.\r\n3. Improved Robustness in `ProjectInstance`\r\nEnhanced the FilteredCopy constructor to handle null collections gracefully.\r\nUpdated code to use modern C# collection initializers and null-safe operations.\r\nMade the handling of various dictionaries (properties, items, etc.) more robust against null values.\r\n4. Changed the logic in `ResultsCache.AreBuildResultFlagsCompatible`\r\nIf a subset of data is requested, we don't need to rely on the cache flag, but check if the available subset of the data can satisfy the request.\r\n\r\n\r\n### Testing\r\nAdded UTs to cover new Merge Logic \r\n\r\n### Notes\r\n",
  "state": "OPEN",
  "createdAt": "2025-04-25T14:19:57Z",
  "updatedAt": "2025-05-30T08:06:36Z",
  "closedAt": null,
  "mergedAt": null,
  "additions": 597,
  "deletions": 91,
  "changedFiles": 5,
  "headRefName": "dev/ykovalova/fix_vs_hang_",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "YuliiaKovalova"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "eb00d00c69aea2544c0a347a8538f1be2fec96ee",
          "message": "update BuildResult add MergeProjectStateAfterBuildInstances and MergeBuildFlags to it",
          "committedDate": "2025-04-25T13:58:15Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e94a41f23e74cb8e30ae41b51fd90de58b5546a8",
          "message": "Update src/Build/BackEnd/BuildManager/RequestedProjectState.cs\n\nCo-authored-by: Copilot <175728472+Copilot@users.noreply.github.com>",
          "committedDate": "2025-04-25T14:22:20Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1eda8f20bcf41c1321dc25fad91a0b1c0416154a",
          "message": "fix compilation error",
          "committedDate": "2025-04-25T14:46:26Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "23b0f07b9b8fb8e4cde2835d9cc3a34cff060c6a",
          "message": "Merge branch 'dotnet:main' into dev/ykovalova/fix_vs_hang_",
          "committedDate": "2025-05-14T08:55:56Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b3931c5351472fced9a76d384cccd2e1cf21c61e",
          "message": "fix review comments",
          "committedDate": "2025-05-30T08:06:27Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "[nitpick] Since 'mergedProperties' is always initialized, the null-conditional operator is unnecessary. You can simplify it by using 'result.PropertyFilters = mergedProperties.ToList();'.\n```suggestion\n                    result.PropertyFilters = mergedProperties.ToList();\n```",
              "createdAt": "2025-04-25T14:20:34Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -44,17 +44,107 @@ internal RequestedProjectState DeepClone()\n             RequestedProjectState result = new RequestedProjectState();\n             if (PropertyFilters is not null)\n             {\n-                result.PropertyFilters = new List<string>(PropertyFilters);\n+                result.PropertyFilters = [.. PropertyFilters];\n             }\n+\n             if (ItemFilters is not null)\n             {\n                 result.ItemFilters = ItemFilters.ToDictionary(\n                     kvp => kvp.Key,\n                     kvp => kvp.Value == null ? null : new List<string>(kvp.Value));\n             }\n+\n             return result;\n         }\n \n+        /// <summary>\n+        /// Returns a new RequestedProjectState that contains the union of filters from this instance and another.\n+        /// </summary>\n+        /// <param name=\"other\">The other RequestedProjectState to merge with.</param>\n+        /// <returns>A new RequestedProjectState representing the merged filters.</returns>\n+        internal RequestedProjectState Merge(RequestedProjectState other)\n+        {\n+            // If either is null, return a clone of the non-null one\n+            if (other == null)\n+            {\n+                return DeepClone();\n+            }\n+\n+            RequestedProjectState result = new RequestedProjectState();\n+\n+            // Merge property filters\n+            if (PropertyFilters != null || other.PropertyFilters != null)\n+            {\n+                HashSet<string> mergedProperties = new(StringComparer.OrdinalIgnoreCase);\n+                if (PropertyFilters != null)\n+                {\n+                    foreach (var prop in PropertyFilters)\n+                    {\n+                        mergedProperties.Add(prop);\n+                    }\n+                }\n+\n+                if (other.PropertyFilters != null)\n+                {\n+                    foreach (var prop in other.PropertyFilters)\n+                    {\n+                        mergedProperties.Add(prop);\n+                    }\n+                }\n+\n+                if (mergedProperties.Count > 0)\n+                {\n+                    result.PropertyFilters = mergedProperties?.ToList();\n+                }",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this make the second branch here obsolete? (around BuildResult.cs:826)\r\n```\r\nif (sourceFilter == null)\r\n{\r\n    mergedFilter = newFilter.DeepClone();\r\n}\r\nelse if (newFilter == null)\r\n{\r\n    mergedFilter = sourceFilter.DeepClone();\r\n}\r\nelse\r\n{\r\n    mergedFilter = sourceFilter.Merge(newFilter);\r\n}\r\n```\r\nI'm asking because this sentence at this place is false, since if the first one was null, it would throw(here) so there had to be some logic elsewhere.",
              "createdAt": "2025-05-28T10:15:14Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -44,17 +44,107 @@ internal RequestedProjectState DeepClone()\n             RequestedProjectState result = new RequestedProjectState();\n             if (PropertyFilters is not null)\n             {\n-                result.PropertyFilters = new List<string>(PropertyFilters);\n+                result.PropertyFilters = [.. PropertyFilters];\n             }\n+\n             if (ItemFilters is not null)\n             {\n                 result.ItemFilters = ItemFilters.ToDictionary(\n                     kvp => kvp.Key,\n                     kvp => kvp.Value == null ? null : new List<string>(kvp.Value));\n             }\n+\n             return result;\n         }\n \n+        /// <summary>\n+        /// Returns a new RequestedProjectState that contains the union of filters from this instance and another.\n+        /// </summary>\n+        /// <param name=\"other\">The other RequestedProjectState to merge with.</param>\n+        /// <returns>A new RequestedProjectState representing the merged filters.</returns>\n+        internal RequestedProjectState Merge(RequestedProjectState other)\n+        {\n+            // If either is null, return a clone of the non-null one",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe\r\n`mergedProperties = new HashSet<string>(PropertyFilters, StringComparer.OrdinalIgnoreCase);`\r\n?",
              "createdAt": "2025-05-28T10:55:48Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -44,17 +44,107 @@ internal RequestedProjectState DeepClone()\n             RequestedProjectState result = new RequestedProjectState();\n             if (PropertyFilters is not null)\n             {\n-                result.PropertyFilters = new List<string>(PropertyFilters);\n+                result.PropertyFilters = [.. PropertyFilters];\n             }\n+\n             if (ItemFilters is not null)\n             {\n                 result.ItemFilters = ItemFilters.ToDictionary(\n                     kvp => kvp.Key,\n                     kvp => kvp.Value == null ? null : new List<string>(kvp.Value));\n             }\n+\n             return result;\n         }\n \n+        /// <summary>\n+        /// Returns a new RequestedProjectState that contains the union of filters from this instance and another.\n+        /// </summary>\n+        /// <param name=\"other\">The other RequestedProjectState to merge with.</param>\n+        /// <returns>A new RequestedProjectState representing the merged filters.</returns>\n+        internal RequestedProjectState Merge(RequestedProjectState other)\n+        {\n+            // If either is null, return a clone of the non-null one\n+            if (other == null)\n+            {\n+                return DeepClone();\n+            }\n+\n+            RequestedProjectState result = new RequestedProjectState();\n+\n+            // Merge property filters\n+            if (PropertyFilters != null || other.PropertyFilters != null)\n+            {\n+                HashSet<string> mergedProperties = new(StringComparer.OrdinalIgnoreCase);\n+                if (PropertyFilters != null)\n+                {\n+                    foreach (var prop in PropertyFilters)",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Thought if it complicates the != null logic too much, it might not be worth it.\r\n[UnionWith(IEnumerable<T>)](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iset-1.unionwith?view=net-9.0#system-collections-generic-iset-1-unionwith(system-collections-generic-ienumerable((-0))))\r\nCould help to solve this, however I'm unsure about performance implications.",
              "createdAt": "2025-05-28T10:56:29Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -44,17 +44,107 @@ internal RequestedProjectState DeepClone()\n             RequestedProjectState result = new RequestedProjectState();\n             if (PropertyFilters is not null)\n             {\n-                result.PropertyFilters = new List<string>(PropertyFilters);\n+                result.PropertyFilters = [.. PropertyFilters];\n             }\n+\n             if (ItemFilters is not null)\n             {\n                 result.ItemFilters = ItemFilters.ToDictionary(\n                     kvp => kvp.Key,\n                     kvp => kvp.Value == null ? null : new List<string>(kvp.Value));\n             }\n+\n             return result;\n         }\n \n+        /// <summary>\n+        /// Returns a new RequestedProjectState that contains the union of filters from this instance and another.\n+        /// </summary>\n+        /// <param name=\"other\">The other RequestedProjectState to merge with.</param>\n+        /// <returns>A new RequestedProjectState representing the merged filters.</returns>\n+        internal RequestedProjectState Merge(RequestedProjectState other)\n+        {\n+            // If either is null, return a clone of the non-null one\n+            if (other == null)\n+            {\n+                return DeepClone();\n+            }\n+\n+            RequestedProjectState result = new RequestedProjectState();\n+\n+            // Merge property filters\n+            if (PropertyFilters != null || other.PropertyFilters != null)\n+            {\n+                HashSet<string> mergedProperties = new(StringComparer.OrdinalIgnoreCase);\n+                if (PropertyFilters != null)\n+                {\n+                    foreach (var prop in PropertyFilters)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If the value isn't in the list, we initialize a new list, then add all the values from the previous list to it.\r\n - I'm not sure how immutable the list is, but since these are results, I would assume immutability.\r\n - in such case, maybe `mergedItems[itemType.Key] = itemType.Value` is workable?\r\n - if that is too risky, then `mergedItems[itemType.Key] = itemType.Value.Copy()` or something similar. (if we know that the first list is empty, we can take the other one as-is, skipping all of the .Contains checks)\r\n - note that this will always be the case for the `MergeItemFiltersFrom(mergedItems, ItemFilters);` invocation since we start with an empty dictionary.\r\nSadly it seems that dictionary doesn't support .Copy() or deep copy, at least not out of the box.",
              "createdAt": "2025-05-28T11:52:25Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -44,17 +44,107 @@ internal RequestedProjectState DeepClone()\n             RequestedProjectState result = new RequestedProjectState();\n             if (PropertyFilters is not null)\n             {\n-                result.PropertyFilters = new List<string>(PropertyFilters);\n+                result.PropertyFilters = [.. PropertyFilters];\n             }\n+\n             if (ItemFilters is not null)\n             {\n                 result.ItemFilters = ItemFilters.ToDictionary(\n                     kvp => kvp.Key,\n                     kvp => kvp.Value == null ? null : new List<string>(kvp.Value));\n             }\n+\n             return result;\n         }\n \n+        /// <summary>\n+        /// Returns a new RequestedProjectState that contains the union of filters from this instance and another.\n+        /// </summary>\n+        /// <param name=\"other\">The other RequestedProjectState to merge with.</param>\n+        /// <returns>A new RequestedProjectState representing the merged filters.</returns>\n+        internal RequestedProjectState Merge(RequestedProjectState other)\n+        {\n+            // If either is null, return a clone of the non-null one\n+            if (other == null)\n+            {\n+                return DeepClone();\n+            }\n+\n+            RequestedProjectState result = new RequestedProjectState();\n+\n+            // Merge property filters\n+            if (PropertyFilters != null || other.PropertyFilters != null)\n+            {\n+                HashSet<string> mergedProperties = new(StringComparer.OrdinalIgnoreCase);\n+                if (PropertyFilters != null)\n+                {\n+                    foreach (var prop in PropertyFilters)\n+                    {\n+                        mergedProperties.Add(prop);\n+                    }\n+                }\n+\n+                if (other.PropertyFilters != null)\n+                {\n+                    foreach (var prop in other.PropertyFilters)\n+                    {\n+                        mergedProperties.Add(prop);\n+                    }\n+                }\n+\n+                if (mergedProperties.Count > 0)\n+                {\n+                    result.PropertyFilters = mergedProperties.ToList();\n+                }\n+            }\n+\n+            // Merge item filters\n+            if (ItemFilters != null || other.ItemFilters != null)\n+            {\n+                Dictionary<string, List<string>> mergedItems = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);\n+\n+                // Add items from both filters\n+                MergeItemFiltersFrom(mergedItems, ItemFilters);\n+                MergeItemFiltersFrom(mergedItems, other.ItemFilters);\n+\n+                if (mergedItems.Count > 0)\n+                {\n+                    result.ItemFilters = mergedItems;\n+                }\n+            }\n+\n+            return result;\n+\n+            // Helper method to add item filters from a source to the merged result\n+            void MergeItemFiltersFrom(Dictionary<string, List<string>> mergedItems, IDictionary<string, List<string>> source)\n+            {\n+                if (source == null)\n+                {\n+                    return;\n+                }\n+\n+                foreach (var itemType in source)\n+                {\n+                    if (!mergedItems.TryGetValue(itemType.Key, out List<string> metadataList))\n+                    {\n+                        metadataList = new List<string>();\n+                        mergedItems[itemType.Key] = metadataList;",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "since [IsSubsetOf(IEnumerable<T>)](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1.issubsetof?view=net-9.0#system-collections-generic-hashset-1-issubsetof(system-collections-generic-ienumerable((-0)))) exists, this could be replaced.\r\nI'm unsure about possible performance implications.",
              "createdAt": "2025-05-28T11:54:24Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -72,7 +162,7 @@ internal bool IsSubsetOf(RequestedProjectState another)\n             }\n             else if (another.PropertyFilters is not null)\n             {\n-                HashSet<string> anotherPropertyFilters = new HashSet<string>(another.PropertyFilters);\n+                HashSet<string> anotherPropertyFilters = new(another.PropertyFilters);\n                 foreach (string propertyFilter in PropertyFilters)\n                 {\n                     if (!anotherPropertyFilters.Contains(propertyFilter))",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same as above ([IsSubsetOf(IEnumerable<T>)](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1.issubsetof?view=net-9.0#system-collections-generic-hashset-1-issubsetof(system-collections-generic-ienumerable((-0)))))",
              "createdAt": "2025-05-28T11:57:11Z",
              "path": "src/Build/BackEnd/BuildManager/RequestedProjectState.cs",
              "diffHunk": "@@ -109,7 +200,7 @@ internal bool IsSubsetOf(RequestedProjectState another)\n                     }\n                     else if (metadata is not null)\n                     {\n-                        HashSet<string> anotherMetadata = new HashSet<string>(metadata);",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Honestly I'm not sure. However as writen it was mildly confusing to parse what is happening.\r\nMaybe something like this? But I'll leave it up to you.\r\n```\r\nif (HasFlag(requestFlags, BuildRequestDataFlags.ProvideProjectStateAfterBuild)) && !HasFlag(resultFlags, BuildRequestDataFlags.ProvideProjectStateAfterBuild)\r\n{\r\n     return false;\r\n}\r\n```",
              "createdAt": "2025-05-28T12:04:54Z",
              "path": "src/Build/BackEnd/Components/Caching/ResultsCache.cs",
              "diffHunk": "@@ -357,56 +345,38 @@ private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, Bui\n                 return true;\n             }\n \n-            BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;\n-            BuildRequestDataFlags buildResultDataFlags = (BuildRequestDataFlags)buildResult.BuildRequestDataFlags;\n+            BuildRequestDataFlags requestFlags = buildRequest.BuildRequestDataFlags;\n+            BuildRequestDataFlags resultFlags = (BuildRequestDataFlags)buildResult.BuildRequestDataFlags;\n \n-            if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))\n+            if ((requestFlags & FlagsAffectingBuildResults) != (resultFlags & FlagsAffectingBuildResults))\n             {\n                 // Mismatch in flags that can affect build results -> not compatible.\n                 return false;\n             }\n \n-            if (HasProvideProjectStateAfterBuild(buildRequestDataFlags))\n+            // ProvideProjectStateAfterBuild represents full state.\n+            // If full state is requested, we must have full state in the cache result.\n+            if (HasFlag(requestFlags, BuildRequestDataFlags.ProvideProjectStateAfterBuild))",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Interestingly enough, few lines lower, there is a similar construct that was much easier to parse.\r\nCould be that I got used to what is happening.",
              "createdAt": "2025-05-28T12:07:17Z",
              "path": "src/Build/BackEnd/Components/Caching/ResultsCache.cs",
              "diffHunk": "@@ -357,56 +345,38 @@ private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, Bui\n                 return true;\n             }\n \n-            BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;\n-            BuildRequestDataFlags buildResultDataFlags = (BuildRequestDataFlags)buildResult.BuildRequestDataFlags;\n+            BuildRequestDataFlags requestFlags = buildRequest.BuildRequestDataFlags;\n+            BuildRequestDataFlags resultFlags = (BuildRequestDataFlags)buildResult.BuildRequestDataFlags;\n \n-            if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))\n+            if ((requestFlags & FlagsAffectingBuildResults) != (resultFlags & FlagsAffectingBuildResults))\n             {\n                 // Mismatch in flags that can affect build results -> not compatible.\n                 return false;\n             }\n \n-            if (HasProvideProjectStateAfterBuild(buildRequestDataFlags))\n+            // ProvideProjectStateAfterBuild represents full state.\n+            // If full state is requested, we must have full state in the cache result.\n+            if (HasFlag(requestFlags, BuildRequestDataFlags.ProvideProjectStateAfterBuild))",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be reasonable to use similar helper function as HasFlag above or is this an overkill in this case?",
              "createdAt": "2025-05-28T12:11:33Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This was a weird one to parse. However after a brief search it looks to be a standard way to unset a flag.\r\nIt's been a while since I've done bitwise operations.",
              "createdAt": "2025-05-28T12:20:43Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be possible to do using Microsoft.Build.Execution to save all these Execution.s?\r\n(For some reason my VS was complaining about it, but why?)\r\nHowever there are just few of them so it's probably fine.",
              "createdAt": "2025-05-28T12:25:48Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this the same sort of reasoning as above?\r\n> // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\r\n",
              "createdAt": "2025-05-28T12:28:16Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Two things here:\r\n - I'm not sure about the way we capture the mergedInstanceCandidate. Can we do it in a more \"visible\" way please? as the function call currently stands, it doesn't look connected to the mergedInstanceCandidate.\r\n - there is a chance that .GetProperty(property.Name) and .SetProperty(property.Name, property.EvaluatedValue); will lock the underlying collection. I'm not 100% sure since the code is structured in a weird way, however the `internal T this[string name]` in PropertyDictionary.cs locks. \r\n   - is this a code path that will get locked? if no, good, if yes, do we care?",
              "createdAt": "2025-05-28T12:45:04Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            if (newProjectStateAfterBuild == null)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (_projectStateAfterBuild == null)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            // Create a deep copy of the existing ProjectStateAfterBuild\n+            ProjectInstance mergedInstanceCandidate = _projectStateAfterBuild.DeepCopy(isImmutable: false);\n+            MergeProperties(newProjectStateAfterBuild.Properties);\n+            MergeItems(newProjectStateAfterBuild.Items);\n+\n+            // Merge RequestedProjectStateFilter\n+            var sourceFilter = _projectStateAfterBuild.RequestedProjectStateFilter;\n+            var newFilter = newProjectStateAfterBuild.RequestedProjectStateFilter;\n+            if (sourceFilter != null || newFilter != null)\n+            {\n+                RequestedProjectState mergedFilter;\n+\n+                if (sourceFilter == null)\n+                {\n+                    mergedFilter = newFilter.DeepClone();\n+                }\n+                else if (newFilter == null)\n+                {\n+                    mergedFilter = sourceFilter.DeepClone();\n+                }\n+                else\n+                {\n+                    mergedFilter = sourceFilter.Merge(newFilter);\n+                }\n+\n+                return mergedInstanceCandidate.FilteredCopy(mergedFilter);\n+            }\n+\n+            return mergedInstanceCandidate;\n+\n+            void MergeProperties(ICollection<ProjectPropertyInstance> newProperties)\n+            {\n+                foreach (var property in newProperties)\n+                {\n+                    if (mergedInstanceCandidate.GetProperty(property.Name) == null)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This could be doing multiple adds to an CopyOnWrite dictionary. Can we double check to make sure this is safe to do please? (This could be creating a bunch of expensive copies in the worst case)\r\nImportMetadata is unfortunately not exposed to the existingItem, so the fix (if needed) might not be straightforward)",
              "createdAt": "2025-05-28T14:12:43Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            if (newProjectStateAfterBuild == null)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (_projectStateAfterBuild == null)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            // Create a deep copy of the existing ProjectStateAfterBuild\n+            ProjectInstance mergedInstanceCandidate = _projectStateAfterBuild.DeepCopy(isImmutable: false);\n+            MergeProperties(newProjectStateAfterBuild.Properties);\n+            MergeItems(newProjectStateAfterBuild.Items);\n+\n+            // Merge RequestedProjectStateFilter\n+            var sourceFilter = _projectStateAfterBuild.RequestedProjectStateFilter;\n+            var newFilter = newProjectStateAfterBuild.RequestedProjectStateFilter;\n+            if (sourceFilter != null || newFilter != null)\n+            {\n+                RequestedProjectState mergedFilter;\n+\n+                if (sourceFilter == null)\n+                {\n+                    mergedFilter = newFilter.DeepClone();\n+                }\n+                else if (newFilter == null)\n+                {\n+                    mergedFilter = sourceFilter.DeepClone();\n+                }\n+                else\n+                {\n+                    mergedFilter = sourceFilter.Merge(newFilter);\n+                }\n+\n+                return mergedInstanceCandidate.FilteredCopy(mergedFilter);\n+            }\n+\n+            return mergedInstanceCandidate;\n+\n+            void MergeProperties(ICollection<ProjectPropertyInstance> newProperties)\n+            {\n+                foreach (var property in newProperties)\n+                {\n+                    if (mergedInstanceCandidate.GetProperty(property.Name) == null)\n+                    {\n+                        mergedInstanceCandidate.SetProperty(property.Name, property.EvaluatedValue);\n+                    }\n+                }\n+            }\n+\n+            void MergeItems(ICollection<ProjectItemInstance> newItems)\n+            {\n+                // Maps item types (e.g., \"Compile\") to a set of includes (e.g., \"File1.cs\")\n+                var existingItemsByType = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n+\n+                // Maps a tuple of (item type, include) to the actual item instance\n+                var existingItemsLookup = new Dictionary<(string, string), ProjectItemInstance>(ItemIdentityComparer.Instance);\n+\n+                foreach (var item in mergedInstanceCandidate.Items)\n+                {\n+                    if (!existingItemsByType.TryGetValue(item.ItemType, out var itemSet))\n+                    {\n+                        itemSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n+                        existingItemsByType[item.ItemType] = itemSet;\n+                    }\n+\n+                    itemSet.Add(item.EvaluatedInclude);\n+                    existingItemsLookup[(item.ItemType, item.EvaluatedInclude)] = item;\n+                }\n+\n+                // Add new items that don't already exist and merge metadata for existing ones\n+                foreach (var item in newProjectStateAfterBuild.Items)\n+                {\n+                    if (existingItemsByType.TryGetValue(item.ItemType, out var existingItems) && existingItems.Contains(item.EvaluatedInclude))\n+                    {\n+                        var existingItem = existingItemsLookup[(item.ItemType, item.EvaluatedInclude)];\n+\n+                        // Merge metadata from the new item into the existing one\n+                        foreach (var metadata in item.EnumerateMetadata())\n+                        {\n+                            existingItem.SetMetadata(metadata.Key, metadata.Value);",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is locking the underlying collection.\r\nAre we fine with that?",
              "createdAt": "2025-05-28T14:18:55Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            if (newProjectStateAfterBuild == null)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (_projectStateAfterBuild == null)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            // Create a deep copy of the existing ProjectStateAfterBuild\n+            ProjectInstance mergedInstanceCandidate = _projectStateAfterBuild.DeepCopy(isImmutable: false);\n+            MergeProperties(newProjectStateAfterBuild.Properties);\n+            MergeItems(newProjectStateAfterBuild.Items);\n+\n+            // Merge RequestedProjectStateFilter\n+            var sourceFilter = _projectStateAfterBuild.RequestedProjectStateFilter;\n+            var newFilter = newProjectStateAfterBuild.RequestedProjectStateFilter;\n+            if (sourceFilter != null || newFilter != null)\n+            {\n+                RequestedProjectState mergedFilter;\n+\n+                if (sourceFilter == null)\n+                {\n+                    mergedFilter = newFilter.DeepClone();\n+                }\n+                else if (newFilter == null)\n+                {\n+                    mergedFilter = sourceFilter.DeepClone();\n+                }\n+                else\n+                {\n+                    mergedFilter = sourceFilter.Merge(newFilter);\n+                }\n+\n+                return mergedInstanceCandidate.FilteredCopy(mergedFilter);\n+            }\n+\n+            return mergedInstanceCandidate;\n+\n+            void MergeProperties(ICollection<ProjectPropertyInstance> newProperties)\n+            {\n+                foreach (var property in newProperties)\n+                {\n+                    if (mergedInstanceCandidate.GetProperty(property.Name) == null)\n+                    {\n+                        mergedInstanceCandidate.SetProperty(property.Name, property.EvaluatedValue);\n+                    }\n+                }\n+            }\n+\n+            void MergeItems(ICollection<ProjectItemInstance> newItems)\n+            {\n+                // Maps item types (e.g., \"Compile\") to a set of includes (e.g., \"File1.cs\")\n+                var existingItemsByType = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n+\n+                // Maps a tuple of (item type, include) to the actual item instance\n+                var existingItemsLookup = new Dictionary<(string, string), ProjectItemInstance>(ItemIdentityComparer.Instance);\n+\n+                foreach (var item in mergedInstanceCandidate.Items)\n+                {\n+                    if (!existingItemsByType.TryGetValue(item.ItemType, out var itemSet))\n+                    {\n+                        itemSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n+                        existingItemsByType[item.ItemType] = itemSet;\n+                    }\n+\n+                    itemSet.Add(item.EvaluatedInclude);\n+                    existingItemsLookup[(item.ItemType, item.EvaluatedInclude)] = item;\n+                }\n+\n+                // Add new items that don't already exist and merge metadata for existing ones\n+                foreach (var item in newProjectStateAfterBuild.Items)\n+                {\n+                    if (existingItemsByType.TryGetValue(item.ItemType, out var existingItems) && existingItems.Contains(item.EvaluatedInclude))\n+                    {\n+                        var existingItem = existingItemsLookup[(item.ItemType, item.EvaluatedInclude)];\n+\n+                        // Merge metadata from the new item into the existing one\n+                        foreach (var metadata in item.EnumerateMetadata())\n+                        {\n+                            existingItem.SetMetadata(metadata.Key, metadata.Value);\n+                        }\n+                    }\n+                    // If the item doesn't exist, add it to the merged instance candidate and update the existing items dictionary\n+                    else\n+                    {\n+                        mergedInstanceCandidate.AddItem(item.ItemType, item.EvaluatedInclude, item.EnumerateMetadata());",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "nice catch, changed to batch ",
              "createdAt": "2025-05-30T07:57:55Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            if (newProjectStateAfterBuild == null)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (_projectStateAfterBuild == null)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            // Create a deep copy of the existing ProjectStateAfterBuild\n+            ProjectInstance mergedInstanceCandidate = _projectStateAfterBuild.DeepCopy(isImmutable: false);\n+            MergeProperties(newProjectStateAfterBuild.Properties);\n+            MergeItems(newProjectStateAfterBuild.Items);\n+\n+            // Merge RequestedProjectStateFilter\n+            var sourceFilter = _projectStateAfterBuild.RequestedProjectStateFilter;\n+            var newFilter = newProjectStateAfterBuild.RequestedProjectStateFilter;\n+            if (sourceFilter != null || newFilter != null)\n+            {\n+                RequestedProjectState mergedFilter;\n+\n+                if (sourceFilter == null)\n+                {\n+                    mergedFilter = newFilter.DeepClone();\n+                }\n+                else if (newFilter == null)\n+                {\n+                    mergedFilter = sourceFilter.DeepClone();\n+                }\n+                else\n+                {\n+                    mergedFilter = sourceFilter.Merge(newFilter);\n+                }\n+\n+                return mergedInstanceCandidate.FilteredCopy(mergedFilter);\n+            }\n+\n+            return mergedInstanceCandidate;\n+\n+            void MergeProperties(ICollection<ProjectPropertyInstance> newProperties)\n+            {\n+                foreach (var property in newProperties)\n+                {\n+                    if (mergedInstanceCandidate.GetProperty(property.Name) == null)\n+                    {\n+                        mergedInstanceCandidate.SetProperty(property.Name, property.EvaluatedValue);\n+                    }\n+                }\n+            }\n+\n+            void MergeItems(ICollection<ProjectItemInstance> newItems)\n+            {\n+                // Maps item types (e.g., \"Compile\") to a set of includes (e.g., \"File1.cs\")\n+                var existingItemsByType = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n+\n+                // Maps a tuple of (item type, include) to the actual item instance\n+                var existingItemsLookup = new Dictionary<(string, string), ProjectItemInstance>(ItemIdentityComparer.Instance);\n+\n+                foreach (var item in mergedInstanceCandidate.Items)\n+                {\n+                    if (!existingItemsByType.TryGetValue(item.ItemType, out var itemSet))\n+                    {\n+                        itemSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n+                        existingItemsByType[item.ItemType] = itemSet;\n+                    }\n+\n+                    itemSet.Add(item.EvaluatedInclude);\n+                    existingItemsLookup[(item.ItemType, item.EvaluatedInclude)] = item;\n+                }\n+\n+                // Add new items that don't already exist and merge metadata for existing ones\n+                foreach (var item in newProjectStateAfterBuild.Items)\n+                {\n+                    if (existingItemsByType.TryGetValue(item.ItemType, out var existingItems) && existingItems.Contains(item.EvaluatedInclude))\n+                    {\n+                        var existingItem = existingItemsLookup[(item.ItemType, item.EvaluatedInclude)];\n+\n+                        // Merge metadata from the new item into the existing one\n+                        foreach (var metadata in item.EnumerateMetadata())\n+                        {\n+                            existingItem.SetMetadata(metadata.Key, metadata.Value);\n+                        }\n+                    }\n+                    // If the item doesn't exist, add it to the merged instance candidate and update the existing items dictionary\n+                    else\n+                    {\n+                        mergedInstanceCandidate.AddItem(item.ItemType, item.EvaluatedInclude, item.EnumerateMetadata());",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since this is the else branch of \r\n```\r\n(existingItemsByType.TryGetValue(item.ItemType, out var existingItems) && existingItems.Contains(item.EvaluatedInclude)\r\n```\r\nwill this be true by default or is there a case where this check is necessary?\r\n`if (existingItems == null)`",
              "createdAt": "2025-05-28T14:24:33Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)\n         }\n \n         /// <summary>\n-        /// Creates the target result dictionary.\n+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.\n         /// </summary>\n-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)\n+        /// <param name=\"newFlags\">The new flags to merge with the existing flags.</param>\n+        /// <returns>The merged BuildRequestDataFlags.</returns>\n+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)\n         {\n-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);\n+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _buildRequestDataFlags;\n+            }\n+\n+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);\n+\n+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;\n+            }\n+\n+            return mergedFlags;\n         }\n \n+        /// <summary>\n+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.\n+        /// </summary>\n+        /// <param name=\"newFlags\">The request flags.</param>\n+        /// <param name=\"newProjectStateAfterBuild\">The new ProjectStateAfterBuild instance to merge.</param>\n+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>\n+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)\n+        {\n+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            if (newProjectStateAfterBuild == null)\n+            {\n+                return _projectStateAfterBuild;\n+            }\n+\n+            if (_projectStateAfterBuild == null)\n+            {\n+                return newProjectStateAfterBuild;\n+            }\n+\n+            // Create a deep copy of the existing ProjectStateAfterBuild\n+            ProjectInstance mergedInstanceCandidate = _projectStateAfterBuild.DeepCopy(isImmutable: false);\n+            MergeProperties(newProjectStateAfterBuild.Properties);\n+            MergeItems(newProjectStateAfterBuild.Items);\n+\n+            // Merge RequestedProjectStateFilter\n+            var sourceFilter = _projectStateAfterBuild.RequestedProjectStateFilter;\n+            var newFilter = newProjectStateAfterBuild.RequestedProjectStateFilter;\n+            if (sourceFilter != null || newFilter != null)\n+            {\n+                RequestedProjectState mergedFilter;\n+\n+                if (sourceFilter == null)\n+                {\n+                    mergedFilter = newFilter.DeepClone();\n+                }\n+                else if (newFilter == null)\n+                {\n+                    mergedFilter = sourceFilter.DeepClone();\n+                }\n+                else\n+                {\n+                    mergedFilter = sourceFilter.Merge(newFilter);\n+                }\n+\n+                return mergedInstanceCandidate.FilteredCopy(mergedFilter);\n+            }\n+\n+            return mergedInstanceCandidate;\n+\n+            void MergeProperties(ICollection<ProjectPropertyInstance> newProperties)\n+            {\n+                foreach (var property in newProperties)\n+                {\n+                    if (mergedInstanceCandidate.GetProperty(property.Name) == null)\n+                    {\n+                        mergedInstanceCandidate.SetProperty(property.Name, property.EvaluatedValue);\n+                    }\n+                }\n+            }\n+\n+            void MergeItems(ICollection<ProjectItemInstance> newItems)\n+            {\n+                // Maps item types (e.g., \"Compile\") to a set of includes (e.g., \"File1.cs\")\n+                var existingItemsByType = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n+\n+                // Maps a tuple of (item type, include) to the actual item instance\n+                var existingItemsLookup = new Dictionary<(string, string), ProjectItemInstance>(ItemIdentityComparer.Instance);\n+\n+                foreach (var item in mergedInstanceCandidate.Items)\n+                {\n+                    if (!existingItemsByType.TryGetValue(item.ItemType, out var itemSet))\n+                    {\n+                        itemSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n+                        existingItemsByType[item.ItemType] = itemSet;\n+                    }\n+\n+                    itemSet.Add(item.EvaluatedInclude);\n+                    existingItemsLookup[(item.ItemType, item.EvaluatedInclude)] = item;\n+                }\n+\n+                // Add new items that don't already exist and merge metadata for existing ones\n+                foreach (var item in newProjectStateAfterBuild.Items)\n+                {\n+                    if (existingItemsByType.TryGetValue(item.ItemType, out var existingItems) && existingItems.Contains(item.EvaluatedInclude))\n+                    {\n+                        var existingItem = existingItemsLookup[(item.ItemType, item.EvaluatedInclude)];\n+\n+                        // Merge metadata from the new item into the existing one\n+                        foreach (var metadata in item.EnumerateMetadata())\n+                        {\n+                            existingItem.SetMetadata(metadata.Key, metadata.Value);\n+                        }\n+                    }\n+                    // If the item doesn't exist, add it to the merged instance candidate and update the existing items dictionary\n+                    else\n+                    {\n+                        mergedInstanceCandidate.AddItem(item.ItemType, item.EvaluatedInclude, item.EnumerateMetadata());\n+\n+                        if (existingItems == null)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      }
    ]
  }
}