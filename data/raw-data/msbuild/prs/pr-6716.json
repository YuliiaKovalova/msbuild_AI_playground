{
  "number": 6716,
  "title": "Optimize item Remove operations",
  "body": "Fixes #6696\r\n\r\n### Context\r\n\r\nRemoving items by referencing other item types or by multiple single-item Remove operations has bad performance characteristics because it leads to N*M comparisons, each involving path normalization of both sides. For projects with as few as small thousands of items, evaluating them becomes a bottleneck with direct impact on build time and VS responsiveness.\r\n\r\n### Changes Made\r\n\r\nReplaced `ImmutableList<ItemData>` with a new collection type `OrderedItemDataCollection` to be used when representing the intermediate list of items. In addition to being a list, the new collection also lazily creates a dictionary of items keyed by normalized paths, which allows for fast matching.\r\n\r\n### Testing\r\n\r\nFunctional:\r\n- Existing unit tests, one new unit test for a previously uncovered scenario.\r\n- Experimental VS insertion.\r\n\r\nPerformance:\r\nUsed a benchmark project with 2000 files in a subdirectory.\r\n\r\nEvaluation time of:\r\n```xml\r\n    <A Include=\"**/*.*\" />\r\n    <B Include=\"**/*.*\" />\r\n    <B Remove=\"@(A)\" />\r\n```\r\nwent from 7300 ms down to 180 ms.\r\n\r\nEvaluation time of:\r\n```xml\r\n    <A Include=\"**/*.*\" />    \r\n    <A Remove='subdir\\file1'/>\r\n    <A Remove='subdir\\file2'/>\r\n    ...\r\n    <A Remove='subdir\\file2000'/>\r\n```\r\nwent from 7900 ms down to 330 ms.\r\n\r\nEvaluation time of a Hello World .NET Core project went got slightly faster as well (520 -> 515 ms, note that this was without NGEN so most of it is JITting).\r\n\r\n### Notes\r\n\r\nI opted for a rather simple implementation of `OrderedItemDataCollection` based on `ImmutableList` and `Dictionary`. It has limitations but seems to work well for the scenarios of interest. It should be possible to implement a completely custom data structure for even better results (requirements: immutable, maintains insertion order for enumeration).",
  "state": "MERGED",
  "createdAt": "2021-07-28T21:30:10Z",
  "updatedAt": "2021-08-23T19:17:10Z",
  "closedAt": "2021-08-23T19:17:10Z",
  "mergedAt": "2021-08-23T19:17:10Z",
  "additions": 674,
  "deletions": 55,
  "changedFiles": 14,
  "headRefName": "6696-linear-remove-operation",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "6c458aa963702d61a6cf57cf46cb4884d7e213ec",
          "message": "Make remove items operation linear",
          "committedDate": "2021-07-28T20:56:56Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21622cf0212118f2c9d5ea8b9dcf5db108116eff",
          "message": "Fix bugs: Respect condition and correctly unescape/normalize",
          "committedDate": "2021-08-02T20:49:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "813de90f59158d62042753570d20d8dc8dc0b75f",
          "message": "Update src/Build/Evaluation/LazyItemEvaluator.cs\n\nCo-authored-by: Marius Ungureanu <therzok@gmail.com>",
          "committedDate": "2021-08-03T08:47:48Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "efb5e4e34fba95ad6f852357337e9a01f2cdca30",
          "message": "Update src/Build/Evaluation/LazyItemEvaluator.cs\n\nCo-authored-by: Marius Ungureanu <therzok@gmail.com>",
          "committedDate": "2021-08-03T08:48:12Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e56c67da1882d5274270603cc76d23ec0abd1cb",
          "message": "Update src/Build/Evaluation/LazyItemEvaluator.cs\n\nCo-authored-by: Marius Ungureanu <therzok@gmail.com>",
          "committedDate": "2021-08-03T09:23:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "264f411661a4e2a21e465b48430ef9d5cf23be07",
          "message": "PR feedback: Eliminate iterator allocations",
          "committedDate": "2021-08-03T09:24:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1e59d3db0fa7331ddd0d4d3e0ca59c0366bb07cc",
          "message": "Fix generic argument",
          "committedDate": "2021-08-03T09:59:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3c965ae023172fca4fcbb1fbc4612820bddd29e7",
          "message": "Revert \"Update src/Build/Evaluation/LazyItemEvaluator.cs\"\n\nThis reverts commit efb5e4e34fba95ad6f852357337e9a01f2cdca30.",
          "committedDate": "2021-08-03T10:00:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "96609353448b5cc44e54509075bc45e6c0fea9b6",
          "message": "Revert \"Update src/Build/Evaluation/LazyItemEvaluator.cs\"\n\nThis reverts commit 813de90f59158d62042753570d20d8dc8dc0b75f.",
          "committedDate": "2021-08-03T10:00:31Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4ce21f379a06502dbb0f444ebb9151c87d1d088b",
          "message": "Use ImmutableList in DictionaryValue",
          "committedDate": "2021-08-03T11:19:18Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "90557bd10c56a261b403e5de4821bf52145b8d10",
          "message": "PR feedback: Use RemoveRange to remove multiple keys from ImmutableDictionary.Builder",
          "committedDate": "2021-08-03T11:34:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c7ddb5bcc55a219cf7662dba88e3d69c3b01847",
          "message": "PR feedback: Move OrderedItemDataCollection into its own file",
          "committedDate": "2021-08-03T12:44:31Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "26f2eee9e8ed92d1866b0371d8d097f5d136bc0b",
          "message": "Add PathIsInvalid checks",
          "committedDate": "2021-08-04T05:49:31Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c7414ff3f2daf3dfcd89b565254745c1252064f",
          "message": "Make path normalization backward compatible",
          "committedDate": "2021-08-04T07:13:24Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cff06a10b3f5bbcd13452c791e1aeb56dca807ab",
          "message": "Make path normalization backward compatible (take 2)",
          "committedDate": "2021-08-04T08:06:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d09e5d05b0f404ec2f412ba6dd92975f73017ce3",
          "message": " Make path normalization backward compatible (take 3)",
          "committedDate": "2021-08-04T09:00:18Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6fc8b382007493e63193886dc39100b6af678c3f",
          "message": "PR feedback: Move removing logic to ItemSpec",
          "committedDate": "2021-08-06T20:27:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8bad8a55eac7b78bef6d6f89f60a71c7bdcd4cf6",
          "message": "PR feedback: Cache normalized item value on ItemData",
          "committedDate": "2021-08-06T20:28:09Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c65fc744ce7e6fa8b5678f1ba2a4bd97e407c363",
          "message": "PR feedback: Comment ItemDataCollectionValue<I>.Enumerator.MoveNext",
          "committedDate": "2021-08-06T20:29:55Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a1d2adf4480a9cc6fd30582546723c069a6f8abd",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-08-06T20:30:50Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "311a8f4a45f5bdce260d0676f9fbed81a8c810c1",
          "message": "PR feedback: `!=` => `is not null`",
          "committedDate": "2021-08-06T20:33:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "679b975b46238fb0be6612cfc0a041b578d27ce4",
          "message": "Do not use ImmutableDictionary",
          "committedDate": "2021-08-12T07:00:35Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5d03b74daac9d78050527685c4cc25d2c4749ba",
          "message": "Do not use ImmutableList",
          "committedDate": "2021-08-13T13:22:29Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e144cd4f985a3ca67fc90dbfe630f5ab754dfffd",
          "message": "Use dictionary-based remove only for large item lists",
          "committedDate": "2021-08-16T09:00:12Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c475fe02c648a63461461def7b44cd96f402ca7",
          "message": "Merge branch '6696-linear-remove-operation' of https://github.com/ladipro/msbuild into 6696-linear-remove-operation",
          "committedDate": "2021-08-16T09:22:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1bd8c23a2efe224d2873dab5f24bee2c4943585f",
          "message": "Undo unrelated change in Project.cs",
          "committedDate": "2021-08-22T20:19:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b317781e717303b70a14de2e6c54163903004ea8",
          "message": "Merge remote-tracking branch 'dotnet/main' into 6696-linear-remove-operation",
          "committedDate": "2021-08-22T20:35:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f905e849b07dd399e1a9277ff48e38af83b1eb3e",
          "message": "Add ProjectItemWithOptimizations_Tests",
          "committedDate": "2021-08-23T09:40:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb345f4a698baa6c3b4c3315b9a808b461898636",
          "message": "Fix ItemDataCollectionValue bugs and add UT coverage",
          "committedDate": "2021-08-23T09:41:21Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "/azp run",
        "createdAt": "2021-08-03T07:10:45Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2021-08-03T07:10:54Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2021-08-03T20:42:10Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2021-08-03T20:42:19Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "> I'm a little curious how few things you would have to remove for it to be not worth it to make this ordered collection. Probably not important, since it would be fast either way.\r\n\r\nThe remove operation is dominated by normalization of item values. This will run on the first remove either way. The extra overhead of building the dictionary should be relatively small and I'd be surprised if two removes were not already faster. I will measure and confirm, it's a fair question.",
        "createdAt": "2021-08-06T20:37:23Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "There is a measurable regression in \"small scale\" removes, just as you suspected @Forgind. It slows down evaluation of a Hello World .NET Core project by a few percent. I will profile and make changes to address this.",
        "createdAt": "2021-08-11T20:06:46Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I've made the following changes:\r\n- No longer maintaining the dictionary as immutable so it is forgotten when the list is added to the cache in `MemoizedOperation`. As @Therzok pointed out earlier, `ImmutableDictionary` has a cost and it turns out that we rarely take advantage of this memoization in real-world projects (when building OC I see <300 cache hits where we further modify the list as opposed to 20k hits with no modification).\r\n- Enabled the new code path only for larger items lists (env variable configurable, >= 100 items by default) because the dictionary set-up work still showed in profiles for small ones.\r\n\r\nI have updated the description with fresh measurements. There is a positive impact on evaluation time even if the dictionary is not used, due to other smaller optimizations, primarily caching the normalized value on `ItemData` and refactoring `FileSpecMatchTester` to prevent repeated normalizations.",
        "createdAt": "2021-08-16T10:00:20Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Given LINQ is optimized to know about LINQ in chained operations, maybe. Unlike `yield return`, this would have support for speed optimizations like `TryGetCount`.\r\n\r\n```suggestion\r\n           return Enumerable.Repeat(TextFragment, 1);\r\n```",
              "createdAt": "2021-07-28T23:05:09Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -415,6 +420,16 @@ public virtual bool IsMatch(string itemToMatch)\n             return FileMatcher.IsMatch(itemToMatch);\n         }\n \n+        public virtual bool IsMatchNormalized(string normalizedItemToMatch)\n+        {\n+            return FileMatcher.IsMatchNormalized(normalizedItemToMatch);\n+        }\n+\n+        public virtual IEnumerable<string> GetReferencedItems()\n+        {\n+            yield return TextFragment;",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Wow, I was hoping C# would generate better code for an iterator function yield-returning a single item. I have applied your change. I find it less readable but it wins perf-wise, at least on Core.",
              "createdAt": "2021-08-03T09:34:23Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -415,6 +420,16 @@ public virtual bool IsMatch(string itemToMatch)\n             return FileMatcher.IsMatch(itemToMatch);\n         }\n \n+        public virtual bool IsMatchNormalized(string normalizedItemToMatch)\n+        {\n+            return FileMatcher.IsMatchNormalized(normalizedItemToMatch);\n+        }\n+\n+        public virtual IEnumerable<string> GetReferencedItems()\n+        {\n+            yield return TextFragment;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            return Enumerable.Empty<string>();\r\n```",
              "createdAt": "2021-07-28T23:05:29Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "This would make it hard to differentiate between \"there were no referenced items\" and \"we couldn't enumerate them efficiently.\" Also, I don't think it's the critical case we're trying to optimize for here\u2014I believe we're mostly looking at RemoveOperations without globs/wildcards.",
              "createdAt": "2021-07-31T06:36:27Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I actually spent some time trying to come up with a combination of glob Includes and Removes that would be slow but couldn't find anything bad. It is orders of magnitude faster than the scenarios addressed with the PR.\r\n\r\nThis `null` is important, it tells the caller that rather than enumerating all referenced items and removing them from the running list, the caller should check each item in the running list and test it against the glob via `IsMatch`.",
              "createdAt": "2021-08-03T09:41:21Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "> it tells the caller that rather than enumerating all referenced items and removing them from the running list, the caller should check each item in the running list and test it against the glob via IsMatch\r\n\r\nYup, which makes the calling code more complex (which gets avoided by https://github.com/dotnet/msbuild/pull/6716#discussion_r678762503)",
              "createdAt": "2021-08-03T18:07:01Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                                    items.UnionWith(multiValue);\r\n```",
              "createdAt": "2021-07-28T23:08:40Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Done, thank you!",
              "createdAt": "2021-08-03T08:48:06Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I reverted this because it doesn't work well with the struct enumerator of `DictionaryValue`. A manual `foreach` avoids boxing and the expected number of items added is 1 so `UnionWith` wouldn't be helping even if it was optimized for multiple adds (which it looks like it is not).",
              "createdAt": "2021-08-03T11:24:53Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                                    items.UnionWith(kvp.Value);\r\n```",
              "createdAt": "2021-07-28T23:09:12Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Done, thank you!",
              "createdAt": "2021-08-03T08:48:24Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I reverted this because it doesn't work well with the struct enumerator of `DictionaryValue`. A manual `foreach` avoids boxing and the expected number of items added is 1 so `UnionWith` wouldn't be helping even if it was optimized for multiple adds (which it looks like it is not).",
              "createdAt": "2021-08-03T11:25:06Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ImmutableDictionary is O(logn) indexing, this might be costly?",
              "createdAt": "2021-07-28T23:15:47Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+\n+                            if (keysToRemove != null)\n+                            {\n+                                foreach (string key in keysToRemove)\n+                                {\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Finish by removing items from the list.\n+                    if (items != null)\n+                    {\n+                        _listBuilder.RemoveAll(item => items.Contains(item.Item));\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Creates an immutable view of this collection.\n+                /// </summary>\n+                public OrderedItemDataCollection ToImmutable()\n+                {\n+                    return new OrderedItemDataCollection(_version, _listBuilder.ToImmutable(), _dictionaryBuilder?.ToImmutable());\n+                }\n+\n+                private IDictionary<string, DictionaryValue> GetOrCreateDictionaryBuilder()\n+                {\n+                    if (_dictionaryBuilder == null)\n+                    {\n+                        _dictionaryBuilder = ImmutableDictionary.CreateBuilder<string, DictionaryValue>(StringComparer.OrdinalIgnoreCase);\n+                        foreach (ItemData item in _listBuilder)\n+                        {\n+                            AddToDictionary(item.Item);\n+                        }\n+                    }\n+                    return _dictionaryBuilder;\n+                }\n+\n+                private void AddToDictionary(I item)\n+                {\n+                    string key = FileUtilities.NormalizePathForComparisonNoThrow(item.EvaluatedInclude, item.ProjectDirectory);\n+\n+                    if (!_dictionaryBuilder.TryGetValue(key, out var dictionaryValue))\n+                    {\n+                        dictionaryValue = new DictionaryValue(_version, item);\n+                    }\n+                    dictionaryValue.Add(_version, item);\n+                    _dictionaryBuilder[key] = dictionaryValue;\n+                }\n+            }\n+\n+            #endregion\n+\n+            /// <summary>\n+            /// The current version of the collection.\n+            /// </summary>\n+            private int _version;\n+\n+            /// <summary>\n+            /// The list of items in the collection. Defines the enumeration order.\n+            /// </summary>\n+            private ImmutableList<ItemData> _list;\n+\n+            /// <summary>\n+            /// A dictionary of items keyed by their normalized value.\n+            /// </summary>\n+            private ImmutableDictionary<string, DictionaryValue> _dictionary;",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "In the grand scheme of things since N is ~number of files on disk, I believe that O(logN) is fine. The alternative would be to use a regular dictionary with O(1) access and rebuilding it every time immutability is actually exercised. Which happens when the collection is added to the cache in `MemoizedOperation`. There may be optimizations that would remove the immutability requirement but I don't want to go there in this PR.",
              "createdAt": "2021-08-03T09:48:04Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+\n+                            if (keysToRemove != null)\n+                            {\n+                                foreach (string key in keysToRemove)\n+                                {\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Finish by removing items from the list.\n+                    if (items != null)\n+                    {\n+                        _listBuilder.RemoveAll(item => items.Contains(item.Item));\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Creates an immutable view of this collection.\n+                /// </summary>\n+                public OrderedItemDataCollection ToImmutable()\n+                {\n+                    return new OrderedItemDataCollection(_version, _listBuilder.ToImmutable(), _dictionaryBuilder?.ToImmutable());\n+                }\n+\n+                private IDictionary<string, DictionaryValue> GetOrCreateDictionaryBuilder()\n+                {\n+                    if (_dictionaryBuilder == null)\n+                    {\n+                        _dictionaryBuilder = ImmutableDictionary.CreateBuilder<string, DictionaryValue>(StringComparer.OrdinalIgnoreCase);\n+                        foreach (ItemData item in _listBuilder)\n+                        {\n+                            AddToDictionary(item.Item);\n+                        }\n+                    }\n+                    return _dictionaryBuilder;\n+                }\n+\n+                private void AddToDictionary(I item)\n+                {\n+                    string key = FileUtilities.NormalizePathForComparisonNoThrow(item.EvaluatedInclude, item.ProjectDirectory);\n+\n+                    if (!_dictionaryBuilder.TryGetValue(key, out var dictionaryValue))\n+                    {\n+                        dictionaryValue = new DictionaryValue(_version, item);\n+                    }\n+                    dictionaryValue.Add(_version, item);\n+                    _dictionaryBuilder[key] = dictionaryValue;\n+                }\n+            }\n+\n+            #endregion\n+\n+            /// <summary>\n+            /// The current version of the collection.\n+            /// </summary>\n+            private int _version;\n+\n+            /// <summary>\n+            /// The list of items in the collection. Defines the enumeration order.\n+            /// </summary>\n+            private ImmutableList<ItemData> _list;\n+\n+            /// <summary>\n+            /// A dictionary of items keyed by their normalized value.\n+            /// </summary>\n+            private ImmutableDictionary<string, DictionaryValue> _dictionary;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This enumerator allocates, maybe a `struct Enumerator` can be used here to avoid this allocations on operations?",
              "createdAt": "2021-07-28T23:16:04Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Fixed by adding a struct Enumerator, thank you!",
              "createdAt": "2021-08-03T09:24:48Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In example, allocations can be avoided here with the ImmutableList enumerator directly:\r\n\r\n```suggestion\r\n                ImmutableList<ItemData>.Enumerator GetEnumerator() => _listBuilder.GetEnumerator();\r\n                IEnumerator<ItemData> IEnumerable<T>.GetEnumerator() => _listBuilder.GetEnumerator();\r\n\r\n                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\r\n```",
              "createdAt": "2021-07-28T23:17:44Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Done, thank you!",
              "createdAt": "2021-08-03T09:23:54Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this throw NotImplementedException to protect against future use where someone hopes this works?",
              "createdAt": "2021-07-29T00:51:27Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "As I understand it, we _do_ use this; we just haven't optimized for it. If it's easy to batch things, we do. If not, this returns null, and we do the slow thing. That shouldn't hurt perf too much because I don't know of cases when someone does a long series of RemoveOperations with wildcards, though I may be wrong on that point.",
              "createdAt": "2021-07-31T06:39:56Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, this is intentional. https://github.com/dotnet/msbuild/pull/6716#discussion_r681603275",
              "createdAt": "2021-08-03T09:49:51Z",
              "path": "src/Build/Evaluation/ItemSpec.cs",
              "diffHunk": "@@ -446,6 +461,12 @@ public GlobFragment(string textFragment, string projectDirectory)\n         {\n         }\n \n+        public override IEnumerable<string> GetReferencedItems()\n+        {\n+            // This fragment cannot efficiently enumerate its referenced items.\n+            return null;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would this be easy to move in a separate file? At least yet another LazyItemEvaluator partial class",
              "createdAt": "2021-07-29T01:01:13Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Yes, done!",
              "createdAt": "2021-08-03T12:45:01Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If Add gets called a lot on the same instance on the hot path the list constructor may end up creating a lot of arrays right? Switching to ImmutableList would alleviate that.\r\n\r\nProfiling OrchardCore would probably show if this is an issue or not.",
              "createdAt": "2021-07-29T01:15:20Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "More fundamentally, can you explain why you need a new list?",
              "createdAt": "2021-07-30T22:13:41Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The list is needed for cases where the same item (or, more precisely, an item with the same path-normalized value) is included multiple times.\r\n\r\n```xml\r\n  <ItemGroup>\r\n    <A Include=\"file\" />    \r\n    <A Include=\"file\" />    \r\n  </ItemGroup>\r\n```\r\n\r\nWhen later we evaluate a remove that matches `file`, both items should be removed from the running list. To support immutability, we keep track of the collection version and clone the list when it would mutate an older version.\r\n\r\nThis shouldn't be common, only ~80 lists are created during a clean build of OC.\r\n\r\nI went with a plain List for perf because this cloning is super rare (duplicate items + memoization) but you're right that `ImmutableList` is exactly what I need and simplifies the code a bit.",
              "createdAt": "2021-08-03T10:42:54Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Switched to `ImmutableList`, thank you!",
              "createdAt": "2021-08-03T11:19:43Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't it be better design-wise to ask the ItemSpec to compute its intersection with a given OrderedItemDataCollection via a new `IntersectWith(OrderedItemDataCollection)` instead of passing the ItemSpec to RemoveMatchingItems?\r\n\r\nThat way you:\r\n- prevent leaking the implementation detail that some itemspec fragments do not support enumeration \r\n- can neatly cache normalized values of the itemspec values without leaking that implementation detail. This would be useful if itemspec values get repeatedly normalized (for example by repeatedly calling any of the IsMatch, MatchCount, or IntersectWith methods on the same ItemSpec instance)\r\n- can reuse the IntersectWith operation to remove the same O(n^2) issue with the Update operation.\r\n\r\nTo support this, OrderedItemDataCollection (or the Builder) could provide a string indexer which would be the normalized key. Ideally you could even hide OrderedItemDataCollection behind some collection interface but maybe that's too much for now.",
              "createdAt": "2021-07-29T01:44:26Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "This is a great suggestion. I think I had the code structured differently but hit a technical issue which had me settle for this mess. I'll wait for CI to start working again to see where I stand with unit tests and will then tackle this. Thank you!",
              "createdAt": "2021-08-03T12:47:48Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have refactored it a bit as suggested and it is indeed nicer. For Update operation, it is possible that we can now revert the previous optimization (#5853) and achieve the same using the new datastructure but I'd like to try this separately later.",
              "createdAt": "2021-08-06T20:40:39Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ImmutableDictionary has bulk removal support In order to minimize tree mutation (node alloc for rebalance):\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable.immutabledictionary-2.builder.removerange?view=net-5.0",
              "createdAt": "2021-07-29T02:36:40Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+\n+                            if (keysToRemove != null)\n+                            {\n+                                foreach (string key in keysToRemove)\n+                                {\n+                                    dictionaryBuilder.Remove(key);",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Thank you, I've fixed the code to use `RemoveRange`.",
              "createdAt": "2021-08-03T11:56:24Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+\n+                            if (keysToRemove != null)\n+                            {\n+                                foreach (string key in keysToRemove)\n+                                {\n+                                    dictionaryBuilder.Remove(key);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "When would you have a version mismatch? Isn't this within a build?",
              "createdAt": "2021-07-30T22:13:22Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I removed the version variables and implemented immutability using `ImmutableList` as suggested in another comment.",
              "createdAt": "2021-08-03T11:55:31Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: move this up two lines",
              "createdAt": "2021-07-31T05:23:26Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+\n+                            if (keysToRemove != null)\n+                            {\n+                                foreach (string key in keysToRemove)\n+                                {\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Finish by removing items from the list.\n+                    if (items != null)\n+                    {\n+                        _listBuilder.RemoveAll(item => items.Contains(item.Item));\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Creates an immutable view of this collection.\n+                /// </summary>\n+                public OrderedItemDataCollection ToImmutable()\n+                {\n+                    return new OrderedItemDataCollection(_version, _listBuilder.ToImmutable(), _dictionaryBuilder?.ToImmutable());\n+                }\n+\n+                private IDictionary<string, DictionaryValue> GetOrCreateDictionaryBuilder()\n+                {\n+                    if (_dictionaryBuilder == null)\n+                    {\n+                        _dictionaryBuilder = ImmutableDictionary.CreateBuilder<string, DictionaryValue>(StringComparer.OrdinalIgnoreCase);\n+                        foreach (ItemData item in _listBuilder)\n+                        {\n+                            AddToDictionary(item.Item);\n+                        }\n+                    }\n+                    return _dictionaryBuilder;\n+                }\n+\n+                private void AddToDictionary(I item)\n+                {\n+                    string key = FileUtilities.NormalizePathForComparisonNoThrow(item.EvaluatedInclude, item.ProjectDirectory);\n+\n+                    if (!_dictionaryBuilder.TryGetValue(key, out var dictionaryValue))\n+                    {\n+                        dictionaryValue = new DictionaryValue(_version, item);\n+                    }\n+                    dictionaryValue.Add(_version, item);\n+                    _dictionaryBuilder[key] = dictionaryValue;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Needs to be done in both cases - when adding a new `DictionaryValue` and when updating an existing one - because it's a struct.",
              "createdAt": "2021-08-03T11:36:21Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -219,17 +219,299 @@ public void MarkAsReferenced()\n                 _isReferenced = true;\n             }\n \n-            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, ImmutableList<ItemData> items)\n+            private void AddItemsToCache(ImmutableHashSet<string> globsToIgnore, OrderedItemDataCollection items)\n             {\n                 if (_cache == null)\n                 {\n-                    _cache = new Dictionary<ISet<string>, ImmutableList<ItemData>>();\n+                    _cache = new Dictionary<ISet<string>, OrderedItemDataCollection>();\n                 }\n \n                 _cache[globsToIgnore] = items;\n             }\n         }\n \n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more versioned items.\n+            /// </summary>\n+            internal struct DictionaryValue : IEnumerable<I>\n+            {\n+                /// <summary>\n+                /// The version of the containing collection at the time this value was last changed.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(int version, I item)\n+                {\n+                    _version = version;\n+                    _value = item;\n+                }\n+\n+                public void Add(int version, I item)\n+                {\n+                    if (_value is List<I> list)\n+                    {\n+                        if (version != _version)\n+                        {\n+                            list = new List<I>(list);\n+                        }\n+                        list.Add(item);\n+                    }\n+                    else\n+                    {\n+                        list = new List<I>\n+                        {\n+                            (I)_value,\n+                            item\n+                        };\n+                    }\n+                    _version = version;\n+                    _value = list;\n+                }\n+\n+                public IEnumerator<I> GetEnumerator()\n+                {\n+                    if (_value is I item)\n+                    {\n+                        yield return item;\n+                    }\n+                    else if (_value is IEnumerable<I> enumerable)\n+                    {\n+                        foreach (I enumerableItem in enumerable)\n+                        {\n+                            yield return enumerableItem;\n+                        }\n+                    }\n+                }\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The current version of the collection.\n+                /// </summary>\n+                private int _version;\n+\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(int version, ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _version = version;\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                public IEnumerator<ItemData> GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            List<string> keysToRemove = null;\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+\n+                            if (keysToRemove != null)\n+                            {\n+                                foreach (string key in keysToRemove)\n+                                {\n+                                    dictionaryBuilder.Remove(key);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Finish by removing items from the list.\n+                    if (items != null)\n+                    {\n+                        _listBuilder.RemoveAll(item => items.Contains(item.Item));\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Creates an immutable view of this collection.\n+                /// </summary>\n+                public OrderedItemDataCollection ToImmutable()\n+                {\n+                    return new OrderedItemDataCollection(_version, _listBuilder.ToImmutable(), _dictionaryBuilder?.ToImmutable());\n+                }\n+\n+                private IDictionary<string, DictionaryValue> GetOrCreateDictionaryBuilder()\n+                {\n+                    if (_dictionaryBuilder == null)\n+                    {\n+                        _dictionaryBuilder = ImmutableDictionary.CreateBuilder<string, DictionaryValue>(StringComparer.OrdinalIgnoreCase);\n+                        foreach (ItemData item in _listBuilder)\n+                        {\n+                            AddToDictionary(item.Item);\n+                        }\n+                    }\n+                    return _dictionaryBuilder;\n+                }\n+\n+                private void AddToDictionary(I item)\n+                {\n+                    string key = FileUtilities.NormalizePathForComparisonNoThrow(item.EvaluatedInclude, item.ProjectDirectory);\n+\n+                    if (!_dictionaryBuilder.TryGetValue(key, out var dictionaryValue))\n+                    {\n+                        dictionaryValue = new DictionaryValue(_version, item);\n+                    }\n+                    dictionaryValue.Add(_version, item);\n+                    _dictionaryBuilder[key] = dictionaryValue;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm kinda wondering if it's worth optimizing this to use EndsWith instead of StartsWith, as I imagine one of the most common differences is amd64 vs. no amd64. Probably not worth it.",
              "createdAt": "2021-07-31T06:31:22Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -41,31 +48,43 @@ public static FileSpecMatcherTester Parse(string currentDirectory, string fileSp\n             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n+        /// <summary>\n+        /// Returns true if the given file matches this file spec.\n+        /// </summary>\n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n+            string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n+            return IsMatchNormalized(normalizedFileToMatch);\n+        }\n+\n+        /// <summary>\n+        /// Same as <see cref=\"IsMatch\" /> but the argument is expected to be a normalized path.\n+        /// </summary>\n+        public bool IsMatchNormalized(string normalizedFileToMatch)\n+        {\n+            Debug.Assert(!string.IsNullOrEmpty(normalizedFileToMatch));\n+\n             // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n-                string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n             if (_filenamePattern != null)\n             {\n                 // Check file name first as it's more likely to not match.\n-                string filename = Path.GetFileName(fileToMatch);\n+                string filename = Path.GetFileName(normalizedFileToMatch);\n                 if (!FileMatcher.IsMatch(filename, _filenamePattern))\n                 {\n                     return false;\n                 }\n \n-                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return normalizedFileToMatch.StartsWith(_currentDirectory, StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't believe that `EndsWith` walks the string differently than `StartsWith`. They both use the same underlying comparison routines, just the (sub)strings being compared are different. We need the file path to start with the directory so `StartsWith` should be the right choice. My gut is that a manual implementation that walks the string backwards would be slower on average than the highly optimized BCL code and it is not worth it.\r\n\r\nhttps://github.com/dotnet/runtime/blob/b3ab2eb4db830f6c520340f80651b806fd9dfce8/src/libraries/System.Private.CoreLib/src/System/Globalization/Ordinal.cs#L14",
              "createdAt": "2021-08-03T11:54:10Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -41,31 +48,43 @@ public static FileSpecMatcherTester Parse(string currentDirectory, string fileSp\n             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n+        /// <summary>\n+        /// Returns true if the given file matches this file spec.\n+        /// </summary>\n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n+            string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n+            return IsMatchNormalized(normalizedFileToMatch);\n+        }\n+\n+        /// <summary>\n+        /// Same as <see cref=\"IsMatch\" /> but the argument is expected to be a normalized path.\n+        /// </summary>\n+        public bool IsMatchNormalized(string normalizedFileToMatch)\n+        {\n+            Debug.Assert(!string.IsNullOrEmpty(normalizedFileToMatch));\n+\n             // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n-                string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n             if (_filenamePattern != null)\n             {\n                 // Check file name first as it's more likely to not match.\n-                string filename = Path.GetFileName(fileToMatch);\n+                string filename = Path.GetFileName(normalizedFileToMatch);\n                 if (!FileMatcher.IsMatch(filename, _filenamePattern))\n                 {\n                     return false;\n                 }\n \n-                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return normalizedFileToMatch.StartsWith(_currentDirectory, StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good point \ud83d\udc4d ",
              "createdAt": "2021-08-06T01:31:59Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -41,31 +48,43 @@ public static FileSpecMatcherTester Parse(string currentDirectory, string fileSp\n             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n+        /// <summary>\n+        /// Returns true if the given file matches this file spec.\n+        /// </summary>\n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n+            string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n+            return IsMatchNormalized(normalizedFileToMatch);\n+        }\n+\n+        /// <summary>\n+        /// Same as <see cref=\"IsMatch\" /> but the argument is expected to be a normalized path.\n+        /// </summary>\n+        public bool IsMatchNormalized(string normalizedFileToMatch)\n+        {\n+            Debug.Assert(!string.IsNullOrEmpty(normalizedFileToMatch));\n+\n             // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n-                string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n             if (_filenamePattern != null)\n             {\n                 // Check file name first as it's more likely to not match.\n-                string filename = Path.GetFileName(fileToMatch);\n+                string filename = Path.GetFileName(normalizedFileToMatch);\n                 if (!FileMatcher.IsMatch(filename, _filenamePattern))\n                 {\n                     return false;\n                 }\n \n-                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return normalizedFileToMatch.StartsWith(_currentDirectory, StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This might deserve a comment like \"if it is not a list, it is a single item.\" My first thought upon seeing this was \"if it snot a list, always return false\" (which isn't quite right)",
              "createdAt": "2021-08-06T01:35:00Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs",
              "diffHunk": "@@ -0,0 +1,293 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    internal partial class LazyItemEvaluator<P, I, M, D>\n+    {\n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more items.\n+            /// </summary>\n+            internal struct DictionaryValue\n+            {\n+                /// <summary>\n+                /// A non-allocating enumerator for the multi-value.\n+                /// </summary>\n+                public struct Enumerator : IEnumerator<I>\n+                {\n+                    private object _value;\n+                    private int _index;\n+\n+                    public Enumerator(object value)\n+                    {\n+                        _value = value;\n+                        _index = -1;\n+                    }\n+\n+                    public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+                    object System.Collections.IEnumerator.Current => Current;\n+\n+                    public void Dispose()\n+                    { }\n+\n+                    public bool MoveNext()\n+                    {\n+                        int count = (_value is IList<I> list) ? list.Count : 1;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have added the comment as suggested. Thank you!",
              "createdAt": "2021-08-06T20:34:01Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs",
              "diffHunk": "@@ -0,0 +1,293 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    internal partial class LazyItemEvaluator<P, I, M, D>\n+    {\n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more items.\n+            /// </summary>\n+            internal struct DictionaryValue\n+            {\n+                /// <summary>\n+                /// A non-allocating enumerator for the multi-value.\n+                /// </summary>\n+                public struct Enumerator : IEnumerator<I>\n+                {\n+                    private object _value;\n+                    private int _index;\n+\n+                    public Enumerator(object value)\n+                    {\n+                        _value = value;\n+                        _index = -1;\n+                    }\n+\n+                    public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+                    object System.Collections.IEnumerator.Current => Current;\n+\n+                    public void Dispose()\n+                    { }\n+\n+                    public bool MoveNext()\n+                    {\n+                        int count = (_value is IList<I> list) ? list.Count : 1;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just for my own benefit\u2014Except would look pretty here, but it would both remove all the items in itemsToRemove and remove duplicates, possibly reordering the list, so it is not ideal.",
              "createdAt": "2021-08-06T01:38:57Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs",
              "diffHunk": "@@ -0,0 +1,293 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    internal partial class LazyItemEvaluator<P, I, M, D>\n+    {\n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more items.\n+            /// </summary>\n+            internal struct DictionaryValue\n+            {\n+                /// <summary>\n+                /// A non-allocating enumerator for the multi-value.\n+                /// </summary>\n+                public struct Enumerator : IEnumerator<I>\n+                {\n+                    private object _value;\n+                    private int _index;\n+\n+                    public Enumerator(object value)\n+                    {\n+                        _value = value;\n+                        _index = -1;\n+                    }\n+\n+                    public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+                    object System.Collections.IEnumerator.Current => Current;\n+\n+                    public void Dispose()\n+                    { }\n+\n+                    public bool MoveNext()\n+                    {\n+                        int count = (_value is IList<I> list) ? list.Count : 1;\n+                        if (_index + 1 < count)\n+                        {\n+                            _index++;\n+                            return true;\n+                        }\n+                        return false;\n+                    }\n+\n+                    public void Reset()\n+                    {\n+                        _index = -1;\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(I item)\n+                {\n+                    _value = item;\n+                }\n+\n+                public void Add(I item)\n+                {\n+                    if (_value is not ImmutableList<I> list)\n+                    {\n+                        list = ImmutableList<I>.Empty;\n+                        list = list.Add((I)_value);\n+                    }\n+                    _value = list.Add(item);\n+                }\n+\n+                public Enumerator GetEnumerator()\n+                {\n+                    return new Enumerator(_value);\n+                }\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                ImmutableList<ItemData>.Enumerator GetEnumerator() => _listBuilder.GetEnumerator();\n+                IEnumerator<ItemData> IEnumerable<ItemData>.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    if (keysToRemove is not null)\r\n                    {\r\n                        dictionaryBuilder.RemoveRange(keysToRemove);\r\n                    }\r\n                    if (items is not null)\r\n```\r\n\r\nMaybe a space between them? I don't really care.",
              "createdAt": "2021-08-06T01:56:35Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs",
              "diffHunk": "@@ -0,0 +1,293 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    internal partial class LazyItemEvaluator<P, I, M, D>\n+    {\n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more items.\n+            /// </summary>\n+            internal struct DictionaryValue\n+            {\n+                /// <summary>\n+                /// A non-allocating enumerator for the multi-value.\n+                /// </summary>\n+                public struct Enumerator : IEnumerator<I>\n+                {\n+                    private object _value;\n+                    private int _index;\n+\n+                    public Enumerator(object value)\n+                    {\n+                        _value = value;\n+                        _index = -1;\n+                    }\n+\n+                    public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+                    object System.Collections.IEnumerator.Current => Current;\n+\n+                    public void Dispose()\n+                    { }\n+\n+                    public bool MoveNext()\n+                    {\n+                        int count = (_value is IList<I> list) ? list.Count : 1;\n+                        if (_index + 1 < count)\n+                        {\n+                            _index++;\n+                            return true;\n+                        }\n+                        return false;\n+                    }\n+\n+                    public void Reset()\n+                    {\n+                        _index = -1;\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(I item)\n+                {\n+                    _value = item;\n+                }\n+\n+                public void Add(I item)\n+                {\n+                    if (_value is not ImmutableList<I> list)\n+                    {\n+                        list = ImmutableList<I>.Empty;\n+                        list = list.Add((I)_value);\n+                    }\n+                    _value = list.Add(item);\n+                }\n+\n+                public Enumerator GetEnumerator()\n+                {\n+                    return new Enumerator(_value);\n+                }\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                ImmutableList<ItemData>.Enumerator GetEnumerator() => _listBuilder.GetEnumerator();\n+                IEnumerator<ItemData> IEnumerable<ItemData>.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    List<string> keysToRemove = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Finish by removing items from the list.\n+                    if (keysToRemove != null)\n+                    {\n+                        dictionaryBuilder.RemoveRange(keysToRemove);\n+                    }\n+                    if (items != null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Done, thank you.",
              "createdAt": "2021-08-06T20:33:31Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs",
              "diffHunk": "@@ -0,0 +1,293 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    internal partial class LazyItemEvaluator<P, I, M, D>\n+    {\n+        /// <summary>\n+        /// A collection of ItemData that maintains insertion order and internally optimizes some access patterns, e.g. bulk removal\n+        /// based on normalized item values.\n+        /// </summary>\n+        internal sealed class OrderedItemDataCollection\n+        {\n+            #region Inner types\n+\n+            /// <summary>\n+            /// An efficient multi-value wrapper holding one or more items.\n+            /// </summary>\n+            internal struct DictionaryValue\n+            {\n+                /// <summary>\n+                /// A non-allocating enumerator for the multi-value.\n+                /// </summary>\n+                public struct Enumerator : IEnumerator<I>\n+                {\n+                    private object _value;\n+                    private int _index;\n+\n+                    public Enumerator(object value)\n+                    {\n+                        _value = value;\n+                        _index = -1;\n+                    }\n+\n+                    public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+                    object System.Collections.IEnumerator.Current => Current;\n+\n+                    public void Dispose()\n+                    { }\n+\n+                    public bool MoveNext()\n+                    {\n+                        int count = (_value is IList<I> list) ? list.Count : 1;\n+                        if (_index + 1 < count)\n+                        {\n+                            _index++;\n+                            return true;\n+                        }\n+                        return false;\n+                    }\n+\n+                    public void Reset()\n+                    {\n+                        _index = -1;\n+                    }\n+                }\n+\n+                /// <summary>\n+                /// Holds one value or a list of values.\n+                /// </summary>\n+                private object _value;\n+\n+                public DictionaryValue(I item)\n+                {\n+                    _value = item;\n+                }\n+\n+                public void Add(I item)\n+                {\n+                    if (_value is not ImmutableList<I> list)\n+                    {\n+                        list = ImmutableList<I>.Empty;\n+                        list = list.Add((I)_value);\n+                    }\n+                    _value = list.Add(item);\n+                }\n+\n+                public Enumerator GetEnumerator()\n+                {\n+                    return new Enumerator(_value);\n+                }\n+            }\n+\n+            /// <summary>\n+            /// A mutable and enumerable version of <see cref=\"OrderedItemDataCollection\"/>.\n+            /// </summary>\n+            internal sealed class Builder : IEnumerable<ItemData>\n+            {\n+                /// <summary>\n+                /// The list of items in the collection. Defines the enumeration order.\n+                /// </summary>\n+                private ImmutableList<ItemData>.Builder _listBuilder;\n+\n+                /// <summary>\n+                /// A dictionary of items keyed by their normalized value.\n+                /// </summary>\n+                private ImmutableDictionary<string, DictionaryValue>.Builder _dictionaryBuilder;\n+\n+                internal Builder(ImmutableList<ItemData>.Builder listBuilder, ImmutableDictionary<string, DictionaryValue>.Builder dictionaryBuilder)\n+                {\n+                    _listBuilder = listBuilder;\n+                    _dictionaryBuilder = dictionaryBuilder;\n+                }\n+\n+                #region IEnumerable implementation\n+\n+                ImmutableList<ItemData>.Enumerator GetEnumerator() => _listBuilder.GetEnumerator();\n+                IEnumerator<ItemData> IEnumerable<ItemData>.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();\n+\n+                #endregion\n+\n+                public int Count => _listBuilder.Count;\n+\n+                public ItemData this[int index]\n+                {\n+                    get { return _listBuilder[index]; }\n+                    set\n+                    {\n+                        _listBuilder[index] = value;\n+                        // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                        _dictionaryBuilder = null;\n+                    }\n+                }\n+\n+                public void Add(ItemData data)\n+                {\n+                    _listBuilder.Add(data);\n+                    if (_dictionaryBuilder != null)\n+                    {\n+                        AddToDictionary(data.Item);\n+                    }\n+                }\n+\n+                public void Clear()\n+                {\n+                    _listBuilder.Clear();\n+                    _dictionaryBuilder?.Clear();\n+                }\n+\n+                public void RemoveAll(ICollection<I> itemsToRemove)\n+                {\n+                    _listBuilder.RemoveAll(item => itemsToRemove.Contains(item.Item));\n+                    // This is a rare operation, don't bother updating the dictionary for now. It will be recreated as needed.\n+                    _dictionaryBuilder = null;\n+                }\n+\n+                /// <summary>\n+                /// Removes items from the collection that match the given ItemSpec.\n+                /// </summary>\n+                /// <remarks>\n+                /// If <see cref=\"_dictionaryBuilder\"/> does not exist yet, it is created in this method to avoid the cost of comparing each item\n+                /// being removed with each item already in the collection. The dictionary is kept in sync with the <see cref=\"_listBuilder\"/>\n+                /// as long as practical. If an operation would result in too much of such work, the dictionary is simply dropped and recreated\n+                /// later if/when needed.\n+                /// </remarks>\n+                public void RemoveMatchingItems(ItemSpec<P, I> itemSpec)\n+                {\n+                    HashSet<I> items = null;\n+                    List<string> keysToRemove = null;\n+                    var dictionaryBuilder = GetOrCreateDictionaryBuilder();\n+\n+                    foreach (var fragment in itemSpec.Fragments)\n+                    {\n+                        IEnumerable<string> referencedItems = fragment.GetReferencedItems();\n+                        if (referencedItems != null)\n+                        {\n+                            // The fragment can enumerate its referenced items, we can do dictionary lookups.\n+                            foreach (var spec in referencedItems)\n+                            {\n+                                string key = FileUtilities.NormalizePathForComparisonNoThrow(spec, fragment.ProjectDirectory);\n+                                if (dictionaryBuilder.TryGetValue(key, out var multiValue))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in multiValue)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(key);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            // The fragment cannot enumerate its referenced items. Iterate over the dictionary and test each item.\n+                            foreach (var kvp in dictionaryBuilder)\n+                            {\n+                                if (fragment.IsMatchNormalized(kvp.Key))\n+                                {\n+                                    items ??= new HashSet<I>();\n+                                    foreach (I item in kvp.Value)\n+                                    {\n+                                        items.Add(item);\n+                                    }\n+                                    keysToRemove ??= new List<string>();\n+                                    keysToRemove.Add(kvp.Key);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Finish by removing items from the list.\n+                    if (keysToRemove != null)\n+                    {\n+                        dictionaryBuilder.RemoveRange(keysToRemove);\n+                    }\n+                    if (items != null)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    if (items is not null)\r\n```",
              "createdAt": "2021-08-06T01:59:51Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs",
              "diffHunk": "@@ -48,37 +53,34 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I\n                     return;\n                 }\n \n-                base.ApplyImpl(listBuilder, globsToIgnore);\n-            }\n-\n-            // todo Perf: do not match against the globs: https://github.com/Microsoft/msbuild/issues/2329\n-            protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)\n-            {\n-                var items = ImmutableHashSet.CreateBuilder<I>();\n-                foreach (ItemData item in listBuilder)\n+                // todo Perf: do not match against the globs: https://github.com/Microsoft/msbuild/issues/2329\n+                if (_matchOnMetadata.IsEmpty)\n                 {\n-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))\n-                        items.Add(item.Item);\n+                    listBuilder.RemoveMatchingItems(_itemSpec);\n+                }\n+                else\n+                {\n+                    HashSet<I> items = null;\n+                    foreach (ItemData item in listBuilder)\n+                    {\n+                        if (MatchesItemOnMetadata(item.Item))\n+                        {\n+                            items ??= new HashSet<I>();\n+                            items.Add(item.Item);\n+                        }\n+                    }\n+                    if (items != null)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we have some unit tests for this class? My first instinct is that this looks like it would drop a single item when adding the next one.",
              "createdAt": "2021-08-18T15:12:36Z",
              "path": "src/Build/Evaluation/ItemDataCollectionValue.cs",
              "diffHunk": "@@ -0,0 +1,106 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    /// <summary>\n+    /// An efficient multi-value wrapper holding one or more items.\n+    /// </summary>\n+    internal struct ItemDataCollectionValue<I>\n+    {\n+        /// <summary>\n+        /// A non-allocating enumerator for the multi-value.\n+        /// </summary>\n+        public struct Enumerator : IEnumerator<I>\n+        {\n+            private object _value;\n+            private int _index;\n+\n+            public Enumerator(object value)\n+            {\n+                _value = value;\n+                _index = -1;\n+            }\n+\n+            public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+            object System.Collections.IEnumerator.Current => Current;\n+\n+            public void Dispose()\n+            { }\n+\n+            public bool MoveNext()\n+            {\n+                // If value is not a list, it is a single item.\n+                int count = (_value is IList<I> list) ? list.Count : 1;\n+                if (_index + 1 < count)\n+                {\n+                    _index++;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void Reset()\n+            {\n+                _index = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Holds one value or a list of values.\n+        /// </summary>\n+        private object _value;\n+\n+        public bool IsEmpty => _value == null || (_value is List<I> list && list.Count == 0);\n+\n+        public ItemDataCollectionValue(I item)\n+        {\n+            _value = item;\n+        }\n+\n+        public void Add(I item)\n+        {\n+            if (_value is not List<I> list)\n+            {\n+                list = new List<I>();\n+                _value = list;\n+            }\n+            list.Add(item);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good catch! We definitely don't have this covered with tests, will fix.",
              "createdAt": "2021-08-18T15:44:01Z",
              "path": "src/Build/Evaluation/ItemDataCollectionValue.cs",
              "diffHunk": "@@ -0,0 +1,106 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    /// <summary>\n+    /// An efficient multi-value wrapper holding one or more items.\n+    /// </summary>\n+    internal struct ItemDataCollectionValue<I>\n+    {\n+        /// <summary>\n+        /// A non-allocating enumerator for the multi-value.\n+        /// </summary>\n+        public struct Enumerator : IEnumerator<I>\n+        {\n+            private object _value;\n+            private int _index;\n+\n+            public Enumerator(object value)\n+            {\n+                _value = value;\n+                _index = -1;\n+            }\n+\n+            public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+            object System.Collections.IEnumerator.Current => Current;\n+\n+            public void Dispose()\n+            { }\n+\n+            public bool MoveNext()\n+            {\n+                // If value is not a list, it is a single item.\n+                int count = (_value is IList<I> list) ? list.Count : 1;\n+                if (_index + 1 < count)\n+                {\n+                    _index++;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void Reset()\n+            {\n+                _index = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Holds one value or a list of values.\n+        /// </summary>\n+        private object _value;\n+\n+        public bool IsEmpty => _value == null || (_value is List<I> list && list.Count == 0);\n+\n+        public ItemDataCollectionValue(I item)\n+        {\n+            _value = item;\n+        }\n+\n+        public void Add(I item)\n+        {\n+            if (_value is not List<I> list)\n+            {\n+                list = new List<I>();\n+                _value = list;\n+            }\n+            list.Add(item);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have fixed the code, added a unit test, and made `ProjectItem_Tests` run with as well as without the directory-based optimization.",
              "createdAt": "2021-08-23T09:43:54Z",
              "path": "src/Build/Evaluation/ItemDataCollectionValue.cs",
              "diffHunk": "@@ -0,0 +1,106 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Evaluation\n+{\n+    /// <summary>\n+    /// An efficient multi-value wrapper holding one or more items.\n+    /// </summary>\n+    internal struct ItemDataCollectionValue<I>\n+    {\n+        /// <summary>\n+        /// A non-allocating enumerator for the multi-value.\n+        /// </summary>\n+        public struct Enumerator : IEnumerator<I>\n+        {\n+            private object _value;\n+            private int _index;\n+\n+            public Enumerator(object value)\n+            {\n+                _value = value;\n+                _index = -1;\n+            }\n+\n+            public I Current => (_value is IList<I> list) ? list[_index] : (I)_value;\n+            object System.Collections.IEnumerator.Current => Current;\n+\n+            public void Dispose()\n+            { }\n+\n+            public bool MoveNext()\n+            {\n+                // If value is not a list, it is a single item.\n+                int count = (_value is IList<I> list) ? list.Count : 1;\n+                if (_index + 1 < count)\n+                {\n+                    _index++;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void Reset()\n+            {\n+                _index = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Holds one value or a list of values.\n+        /// </summary>\n+        private object _value;\n+\n+        public bool IsEmpty => _value == null || (_value is List<I> list && list.Count == 0);\n+\n+        public ItemDataCollectionValue(I item)\n+        {\n+            _value = item;\n+        }\n+\n+        public void Add(I item)\n+        {\n+            if (_value is not List<I> list)\n+            {\n+                list = new List<I>();\n+                _value = list;\n+            }\n+            list.Add(item);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you give a bit more color on the types of scenarios where the difference is observable?",
              "createdAt": "2021-08-18T15:29:01Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -41,31 +48,52 @@ public static FileSpecMatcherTester Parse(string currentDirectory, string fileSp\n             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n+        /// <summary>\n+        /// Returns true if the given file matches this file spec.\n+        /// </summary>\n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n+            // Historically we've used slightly different normalization logic depending on the type of matching\n+            // performed in IsMatchNormalized. We have to keep doing it for compat.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Trying to unify the code to use the same path normalization function for pattern matching and for single path matching resulted in unit test failures for me. I can revisit if you want but generally I treat this as something that should not be changed just for code cleanliness, even if it affects only corner cases.",
              "createdAt": "2021-08-23T09:49:26Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -41,31 +48,52 @@ public static FileSpecMatcherTester Parse(string currentDirectory, string fileSp\n             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n+        /// <summary>\n+        /// Returns true if the given file matches this file spec.\n+        /// </summary>\n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n+            // Historically we've used slightly different normalization logic depending on the type of matching\n+            // performed in IsMatchNormalized. We have to keep doing it for compat.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I agree.",
              "createdAt": "2021-08-23T11:40:09Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -41,31 +48,52 @@ public static FileSpecMatcherTester Parse(string currentDirectory, string fileSp\n             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n+        /// <summary>\n+        /// Returns true if the given file matches this file spec.\n+        /// </summary>\n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n+            // Historically we've used slightly different normalization logic depending on the type of matching\n+            // performed in IsMatchNormalized. We have to keep doing it for compat.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure I understand the implications of this. Can you describe what it helps?",
              "createdAt": "2021-08-18T15:38:33Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -505,7 +507,7 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro\n                 options.SubToolsetVersion,\n                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,\n                 options.LoadSettings,\n-                options.EvaluationContext);\n+                options.EvaluationContext ?? _sharedEvaluationContext);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This was an experiment which was not supposed to become part of this PR. I'll remove it.",
              "createdAt": "2021-08-18T15:45:16Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -505,7 +507,7 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro\n                 options.SubToolsetVersion,\n                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,\n                 options.LoadSettings,\n-                options.EvaluationContext);\n+                options.EvaluationContext ?? _sharedEvaluationContext);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Removed.",
              "createdAt": "2021-08-23T09:44:11Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -505,7 +507,7 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro\n                 options.SubToolsetVersion,\n                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,\n                 options.LoadSettings,\n-                options.EvaluationContext);\n+                options.EvaluationContext ?? _sharedEvaluationContext);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}