{
  "number": 9985,
  "title": "Handle solution traversal targets in graph builds",
  "body": "Fixes #9952\r\n\r\nThis change adds understanding of \"solution traversal\" targets to graph builds. The special targets are like \"ProjectName\" or \"ProjectName:TargetName\" and can be used to build specific projects in a sln or specific targets on specific projects in a sln.\r\n\r\nAlso added some missing UTs for `SolutionProjectGenerator` to help my understanding for how these kinds of targets work.",
  "state": "MERGED",
  "createdAt": "2024-04-09T22:53:59Z",
  "updatedAt": "2024-04-25T18:52:27Z",
  "closedAt": "2024-04-19T08:06:21Z",
  "mergedAt": "2024-04-19T08:06:21Z",
  "additions": 266,
  "deletions": 25,
  "changedFiles": 5,
  "headRefName": "fix-graph-sln-traversal-targets",
  "isDraft": false,
  "author": {
    "login": "dfederm"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "aa7e3ae8b8c395e5a9892715f053543b7ddbef63",
          "message": "Handle solution traversal targets in graph builds",
          "committedDate": "2024-04-09T22:54:26Z",
          "author": {
            "name": "dfederm",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d52ec6a6534a3332599c2bee0ae8d4a0d4748254",
          "message": "PR feedback",
          "committedDate": "2024-04-18T20:27:43Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `MSBuildNameIgnoreCaseComparer.Default` can be used here (but this is not a tight loop - so no big gain from it)",
              "createdAt": "2024-04-17T11:16:59Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -604,14 +608,92 @@ private string DebuggerDisplayString()\n             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();\n             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();\n \n-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)\n+            {\n+                // If no targets were specified, use every project's default targets.\n+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                {\n+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                    encounteredEdges.Add(entryEdge);\n+                    edgesToVisit.Enqueue(entryEdge);\n+                }\n+            }\n+            else\n             {\n-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0\n-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)\n-                    : ImmutableList.CreateRange(entryProjectTargets);\n-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n-                encounteredEdges.Add(entryEdge);\n-                edgesToVisit.Enqueue(entryEdge);\n+                foreach (string targetName in entryProjectTargets)\n+                {\n+                    // Special-case the \"Build\" target. The solution's metaproj invokes each project's default targets\n+                    if (targetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+\n+                        continue;\n+                    }\n+\n+                    bool isSolutionTraversalTarget = false;\n+                    if (Solution != null)\n+                    {\n+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)\n+                        {\n+                            if (!SolutionFile.IsBuildableProject(project))\n+                            {\n+                                continue;\n+                            }\n+\n+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());\n+\n+                            // Solutions generate target names to build individual projects. Map these to \"real\" targets on the relevant projects.\n+                            // This logic should match SolutionProjectGenerator's behavior\n+                            if (targetName.Equals(baseProjectName, StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is explicit `Build` target not supported?",
              "createdAt": "2024-04-17T11:19:21Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -2808,6 +2808,119 @@ public void MultitargettingTargetsWithBuildProjectReferencesFalse()\n             }\n         }\n \n+        [Theory]\n+        // Built-in targets\n+        [InlineData(new string[0], new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Build\" }, new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Rebuild\" }, new[] { \"Rebuild\" }, new[] { \"Rebuild\" })]\n+        [InlineData(new[] { \"Clean\" }, new[] { \"Clean\" }, new[] { \"Clean\" })]\n+        [InlineData(new[] { \"Publish\" }, new[] { \"Publish\" }, new[] { \"Publish\" })]\n+        // Traversal targets\n+        [InlineData(new[] { \"Project1\" }, new[] { \"Project1Default\" }, new string[0])]\n+        [InlineData(new[] { \"Project2\" }, new string[0], new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Project1\", \"Project2\" }, new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Project1:Rebuild\" }, new[] { \"Rebuild\" }, new string[0])]\n+        [InlineData(new[] { \"Project2:Rebuild\" }, new string[0], new[] { \"Rebuild\" })]\n+        [InlineData(new[] { \"Project1:Rebuild\", \"Project2:Clean\" }, new[] { \"Rebuild\" }, new[] { \"Clean\" })]\n+        [InlineData(new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" })]\n+        [InlineData(new[] { \"Project1:CustomTarget\" }, new[] { \"CustomTarget\" }, new string[0])]\n+        [InlineData(new[] { \"Project2:CustomTarget\" }, new string[0], new[] { \"CustomTarget\" })]\n+        [InlineData(new[] { \"Project1:CustomTarget\", \"Project2:CustomTarget\" }, new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" })]\n+        public void GetTargetListsWithSolution(string[] entryTargets, string[] expectedProject1Targets, string[] expectedProject2Targets)\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                const string ExtraContent = \"\"\"\n+                    <Target Name=\"CustomTarget\" />\n+                    \"\"\";\n+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1, defaultTargets: \"Project1Default\", extraContent: ExtraContent);\n+                TransientTestFile project2File = CreateProjectFile(env: env, projectNumber: 2, defaultTargets: \"Project2Default\", extraContent: ExtraContent);\n+\n+                string solutionFileContents = $$\"\"\"\n+                    Microsoft Visual Studio Solution File, Format Version 12.00\n+                    # Visual Studio Version 17\n+                    VisualStudioVersion = 17.0.31903.59\n+                    MinimumVisualStudioVersion = 17.0.31903.59\n+                    Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Project1\", \"{{project1File.Path}}\", \"{8761499A-7280-43C4-A32F-7F41C47CA6DF}\"\n+                    EndProject\n+                    Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Project2\", \"{{project2File.Path}}\", \"{2022C11A-1405-4983-BEC2-3A8B0233108F}\"\n+                    EndProject\n+                    Global\n+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution\n+                            Debug|x64 = Debug|x64\n+                            Release|x64 = Release|x64\n+                        EndGlobalSection\n+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64\n+                        EndGlobalSection\n+                        GlobalSection(SolutionProperties) = preSolution\n+                            HideSolutionNode = FALSE\n+                        EndGlobalSection\n+                    EndGlobal\n+                    \"\"\";\n+                TransientTestFile slnFile = env.CreateFile(@\"Solution.sln\", solutionFileContents);\n+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);\n+\n+                ProjectGraph projectGraph = new(slnFile.Path);\n+                ProjectGraphNode project1Node = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+                ProjectGraphNode project2Node = GetFirstNodeWithProjectNumber(projectGraph, 2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(entryTargets);\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[project1Node].ShouldBe(expectedProject1Targets);\n+                targetLists[project2Node].ShouldBe(expectedProject2Targets);\n+            }\n+        }\n+\n+        [Theory]\n+        [InlineData(\"Project1:Build\")]",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Not sure, it just isn't :). I'm matching the behavior of what the metaproj has today.\r\n\r\n`SolutionProjectGenerator.EvaluateAndAddProjects` does `null` (\"Project\" only, no \":\"), `\"Clean\"`, `\"Rebuild\"`, and `\"Publish\"`. So \"Build\" doesn't get generated there.\r\n\r\nThere is also logic there to just generate a target for whatever is provided (eg \"Project:CustomTarget\"), but that doesn't happen for \"Build\" because in `SolutionProjectGenerator.EvaluateAndAddProjects` has `_targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i))`, and `CreateTraversalInstance` adds \"dummy targets\" apparently which does include \"Build\", so the previously mentioned filtering will filter it out.",
              "createdAt": "2024-04-18T20:10:09Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -2808,6 +2808,119 @@ public void MultitargettingTargetsWithBuildProjectReferencesFalse()\n             }\n         }\n \n+        [Theory]\n+        // Built-in targets\n+        [InlineData(new string[0], new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Build\" }, new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Rebuild\" }, new[] { \"Rebuild\" }, new[] { \"Rebuild\" })]\n+        [InlineData(new[] { \"Clean\" }, new[] { \"Clean\" }, new[] { \"Clean\" })]\n+        [InlineData(new[] { \"Publish\" }, new[] { \"Publish\" }, new[] { \"Publish\" })]\n+        // Traversal targets\n+        [InlineData(new[] { \"Project1\" }, new[] { \"Project1Default\" }, new string[0])]\n+        [InlineData(new[] { \"Project2\" }, new string[0], new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Project1\", \"Project2\" }, new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Project1:Rebuild\" }, new[] { \"Rebuild\" }, new string[0])]\n+        [InlineData(new[] { \"Project2:Rebuild\" }, new string[0], new[] { \"Rebuild\" })]\n+        [InlineData(new[] { \"Project1:Rebuild\", \"Project2:Clean\" }, new[] { \"Rebuild\" }, new[] { \"Clean\" })]\n+        [InlineData(new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" })]\n+        [InlineData(new[] { \"Project1:CustomTarget\" }, new[] { \"CustomTarget\" }, new string[0])]\n+        [InlineData(new[] { \"Project2:CustomTarget\" }, new string[0], new[] { \"CustomTarget\" })]\n+        [InlineData(new[] { \"Project1:CustomTarget\", \"Project2:CustomTarget\" }, new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" })]\n+        public void GetTargetListsWithSolution(string[] entryTargets, string[] expectedProject1Targets, string[] expectedProject2Targets)\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                const string ExtraContent = \"\"\"\n+                    <Target Name=\"CustomTarget\" />\n+                    \"\"\";\n+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1, defaultTargets: \"Project1Default\", extraContent: ExtraContent);\n+                TransientTestFile project2File = CreateProjectFile(env: env, projectNumber: 2, defaultTargets: \"Project2Default\", extraContent: ExtraContent);\n+\n+                string solutionFileContents = $$\"\"\"\n+                    Microsoft Visual Studio Solution File, Format Version 12.00\n+                    # Visual Studio Version 17\n+                    VisualStudioVersion = 17.0.31903.59\n+                    MinimumVisualStudioVersion = 17.0.31903.59\n+                    Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Project1\", \"{{project1File.Path}}\", \"{8761499A-7280-43C4-A32F-7F41C47CA6DF}\"\n+                    EndProject\n+                    Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Project2\", \"{{project2File.Path}}\", \"{2022C11A-1405-4983-BEC2-3A8B0233108F}\"\n+                    EndProject\n+                    Global\n+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution\n+                            Debug|x64 = Debug|x64\n+                            Release|x64 = Release|x64\n+                        EndGlobalSection\n+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64\n+                        EndGlobalSection\n+                        GlobalSection(SolutionProperties) = preSolution\n+                            HideSolutionNode = FALSE\n+                        EndGlobalSection\n+                    EndGlobal\n+                    \"\"\";\n+                TransientTestFile slnFile = env.CreateFile(@\"Solution.sln\", solutionFileContents);\n+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);\n+\n+                ProjectGraph projectGraph = new(slnFile.Path);\n+                ProjectGraphNode project1Node = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+                ProjectGraphNode project2Node = GetFirstNodeWithProjectNumber(projectGraph, 2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(entryTargets);\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[project1Node].ShouldBe(expectedProject1Targets);\n+                targetLists[project2Node].ShouldBe(expectedProject2Targets);\n+            }\n+        }\n+\n+        [Theory]\n+        [InlineData(\"Project1:Build\")]",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Interesting.\r\nOk - sounds OK here then",
              "createdAt": "2024-04-19T08:06:01Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -2808,6 +2808,119 @@ public void MultitargettingTargetsWithBuildProjectReferencesFalse()\n             }\n         }\n \n+        [Theory]\n+        // Built-in targets\n+        [InlineData(new string[0], new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Build\" }, new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Rebuild\" }, new[] { \"Rebuild\" }, new[] { \"Rebuild\" })]\n+        [InlineData(new[] { \"Clean\" }, new[] { \"Clean\" }, new[] { \"Clean\" })]\n+        [InlineData(new[] { \"Publish\" }, new[] { \"Publish\" }, new[] { \"Publish\" })]\n+        // Traversal targets\n+        [InlineData(new[] { \"Project1\" }, new[] { \"Project1Default\" }, new string[0])]\n+        [InlineData(new[] { \"Project2\" }, new string[0], new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Project1\", \"Project2\" }, new[] { \"Project1Default\" }, new[] { \"Project2Default\" })]\n+        [InlineData(new[] { \"Project1:Rebuild\" }, new[] { \"Rebuild\" }, new string[0])]\n+        [InlineData(new[] { \"Project2:Rebuild\" }, new string[0], new[] { \"Rebuild\" })]\n+        [InlineData(new[] { \"Project1:Rebuild\", \"Project2:Clean\" }, new[] { \"Rebuild\" }, new[] { \"Clean\" })]\n+        [InlineData(new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" })]\n+        [InlineData(new[] { \"Project1:CustomTarget\" }, new[] { \"CustomTarget\" }, new string[0])]\n+        [InlineData(new[] { \"Project2:CustomTarget\" }, new string[0], new[] { \"CustomTarget\" })]\n+        [InlineData(new[] { \"Project1:CustomTarget\", \"Project2:CustomTarget\" }, new[] { \"CustomTarget\" }, new[] { \"CustomTarget\" })]\n+        public void GetTargetListsWithSolution(string[] entryTargets, string[] expectedProject1Targets, string[] expectedProject2Targets)\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                const string ExtraContent = \"\"\"\n+                    <Target Name=\"CustomTarget\" />\n+                    \"\"\";\n+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1, defaultTargets: \"Project1Default\", extraContent: ExtraContent);\n+                TransientTestFile project2File = CreateProjectFile(env: env, projectNumber: 2, defaultTargets: \"Project2Default\", extraContent: ExtraContent);\n+\n+                string solutionFileContents = $$\"\"\"\n+                    Microsoft Visual Studio Solution File, Format Version 12.00\n+                    # Visual Studio Version 17\n+                    VisualStudioVersion = 17.0.31903.59\n+                    MinimumVisualStudioVersion = 17.0.31903.59\n+                    Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Project1\", \"{{project1File.Path}}\", \"{8761499A-7280-43C4-A32F-7F41C47CA6DF}\"\n+                    EndProject\n+                    Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Project2\", \"{{project2File.Path}}\", \"{2022C11A-1405-4983-BEC2-3A8B0233108F}\"\n+                    EndProject\n+                    Global\n+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution\n+                            Debug|x64 = Debug|x64\n+                            Release|x64 = Release|x64\n+                        EndGlobalSection\n+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64\n+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64\n+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64\n+                        EndGlobalSection\n+                        GlobalSection(SolutionProperties) = preSolution\n+                            HideSolutionNode = FALSE\n+                        EndGlobalSection\n+                    EndGlobal\n+                    \"\"\";\n+                TransientTestFile slnFile = env.CreateFile(@\"Solution.sln\", solutionFileContents);\n+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);\n+\n+                ProjectGraph projectGraph = new(slnFile.Path);\n+                ProjectGraphNode project1Node = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+                ProjectGraphNode project2Node = GetFirstNodeWithProjectNumber(projectGraph, 2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(entryTargets);\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[project1Node].ShouldBe(expectedProject1Targets);\n+                targetLists[project2Node].ShouldBe(expectedProject2Targets);\n+            }\n+        }\n+\n+        [Theory]\n+        [InlineData(\"Project1:Build\")]",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Out of curiosity: Could you please clarify if it is expected that this mentioned code block could be executed multiple times and populate the nodes to visit with the EntryPointNodes (which could result duplicate nodes to visit?) ",
              "createdAt": "2024-04-18T08:30:15Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -604,14 +608,92 @@ private string DebuggerDisplayString()\n             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();\n             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();\n \n-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)\n+            {\n+                // If no targets were specified, use every project's default targets.\n+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                {\n+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                    encounteredEdges.Add(entryEdge);\n+                    edgesToVisit.Enqueue(entryEdge);\n+                }\n+            }\n+            else\n             {\n-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0\n-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)\n-                    : ImmutableList.CreateRange(entryProjectTargets);\n-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n-                encounteredEdges.Add(entryEdge);\n-                edgesToVisit.Enqueue(entryEdge);\n+                foreach (string targetName in entryProjectTargets)\n+                {\n+                    // Special-case the \"Build\" target. The solution's metaproj invokes each project's default targets\n+                    if (targetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+\n+                        continue;\n+                    }\n+\n+                    bool isSolutionTraversalTarget = false;\n+                    if (Solution != null)\n+                    {\n+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)\n+                        {\n+                            if (!SolutionFile.IsBuildableProject(project))\n+                            {\n+                                continue;\n+                            }\n+\n+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());\n+\n+                            // Solutions generate target names to build individual projects. Map these to \"real\" targets on the relevant projects.\n+                            // This logic should match SolutionProjectGenerator's behavior\n+                            if (targetName.Equals(baseProjectName, StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                // Build a specific project with its default targets.\n+                                ProjectGraphNode node = GetNodeForProject(project);\n+                                ProjectGraphBuildRequest entryEdge = new(node, ImmutableList.CreateRange(node.ProjectInstance.DefaultTargets));\n+                                encounteredEdges.Add(entryEdge);\n+                                edgesToVisit.Enqueue(entryEdge);\n+                                isSolutionTraversalTarget = true;\n+                            }\n+                            else if (targetName.StartsWith($\"{baseProjectName}:\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                // Build a specific project with the specified target\n+                                string projectTargetName = targetName.Substring(baseProjectName.Length + 1);\n+\n+                                // Special-case \"Project:\" and \"Project:Build\". SolutionProjectGenerator does not generate a target for those, so should error with MSB4057\n+                                ProjectErrorUtilities.VerifyThrowInvalidProject(\n+                                    projectTargetName.Length > 0 && !projectTargetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase),\n+                                    ElementLocation.Create(Solution.FullPath),\n+                                    \"TargetDoesNotExist\",\n+                                    targetName);\n+\n+                                ProjectGraphNode node = GetNodeForProject(project);\n+                                ProjectGraphBuildRequest entryEdge = new(node,[projectTargetName]);\n+                                encounteredEdges.Add(entryEdge);\n+                                edgesToVisit.Enqueue(entryEdge);\n+                                isSolutionTraversalTarget = true;\n+                            }\n+\n+                            // For solutions, there should only be exactly one entry node per project file\n+                            ProjectGraphNode GetNodeForProject(ProjectInSolution project) => EntryPointNodes.First(node => string.Equals(node.ProjectInstance.FullPath, project.AbsolutePath));\n+                        }\n+                    }\n+\n+                    if (!isSolutionTraversalTarget)\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            ProjectGraphBuildRequest entryEdge = new(entryPointNode,[targetName]);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+                    }",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Yep, it's expected because it needs to visit once per entry target. I considered doing the loops nested the other way, but the complexity inside the loop would be increased by doing it that way.",
              "createdAt": "2024-04-18T20:19:50Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -604,14 +608,92 @@ private string DebuggerDisplayString()\n             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();\n             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();\n \n-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)\n+            {\n+                // If no targets were specified, use every project's default targets.\n+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                {\n+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                    encounteredEdges.Add(entryEdge);\n+                    edgesToVisit.Enqueue(entryEdge);\n+                }\n+            }\n+            else\n             {\n-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0\n-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)\n-                    : ImmutableList.CreateRange(entryProjectTargets);\n-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n-                encounteredEdges.Add(entryEdge);\n-                edgesToVisit.Enqueue(entryEdge);\n+                foreach (string targetName in entryProjectTargets)\n+                {\n+                    // Special-case the \"Build\" target. The solution's metaproj invokes each project's default targets\n+                    if (targetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+\n+                        continue;\n+                    }\n+\n+                    bool isSolutionTraversalTarget = false;\n+                    if (Solution != null)\n+                    {\n+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)\n+                        {\n+                            if (!SolutionFile.IsBuildableProject(project))\n+                            {\n+                                continue;\n+                            }\n+\n+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());\n+\n+                            // Solutions generate target names to build individual projects. Map these to \"real\" targets on the relevant projects.\n+                            // This logic should match SolutionProjectGenerator's behavior\n+                            if (targetName.Equals(baseProjectName, StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                // Build a specific project with its default targets.\n+                                ProjectGraphNode node = GetNodeForProject(project);\n+                                ProjectGraphBuildRequest entryEdge = new(node, ImmutableList.CreateRange(node.ProjectInstance.DefaultTargets));\n+                                encounteredEdges.Add(entryEdge);\n+                                edgesToVisit.Enqueue(entryEdge);\n+                                isSolutionTraversalTarget = true;\n+                            }\n+                            else if (targetName.StartsWith($\"{baseProjectName}:\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                // Build a specific project with the specified target\n+                                string projectTargetName = targetName.Substring(baseProjectName.Length + 1);\n+\n+                                // Special-case \"Project:\" and \"Project:Build\". SolutionProjectGenerator does not generate a target for those, so should error with MSB4057\n+                                ProjectErrorUtilities.VerifyThrowInvalidProject(\n+                                    projectTargetName.Length > 0 && !projectTargetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase),\n+                                    ElementLocation.Create(Solution.FullPath),\n+                                    \"TargetDoesNotExist\",\n+                                    targetName);\n+\n+                                ProjectGraphNode node = GetNodeForProject(project);\n+                                ProjectGraphBuildRequest entryEdge = new(node,[projectTargetName]);\n+                                encounteredEdges.Add(entryEdge);\n+                                edgesToVisit.Enqueue(entryEdge);\n+                                isSolutionTraversalTarget = true;\n+                            }\n+\n+                            // For solutions, there should only be exactly one entry node per project file\n+                            ProjectGraphNode GetNodeForProject(ProjectInSolution project) => EntryPointNodes.First(node => string.Equals(node.ProjectInstance.FullPath, project.AbsolutePath));\n+                        }\n+                    }\n+\n+                    if (!isSolutionTraversalTarget)\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            ProjectGraphBuildRequest entryEdge = new(entryPointNode,[targetName]);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+                    }",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Could you please add the link to which exactly logic it should match? ",
              "createdAt": "2024-04-18T08:36:32Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -604,14 +608,92 @@ private string DebuggerDisplayString()\n             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();\n             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();\n \n-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)\n+            {\n+                // If no targets were specified, use every project's default targets.\n+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                {\n+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                    encounteredEdges.Add(entryEdge);\n+                    edgesToVisit.Enqueue(entryEdge);\n+                }\n+            }\n+            else\n             {\n-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0\n-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)\n-                    : ImmutableList.CreateRange(entryProjectTargets);\n-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n-                encounteredEdges.Add(entryEdge);\n-                edgesToVisit.Enqueue(entryEdge);\n+                foreach (string targetName in entryProjectTargets)\n+                {\n+                    // Special-case the \"Build\" target. The solution's metaproj invokes each project's default targets\n+                    if (targetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+\n+                        continue;\n+                    }\n+\n+                    bool isSolutionTraversalTarget = false;\n+                    if (Solution != null)\n+                    {\n+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)\n+                        {\n+                            if (!SolutionFile.IsBuildableProject(project))\n+                            {\n+                                continue;\n+                            }\n+\n+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());\n+\n+                            // Solutions generate target names to build individual projects. Map these to \"real\" targets on the relevant projects.\n+                            // This logic should match SolutionProjectGenerator's behavior",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "It's kinda all over that class, but I'll be a bit more targetted.",
              "createdAt": "2024-04-18T20:23:34Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -604,14 +608,92 @@ private string DebuggerDisplayString()\n             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();\n             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();\n \n-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)\n+            {\n+                // If no targets were specified, use every project's default targets.\n+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                {\n+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                    encounteredEdges.Add(entryEdge);\n+                    edgesToVisit.Enqueue(entryEdge);\n+                }\n+            }\n+            else\n             {\n-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0\n-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)\n-                    : ImmutableList.CreateRange(entryProjectTargets);\n-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n-                encounteredEdges.Add(entryEdge);\n-                edgesToVisit.Enqueue(entryEdge);\n+                foreach (string targetName in entryProjectTargets)\n+                {\n+                    // Special-case the \"Build\" target. The solution's metaproj invokes each project's default targets\n+                    if (targetName.Equals(\"Build\", StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)\n+                        {\n+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);\n+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);\n+                            encounteredEdges.Add(entryEdge);\n+                            edgesToVisit.Enqueue(entryEdge);\n+                        }\n+\n+                        continue;\n+                    }\n+\n+                    bool isSolutionTraversalTarget = false;\n+                    if (Solution != null)\n+                    {\n+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)\n+                        {\n+                            if (!SolutionFile.IsBuildableProject(project))\n+                            {\n+                                continue;\n+                            }\n+\n+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());\n+\n+                            // Solutions generate target names to build individual projects. Map these to \"real\" targets on the relevant projects.\n+                            // This logic should match SolutionProjectGenerator's behavior",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      }
    ]
  }
}