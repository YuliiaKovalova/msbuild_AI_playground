{
  "number": 11672,
  "title": "Add docs about Scheduler",
  "body": "This document describes MSBuild Scheduler on high level.\r\nRelated to [#11701](https://github.com/dotnet/msbuild/issues/11701)",
  "state": "OPEN",
  "createdAt": "2025-04-03T12:56:27Z",
  "updatedAt": "2025-05-28T08:53:14Z",
  "closedAt": null,
  "mergedAt": null,
  "additions": 172,
  "deletions": 0,
  "changedFiles": 3,
  "headRefName": "dev/ykovalova/add_docs_about_scheduling",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "YuliiaKovalova"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "7cb2088df3078dd203d39af70483d2cba95bddde",
          "message": "add scheduler overview",
          "committedDate": "2025-04-03T12:48:42Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fce8e8857130c937a4241ccb44ad3daf703d4967",
          "message": "markup cleanup",
          "committedDate": "2025-04-03T12:52:34Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3bfd579a09d848e5f55726988788326ae8ff8646",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Copilot <175728472+Copilot@users.noreply.github.com>",
          "committedDate": "2025-04-03T12:59:38Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1923844d541c9aa730e347afc2c52b2e57988059",
          "message": "the document content adjustment",
          "committedDate": "2025-05-20T14:48:41Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d548123bf30f3ccf3c73b9045bd8009474beb779",
          "message": "Merge branch 'dev/ykovalova/add_docs_about_scheduling' of https://github.com/YuliiaKovalova/msbuild into dev/ykovalova/add_docs_about_scheduling",
          "committedDate": "2025-05-20T14:50:03Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "The phrase 'generates submits' appears to contain an extra word; consider removing one of these verbs (e.g., 'submits') for clarity.\n```suggestion\n- BuildManager generates root request to the Scheduler\n```",
              "createdAt": "2025-04-03T12:57:48Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates submits root request to the Scheduler",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "[nitpick] Consider revising the sentence for clarity and punctuation, such as replacing '=' with a comma or rephrasing it entirely.\n```suggestion\nIf the parent is absent, meaning a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.\n```",
              "createdAt": "2025-04-03T12:57:49Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates submits root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If parent is absent = a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.\n+",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The description ends abruptly with 'as it'; please clarify or complete the sentence to explain what ProjectA's request ID is used for.\n```suggestion\n- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n```",
              "createdAt": "2025-04-03T12:57:49Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates submits root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If parent is absent = a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.\n+\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as it.",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "does this really happen? I see that some code for .buildplan files exists but I have never seen it",
              "createdAt": "2025-04-03T13:59:23Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,171 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If the parent is absent, meaning a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n+- `Targets`: The list of targets to build in this project. These are the specific build tasks to execute, like \"Clean\", \"Build\", or \"Publish\".\n+\n+## Caching System\n+\n+### ConfigCache\n+Project configuration storage\n+- Project files\n+- Global properties\n+- Targets\n+- ToolsVersion\n+\n+### ResultsCache\n+Build result storage\n+- Target outputs\n+- Build success/failure\n+- Target-level granularity\n+\n+## Scheduling Algorithms\n+\n+So the default scheduling algorithm varies based on:\n+\n+### Single-Processor Case (MaxNodeCount = 1):\n+Uses AssignUnscheduledRequestsFIFO (First-In-First-Out)\n+\n+### Multi-Processor Case (MaxNodeCount > 1):\n+- First calls AssignUnscheduledRequestsByTraversalsFirst to prioritize traversal projects\n+- Then calls AssignUnscheduledProxyBuildRequestsToInProcNode for proxy builds\n+- Then chooses based on whether a valid scheduling plan exists:\n+\n+#### With Valid Plan:\n+- For 2 nodes: AssignUnscheduledRequestsWithPlanByMostImmediateReferences\n+- For 3+ nodes: AssignUnscheduledRequestsWithPlanByGreatestPlanTime\n+\n+#### Without Valid Plan:\n+- AssignUnscheduledRequestsWithConfigurationCountLevelling\n+\n+A \"valid plan\" in MSBuild refers to historical build data that was collected from previous successful builds and stored for optimization purposes.\n+A scheduling plan contains information about:\n+\n+1) Build Times: How long each project took to build\n+2) Project References: Which projects reference other projects\n+3) Configuration Maps: How project paths map to configuration IDs\n+\n+This data is saved at the end of a successful build, typically in a file with extension `.buildplan`, so it can be used to make better scheduling decisions in future builds.",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": ":)\r\nhttps://github.com/dotnet/msbuild/issues/11673",
              "createdAt": "2025-04-03T14:44:37Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,171 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If the parent is absent, meaning a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n+- `Targets`: The list of targets to build in this project. These are the specific build tasks to execute, like \"Clean\", \"Build\", or \"Publish\".\n+\n+## Caching System\n+\n+### ConfigCache\n+Project configuration storage\n+- Project files\n+- Global properties\n+- Targets\n+- ToolsVersion\n+\n+### ResultsCache\n+Build result storage\n+- Target outputs\n+- Build success/failure\n+- Target-level granularity\n+\n+## Scheduling Algorithms\n+\n+So the default scheduling algorithm varies based on:\n+\n+### Single-Processor Case (MaxNodeCount = 1):\n+Uses AssignUnscheduledRequestsFIFO (First-In-First-Out)\n+\n+### Multi-Processor Case (MaxNodeCount > 1):\n+- First calls AssignUnscheduledRequestsByTraversalsFirst to prioritize traversal projects\n+- Then calls AssignUnscheduledProxyBuildRequestsToInProcNode for proxy builds\n+- Then chooses based on whether a valid scheduling plan exists:\n+\n+#### With Valid Plan:\n+- For 2 nodes: AssignUnscheduledRequestsWithPlanByMostImmediateReferences\n+- For 3+ nodes: AssignUnscheduledRequestsWithPlanByGreatestPlanTime\n+\n+#### Without Valid Plan:\n+- AssignUnscheduledRequestsWithConfigurationCountLevelling\n+\n+A \"valid plan\" in MSBuild refers to historical build data that was collected from previous successful builds and stored for optimization purposes.\n+A scheduling plan contains information about:\n+\n+1) Build Times: How long each project took to build\n+2) Project References: Which projects reference other projects\n+3) Configuration Maps: How project paths map to configuration IDs\n+\n+This data is saved at the end of a successful build, typically in a file with extension `.buildplan`, so it can be used to make better scheduling decisions in future builds.",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "maybe mention `MSBUILDENABLEBUILDPLAN` in the doc?",
              "createdAt": "2025-04-03T15:11:37Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,171 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If the parent is absent, meaning a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n+- `Targets`: The list of targets to build in this project. These are the specific build tasks to execute, like \"Clean\", \"Build\", or \"Publish\".\n+\n+## Caching System\n+\n+### ConfigCache\n+Project configuration storage\n+- Project files\n+- Global properties\n+- Targets\n+- ToolsVersion\n+\n+### ResultsCache\n+Build result storage\n+- Target outputs\n+- Build success/failure\n+- Target-level granularity\n+\n+## Scheduling Algorithms\n+\n+So the default scheduling algorithm varies based on:\n+\n+### Single-Processor Case (MaxNodeCount = 1):\n+Uses AssignUnscheduledRequestsFIFO (First-In-First-Out)\n+\n+### Multi-Processor Case (MaxNodeCount > 1):\n+- First calls AssignUnscheduledRequestsByTraversalsFirst to prioritize traversal projects\n+- Then calls AssignUnscheduledProxyBuildRequestsToInProcNode for proxy builds\n+- Then chooses based on whether a valid scheduling plan exists:\n+\n+#### With Valid Plan:\n+- For 2 nodes: AssignUnscheduledRequestsWithPlanByMostImmediateReferences\n+- For 3+ nodes: AssignUnscheduledRequestsWithPlanByGreatestPlanTime\n+\n+#### Without Valid Plan:\n+- AssignUnscheduledRequestsWithConfigurationCountLevelling\n+\n+A \"valid plan\" in MSBuild refers to historical build data that was collected from previous successful builds and stored for optimization purposes.\n+A scheduling plan contains information about:\n+\n+1) Build Times: How long each project took to build\n+2) Project References: Which projects reference other projects\n+3) Configuration Maps: How project paths map to configuration IDs\n+\n+This data is saved at the end of a successful build, typically in a file with extension `.buildplan`, so it can be used to make better scheduling decisions in future builds.",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\"If the parent is absent, meaning a schedulable request doesn't have any dependencies\" - this does not seem right. If the project has no dependencies, the request will not have children, not parents.",
              "createdAt": "2025-04-04T07:42:49Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,171 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If the parent is absent, meaning a schedulable request doesn't have any dependencies, the request will have `parentRequest = null`.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What sort of algorithm are we using? (if it is relevant to the documentation, otherwise just for my curiosity)",
              "createdAt": "2025-05-28T08:19:52Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Just saw the section further down the line. ",
              "createdAt": "2025-05-28T08:47:17Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\"how\" -> \"when\" ?\r\nor maybe I'm misunderstanding something.",
              "createdAt": "2025-05-28T08:28:14Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "To check if my understanding is correct:\r\nBuildRequest - a building block of a project + a plan where to put it. (a lego brick + a the picture that shows where is it placed which shows the previous bricks)\r\nSchedulableRequest - a sticker note I will put on the brick when I take it from the box to keep track of what needs to happen to it.\r\n\r\nI'm aware it is a weird comparison.",
              "createdAt": "2025-05-28T08:33:41Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this hold in the context of Graph build or is the granularity there different?",
              "createdAt": "2025-05-28T08:36:02Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit:\r\nWhen does SchedulableRequest have a parent?",
              "createdAt": "2025-05-28T08:41:56Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is a proxy build please? This is the first time I saw this keyword.",
              "createdAt": "2025-05-28T08:46:22Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If parent is absent, a schedulable request has `parentRequest = null`.\n+\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n+- `Targets`: The list of targets to build in this project. These are the specific build tasks to execute, like \"Clean\", \"Build\", or \"Publish\".\n+\n+## Caching System\n+\n+### ConfigCache\n+Project configuration storage\n+- Project files\n+- Global properties\n+- Targets\n+- ToolsVersion\n+\n+### ResultsCache\n+Build result storage\n+- Target outputs\n+- Build success/failure\n+- Target-level granularity\n+\n+## Scheduling Algorithms\n+\n+So the default scheduling algorithm varies based on:\n+\n+### Single-Processor Case (MaxNodeCount = 1):\n+Uses AssignUnscheduledRequestsFIFO (First-In-First-Out)\n+\n+### Multi-Processor Case (MaxNodeCount > 1):\n+- First calls AssignUnscheduledRequestsByTraversalsFirst to prioritize traversal projects\n+- Then calls AssignUnscheduledProxyBuildRequestsToInProcNode for proxy builds",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A personal curiosity:\r\nDo we have any sort of data from some reasonably large repo like OrchardCore (or maybe even VMR) about the effect the build plan has on perf?\r\nAdditionally, how does this interplay with graph build?",
              "createdAt": "2025-05-28T08:49:58Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If parent is absent, a schedulable request has `parentRequest = null`.\n+\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n+- `Targets`: The list of targets to build in this project. These are the specific build tasks to execute, like \"Clean\", \"Build\", or \"Publish\".\n+\n+## Caching System\n+\n+### ConfigCache\n+Project configuration storage\n+- Project files\n+- Global properties\n+- Targets\n+- ToolsVersion\n+\n+### ResultsCache\n+Build result storage\n+- Target outputs\n+- Build success/failure\n+- Target-level granularity\n+\n+## Scheduling Algorithms\n+\n+So the default scheduling algorithm varies based on:\n+\n+### Single-Processor Case (MaxNodeCount = 1):\n+Uses AssignUnscheduledRequestsFIFO (First-In-First-Out)\n+\n+### Multi-Processor Case (MaxNodeCount > 1):\n+- First calls AssignUnscheduledRequestsByTraversalsFirst to prioritize traversal projects\n+- Then calls AssignUnscheduledProxyBuildRequestsToInProcNode for proxy builds\n+- Then chooses based on whether a valid scheduling plan exists:\n+\n+#### With Valid Plan:\n+- For 2 nodes: AssignUnscheduledRequestsWithPlanByMostImmediateReferences\n+- For 3+ nodes: AssignUnscheduledRequestsWithPlanByGreatestPlanTime\n+\n+#### Without Valid Plan:\n+- AssignUnscheduledRequestsWithConfigurationCountLevelling\n+\n+A \"valid plan\" in MSBuild refers to historical build data that was collected from previous successful builds and stored for optimization purposes.\n+A scheduling plan contains information about:\n+\n+1) Build Times: How long each project took to build\n+2) Project References: Which projects reference other projects\n+3) Configuration Maps: How project paths map to configuration IDs\n+\n+This data is saved at the end of a successful build, typically in a file with extension `.buildplan`, so it can be used to make better scheduling decisions in future builds. To have this build plan generated, environment variable `MSBUILDENABLEBUILDPLAN` should be set with `true` value.\n+\n+MSBuild supports multiple scheduling algorithms that can be selected via the `MSBUILDCUSTOMSCHEDULER` environment variable:\n+\n+### FIFO\n+First-come, first-served scheduling - assigns requests in the order they are received. This is the simplest algorithm and works well for single-processor scenarios.\n+\n+### ByTraversalsFirst\n+Prioritizes traversal projects (like solution files) to identify more work quickly. This algorithm identifies and schedules projects that reference many other projects first, helping to discover parallelization opportunities early in the build.\n+\n+### WithConfigurationCountLevelling\n+Balances configurations across nodes to distribute work evenly. This algorithm tries to ensure each node has approximately the same number of distinct project configurations, which can improve caching behavior.\n+\n+### WithPlanByMostImmediateReferences\n+Prioritizes projects with the most direct references to other projects. This requires a valid scheduling plan from a previous build and helps maximize parallelism by tackling projects with many dependencies first.",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER \r\nnow this is peak naming.\r\n(not relevant for the review but made me chuckle. Feel free to close this one)",
              "createdAt": "2025-05-28T08:51:10Z",
              "path": "documentation/MSBuild-scheduler.md",
              "diffHunk": "@@ -0,0 +1,172 @@\n+# MSBuild Scheduler Architecture\n+\n+The diagram below illustrates the key components and workflows of the MSBuild Scheduler system.\n+\n+![MSBuild Scheduler Schema](./scheduler_architecture.png)\n+\n+## Request Lifecycle\n+\n+### 1. Submission\n+- BuildManager generates root request to the Scheduler\n+- Configuration is registered and SchedulableRequest is created\n+\n+### 2. Scheduling\n+- Scheduler applies algorithm to select node for request\n+- Request is assigned to node and moves to Executing state\n+\n+### 3. Execution\n+- Node processes request and may encounter dependencies\n+- If blocked, node reports to Scheduler with blocker information\n+- Scheduler creates new requests for dependencies and schedules them\n+\n+### 4. Completion\n+- Node reports build results back to Scheduler\n+- Results are cached and request is marked complete\n+- Parent requests are unblocked with results\n+\n+### 5. Result Processing\n+- Results propagate through dependency chain\n+- When all requests complete, submission is reported complete\n+\n+## Core Components\n+\n+### SchedulableRequest\n+The SchedulableRequest is a crucial internal wrapper class in the MSBuild scheduler that manages the lifecycle of build requests.\n+It tracks:\n+\n+- The current state of the request (Unscheduled, Executing, Blocked, Ready, Yielding, Completed)\n+- Which node it's assigned to\n+- The relationships to other requests (parent/child or blocking/blocked-by)\n+- Timing and execution details\n+\n+Think of `BuildRequest` as the \"what\" and `SchedulableRequest` as the \"how\" to build a project.\n+\n+#### When SchedulableRequest has a parent?\n+In MSBuild, builds often have dependencies. When a project needs to build another project first, it creates a child request.\n+The original one becomes the \"parent request\" of this new child request.\n+For example:\n+\n+`ProjectA` is building (parent request) => `ProjectA` references `ProjectB`, so it creates a request to build `ProjectB` (child request) => `ProjectA's` request is considered the \"parent request\" of `ProjectB's` request\n+\n+This parent-child relationship is tracked through:\n+- `ParentGlobalRequestId` in the `BuildRequest`\n+- The `Parent` property in the `SchedulableRequest`\n+\n+The parent request is blocked while its child request is executing. This is a fundamental aspect of MSBuild's dependency handling system.\n+When a parent request determines it needs results from a child request, the following happens:\n+\n+1) The parent request enters the \"Blocked\" state\n+2) The scheduler creates the child request\n+3) The parent remains blocked until the child completes\n+4) Once the child request finishes, its results are returned to the parent\n+5) The parent moves from \"Blocked\" to \"Ready\" state\n+6) The scheduler can then resume executing the parent request\n+\n+![MSBuild Scheduler Schema](./schedulableRequest_parent_relationships.png)\n+\n+If parent is absent, a schedulable request has `parentRequest = null`.\n+\n+### Scheduler\n+Central controller that manages build requests:\n+- Assigns `SchedulableRequests` to nodes\n+- Handles blocking and unblocking requests\n+- Checks if the result can be satisfied from the MSBuild cache\n+\n+### SchedulingData\n+Tracks state of all `SchedulableRequest`\n+- Request `SchedulableRequest` state transitions\n+- Node assignments\n+- Configuration tracking\n+\n+### SchedulingPlan\n+Historical build information\n+- Project references\n+- Build times\n+- Configuration mappings\n+This data can then be used by subsequent builds to determine how best to distribute work among several nodes.\n+\n+## Request Management\n+\n+### BuildRequest\n+Basic representation of build operation\n+- `GlobalRequestId`: A unique identifier for the request across the entire build session. This ID stays constant regardless of which node processes the request. It allows the scheduler to track and reference the request throughout the build lifecycle. If two requests are semantically identical (same targets for the same project **configuration**), they may share the same GlobalRequestId to enable result reuse.\n+- `ConfigurationId`: Identifies which project configuration this request is for. A configuration represents a unique combination of project file + global properties + tools version.\n+- `NodeRequestId`: A node-specific identifier for the request. Each node maintains its own request IDs, which are used for local tracking on that node (whether in-process or out-of-process).\n+- `SubmissionId`: an identifier that groups related BuildRequests that originate from a single top-level build command or operation.\n+- `ParentGlobalRequestId`: References the GlobalRequestId of the request that created this one. For example, if ProjectA depends on ProjectB, the request to build ProjectB would have ProjectA's request ID as its ParentGlobalRequestId. This allows the scheduler to track dependencies and manage the build process effectively.\n+- `Targets`: The list of targets to build in this project. These are the specific build tasks to execute, like \"Clean\", \"Build\", or \"Publish\".\n+\n+## Caching System\n+\n+### ConfigCache\n+Project configuration storage\n+- Project files\n+- Global properties\n+- Targets\n+- ToolsVersion\n+\n+### ResultsCache\n+Build result storage\n+- Target outputs\n+- Build success/failure\n+- Target-level granularity\n+\n+## Scheduling Algorithms\n+\n+So the default scheduling algorithm varies based on:\n+\n+### Single-Processor Case (MaxNodeCount = 1):\n+Uses AssignUnscheduledRequestsFIFO (First-In-First-Out)\n+\n+### Multi-Processor Case (MaxNodeCount > 1):\n+- First calls AssignUnscheduledRequestsByTraversalsFirst to prioritize traversal projects\n+- Then calls AssignUnscheduledProxyBuildRequestsToInProcNode for proxy builds\n+- Then chooses based on whether a valid scheduling plan exists:\n+\n+#### With Valid Plan:\n+- For 2 nodes: AssignUnscheduledRequestsWithPlanByMostImmediateReferences\n+- For 3+ nodes: AssignUnscheduledRequestsWithPlanByGreatestPlanTime\n+\n+#### Without Valid Plan:\n+- AssignUnscheduledRequestsWithConfigurationCountLevelling\n+\n+A \"valid plan\" in MSBuild refers to historical build data that was collected from previous successful builds and stored for optimization purposes.\n+A scheduling plan contains information about:\n+\n+1) Build Times: How long each project took to build\n+2) Project References: Which projects reference other projects\n+3) Configuration Maps: How project paths map to configuration IDs\n+\n+This data is saved at the end of a successful build, typically in a file with extension `.buildplan`, so it can be used to make better scheduling decisions in future builds. To have this build plan generated, environment variable `MSBUILDENABLEBUILDPLAN` should be set with `true` value.\n+\n+MSBuild supports multiple scheduling algorithms that can be selected via the `MSBUILDCUSTOMSCHEDULER` environment variable:\n+\n+### FIFO\n+First-come, first-served scheduling - assigns requests in the order they are received. This is the simplest algorithm and works well for single-processor scenarios.\n+\n+### ByTraversalsFirst\n+Prioritizes traversal projects (like solution files) to identify more work quickly. This algorithm identifies and schedules projects that reference many other projects first, helping to discover parallelization opportunities early in the build.\n+\n+### WithConfigurationCountLevelling\n+Balances configurations across nodes to distribute work evenly. This algorithm tries to ensure each node has approximately the same number of distinct project configurations, which can improve caching behavior.\n+\n+### WithPlanByMostImmediateReferences\n+Prioritizes projects with the most direct references to other projects. This requires a valid scheduling plan from a previous build and helps maximize parallelism by tackling projects with many dependencies first.\n+\n+### WithPlanByGreatestPlanTime\n+Uses historical build times to prioritize longer-running tasks. This requires a valid scheduling plan from a previous build and schedules the most time-consuming projects first to minimize overall build time.\n+\n+### WithSmallestFileSize\n+Prioritizes projects with smaller source file sizes. This can be useful when you want to complete many small projects quickly before tackling larger ones.\n+\n+### WithLargestFileSize\n+Prioritizes projects with larger source file sizes. This assumes that larger project files may take longer to build and schedules them earlier.\n+\n+### WithMaxWaitingRequests\n+Prioritizes requests that have the most other requests waiting on them, using the transitive closure of the dependency tree. This helps unblock the maximum number of dependent projects.\n+\n+### WithMaxWaitingRequests2\n+Similar to WithMaxWaitingRequests, but only considers direct dependencies rather than the full transitive closure of waiting requests.\n+\n+### CustomSchedulerForSQL\n+Specialized algorithm for SQL builds to avoid node overloading. This algorithm intentionally limits the number of configurations assigned to any single node, which helps with builds that have many configurations that reference the same projects. It can be fine-tuned with the `MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER` environment variable.",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      }
    ]
  }
}