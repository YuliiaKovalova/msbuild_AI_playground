{
  "number": 6655,
  "title": "ProjectReferences Negotiate SetPlatform Metadata",
  "body": "Fixes #5338 \r\n\r\n### Context\r\nTargetFrameworks are determined dynamically at build time, this change sets a baseline for performing `SetPlatform` negotiation.\r\n\r\nIn a project setup like so:\r\n\r\n```\r\nA --> B --> C\r\n```\r\nA can build as x86\r\nB as x86, x64\r\nC as AnyCPU\r\n\r\nProjects can tell ProjectReferences to build as their \"most compatible\" platform.\r\n\r\nA would tell B to build as x86, and B would tell C to build AnyCPU.\r\n\r\nThe build can now negotiate what Platform a ProjectReference should build as. This negotiation happens in the `_GetProjectReferencePlatformProperties` target. It piggybacks off of the `GetTargetFrameworks` call that happens in `_GetProjectReferenceTargetFrameworkProperties` that now pulls `$(Platforms)` data from referenced projects. The `GetCompatiblePlatform` task performs the main negotiation. An optional `PlatformLookupTable` can be specified per `ProjectReference`, or in individual projects, or in a Directory.Build.props. This lookup table is in the form `foo=bar;C=D` and means (in English), \"When some project is building with platform `foo`, and a `ProjectReference` can build with platform B, tell the referenced project to build as `bar`\"\r\n\r\nThese are the rules by which the `GetCompatiblePlatform` task assigns a platform:\r\n\r\n1. Can the referenced project build with the same platform as the currently-building project? Use that.\r\n2. Does the `ProjectReference` item have a PlatformTranslationTable defined? Use that to find a mapping if possible\r\n3. Does the currently-building project have a PlatformTranslationTable defined? Use that to find a mapping if possible\r\n4. Can the child build as AnyCPU? Use that if possible.\r\n5. Can't determine the platform to pass along, log a warning and undefine platform.\r\n\r\nFinally, the `SetPlatform` metadata is set or undefined per `ProjectReference`.\r\n\r\n### Changes Made\r\n- MODIFIED TARGETS\r\n\t- GetTargetFrameworks\r\n\t\t- Extracts $(Platforms) and $(IsVcxOrNativeProj) from ProjectReference Items\r\n- NEW TARGETS\r\n\t- _GetProjectReferencePlatformProperties\r\n\t\t- Calls GetPlatforms on referenced projects\r\n\t\t- Only runs when `EnableDynamicPlatformResolution` is true on the referencing project\r\n\t\t- Sets or undefines `SetPlatform` metadata on all referenced projects\r\n\r\n- New Task\r\n\t- GetCompatiblePlatform\r\n\t\t- Performs the negotiation\r\n\t\t- Can throw a warning when no compatible platform is found.\r\n\r\n### Testing\r\n\u2714\ufe0f\r\n\r\n### Notes\r\nReviewing as a whole is better for this PR.\r\n\r\n### To Do\r\n- [x] Add codes/resources for all warnings\r\n- [x] Add tests\r\n- [x] Add docs",
  "state": "MERGED",
  "createdAt": "2021-07-06T18:17:23Z",
  "updatedAt": "2021-07-30T06:56:52Z",
  "closedAt": "2021-07-30T06:56:52Z",
  "mergedAt": "2021-07-30T06:56:52Z",
  "additions": 1150,
  "deletions": 9,
  "changedFiles": 24,
  "headRefName": "setplatform-negotiation",
  "isDraft": false,
  "author": {
    "login": "benvillalobos"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "68c396b8eb52badcd5e02f044ab741a5c9a4e8bc",
          "message": "GetPlatforms target added",
          "committedDate": "2021-07-06T17:59:41Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b85f9e16e10390cc8c724e3964997e2a1851255",
          "message": "Add _GetProjectReferencePlatformProperties",
          "committedDate": "2021-07-06T17:59:41Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c8c91fa7e06d944d1c9b24eb6e1d1ab85de9a0c",
          "message": "Add GetNearestPlatformTask v1",
          "committedDate": "2021-07-06T17:59:41Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4f95be96c9eeecbdb971c7e3fc78a4e965b6c95",
          "message": "Changes to GetNearestPlatformTask, Platform items\nflow into TargetFramework logic.",
          "committedDate": "2021-07-06T17:59:42Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2edda9e12ee1b1488ab1f13a01586e2cbe3b3ab6",
          "message": "Flip boolean logic for setting SetPlatform metadata",
          "committedDate": "2021-07-06T17:59:42Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e5d4f9cdb9a8dc906853fab2d882bd8173b108f6",
          "message": "Check for comma to see if project can multiplatform",
          "committedDate": "2021-07-06T17:59:42Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "42cf4e11a2b31a06ff7aa2a54d4f28e23903076c",
          "message": "Don't run GetNearestPlatformTask if a project can't multiplatform. Also don't modify any items if the task didn't run or there were no items added to ProjectsWithPlatformAssignment",
          "committedDate": "2021-07-06T17:59:42Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8e39ff15a030008b3b07c6f6391cd78d24618b24",
          "message": "Combine itemgroup logic when transferring items with new metadata to existent projects item",
          "committedDate": "2021-07-06T17:59:42Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4c25a0c5c6200e325b73828827036c79986d793",
          "message": "Remove redundant CanMultiPlatform check",
          "committedDate": "2021-07-06T17:59:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92f329ce79e3352294390695a28f8dbc3cc126ab",
          "message": "Only account for $(Platforms) when retrieving possible platforms to build. Bring over CanMultiPlatform logic to CrossTargeting.targets",
          "committedDate": "2021-07-06T17:59:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e036043408e6a2bfacb6861609a4ceb690804beb",
          "message": "Undefine Platform/PlatformTarget when there is no clear platform to choose",
          "committedDate": "2021-07-06T17:59:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cc9a40189ce5e1e1228d500d7d66d23b85d2cd44",
          "message": "Add property to simplify vcxproj and nativeproj checks",
          "committedDate": "2021-07-06T17:59:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4f6e41f2b23a4f23f45fb57c16f2a0dde6b2e78f",
          "message": "PlatformOptions should be semicolon-delimited",
          "committedDate": "2021-07-06T17:59:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0cd0e528e780f82f04447c1734e9674ee59f76d6",
          "message": "Take Platform or PlatformTarget into account when consider platform options",
          "committedDate": "2021-07-06T17:59:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed3578ef9d3097a09a2dab6c1cdc1a379e1accce",
          "message": "Revert \"Take Platform or PlatformTarget into account when consider platform options\"\n\nThis reverts commit c4a108825e586398d7cc8eb0bd171062dd043cc1.",
          "committedDate": "2021-07-06T17:59:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1351751c9d93c9d82e5b806707517ec806ff7b3c",
          "message": "Code cleanup.\n\nContinue instead of breaking if the platform lookup table is malformed,\nother items in the table might be valid.\n\nRemove CanMultiPlatform, not necessary if GetNearestPlatformTask can\nfigure that out.\n\nUse IsVcxOrNativeProj when setting PlatformLookupTable",
          "committedDate": "2021-07-06T17:59:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3161d84688a040233ed2f6ca4799f29b0d95d3d7",
          "message": "Refactor GetNearestPlatformTask",
          "committedDate": "2021-07-06T17:59:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b6d7aeefa175985f87d09c815aef2c5731a073d6",
          "message": "Use BuildArchitecturesAllowed as PlatformOptions. VS Uses this property already",
          "committedDate": "2021-07-06T17:59:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "649cc5bc11a87cf914b1a087d8b7d72f2c8ac871",
          "message": "Account for user-defined PlatformLookupTables when calling GetNearestPlatformTask. The use case is when a particular project wants its Win32 or AnyCPU platforms to map to a specific other platform",
          "committedDate": "2021-07-06T17:59:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95940684e17954c98c29c9b70ff9c1961fb485ac",
          "message": "Add verbose logging to help debug",
          "committedDate": "2021-07-06T17:59:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5b2ba539d36b3362007da36cf4a8a95635971d98",
          "message": "Pass parent platform based on file extension. Add 'is parent managed' check when setting default managed->unmanaged PlatformLookupTable",
          "committedDate": "2021-07-06T17:59:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9dae683738056c2036dc18178c837ea746a4a3b9",
          "message": "Clean up DefaultToVcxPlatformMapping\n\nRemove extra file?",
          "committedDate": "2021-07-06T17:59:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "84b7d716842715e99e96729484382d50adc9737c",
          "message": "Revert \"Use BuildArchitecturesAllowed as PlatformOptions. VS Uses this property already\"\n\nThis reverts commit 6aba0c91109528a2e067b6331ae26af87f81feea.",
          "committedDate": "2021-07-06T17:59:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "890bed2f539a145c8036888109ca0ac40ad86e97",
          "message": "Only run _GetProjectReferencePlatformProperties if there are any project references",
          "committedDate": "2021-07-06T17:59:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5a65fb873a69fabe9ee7686c8c5858969835df4",
          "message": "Add warning when we want to dynamically figure out platform, but child project doesn't have Platforms specified",
          "committedDate": "2021-07-06T17:59:46Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "097cb71dcde88f4b52998f4cca307a4c97897e1e",
          "message": "Undefine Platform and PlatformTarget when getting platforms from a child project",
          "committedDate": "2021-07-06T17:59:46Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8030f1095f1b6e0ca408a056d97baf7979a63045",
          "message": "Revert \"Undefine Platform and PlatformTarget when getting platforms from a child project\"\n\nThis reverts commit 9b4cbd0aee395b79f629015cffb9e1967ed6e84a.",
          "committedDate": "2021-07-06T17:59:46Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2841da20e4d0163bd354f48ca973d2fc9f922cd1",
          "message": "Move GetPlatforms target for easier copy/paste",
          "committedDate": "2021-07-06T17:59:46Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7ff6614212db497187ce10765026cb411a9364d1",
          "message": "Only warn on $(Platforms) if it's not going to skip the platform logic",
          "committedDate": "2021-07-06T17:59:47Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0ad8a9154f7a399396b7a1c59d4c04b924a5c8dd",
          "message": "Remove defaulting to the single option when $(Platforms) only contains single option",
          "committedDate": "2021-07-06T17:59:47Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5553b7cf7b18e8cd460994e70dd338d183659a75",
          "message": "Make GetCompatiblePlatform its own task. Renamed from GetNearestPlatformTask",
          "committedDate": "2021-07-06T17:59:47Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d480ecf89798c59252fed36b9126aef2b2867271",
          "message": "SetPlatform logic now piggybacks off of SetTF logic. This is accomplished by running after the TF negotiation happened. This fixes edge cases where a multi-tfm project will get an extra eval when SetPlatform is set and MSBuild is then called to extract TF logic",
          "committedDate": "2021-07-07T22:01:37Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c91579c1c324b17ab20d81f853ba87084085b408",
          "message": "Remove dependsontargets to avoid TF target from attempting to run multiple times",
          "committedDate": "2021-07-08T19:08:31Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8cb404515e72df8ae9d2a2aefd0ef07c63eefa00",
          "message": "Default the PlatformLookupTable only when empty",
          "committedDate": "2021-07-08T19:18:21Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6f2e1ae27e0ae518dadb65745ade7740bb7000ab",
          "message": "Default PlatformTarget to Platform when empty",
          "committedDate": "2021-07-08T19:40:48Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a76be89203c26878cd13059bc1d474c59f8b55c1",
          "message": "Add resources for warning from GetCompatiblePlatform task",
          "committedDate": "2021-07-08T20:06:04Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "78d70c60e710a39d248f8a7a8b3287c5646eb53b",
          "message": "Properly use warning resource",
          "committedDate": "2021-07-08T20:55:51Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "12a7fee65205d5b27424b40ac6ab91c2b33d6b9e",
          "message": "Add code for warning when a projectreference has no PlatformOptions",
          "committedDate": "2021-07-08T21:21:04Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1af7349745372f8ca8d64c2860a9ac9b7d89b2b6",
          "message": "Update xlf's",
          "committedDate": "2021-07-08T22:36:08Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21908e3af5b69073561e5b07e2ea60cae1866f91",
          "message": "Fix GetTargetFrameworks returning more items than necessary. CrossTargeting projects always return false for IsVcxOrNativeProj",
          "committedDate": "2021-07-09T21:33:32Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8d7a7956fcccfb95b83e88bc89c3b7eee185aa05",
          "message": "Make output of GetCompatiblePlatform 'private'",
          "committedDate": "2021-07-09T21:42:27Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "55faa41743087c3b4e97b78edb80aead6212684d",
          "message": "Optimize item count checks",
          "committedDate": "2021-07-09T21:44:35Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "121133e660c24bb8a71782d69a837750f4f35e01",
          "message": "Move warning to task for translatable strings",
          "committedDate": "2021-07-09T22:44:56Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3054e9738a3ead5b16c8611aad891f86e08b2eed",
          "message": "Add ProjectReference documentation",
          "committedDate": "2021-07-14T21:19:34Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "744ca6896e33da21ec4071fa04b669c00eb91190",
          "message": "Doc changes",
          "committedDate": "2021-07-15T17:19:57Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a29d5be75f1b6f60bdd88acd51e58b873a6ed9f4",
          "message": "Add tests for GetCompatiblePlatform",
          "committedDate": "2021-07-16T18:41:21Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "adf8ccc2e118d76a4856c7b1a7217fdd653e446f",
          "message": "Allow managed->unmanaged SetPlatform negotiation.\n\nThe MSBuild call in _GetProjectReferenceTargetFrameworkProperties\nnow runs for all vcxproj and nativeproj's when opted into\nEnableDynamicPlatformResolution. These items are specially filtered\ninto AnnotatedProjects and TF resolution logic avoids these.",
          "committedDate": "2021-07-19T21:12:34Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "833ac302f64c079ae804bb3da71fb5d5f4c891bd",
          "message": "PR feedback & code cleanup",
          "committedDate": "2021-07-20T21:51:41Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "953e0ba45234341945477189c53985a85cd84ceb",
          "message": "Fix typo in docs, add example projectreference",
          "committedDate": "2021-07-21T22:37:49Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c1ab9ef3b17a52652817359bf8a8052a66c9041",
          "message": "Clarify platformlookuptable description",
          "committedDate": "2021-07-22T20:54:32Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5acff5451a4d81e970f92d2f9bd9063da554c754",
          "message": "Remove irrelevant comment",
          "committedDate": "2021-07-22T21:03:24Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f29408b325baf17fa2b75a758b2aeba25c72bd5f",
          "message": "GetCompatiblePlatform PR feedback. Rename ParentProjectPlatform to CurrentProjectPlatform. Create method to extract lookup table from a string. Account for ProjectReference item's platformlookuptable. Stop passing in PlatformLookupTable to the task to prevent batching, instead look it up through the metadata",
          "committedDate": "2021-07-22T22:07:56Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "45f7d32341e8ee3cadc228211a35e174d07d3577",
          "message": "Add test where a ProjectReference's PlatformLookupTable takes priority over the current project's lookup table",
          "committedDate": "2021-07-22T22:11:44Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "041a618d86f1ae269e67c9603faaf990d98d1403",
          "message": "Rename childproject to projectreference in tests. Add test for failing when the platformlookuptable of a projectreference is in the incorrect format",
          "committedDate": "2021-07-22T23:28:56Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a0f25bba544670ccd1d28cc6e3dfa72d6c48270c",
          "message": "Add warning for invalid PlatformLookupTables. Tests check for each warning",
          "committedDate": "2021-07-26T17:04:48Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cbd1e8e00b32ba206d45e4c0f482713bc8a1f183",
          "message": "Rename PlatformOptions to Platforms",
          "committedDate": "2021-07-26T19:37:22Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a991ee007703635a74a830db4612b6858d490dc1",
          "message": "Matching platforms takes priority over AnyCPU",
          "committedDate": "2021-07-27T18:51:20Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f4e8c356b2707124597b469dfb279068bb71c504",
          "message": "Add default cpp to managed PlatformLookupTable. Let default PlatformLookupTables be opt-out",
          "committedDate": "2021-07-27T20:06:03Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2e7d06f4e95422399ec1f9f8da38647b18f91592",
          "message": "Remove AnyCPU to Win32 default mapping",
          "committedDate": "2021-07-27T21:27:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "429d09738d34bc89af2e782bf4268a47daa26ae8",
          "message": "Matching platforms takes #1 priority",
          "committedDate": "2021-07-27T21:45:23Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1eac0400d7b030172a9b4bba27d336599ada70c",
          "message": "Construct Platforms via ProjectConfiguration for cpp projects",
          "committedDate": "2021-07-27T23:02:08Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4ffc4dab0d6dbf124182a8172b42091f6185020a",
          "message": "PR Feedback: string.empty, extra keyval check, shouldly",
          "committedDate": "2021-07-27T23:41:10Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a938d7dc8566b6d79e6699dc6b317f491189f54",
          "message": "PR Feedback: Clearer comments and low importance messages",
          "committedDate": "2021-07-28T00:42:26Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "55305209a0135da20001a6570ffb6174828c5371",
          "message": "Reword 'parent' to 'current'",
          "committedDate": "2021-07-28T00:49:55Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "56b466f3fcc233a749be8e1c5bb2e5b7f3051ffe",
          "message": "Reword 'child' to 'projectreference'",
          "committedDate": "2021-07-28T01:08:52Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4fd1fac006cbd8a67ad6c2d3efdcd3dbd4ea5a7",
          "message": "Code cleanup, add resources for low prio messages",
          "committedDate": "2021-07-28T04:06:50Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f9c3e66f9f42e6dccdce39c7ce00068424fa4f07",
          "message": "Enable nullable. Marked required params as required",
          "committedDate": "2021-07-28T04:37:27Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1dbf392b46073fc068063a72ab2fd050264d36a5",
          "message": "Trim whitespace around translation table and each entry",
          "committedDate": "2021-07-28T04:45:00Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d011e32f52c2ca4139102fb2cf4923b12fb048be",
          "message": "Change resource to be more specific about what 'normally' means",
          "committedDate": "2021-07-28T05:19:45Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f483ff09d374d42756b8a2d8081855a31fd9f224",
          "message": "Allow empty entries when splitting individual mappings",
          "committedDate": "2021-07-28T15:36:23Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "948643569e4fcf186ebd384b569a5e6d0a9bf0b9",
          "message": "Revert \"Allow empty entries when splitting individual mappings\"\n\nThis reverts commit f483ff09d374d42756b8a2d8081855a31fd9f224.",
          "committedDate": "2021-07-28T16:10:23Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9404a0c79134b1136fff4b2a1e989ccb09f715c6",
          "message": "Update SetPlatform documentation",
          "committedDate": "2021-07-28T16:59:25Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "275738f3e35d500dd1c036df8af430d8f08ca4a3",
          "message": "dont clear empty entries on equals split. simplify length check",
          "committedDate": "2021-07-28T17:22:43Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3cb5a72d71cfbf59305d89d9f7ac9f1618a5fe88",
          "message": "PR Feedback: Doc clarification",
          "committedDate": "2021-07-29T17:53:02Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "4691428+BenVillalobos@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "/cc: @MarkOsborneMS @yuehuang010 @AArnott \r\n\r\nStill plenty to do in this PR but would appreciate any feedback.",
        "createdAt": "2021-07-06T18:23:44Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Known issue:\r\n\r\nIn the context of A->B(net472;foo;bar), we get extra evaluations that can probably be avoided.\r\n\r\n![image](https://user-images.githubusercontent.com/4691428/124648887-a5794100-de4c-11eb-8b9d-89f36e01cef3.png)\r\n\r\nThinking out loud: When A gets platform data from B, an evaluation occurs with no special global properties. This is fine. BUT when the TargetFramework negotiation logic kicks in, it passes along `SetPlatform`, which results in an extra evaluation of the B(net472;foo;bar) project instance. Should that logic be modified not to pass SetPlatform logic? Maybe only when not in VS scenarios? Need to double check that it's only passed along to prevent extra evals. \r\n\r\nEdit: This can always be a future optimization.\r\n\r\n/cc: @dsplaisted",
        "createdAt": "2021-07-06T18:26:45Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Instead of having a separate call to `GetPlatforms` for referenced projects, can we update `GetTargetFrameworks` so that it also returns the platform information?  That seems like it would solve the double-evaluation problem and might be more performant anyway.",
        "createdAt": "2021-07-06T18:41:34Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "@dsplaisted The reason I couldn't piggyback off of `GetTargetFrameworks` (like I [initially thought I could](https://github.com/dotnet/msbuild/issues/5338#issuecomment-839287604)) is that `GetTargetFrameworks` isn't [called on `.vcxproj` or `.nativeproj` references](https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1660). Would you suggest relaxing that restriction for this feature, or keep them separate?",
        "createdAt": "2021-07-06T19:05:10Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Can you drop that but only if opted into this new feature?",
        "createdAt": "2021-07-06T19:07:03Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald I think that works. It will make the logic in `_GetProjectReferenceTargetFrameworkProperties` slightly less intuitive since it'll also have platform logic, but it's not a high price to pay.\r\n\r\nI wondered what would happen if somewhere down the chain a project wasn't opted in, but we chatted about making it a repo wide opt-in so that shouldn't be a concern either.",
        "createdAt": "2021-07-06T19:23:35Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> BUT when the TargetFramework negotiation logic kicks in, it passes along SetPlatform, which results in an extra evaluation of the B(net472;foo;bar) project instance. Should that logic be modified not to pass SetPlatform logic? \r\n\r\nThat sounds reasonable to me.\r\n\r\n> Instead of having a separate call to GetPlatforms for referenced projects, can we update GetTargetFrameworks so that it also returns the platform information? \r\n\r\nThat seems reasonable too.",
        "createdAt": "2021-07-12T15:33:44Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "@AArnott I've opted for the second option.\r\n\r\n> Instead of having a separate call to GetPlatforms for referenced projects, can we update GetTargetFrameworks so that it also returns the platform information?",
        "createdAt": "2021-07-12T17:53:03Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Ready for review.\r\n\r\n@MarkOsborneMS could I get some feedback on the documentation, since you're likely to adopt this feature first?\r\n\r\n@yuehuang010 you're oof atm, here are some questions I have for the cpp side (/cc: @olgaark):\r\n\r\n1. Is there any sort of property in cpp props/targets that translates to \"I'm a cpp/native project?\" Currently, we check if the project is a `.vcxproj` or `.nativeproj` to determine this.\r\n2. To confirm, building a cpp project and passing `SetPlatform` metadata as `Platform=xyz` (instead of `PlatformTarget=xyz`) is valid? I saw this in cpp.common.props and mimicked it: \r\n```xml\r\n<SetPlatform Condition=\"'%(ProjectReference.SetPlatform)' == '' and '$(Platform_Actual)' == 'x86'\">Platform=x86</SetPlatform>\r\n```",
        "createdAt": "2021-07-16T19:37:06Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "cc @jjmew for visibility, this feature is using `$(Platforms)` metadata for build logic. Other than showing platforms in the VS dropdown, I don't think this property was used elsewhere.",
        "createdAt": "2021-07-19T15:35:09Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "@yuehuang010 \r\n\r\n> You should consider the opposite, off by default, then only those project which are \"supported\" could be opt-ed in. This way, you will have control of all the projects types.\r\n\r\nYou're suggesting there be _no_ default mapping between managed and unmanaged, instead requiring everyone that opts in to manage the table themselves?\r\n\r\n\r\n> Have you created sample projects that actually reproduce this issue? Because vcxproj should just work already.\r\n\r\nI've uploaded the projects I've been working with here: https://github.com/BenVillalobos/setplatform-repro\r\n\r\nThey're repros of the projects described in the original issue.",
        "createdAt": "2021-07-19T19:28:15Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "You need two properties.  The \"desire\" platform and\n\"transversal\" platform.  The project builds the \"desire\" platform (aka\nPlatformTarget) and passes transversal to the P2P.  I don't think it is\npossible to solve the \"transversal\" platform from the \"desire\" platform.\n\nOn Mon, Jul 19, 2021 at 1:33 PM Ben Villalobos ***@***.***>\nwrote:\n\n> *@BenVillalobos* commented on this pull request.\n> ------------------------------\n>\n> In src/Tasks/Microsoft.Common.CurrentVersion.targets\n> <https://github.com/dotnet/msbuild/pull/6655#discussion_r672611635>:\n>\n> > +    </ItemGroup>\n> +\n> +    <ItemGroup>\n> +      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\"\n> +                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n> +    </ItemGroup>\n> +\n> +    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n> +    <PropertyGroup>\n> +      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n> +      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n> +    </PropertyGroup>\n> +\n> +    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n> +    <ItemGroup>\n> +      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n>\n> Thinking on this: We shouldn't pass Platform to ProjectReference items if\n> we don't know for sure that it can build with that (child project listing\n> it in Platforms or a PlatformTranslationTable being defined).\n>\n> If we pass it through then unmanaged platforms would be built with\n> Platform=AnyCPU which both doesn't make sense and would give us an\n> evaluation that we then need to dig into to see what AnyCPU actually\n> converted into.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dotnet/msbuild/pull/6655#discussion_r672611635>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEXI5GOGWWST2E57UHR3NDDTYSD3LANCNFSM475CT6WA>\n> .\n>\n",
        "createdAt": "2021-07-19T20:42:43Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "@yuehuang010 I assume you mean \"desire\" platform as the parent's platform, and \"transversal\" as the \"correct\" translation? The transversal platform in this case is the translation table that should be supplied in a given project that goes from unmanaged<->managed.\r\n\r\nWhat is the preferred outcome when A can't determine what B should build as? It sounds like you prefer B building with A's platform in this case, allowing the error case. The current agreed upon implementation is to warn and tell B to build without a platform, deferring to @AArnott or @MarkOsborneMS here",
        "createdAt": "2021-07-19T21:05:03Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "My bad for using autocomplete.  I meant \"Traversal\".\n\"*Traversal*\" is the Platform passed in P2P.  This is also the\ndefault platform and user platform set on the command line.  I don't want\nto use the word \"translated\" or \"mapped\" as that limits the thinking to a\nspecific method.\n\n\"Desire\" or \"Current\" or \"Target\" Platform is the platform that the current\nproject will build.\n\n\n\n\n\nOn Mon, Jul 19, 2021 at 2:05 PM Ben Villalobos ***@***.***>\nwrote:\n\n> @yuehuang010 <https://github.com/yuehuang010> I assume you mean \"desire\"\n> platform as the parent's platform, and \"transversal\" as the \"correct\"\n> translation? The transversal platform in this case is the translation table\n> that should be supplied in a given project that goes from\n> unmanaged<->managed.\n>\n> What is the preferred outcome when A can't determine what B should build\n> as? It sounds like you prefer B building with A's platform in this case,\n> allowing the error case. The current agreed upon implementation is to warn\n> and tell B to build without a platform, deferring to @AArnott\n> <https://github.com/AArnott> or @MarkOsborneMS\n> <https://github.com/MarkOsborneMS> here\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dotnet/msbuild/pull/6655#issuecomment-882858334>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEXI5GJSFY7ZNLIQEIERBH3TYSHQVANCNFSM475CT6WA>\n> .\n>\n",
        "createdAt": "2021-07-19T21:34:20Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "@yuehuang010 Wanted to confirm that you're okay with the implementation here. The path we're going is by requiring a \"desired\" (current proj platform) and a \"traversal\" (platform lookup table) for cases such as win32->anycpu/x86.\r\n\r\nIn theory when a cpp proj is being built anycpu, it could determine what it should build as on its own (like you mentioned [here](https://github.com/dotnet/msbuild/pull/6655#discussion_r667252518)), but that seems overly complicated when we can determine it ahead of time via this feature and an extra property.",
        "createdAt": "2021-07-22T19:12:42Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> @yuehuang010 Wanted to confirm that you're okay with the implementation here. The path we're going is by requiring a \"desired\" (current proj platform) and a \"traversal\" (platform lookup table) for cases such as win32->anycpu/x86.\r\n> \r\n> In theory when a cpp proj is being built anycpu, it could determine what it should build as on its own (like you mentioned [here](https://github.com/dotnet/msbuild/pull/6655#discussion_r667252518)), but that seems overly complicated when we can determine it ahead of time via this feature and an extra property.\r\n\r\nHave you determine what will happen in this diamond case?\r\n````\r\n /--> B -\\\r\nA          D\r\n \\--> C -/\r\n`````\r\nCase 1) A, B, and D are csproj and C is CLI/C++.  D should only build a single platform.\r\nCase 2) A and B are csproj with C and D are CLI/C++.  D should only build a single platform.\r\n\r\nI think case 2 will be ok, but case 1 will have issues.  The path ABD will be anycpu,anycpu,anycpu, while the path ACD will be anycpu,x86,x86.  This would lead to D being built for x86 and anycpu.  Suppose the vcxproj wants x64.  ACD path will be anycpu,x64,x64.  Mapping x86 back to anycpu won't work in x64 case.  ",
        "createdAt": "2021-07-22T19:45:56Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "> You need two properties.  The \"desire\" platform and\r\n\"transversal\" platform.  The project builds the \"desire\" platform (aka\r\nPlatformTarget) and passes transversal to the P2P.  I don't think it is\r\npossible to solve the \"transversal\" platform from the \"desire\" platform.\r\n\r\n@yuehuang010 Are you talking about two global properties? I don't think we should go there. That will cause significant overbuild with no gain that I can see. A project should build the same way for a given platform no matter what platform its referencing project targets. I feel this applies to C# and C++ projects equally. \r\n\r\nCC: @BenVillalobos",
        "createdAt": "2021-07-22T19:48:38Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "> Case 1) A, B, and D are csproj and C is CLI/C++. D should only build a single platform.\r\nThe path ABD will be anycpu,anycpu,anycpu, while the path ACD will be anycpu,x86,x86\r\n\r\nWhat is the ideal case here? Is it D=x86/x86? D=AnyCPU/AnyCPU? Whatever the case, if we know there's an overbuild problem then we can define a `PlatformLookupTable` that would inform D what to build as so we don't get the overbuild.",
        "createdAt": "2021-07-22T20:00:01Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "@AArnott \r\n\r\n> A project should build the same way for a given platform no matter what platform its referencing project targets. I feel this applies to C# and C++ projects equally.\r\n\r\nCould you elaborate on this a bit? Where is the \"given platform\" coming from? I've always seen \"the given platform\" as what the referencing project is building as.",
        "createdAt": "2021-07-22T20:04:10Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> > Case 1) A, B, and D are csproj and C is CLI/C++. D should only build a single platform.\r\n> > The path ABD will be anycpu,anycpu,anycpu, while the path ACD will be anycpu,x86,x86\r\n> \r\n> What is the ideal case here? Is it D=x86/x86? D=AnyCPU/AnyCPU? Whatever the case, if we know there's an overbuild problem then we can define a `PlatformLookupTable` that would inform D what to build as so we don't get the overbuild.\r\n\r\nI don't think it is solvable with a lookup table because everytime the lookup is used, you can think of it as forking the subproject.  While this is handy to perform batching build, it makes Diamond patterns impossible to be deterministic.  ",
        "createdAt": "2021-07-22T20:26:07Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "> I don't think it is solvable with a lookup table because every time the lookup is used, you can think of it as forking the subproject. While this is handy to perform batching build, it makes Diamond patterns impossible to be deterministic.\r\n\r\nCan you give me a scenario that does what your describing? I'm not sure what you mean as forking the subproject. Its possible that C->D needs a lookup table while B->D does not, but would still result in D being built as the same platform.",
        "createdAt": "2021-07-22T20:48:14Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": ">> Case 1) A, B, and D are csproj and C is CLI/C++. D should only build a single platform.\r\nThe path ABD will be anycpu,anycpu,anycpu, while the path ACD will be anycpu,x86,x86\r\n\r\n> What is the ideal case here? Is it D=x86/x86? D=AnyCPU/AnyCPU? Whatever the case, if we know there's an overbuild problem then we can define a PlatformLookupTable that would inform D what to build as so we don't get the overbuild.\r\n\r\nABD is arguably invalid, because an AnyCPU project should not be referencing an x86 project. Or if it does, it should be an explicit opt-in at that ProjectReference. Either way, C->D where C is x86 and D offers an x86 option should _always_ produce D with x86. No matter whether \"A\" appears in front of C.",
        "createdAt": "2021-07-22T22:15:16Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": ">> A project should build the same way for a given platform no matter what platform its referencing project targets. I feel this applies to C# and C++ projects equally.\r\n\r\n> Could you elaborate on this a bit? Where is the \"given platform\" coming from? I've always seen \"the given platform\" as what the referencing project is building as.\r\n\r\nThe given platform is whatever the project is built with for its `Platform` global property. For the top-level project, that would be how it's built at the CLI with `/p:Platform=x86` or whatever its default is set to. Or for a project built due to P2P, it's whatever the referencing project decided to pass in (after platform negotiation) when building its dependency.",
        "createdAt": "2021-07-22T22:17:31Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "> > > Case 1) A, B, and D are csproj and C is CLI/C++. D should only build a single platform.\r\n> > > The path ABD will be anycpu,anycpu,anycpu, while the path ACD will be anycpu,x86,x86\r\n> \r\n> > What is the ideal case here? Is it D=x86/x86? D=AnyCPU/AnyCPU? Whatever the case, if we know there's an overbuild problem then we can define a PlatformLookupTable that would inform D what to build as so we don't get the overbuild.\r\n> \r\n> ABD is arguably invalid, because an AnyCPU project should not be referencing an x86 project. Or if it does, it should be an explicit opt-in at that ProjectReference. Either way, C->D where C is x86 and D offers an x86 option should _always_ produce D with x86. No matter whether \"A\" appears in front of C.\r\n\r\nToday vcxproj doesn't have AnyCPU so when a C# (anycpu) reference it, the vcxproj will build with x86.  This works today even without a solution.  \r\n\r\nWhat if D offers AnyCPU and x86?  Then paths ABD and ACD will build different platforms.  Project A will need to resolve which of those dll are needed for runtime because they both share the same file name.",
        "createdAt": "2021-07-22T22:36:51Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "@yuehuang010\r\n\r\n> Today vcxproj doesn't have AnyCPU so when a C# (anycpu) reference it, the vcxproj will build with x86. This works today even without a solution.\r\n\r\nThis situation would get the default translation of AnyCPU=Win32 from here: https://github.com/dotnet/msbuild/pull/6655/files#diff-5407d46dd30ce4031e530c35cc2e0a62a6c96e54cb1def14fb316f351ef92de9R1651\r\n\r\n> What if D offers AnyCPU and x86? Then paths ABD and ACD will build different platforms. \r\n\r\nSee https://github.com/dotnet/msbuild/pull/6655/files#diff-819eb5b5b3186cc588bc0bb97ac0a62933da12730465af953b86a8a7b4d3c60aR102, in the case of _any_ project where AnyCPU is available and there is no translation table, AnyCPU will be chosen.",
        "createdAt": "2021-07-22T23:07:43Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "For clarification here's how this feature would work in the diamond case:\r\n\r\n```\r\n /--> B -\\\r\nA          D\r\n \\--> C -/\r\n```\r\n\r\nA is managed AnyCPU\r\nB is managed AnyCPU/x86\r\nC is unmanaged x86\r\nD is managed AnyCPU/x86\r\n\r\nA->B->D will be built AnyCPU all the way through.\r\n\r\nA->C will need some translation from AnyCPU to something C can build as. Either in A's project or in the `ProjectReference` item for C, otherwise a warning is logged and C is build with no platform specified.\r\n\r\nC -> D, lets say C was building as x86. D would build as AnyCPU because we default to AnyCPU when there's no translation table that provides x86 to something that D can build as.\r\n\r\nHere's the simplified logic of how platforms are chosen for project references (where \"parent\" is the currently building project and \"child\" is the ProjectReference):\r\n1. Does the child have a `PlatformTranslationTable `defined? Use that to find a mapping if possible\r\n2. Does the parent have a `PlatformTranslationTable` defined? Use that to find a mapping if possible\r\n3. Can the child build as AnyCPU? Use that if possible.\r\n4. Can the child build with the same platform as the parent project? Use that.\r\n5. Can't determine the platform to pass along, log a warning and undefine platform.",
        "createdAt": "2021-07-22T23:22:20Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Consider this case for this diamond.\r\nA is unmanaged x86,x64\r\nB is managed AnyCPU\r\nC is unmanaged x86,x64\r\nD is unmanaged x86,x64\r\n\r\nABD path will have x64,AnyCPU,x86.\r\nACD path will have x64,x64,x64.  ",
        "createdAt": "2021-07-23T00:27:43Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "@yuehuang010 Right, without B having context on A's build there's no way for B to tell D to build specifically as x64 without specifying a lookup table.\r\n\r\nThis PR won't be solving the problem of B telling D to build as x64 when A builds x64, or x86 when A is x86, but it's a starting point. cc @AArnott ",
        "createdAt": "2021-07-23T18:36:18Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> Consider this case for this diamond.\r\nA is unmanaged x86,x64\r\nB is managed AnyCPU\r\nC is unmanaged x86,x64\r\nD is unmanaged x86,x64\r\nABD path will have x64,AnyCPU,x86.\r\nACD path will have x64,x64,x64.\r\n\r\nHow common is a scenario like this in VS? cc @forrestcoward",
        "createdAt": "2021-07-26T16:36:38Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Note to self for possible perf improvement: If the ProjectReference is about to be assigned `SetPlatform` metadata and it only has one possible platform, should we undefine `SetPlatform` to avoid another evaluation?\r\n\r\nPro: Skip an unnecessary eval.\r\n\r\nCons: What if, by default, that platform would build as something outside of its `Platforms` list?\r\n\r\nEx: Managed project has (x86) as `Platforms`, but undefining `SetPlatform` and having the project build on its own would have it default to `AnyCPU`. Or an unmanaged project that lists x64, but without it being passed `SetPlatform` it would default to x86.",
        "createdAt": "2021-07-26T19:10:02Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> Today vcxproj doesn't have AnyCPU so when a C# (anycpu) reference it, the vcxproj will build with x86. This works today even without a solution.\r\n\r\nThat's not great. That means my \"AnyCPU\" C# project is quietly degraded to a CPU-specific binary by virtue of a dependency. As I mentioned before, C# -> C# doesn't allow such a P2P jump without a warning. Why should C# -> C++ get away with it?\r\n\r\n> What if D offers AnyCPU and x86? Then paths ABD and ACD will build different platforms. Project A will need to resolve which of those dll are needed for runtime because they both share the same file name.\r\n\r\nThat's fine. A is AnyCPU and without C in the path, all assemblies should be AnyCPU. But as soon as C is in the path, A is committed to x86 so bringing in D as x86 is a Good Thing. Note that in this case D offers *both* x86 and AnyCPU. Since AnyCPU is generally more portable, presumably an x86 platform is offered because it's better when it applies. This is similar to how TFMs are resolved: netstandard is portable, but net472 is preferred when compatible. \r\nTherefore ABD produces an AnyCPU portable application where D is AnyCPU to match. And ACD produces an x86-only application where D takes advantage of that fact and deploys its x86 binary. But still: A being AnyCPU in this case is a misnomer, and ACD should only be allowed when A is itself x86 or when it explicitly sets the Platform on the C reference to win32.\r\n\r\n> 3. Can the child build as AnyCPU? Use that if possible.\r\n> 4. Can the child build with the same platform as the parent project? Use that.\r\n \r\nIMO these two should be reversed. The child should inherit the parent platform if they are compatible. AnyCPU is *not* preferred  when a platform-specific alternative is compatible and available, which I justify earlier in this comment.\r\n\r\n> Consider this case for this diamond.\r\nA is unmanaged x86,x64\r\nB is managed AnyCPU\r\nC is unmanaged x86,x64\r\nD is unmanaged x86,x64\r\n> \r\n> ABD path will have x64,AnyCPU,x86.\r\nACD path will have x64,x64,x64.\r\n\r\nThat again is arguably broken because B is *claiming* to be AnyCPU while depending on a specific architecture component. And per my proposed policy of blocking this (or at least flagging a warning), this would resolve by B either becoming arch-specific, or explicitly setting the platform on the ProjectReference item, at which point ABD and ACD will produce the same result.",
        "createdAt": "2021-07-26T22:47:14Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "In this solution ([ConsoleApp4.zip](https://github.com/dotnet/msbuild/files/6881606/ConsoleApp4.zip)) I have a C# AnyCPU console application with P2Ps to a C# x86 project and a C++ Win32 project.\r\nWhen building the *solution* within VS or at the command line, a warning is emitted for the C#->C# jump, but (oddly) not for the C#->C++ jump:\r\n\r\n```\r\n msbuild /t:rebuild /v:m /p:Platform=x86\r\nMicrosoft (R) Build Engine version 17.0.0-preview-21370-03+eac68aa8b for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  You are using a preview version of .NET. See: https://aka.ms/dotnet-core-preview\r\n  pch.cpp\r\n  dllmain.cpp\r\n  Cppx86.vcxproj -> C:\\temp\\ConsoleApp4\\Debug\\Cppx86.dll\r\n  CSx86 -> C:\\temp\\ConsoleApp4\\ClassLibrary1\\bin\\x86\\Debug\\net6.0\\CSx86.dll\r\nC:\\Program Files\\Microsoft Visual Studio\\2022\\IntPreview\\MSBuild\\Current\\Bin\\amd64\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3270: There was a mismatch between the processor architecture of the project being built \"MSIL\" and the processor architectu\r\nre of the reference \"C:\\temp\\ConsoleApp4\\ClassLibrary1\\bin\\x86\\Debug\\net6.0\\CSx86.dll\", \"x86\". This mismatch may cause runtime failures. Please consider changing the targeted processor architecture of your project through the Configuration Manager so as to align the\r\nprocessor architectures between your project and references, or take a dependency on references with a processor architecture that matches the targeted processor architecture of your project. [C:\\temp\\ConsoleApp4\\ConsoleApp4\\ConsoleApp4.csproj]\r\n  ConsoleApp4 -> C:\\temp\\ConsoleApp4\\ConsoleApp4\\bin\\Debug\\net6.0\\ConsoleApp4.dll\r\n```\r\n\r\nAlso oddly, when building the C# console app itself (without help from the solution configuration), no warning *at all* appears:\r\n\r\n```\r\nmsbuild /t:rebuild .\\ConsoleApp4\\ /v:m\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  You are using a preview version of .NET. See: https://aka.ms/dotnet-core-preview\r\n  pch.cpp\r\n  dllmain.cpp\r\n  Cppx86.vcxproj -> C:\\temp\\ConsoleApp4\\Cppx86\\Debug\\Cppx86.dll\r\n  CSx86 -> C:\\temp\\ConsoleApp4\\ClassLibrary1\\bin\\x86\\Debug\\net6.0\\CSx86.dll\r\n  ConsoleApp4 -> C:\\temp\\ConsoleApp4\\ConsoleApp4\\bin\\Debug\\net6.0\\ConsoleApp4.dll\r\n```\r\n\r\nSo what I'm hoping for is:\r\n1. a warning for any and all jumps from AnyCPU to a CPU-arch-specific platform unless it is suppressed by an explicit platform set at the P2P (or the translation table)\r\n2. every parent/child relationship picks the best match as @BenVillalobos describes in https://github.com/dotnet/msbuild/pull/6655#issuecomment-885299089 but with 3 and 4 reversed so that AnyCPU is less preferred than a CPU arch-specific match.",
        "createdAt": "2021-07-26T22:58:12Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "On another note, @BenVillalobos, when a project targets multiple platforms, will this change (or a subsequent one you have planned) also cause that building that project as a top-level project with no `/p:Platform=` specified will build *all* its platforms, similar to how multi-targeting TFM projects build all frameworks where none is specified or negotiated?",
        "createdAt": "2021-07-26T23:00:20Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "> will this change (or a subsequent one you have planned) also cause that building that project as a top-level project with no /p:Platform= specified will build all its platforms, similar to how multi-targeting TFM projects build all frameworks where none is specified or negotiated?\r\n\r\nYou mean a `DispatchToInnerBuilds` equivalent? (I believe that's the target that runs when you multi-target tfms) No, this PR only handles setting `SetPlatform` before jumping to the next ProjectReference build. It's also not part of a roadmap, is that of significant interest to VS? cc @marcpopMSFT ",
        "createdAt": "2021-07-26T23:28:13Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> But as soon as C is in the path, A is committed to x86 so bringing in D as x86 is a Good Thing\r\n\r\nThis confused me for a sec, as A can't know what C will be building as ahead of time. At least with this implementation.\r\n\r\n> But still: A being AnyCPU in this case is a misnomer, and ACD should only be allowed when A is itself x86 or when it explicitly sets the Platform on the C reference to win32.\r\n\r\nSolves that confusion. Though this feature won't stop that from building. At the moment, if A->foo would have foo built as something incompatible to A, we will warn and just have it build with no platform set.",
        "createdAt": "2021-07-26T23:34:36Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> IMO these two should be reversed. The child should inherit the parent platform if they are compatible. AnyCPU is not preferred when a platform-specific alternative is compatible and available, which I justify earlier in this comment.\r\n\r\nAn easy enough fix. From our discussion a while back, it sounded like a big problem was \"many architecture-specific projects point to an AnyCPU project, but that AnyCPU project is still built with many architectures, causing 'over-builds'\". Wouldn't this continue that trend? Maybe the `PlatformLookupTable` is the \"right\" solution in these cases, instead of defaulting to anycpu?",
        "createdAt": "2021-07-26T23:38:53Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Tossed this into an experimental branch and it passed RPS. No surprise since it's opt-in.",
        "createdAt": "2021-07-27T17:59:00Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> we will warn and just have it build with no platform set.\r\n\r\nA warning should be fine, particularly if it respects the TreatWarningsAsErrors property so we can elevate it if we wish.\r\n\r\n> You mean a DispatchToInnerBuilds equivalent? (I believe that's the target that runs when you multi-target tfms) No, this PR only handles setting SetPlatform before jumping to the next ProjectReference build. It's also not part of a roadmap, is that of significant interest to VS?\r\n\r\nYes, that's what I was referring to. I recall believing that VS either needed this, or quickbuild/cloudbuild would have to make an enhancement that they seemed unlikely to make. But I can't remember the details. I'll see what I can recover and file a separate issue if we need this.\r\n\r\n> From our discussion a while back, it sounded like a big problem was \"many architecture-specific projects point to an AnyCPU project, but that AnyCPU project is still built with many architectures, causing 'over-builds'\". Wouldn't this continue that trend? Maybe the PlatformLookupTable is the \"right\" solution in these cases, instead of defaulting to anycpu?\r\n\r\nWe certainly do not want our AnyCPU projects over-building due to P2Ps from arch-specific projects. But if 4 came before 3, such that those two were now ordered like this: (using letters to avoid confusion with the original order\r\n\r\n> A. Can the child build with the same platform as the parent project? Use that.\r\nB. Can the child build as AnyCPU? Use that if possible.\r\n\r\nThen **A** would be skipped because the if the parent is x86, it will fail the check as the child cannot build as x86. It would then fallback to **B**, which is what we want.\r\n\r\nFor that to work, the AnyCPU project would have to express the platforms it is willing to be built with. In the VS repo we have a property that reflects this already. I believe in the shipping .targets for the SDK style C# projects there is a `Platforms` property that contains the list, which I'm expecting you're already using for the compatibility checks. (I haven't studied the content of this PR to know.)",
        "createdAt": "2021-07-27T18:12:49Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "> Then A would be skipped because the if the parent is x86, it will fail the check as the child cannot build as x86. It would then fallback to B, which is what we want.\r\n\r\nI see, so it's up to the referred project to stray away from listing something like `Platforms: x86;x64;AnyCPU` and stick to `AnyCPU`. Will make the change.\r\n\r\n> I believe in the shipping .targets for the SDK style C# projects there is a Platforms property that contains the list, which I'm expecting you're already using for the compatibility checks. (I haven't studied the content of this PR to know.)\r\n\r\nYes, this PR expects referred projects to contain a `Platforms` property with all platforms it is willing to build as. If no `Platforms` is specified in the referenced project, a warning will be logged. I believe the default in .NET.Sdk.props is `<Platforms Condition=\" '$(Platforms)' == '' \">AnyCPU</Platforms>`",
        "createdAt": "2021-07-27T18:21:53Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Notes from the meeting between @AArnott and @yuehuang010 and myself today:\r\n\r\n\u2714\ufe0f We should construct the set of platforms a cpp or nativeproj can build as via its itemgroup labeled `ProjectConfigurations`, which has the `Platform` for each configuration.\r\n\u274c Whenever we're currently building as AnyCPU and \"hop off\" to any non-AnyCPU architecture, we should log a warning when it isn't a \"user-specified\" (lookup table) hop\r\n\t- On second thought, the only way this _could_ happen is if it came from a lookup table. \r\n\u2714\ufe0f If the current project platform matches the referenced project's platform, that should **always** take priority.\r\n\u2714\ufe0f AnyCPU should _not_ map to Win32 by default",
        "createdAt": "2021-07-27T21:39:17Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> AnyCPU should not map to Win32 by default\r\n\r\n@AArnott When a customer opts into this feature and has no PlatformLookupTable, a ProjectReference from a managed project to an unmanaged project won't \"just work\". You were pushing for a solution that had the feature do most of the work, is requiring a lookup table in this scenario acceptable? The answer must be yes since we agreed AnyCPU shouldn't map to win32 by default, just double checking.\r\n\r\nThis doesn't change the fact that if A was x86, it would see that B could be x86 and map to that by default.",
        "createdAt": "2021-07-28T05:10:21Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> This doesn't change the fact that if A was x86, it would see that B could be x86 and map to that by default.\r\n\r\nWe also want a C# x86 project to reference a C++ win32 project without any extra effort. So a default mapping of x86=win32 is desirable.\r\n\r\nBut yes, I think AnyCPU=win32 is *not* a good thing. Warn by default for such jumps, and make it easy to suppress the warning (by adding to the lookup table or adding `SetPlatform` metadata) for those that want that behavior.",
        "createdAt": "2021-07-28T14:19:11Z",
        "author": {
          "login": "AArnott"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Add a code for this",
              "createdAt": "2021-07-06T18:21:17Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,97 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          BeforeTargets=\"_GetProjectReferenceTargetFrameworkProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <MSBuild Projects=\"@(_MSBuildProjectReferenceExistent)\"\n+        Targets=\"GetPlatforms\"\n+        BuildInParallel=\"$(BuildInParallel)\"\n+        ContinueOnError=\"!$(BuildingProject)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"\n+        SkipNonexistentTargets=\"true\">\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferencePlatformPossibilities\" />\n+    </MSBuild>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable>AnyCPU=Win32;x86=Win32;x64=x64</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <Warning Condition=\"'@(_ProjectReferencePlatformPossibilities.SkipGetPlatformProperties)' == '' and '%(_ProjectReferencePlatformPossibilities.PlatformOptions)' == ''\" ",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "cc @yuehuang010 is anycpu->win32 acceptable here as a default?\r\n\r\nAlso note to self: this property should not assign a value to `PlatformLookupTable` if it's already set (to allow user customization)",
              "createdAt": "2021-07-06T18:22:51Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,97 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          BeforeTargets=\"_GetProjectReferenceTargetFrameworkProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <MSBuild Projects=\"@(_MSBuildProjectReferenceExistent)\"\n+        Targets=\"GetPlatforms\"\n+        BuildInParallel=\"$(BuildInParallel)\"\n+        ContinueOnError=\"!$(BuildingProject)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"\n+        SkipNonexistentTargets=\"true\">\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferencePlatformPossibilities\" />\n+    </MSBuild>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable>AnyCPU=Win32;x86=Win32;x64=x64</PlatformLookupTable>",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "How would vcxproj --> csproj work?  What platform will vcx set for cs project?  AnyCPU or x86?\r\nLikewise, csproj --> vcxproj --> csproj, will have platform AnyCPU --> Win32 --> AnyCPU or x86?",
              "createdAt": "2021-07-06T23:47:51Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,97 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          BeforeTargets=\"_GetProjectReferenceTargetFrameworkProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <MSBuild Projects=\"@(_MSBuildProjectReferenceExistent)\"\n+        Targets=\"GetPlatforms\"\n+        BuildInParallel=\"$(BuildInParallel)\"\n+        ContinueOnError=\"!$(BuildingProject)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"\n+        SkipNonexistentTargets=\"true\">\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferencePlatformPossibilities\" />\n+    </MSBuild>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable>AnyCPU=Win32;x86=Win32;x64=x64</PlatformLookupTable>",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "Do you have a test repro/solution that has an issue with vcxproj?  I have implemented this for vcxproj so it should just work if you call it like a csproj.",
              "createdAt": "2021-07-07T00:19:21Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,97 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          BeforeTargets=\"_GetProjectReferenceTargetFrameworkProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <MSBuild Projects=\"@(_MSBuildProjectReferenceExistent)\"\n+        Targets=\"GetPlatforms\"\n+        BuildInParallel=\"$(BuildInParallel)\"\n+        ContinueOnError=\"!$(BuildingProject)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"\n+        SkipNonexistentTargets=\"true\">\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferencePlatformPossibilities\" />\n+    </MSBuild>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable>AnyCPU=Win32;x86=Win32;x64=x64</PlatformLookupTable>",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "> How would vcxproj --> csproj work? What platform will vcx set for cs project? AnyCPU or x86?\r\n\r\nWould love your input on that actually. If you have any vcx->cs reference you need to define `PlatformLookupTable` in that `vcxproj` or somewhere for that project. Is there any sort of acceptable \"default\" platform lookup for vcx->cs?\r\n\r\n> Likewise, csproj --> vcxproj --> csproj, will have platform AnyCPU --> Win32 --> AnyCPU or x86?\r\n\r\nIn this example of A->B->C, there's currently no way for C to know that A built with AnyCPU. The path forward here is to define the `PlatformLookupTable` in B so that it knows what it should point a Win32 build to.\r\n\r\nALso note to self: x64=x64 is not necessary. The logic already exists in the task.",
              "createdAt": "2021-07-07T01:22:22Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,97 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          BeforeTargets=\"_GetProjectReferenceTargetFrameworkProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <MSBuild Projects=\"@(_MSBuildProjectReferenceExistent)\"\n+        Targets=\"GetPlatforms\"\n+        BuildInParallel=\"$(BuildInParallel)\"\n+        ContinueOnError=\"!$(BuildingProject)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"\n+        SkipNonexistentTargets=\"true\">\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferencePlatformPossibilities\" />\n+    </MSBuild>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable>AnyCPU=Win32;x86=Win32;x64=x64</PlatformLookupTable>",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "IMO AnyCPU->Win32 should never happen automatically. C# doesn't even allow a C#->C# p2p from AnyCPU->x86 (without a warning, at least). AnyCPU is supposed to mean you are architecture agnostic, but you aren't if you reference an architecture-specific project.\r\nvcxproj->csproj should map to arch-specific if there is a match (e.g. win32->x86, x64->x64) and fallback to AnyCPU otherwise (e.g. win32->anycpu).\r\n\r\n> In this example of A->B->C, there's currently no way for C to know that A built with AnyCPU.\r\n\r\nIt shouldn't know. We don't want C influenced by A. When I build B with a given platform it should build the same (including with C) whether or not B was the top-level build or built as a P2P target of A. Given B is Win32, C should be build with x86 if there is one, or AnyCPU otherwise. ",
              "createdAt": "2021-07-12T15:30:15Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,97 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          BeforeTargets=\"_GetProjectReferenceTargetFrameworkProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <MSBuild Projects=\"@(_MSBuildProjectReferenceExistent)\"\n+        Targets=\"GetPlatforms\"\n+        BuildInParallel=\"$(BuildInParallel)\"\n+        ContinueOnError=\"!$(BuildingProject)\"\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)\"\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"\n+        SkipNonexistentTargets=\"true\">\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferencePlatformPossibilities\" />\n+    </MSBuild>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable>AnyCPU=Win32;x86=Win32;x64=x64</PlatformLookupTable>",
              "author": {
                "login": "AArnott"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: it's actually faster to do `'@(item)' == ''`, because of this optimization:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/cdc5faeda066a83b084c96b8a455ad0a5e8713ab/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs#L45-L56",
              "createdAt": "2021-07-08T20:08:30Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,81 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this be more descriptive, and conditioned on a property or something rather than extension? In the project itself we should be able to know whether it's a C++ project.",
              "createdAt": "2021-07-09T21:12:19Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -46,6 +46,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n         <IsRidAgnostic>false</IsRidAgnostic>\n         <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <!-- Extract necessary information for SetPlatform negotiation -->\n+        <IsVcxOrNativeProj Condition=\"'%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj'\">true</IsVcxOrNativeProj>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good timing, I actually _just_ caught this as a bug. Using metadata here causes issues with batching over each project reference and we end up with extra items being returned.\r\n\r\nThis is now using $(MSBuildProjectExtension) to check extension. @yuehuang010 does such a \"I'm a cpp project\" property exist?",
              "createdAt": "2021-07-09T21:30:38Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -46,6 +46,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n         <IsRidAgnostic>false</IsRidAgnostic>\n         <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <!-- Extract necessary information for SetPlatform negotiation -->\n+        <IsVcxOrNativeProj Condition=\"'%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj'\">true</IsVcxOrNativeProj>",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I think there is Property Language.  But project extensions is better.\r\n",
              "createdAt": "2021-07-09T23:20:32Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -46,6 +46,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n         <IsRidAgnostic>false</IsRidAgnostic>\n         <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <!-- Extract necessary information for SetPlatform negotiation -->\n+        <IsVcxOrNativeProj Condition=\"'%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj'\">true</IsVcxOrNativeProj>",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you move this into the task so it can be localized?",
              "createdAt": "2021-07-09T21:17:11Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,88 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <Warning Condition=\"'%(_ProjectReferencePlatformPossibilities.PlatformOptions)' == ''\"\n+           Code=\"MSB3982\" \n+           Text=\"EnableDynamicPlatformResolution is enabled, but '%(_ProjectReferencePlatformPossibilities.Identity)' has no 'Platforms' set. It will be built without a specified platform.\"/>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Opted for this to avoid an unnecessary task call. We have other `Warning` calls that have codes and non-translated text. Out of curiosity, what's the deciding factor there? #legacy?\r\n\r\nWill pop this into the task regardless.",
              "createdAt": "2021-07-09T21:36:45Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,88 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <Warning Condition=\"'%(_ProjectReferencePlatformPossibilities.PlatformOptions)' == ''\"\n+           Code=\"MSB3982\" \n+           Text=\"EnableDynamicPlatformResolution is enabled, but '%(_ProjectReferencePlatformPossibilities.Identity)' has no 'Platforms' set. It will be built without a specified platform.\"/>",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "All of our user-facing errors should be localized. We can sometimes get away with an unlocalized string if it's \"something's horked with your installation\" or \"this condition should never happen\" type stuff, plus some stuff has just Been Like That.",
              "createdAt": "2021-07-09T21:52:52Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,88 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <Warning Condition=\"'%(_ProjectReferencePlatformPossibilities.PlatformOptions)' == ''\"\n+           Code=\"MSB3982\" \n+           Text=\"EnableDynamicPlatformResolution is enabled, but '%(_ProjectReferencePlatformPossibilities.Identity)' has no 'Platforms' set. It will be built without a specified platform.\"/>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Output should be \"private\", right?",
              "createdAt": "2021-07-09T21:18:35Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,88 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent->Count())' != '0'\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <Warning Condition=\"'%(_ProjectReferencePlatformPossibilities.PlatformOptions)' == ''\"\n+           Code=\"MSB3982\" \n+           Text=\"EnableDynamicPlatformResolution is enabled, but '%(_ProjectReferencePlatformPossibilities.Identity)' has no 'Platforms' set. It will be built without a specified platform.\"/>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"\n+                            Condition=\"'@(_ProjectReferencePlatformPossibilities->Count())' != '0' and '%(_ProjectReferencePlatformPossibilities.PlatformOptions)' != ''\">\n+      <Output ItemName=\"ProjectsWithPlatformAssignment\" TaskParameter=\"AssignedProjectsWithPlatform\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Also today C++ projects don't support multitargeting/cross-targeting so you can probably just say `false` here.",
              "createdAt": "2021-07-09T21:25:11Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -46,6 +46,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n         <IsRidAgnostic>false</IsRidAgnostic>\n         <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <!-- Extract necessary information for SetPlatform negotiation -->\n+        <IsVcxOrNativeProj Condition=\"'%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj'\">true</IsVcxOrNativeProj>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You don't need to special case for vcxproj.  Just pass the init $(Platform) and the vcxproj already handles the rest.",
              "createdAt": "2021-07-09T23:24:47Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "So there's already default case for a cpp project receiving `AnyCPU` as the `Platform`? Where is that handled?",
              "createdAt": "2021-07-19T19:28:22Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Thinking on this: We shouldn't pass `Platform` to `ProjectReference` items if we don't know for sure that it can build with that (child project listing it in `Platforms` or a `PlatformTranslationTable` being defined).\r\n\r\nIf we pass it through then unmanaged platforms would be built with `Platform=AnyCPU` which both doesn't make sense and would give us an evaluation that we then need to dig into to see what AnyCPU actually converted into.",
              "createdAt": "2021-07-19T20:33:46Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'm confused here. Why do you need to check that it is neither a vcxproj nor a nativeproj, but something else IsVcxOrNativeProj?",
              "createdAt": "2021-07-19T23:07:11Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`$(MSBuildProjectExtension)` is the current project's file extension, `'%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)'` is any given project reference that happens to be a vcx or nativeproj.\r\n\r\nIn english, this item does the following: \"When this is a managed project, assign a default `PlatformLookupTable` metadata to all `ProjectReference` items that are `.vcxproj` or `.nativeproj`.\" I should probably update the comment with this clearer explanation.\r\n\r\nFor the purposes of this opt-in feature, we're assuming anything that isn't vcxproj or nativeproj is managed.",
              "createdAt": "2021-07-19T23:52:36Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Instead of check for vcxproj and nativeproj. You should check for supported extensions like vbproj, csproj etc.  You can have control of this list. ",
              "createdAt": "2021-07-22T19:19:11Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "copywrite header",
              "createdAt": "2021-07-19T15:15:44Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment on what this is supposed to do?",
              "createdAt": "2021-07-19T21:00:43Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm wondering if this should be an exception. There should definitely be some error-checking logic for the split with '=', since that would throw if there's no =.",
              "createdAt": "2021-07-19T21:01:29Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't feel strongly about this, but can't come up with a reason against throwing an exception. I'll add it & test for it.",
              "createdAt": "2021-07-20T21:33:58Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should be cleaner with String.Join:\r\n```suggestion\r\n                Log.LogMessage($\"Translation Table: {string.Join(';', translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\r\n```",
              "createdAt": "2021-07-19T21:04:31Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Also, how big do you expect these translation tables to be? I would guess pretty small, but if they're big, we should consider the performance of creating a big string just to log it. We can always log it in small pieces.",
              "createdAt": "2021-07-19T21:08:15Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I foresee these tables on average being 2~3 kvps if they exist. ",
              "createdAt": "2021-07-19T23:39:31Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm assuming this clones. Could you get away with just modifying AnnotatedProjects?",
              "createdAt": "2021-07-19T21:10:59Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'll save that for a future update to this feature. Reasons:\r\n\r\n1. We can always improve perf after we get this in\r\n2. The `GetReferenceNearestTargetFrameworkTask` does a similar copy\r\n\t- Source for that is in Nuget.Build.Tasks.dll\r\n3. Trying to get this merge sooner rather than later",
              "createdAt": "2021-07-19T23:44:36Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(';', StringSplitOptions.RemoveEmptyEntries))\r\n                {\r\n                    childPlatforms.Add(s);\r\n                }\r\n```",
              "createdAt": "2021-07-19T21:12:11Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(';'))\n+                {\n+                    if (!string.IsNullOrEmpty(s))\n+                    {\n+                        childPlatforms.Add(s);\n+                    }\n+                }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm less familiar with platforms than with frameworks. Is there some concept of \"A is a subset of B\" such that you might want to use A if one can build for A and the other B?",
              "createdAt": "2021-07-19T21:15:41Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(';'))\n+                {\n+                    if (!string.IsNullOrEmpty(s))\n+                    {\n+                        childPlatforms.Add(s);\n+                    }\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // Translation table takes priority\n+                if (translationTable.ContainsKey(ParentProjectPlatform) &&\n+                          childPlatforms.Contains(translationTable[ParentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[ParentProjectPlatform];\n+                    Log.LogMessage($\"Found '{ParentProjectPlatform}={buildChildProjectAs}' in the given translation table.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(ParentProjectPlatform))\n+                {\n+                    buildChildProjectAs = ParentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                else",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "To give that an example: A is x64, B is AnyCPU, potentially build B as x64? I don't think so. This would be useful if we could keep memory of what previous projects had built as, but we're keeping each layer independent.",
              "createdAt": "2021-07-19T23:55:58Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(';'))\n+                {\n+                    if (!string.IsNullOrEmpty(s))\n+                    {\n+                        childPlatforms.Add(s);\n+                    }\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // Translation table takes priority\n+                if (translationTable.ContainsKey(ParentProjectPlatform) &&\n+                          childPlatforms.Contains(translationTable[ParentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[ParentProjectPlatform];\n+                    Log.LogMessage($\"Found '{ParentProjectPlatform}={buildChildProjectAs}' in the given translation table.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(ParentProjectPlatform))\n+                {\n+                    buildChildProjectAs = ParentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                else",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not return !HasLoggedErrors && !HasLoggedWarnings? (Might be named something slightly different.)",
              "createdAt": "2021-07-19T21:16:38Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    class GetCompatiblePlatform : TaskExtension\n+    {\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        public string ParentProjectPlatform { get; set; }\n+\n+        public string PlatformLookupTable { get; set; }\n+\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(';'))\n+                {\n+                    // Minimum translation: a=b\n+                    if (s.Length < 3)\n+                    {\n+                        continue;\n+                    }\n+                    string key = s.Split('=')[0];\n+                    string val = s.Split('=')[1];\n+                    translationTable[key] = val;\n+                }\n+                Log.LogMessage($\"Translation Table: {translationTable.Aggregate(new StringBuilder(), (sb, kvp) => sb.Append(kvp.Key + \"=\" + kvp.Value + \";\"), sb => sb.ToString())}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(';'))\n+                {\n+                    if (!string.IsNullOrEmpty(s))\n+                    {\n+                        childPlatforms.Add(s);\n+                    }\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // Translation table takes priority\n+                if (translationTable.ContainsKey(ParentProjectPlatform) &&\n+                          childPlatforms.Contains(translationTable[ParentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[ParentProjectPlatform];\n+                    Log.LogMessage($\"Found '{ParentProjectPlatform}={buildChildProjectAs}' in the given translation table.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(ParentProjectPlatform))\n+                {\n+                    buildChildProjectAs = ParentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                else\n+                {\n+                    // Keep it empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return true;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can the first half of this condition be false?",
              "createdAt": "2021-07-19T23:08:07Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"\n+                            Condition=\"'@(_ProjectReferencePlatformPossibilities)' != ''\">\n+      <Output ItemName=\"_ProjectsWithPlatformAssignment\" TaskParameter=\"AssignedProjectsWithPlatform\" />\n+    </GetCompatiblePlatform>\n+\n+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.\n+         Don't do anything in this case. Ex: A project references many projects\n+         that can't multiplatform.  -->\n+    <ItemGroup Condition=\"'@(_ProjectsWithPlatformAssignment)' != ''\">\n+      <ProjectsWithNearestPlatform Include=\"@(_ProjectsWithPlatformAssignment)\"/>\n+      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->\n+      <ProjectsWithNearestPlatform Condition=\"'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''\">",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No, it's to ensure that this runs on every `ProjectsWithNearestPlatform` item. This style is mostly just to mimic how it was done in the TF logic",
              "createdAt": "2021-07-19T23:53:47Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"\n+                            Condition=\"'@(_ProjectReferencePlatformPossibilities)' != ''\">\n+      <Output ItemName=\"_ProjectsWithPlatformAssignment\" TaskParameter=\"AssignedProjectsWithPlatform\" />\n+    </GetCompatiblePlatform>\n+\n+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.\n+         Don't do anything in this case. Ex: A project references many projects\n+         that can't multiplatform.  -->\n+    <ItemGroup Condition=\"'@(_ProjectsWithPlatformAssignment)' != ''\">\n+      <ProjectsWithNearestPlatform Include=\"@(_ProjectsWithPlatformAssignment)\"/>\n+      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->\n+      <ProjectsWithNearestPlatform Condition=\"'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''\">",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yeah, the batching thing. I would've guessed the second half would have ensured that, too, but this is definitely not my area of expertise.",
              "createdAt": "2021-07-20T22:29:55Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"\n+                            Condition=\"'@(_ProjectReferencePlatformPossibilities)' != ''\">\n+      <Output ItemName=\"_ProjectsWithPlatformAssignment\" TaskParameter=\"AssignedProjectsWithPlatform\" />\n+    </GetCompatiblePlatform>\n+\n+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.\n+         Don't do anything in this case. Ex: A project references many projects\n+         that can't multiplatform.  -->\n+    <ItemGroup Condition=\"'@(_ProjectsWithPlatformAssignment)' != ''\">\n+      <ProjectsWithNearestPlatform Include=\"@(_ProjectsWithPlatformAssignment)\"/>\n+      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->\n+      <ProjectsWithNearestPlatform Condition=\"'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''\">",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "header",
              "createdAt": "2021-07-19T23:12:43Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,113 @@\n+\ufeffusing Microsoft.Build.UnitTests;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: make these line up?",
              "createdAt": "2021-07-19T23:15:57Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should there be a default, perhaps taking some global variable?",
              "createdAt": "2021-07-19T23:16:21Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This could be done through a directory.build.props",
              "createdAt": "2021-07-20T21:58:52Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "That would be clean.",
              "createdAt": "2021-07-20T22:30:27Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is this?",
              "createdAt": "2021-07-19T23:16:55Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Alignment for each cell in markdown. Left cell is left aligned and others are centered",
              "createdAt": "2021-07-20T21:33:34Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Fancy markdown \ud83d\ude42 Guess that also explains why you didn't care about making all of the | line up.",
              "createdAt": "2021-07-20T22:31:58Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It should be `win32=AnyCPU` instead `win32=x64`, right?",
              "createdAt": "2021-07-21T21:35:19Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=x64`. You can also define this on the `ProjectReference` item as metadata.",
              "author": {
                "login": "brunolins16"
              }
            },
            {
              "body": "Can win32 not translate to x64? Must have gotten it mixed up. Will modify to anycpu.\r\n\r\nEdit: Just realized my example scenario 3 lines above listed anycpu \ud83d\ude43",
              "createdAt": "2021-07-21T21:52:24Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=x64`. You can also define this on the `ProjectReference` item as metadata.",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you add an example of ProjectReference with the metadata?",
              "createdAt": "2021-07-21T21:37:21Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=x64`. You can also define this on the `ProjectReference` item as metadata.",
              "author": {
                "login": "brunolins16"
              }
            },
            {
              "body": "~~This brought up an implementation detail: defining `PlatformLookupTable` on `ProjectReference` items is currently unsupported. I believe I meant to suggest setting the `SetPlatform` metadata on the projectreference itself.~~ This _is_ implemented, will update the doc showing how to do this.",
              "createdAt": "2021-07-21T22:12:58Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,53 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=x64`. You can also define this on the `ProjectReference` item as metadata.",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would mostly avoid describing this in terms of what's new.  It should note that the support was added in VS 17.0, but I think it will be better if the documentation describes how the system works, not how it changed from how it previously worked.",
              "createdAt": "2021-07-22T19:26:56Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does the ordering matter?  IE is `win32=x86` the same as `x86=win32`?  I think there should be a sentence explaining what this value means, something like this:\r\n\r\n> This means that if the current project is building for `win32`, it should build referenced projects using `x86` as the `Platform`.\r\n\r\nI'm not sure whether this description is accurate, but it's my current guess.",
              "createdAt": "2021-07-22T19:32:55Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Ordering does matter here, thanks for asking for clarification!",
              "createdAt": "2021-07-22T20:50:22Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Any reason not to call this `Platforms` instead of `PlatformOptions`?",
              "createdAt": "2021-07-22T19:35:44Z",
              "path": "src/Tasks/Microsoft.Common.CrossTargeting.targets",
              "diffHunk": "@@ -46,6 +46,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\n         <IsRidAgnostic>false</IsRidAgnostic>\n         <IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</IsRidAgnostic>\n+        <!-- Extract necessary information for SetPlatform negotiation -->\n+        <!-- This target does not run for cpp projects. -->\n+        <IsVcxOrNativeProj>false</IsVcxOrNativeProj>\n+        <PlatformOptions>$(Platforms)</PlatformOptions>",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This shouldn't be an internal exception, should it? This will happen if someone sets `PlatformLookupTable` incorrectly.",
              "createdAt": "2021-07-22T19:38:22Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,128 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    sealed public class GetCompatiblePlatform_Tests\n+    {\n+        private readonly ITestOutputHelper _output;\n+\n+        public GetCompatiblePlatform_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable_Task()\n+        {\n+            // PlatformLookupTable always takes priority. It is typically user-defined.\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x64;x86;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"win32\",\n+                PlatformLookupTable = \"win32=x64\",\n+                AnnotatedProjects = new TaskItem[] { childProj }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x64\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault_Task()\n+        {\n+            // No valid mapping via the lookup table, should default to AnyCPU when possible because\n+            // it is inherently compatible with any platform.\n+\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x86;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\", \n+                AnnotatedProjects = new TaskItem[] { childProj }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"AnyCPU\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform_Task()\n+        {\n+            // No valid mapping via the lookup table, child project can't default to AnyCPU,\n+            // child project can match with parent project so match them.\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x86;x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { childProj }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x86\");\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve_Task()\n+        {\n+            MockLogger log = new MockLogger(_output);\n+            // No valid mapping via the lookup table, child project can't default to AnyCPU,\n+            // child can't match with parent, log a warning.\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { childProj },\n+            };\n+            \n+            task.Execute();\n+            // When the task logs a warning, it does not set NearestPlatform\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"\");\n+        }\n+\n+        /// <summary>\n+        /// Invalid format on PlatformLookupTable results in an exception being thrown.\n+        /// </summary>\n+        [Fact]\n+        public void FailsOnInvalidFormatLookupTable ()\n+        {\n+            MockLogger log = new MockLogger(_output);\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=;A=B\", // invalid format\n+                AnnotatedProjects = new TaskItem[] { childProj },\n+            };\n+\n+            Should.Throw<InternalErrorException>(() => task.Execute());",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Given that the logic should be fine if it continues (when it skips an invalid platformlookuptable), we can turn this into a warning stating that it either won't use that entry or won't use the table.",
              "createdAt": "2021-07-23T18:38:57Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,128 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    sealed public class GetCompatiblePlatform_Tests\n+    {\n+        private readonly ITestOutputHelper _output;\n+\n+        public GetCompatiblePlatform_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable_Task()\n+        {\n+            // PlatformLookupTable always takes priority. It is typically user-defined.\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x64;x86;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"win32\",\n+                PlatformLookupTable = \"win32=x64\",\n+                AnnotatedProjects = new TaskItem[] { childProj }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x64\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault_Task()\n+        {\n+            // No valid mapping via the lookup table, should default to AnyCPU when possible because\n+            // it is inherently compatible with any platform.\n+\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x86;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\", \n+                AnnotatedProjects = new TaskItem[] { childProj }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"AnyCPU\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform_Task()\n+        {\n+            // No valid mapping via the lookup table, child project can't default to AnyCPU,\n+            // child project can match with parent project so match them.\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x86;x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { childProj }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x86\");\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve_Task()\n+        {\n+            MockLogger log = new MockLogger(_output);\n+            // No valid mapping via the lookup table, child project can't default to AnyCPU,\n+            // child can't match with parent, log a warning.\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { childProj },\n+            };\n+            \n+            task.Execute();\n+            // When the task logs a warning, it does not set NearestPlatform\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"\");\n+        }\n+\n+        /// <summary>\n+        /// Invalid format on PlatformLookupTable results in an exception being thrown.\n+        /// </summary>\n+        [Fact]\n+        public void FailsOnInvalidFormatLookupTable ()\n+        {\n+            MockLogger log = new MockLogger(_output);\n+            TaskItem childProj = new TaskItem(\"foo.bar\");\n+            childProj.SetMetadata(\"PlatformOptions\", \"x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                ParentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=;A=B\", // invalid format\n+                AnnotatedProjects = new TaskItem[] { childProj },\n+            };\n+\n+            Should.Throw<InternalErrorException>(() => task.Execute());",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there test coverage for putting `PlatformLookupTable` metadata on `ProjectReference` items?",
              "createdAt": "2021-07-22T19:39:12Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,128 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    sealed public class GetCompatiblePlatform_Tests",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2021-07-22T22:13:10Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,128 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    sealed public class GetCompatiblePlatform_Tests",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure \"Parent\" is the right term here.  I would probably call this either `CurrentProjectPlatform` or just `ProjectPlatform`.",
              "createdAt": "2021-07-22T19:40:03Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the parent is building as. \n+        /// </summary>\n+        public string ParentProjectPlatform { get; set; }",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is setting `PlatformLookupTable` metedata on project references actually implemented in this PR?  It looks like maybe not.",
              "createdAt": "2021-07-22T19:42:15Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "It is, it's passed in after with the current project's platform lookup table [here](https://github.com/dotnet/msbuild/pull/6655/files/953e0ba45234341945477189c53985a85cd84ceb#diff-5407d46dd30ce4031e530c35cc2e0a62a6c96e54cb1def14fb316f351ef92de9R1657). This allows for the metadata to take priority over the current project's table.\r\n\r\nEdit: After seeing your suggestion to un-batch it, it'll have to be implemented in the task now",
              "createdAt": "2021-07-22T20:57:40Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't you want to prefer a matching platform (if available) over AnyCPU?  I'm not very familiar with the scenarios here, but that's what I would expect.",
              "createdAt": "2021-07-22T19:45:11Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the parent is building as. \n+        /// </summary>\n+        public string ParentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);\n+\n+                    ErrorUtilities.VerifyThrow(keyVal.Length > 1, \"PlatformLookupTable must be of the form A=B;C=D\");\n+\n+                    translationTable[keyVal[0]] = keyVal[1];\n+                }\n+                \n+                Log.LogMessage($\"Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // Translation table takes priority\n+                if (translationTable.ContainsKey(ParentProjectPlatform) &&\n+                          childPlatforms.Contains(translationTable[ParentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[ParentProjectPlatform];\n+                    Log.LogMessage($\"Found '{ParentProjectPlatform}={buildChildProjectAs}' in the given translation table.\");\n+                }\n+                // AnyCPU if possible",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Part of what @MarkOsborneMS described in their scenario was avoiding a situation where many architecture specific projects would target a single project that _could_ build as AnyCPU but would pass in a specific architecture anyway. Preferring AnyCPU sounded ideal for their scenario",
              "createdAt": "2021-07-22T20:58:40Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the parent is building as. \n+        /// </summary>\n+        public string ParentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);\n+\n+                    ErrorUtilities.VerifyThrow(keyVal.Length > 1, \"PlatformLookupTable must be of the form A=B;C=D\");\n+\n+                    translationTable[keyVal[0]] = keyVal[1];\n+                }\n+                \n+                Log.LogMessage($\"Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // Translation table takes priority\n+                if (translationTable.ContainsKey(ParentProjectPlatform) &&\n+                          childPlatforms.Contains(translationTable[ParentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[ParentProjectPlatform];\n+                    Log.LogMessage($\"Found '{ParentProjectPlatform}={buildChildProjectAs}' in the given translation table.\");\n+                }\n+                // AnyCPU if possible",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Having a preference for AnyCpu certainly makes sense - the typical scenario is having an architecture specific exe (which defines the bitness of the executable) that consumes an AnyCpu dependency. In reality I'd be surprised if a project defined a mix of AnyCpu and specific architectures deliberately - being capable of building AnyCpu should be enough. I could imaging someone doing this inadvertently though - in which case preferring AnyCpu would be desirable.",
              "createdAt": "2021-07-26T23:55:00Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the parent is building as. \n+        /// </summary>\n+        public string ParentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+            if (!string.IsNullOrEmpty(PlatformLookupTable))\n+            {\n+                foreach (string s in PlatformLookupTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);\n+\n+                    ErrorUtilities.VerifyThrow(keyVal.Length > 1, \"PlatformLookupTable must be of the form A=B;C=D\");\n+\n+                    translationTable[keyVal[0]] = keyVal[1];\n+                }\n+                \n+                Log.LogMessage($\"Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                if (string.IsNullOrEmpty(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\")))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformOptions\").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // Translation table takes priority\n+                if (translationTable.ContainsKey(ParentProjectPlatform) &&\n+                          childPlatforms.Contains(translationTable[ParentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[ParentProjectPlatform];\n+                    Log.LogMessage($\"Found '{ParentProjectPlatform}={buildChildProjectAs}' in the given translation table.\");\n+                }\n+                // AnyCPU if possible",
              "author": {
                "login": "MarkOsborneMS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "So this is disabled when running in Visual Studio?  Do people need to use the configuration dialog in that case?",
              "createdAt": "2021-07-22T19:48:19Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Yes its disabled in VS because platform and configuration is already defined when running builds",
              "createdAt": "2021-07-22T21:01:20Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'm not sure how to modify what each project would build as in VS, the config dialog sounds right.",
              "createdAt": "2021-07-22T21:01:47Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Comment this please",
              "createdAt": "2021-07-27T20:19:46Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this means that the task is going to batch over the project reference items, and only run for one project reference at a time.  If you modify the task to look at `PlatformLookupTable` metadata on the project items it gets passed in, then it wouldn't have to batch, which might be preferrable.",
              "createdAt": "2021-07-22T19:57:01Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"",
              "author": {
                "login": "dsplaisted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This comment doesn't entirely make sense, was it copied from the TargetFramework logic but not modified?",
              "createdAt": "2021-07-22T19:58:53Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"\n+                            Condition=\"'@(_ProjectReferencePlatformPossibilities)' != ''\">\n+      <Output ItemName=\"_ProjectsWithPlatformAssignment\" TaskParameter=\"AssignedProjectsWithPlatform\" />\n+    </GetCompatiblePlatform>\n+\n+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.\n+         Don't do anything in this case. Ex: A project references many projects\n+         that can't multiplatform.  -->\n+    <ItemGroup Condition=\"'@(_ProjectsWithPlatformAssignment)' != ''\">\n+      <ProjectsWithNearestPlatform Include=\"@(_ProjectsWithPlatformAssignment)\"/>\n+      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->",
              "author": {
                "login": "dsplaisted"
              }
            },
            {
              "body": "Whoops!",
              "createdAt": "2021-07-22T21:02:38Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -1603,6 +1603,84 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ====================================================================================\n+                                        _GetProjectReferencePlatformProperties\n+\n+    If a project is opted in via $(EnableDynamicPlatformResolution), this target builds the GetPlatforms\n+    target of all existing references to get a list of all possible platforms of the referenced projects. \n+    Calls the GetCompatiblePlatform task to determine the most compatible platform for each project.\n+    This prevents overbuilding a project when 'AnyCPU' is available, for example.\n+\n+    ======================================================================================\n+  -->\n+\n+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->\n+  <PropertyGroup>\n+    <PlatformTarget Condition=\"'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''\n+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'\">$(Platform)</PlatformTarget>\n+  </PropertyGroup>\n+\n+  <Target Name=\"_GetProjectReferencePlatformProperties\"\n+          Condition=\"'$(EnableDynamicPlatformResolution)' == 'true'\n+                     and '$(BuildingInsideVisualStudio)' != 'true'\n+                     and '@(_MSBuildProjectReferenceExistent)' != ''\">\n+\n+    <!-- Allow preset SetPlatform to override this operation -->\n+    <ItemGroup>\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''\">\n+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>\n+      </_MSBuildProjectReferenceExistent>\n+    </ItemGroup>\n+\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Include=\"@(_MSBuildProjectReferenceExistent)\" \n+                                              Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'\"/>\n+    </ItemGroup>\n+\n+    <!-- Managed Platform \"source of truth\" is $(PlatformTarget). For cpp it's $(Platform) -->\n+    <PropertyGroup>\n+      <ParentPlatform>$(PlatformTarget)</ParentPlatform>\n+      <ParentPlatform Condition=\"'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'\">$(Platform)</ParentPlatform>\n+    </PropertyGroup>\n+\n+    <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->\n+    <ItemGroup>\n+      <_ProjectReferencePlatformPossibilities Condition=\"'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'\">\n+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->\n+        <PlatformLookupTable Condition=\"$(PlatformLookupTable) == ''\">AnyCPU=Win32;x86=Win32</PlatformLookupTable>\n+      </_ProjectReferencePlatformPossibilities>\n+    </ItemGroup>\n+\n+    <GetCompatiblePlatform AnnotatedProjects=\"@(_ProjectReferencePlatformPossibilities)\"\n+                            ParentProjectPlatform=\"$(ParentPlatform)\"\n+                            PlatformLookupTable=\"$(PlatformLookupTable);%(_ProjectReferencePlatformPossibilities.PlatformLookupTable)\"\n+                            Condition=\"'@(_ProjectReferencePlatformPossibilities)' != ''\">\n+      <Output ItemName=\"_ProjectsWithPlatformAssignment\" TaskParameter=\"AssignedProjectsWithPlatform\" />\n+    </GetCompatiblePlatform>\n+\n+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.\n+         Don't do anything in this case. Ex: A project references many projects\n+         that can't multiplatform.  -->\n+    <ItemGroup Condition=\"'@(_ProjectsWithPlatformAssignment)' != ''\">\n+      <ProjectsWithNearestPlatform Include=\"@(_ProjectsWithPlatformAssignment)\"/>\n+      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The way this paragraph reads makes me wonder if `Win32=x86` set in a vcxproj will break P2Ps to other vcxproj's, which expect Win32 and *not* x86.\r\nHow would we resolve this for when a project references a blend of C# and C++ projects?",
              "createdAt": "2021-07-27T19:13:19Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "AArnott"
              }
            },
            {
              "body": "In this case the `PlatformLookupTable` is presumably defined globally in some Directory.Build.props, or in the cpp project that could reference c# and cpp projects. In the specific projectreference of cpp -> cpp, you can set `PlatformLookupTable` (or SetPlatform) metadata on that individual projectreference, and that metadata will take priority.\r\n\r\nWe could make this a cleaner experience but that would be in a future PR.",
              "createdAt": "2021-07-27T19:56:51Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: the second use of the word platforms is as an english explanation rather than a recursive definition, so drop the identifier treatment.\r\n```suggestion\r\n    * `Platforms` indicating what platforms are available for the project to build as.\r\n```",
              "createdAt": "2021-07-27T19:14:20Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -57,7 +57,8 @@ If implementing a project with an \u201couter\u201d (determine what properties to pass\n   * It returns an item with the following metadata:\n     * `TargetFrameworks` indicating what TargetFrameworks are available in the project\n     * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)\n-    * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.\n+    * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic` and `IsVcxOrNativeProj`.\n+    * `Platforms` indicating what `Platforms` are available for the project to build as.",
              "author": {
                "login": "AArnott"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this default mapping still correct? I thought we agreed in the discussion that AnyCPU->Win32 should emit a warning at least, if not block, unless the user explicitly opted into that jump.",
              "createdAt": "2021-07-27T19:15:49Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |",
              "author": {
                "login": "AArnott"
              }
            },
            {
              "body": "To clarify here, when jumping from a parent that's AnyCPU to a child that is anything non-AnyCPU, a warning should be emitted>",
              "createdAt": "2021-07-27T19:48:32Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "That sounds good. But with the default table, an AnyCPU->Win32 jump looks permissible. I don't think I would expect a warning if an entry exists in the table. If it does, what would I do to suppress the warning if I needed to?",
              "createdAt": "2021-07-27T19:52:39Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |",
              "author": {
                "login": "AArnott"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is a table required when C++ references a C# project? C++ is always arch-specific and C# will almost always have either AnyCPU or a compatible arch-specific platform. Couldn't a default mapping of `win32=x86;x64=x64;arm=arm` apply here?",
              "createdAt": "2021-07-27T19:17:17Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |",
              "author": {
                "login": "AArnott"
              }
            },
            {
              "body": "My main confusion here was `win32` being applicable to `x86` and `AnyCPU` and not being entirely sure if either should be the default mapping from `win32`. Is win32->x86 more common?\r\n\r\nSide note: `x64=x64` isn't necessary because that's auto-detected in the task.",
              "createdAt": "2021-07-27T19:51:01Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "It goes back to my TFM analogy: where netstandard2.0 and net472 are both built by a child, a net472 parent project will pick the platform-specific one (net472) because if you offer something portable *and* a compatible specific target, the only reason the specific target would exist is because it is preferred over the portable one.\r\nSo ya, win32->x86 would be preferred over win32->anycpu by the same reasoning.\r\nBut of course for the (default) C# project that *doesn't* list x86 in its Platforms property, then the behavior would be win32->anycpu because of your \"fallback to anycpu\" logic. So your table for vcxproj->csproj references would just be `win32=x86`. And all other platform combination either may directly (e.g. x64=x64) or use the `*=anycpu` fallback.",
              "createdAt": "2021-07-27T19:58:44Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |",
              "author": {
                "login": "AArnott"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "IMO win32=x86 is a reasonable default mapping. Why would the user have to specify it explicitly?",
              "createdAt": "2021-07-27T19:19:23Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.",
              "author": {
                "login": "AArnott"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since this should happen automatically in most cases (as per my above comment), a more compelling sample would be a C# -> C++ reference I think. Of course in that case a default table should be able to resolve it without help, except in the case where C# only defines AnyCPU. In that case though, would the easiest thing be for the customer to set the table property, or just directly set the `SetPlatform` metadata?",
              "createdAt": "2021-07-27T19:24:30Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "AArnott"
              }
            },
            {
              "body": "When there's only one option, the customer should just set `SetPlatform`. It's when the parent project _could_ build as multiple platforms and we're not sure which one its building as before the build has started.",
              "createdAt": "2021-07-27T19:52:19Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Ok, that makes sense. But specifying `Win32=AnyCPU` here should only be necessary if C# offered an x86 option (that would fit the default mapping table) and the user *didn't* want that option taken but wanted AnyCPU to be used instead. This would be *very* strange, as why would the user define an x86 target platform and then not use it in an x86 process?",
              "createdAt": "2021-07-27T20:00:33Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "AArnott"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Up to this point, the docs keep referring to `PlatformLookupTable` as a *property*, but this sample defines it as a `ProjectReference` item metadata. Is it one, the other, or both? Should the docs clarify this a bit more?",
              "createdAt": "2021-07-27T19:25:36Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "AArnott"
              }
            },
            {
              "body": "The docs definitely need a refresh \ud83d\ude42",
              "createdAt": "2021-07-27T19:52:35Z",
              "path": "documentation/ProjectReference-Protocol.md",
              "diffHunk": "@@ -119,4 +120,59 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They\n </AdditionalProjectProperties>\n ```\n \n-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n\\ No newline at end of file\n+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.\n+\n+## SetPlatform Negotiation\n+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. \n+\n+### What's new?\n+Modified target: `GetTargetFrameworks`\n+- Extracts `$(Platform)` information and determines whether the referred project is a `.vcxproj` or `.nativeproj`.\n+\n+New target: `_GetProjectReferencePlatformProperties`\n+- Runs after `_GetProjectReferenceTargetFrameworkProperties`\n+- Calls the new `GetCompatiblePlatform` task\n+- Sets or unsets `SetPlatform` metadata based on the `NearestPlatform` metadata from `GetCompatiblePlatform`.\n+\n+New task: `GetCompatiblePlatform`\n+- Parameters: Parent's `$(Platform)`(for `.vcxproj` or `.nativeproj`) or `$(PlatformTarget)`(for managed projects), the `$(Platforms)` of the referenced project, and an optional `$(PlatformLookupTable)`\n+- Using the given information, sets the `NearestPlatform` metadata as best it can or throws a warning.\n+\n+### How To Opt In\n+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+ If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.\n+\n+ Next, every referenced project is required to define a `$(Platforms)` property. `$(Platforms)` is a semicolon-delimited list of platforms that project could build as. `<Platforms>x64;x86;AnyCPU</Platforms>`, for example.\n+\n+ Lastly, projects that contain `ProjectReference` items may need to define a `$(PlatformLookupTable)` property. `$(PlatformLookupTable)` is a semicolon-delimited list of mappings between projects. `<PlatformLookupTable>win32=x86</PlatformLookupTable>`, for example. This means that if the current project is building for `Win32`, it should build referenced projects using `x86` as the `Platform`. This is mostly relevant for references between managed and unmanaged projects.\n+\n+ ### References between managed and unmanaged projects\n+ Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as.\n+| Project Reference Type | `PlatformLookupTable` Required? | Notes |\n+| :--  | :-: | :-: |\n+| Unmanaged -> Unmanaged | No |  |\n+| Managed -> Managed | No |  |\n+| Unmanaged -> Managed | **Yes** |  |\n+| Managed -> Unmanaged | Optional | Uses default mapping: `AnyCPU=Win32;x86=Win32` |\n+\n+ Example:\n+ Project A: Unmanaged, building as `win32`, has a `ProjectReference` on Project B.\n+ Project B: Managed, has `$(Platforms)` defined as `x86;AnyCPU`.\n+\n+ Because `win32` can map to multiple managed platforms, there's no way for A to know what B should build as without some sort of mapping. The `GetCompatiblePlatform` task **requires** the property `PlatformLookupTable` to be defined in this case. To resolve this scenario, Project A should define `PlatformLookupTable` as `win32=x86` or `win32=AnyCPU`. You can also define this on the `ProjectReference` item as metadata.\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"B.csproj\" PlatformLookupTable=\"Win32=AnyCPU\">",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            task.Execute().ShouldBeTrue();\r\n```\r\n\r\n? For all these?",
              "createdAt": "2021-07-27T19:59:57Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,202 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    sealed public class GetCompatiblePlatform_Tests\n+    {\n+        private readonly ITestOutputHelper _output;\n+\n+        public GetCompatiblePlatform_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            // PlatformLookupTable always takes priority. It is typically user-defined.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"x64;x86;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"win32\",\n+                PlatformLookupTable = \"win32=x64\",\n+                AnnotatedProjects = new TaskItem[] { projectReference }\n+            };\n+\n+            task.Execute();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Our style is usually\r\n```suggestion\r\n            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(string.Empty);\r\n```",
              "createdAt": "2021-07-27T20:01:10Z",
              "path": "src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs",
              "diffHunk": "@@ -0,0 +1,202 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    sealed public class GetCompatiblePlatform_Tests\n+    {\n+        private readonly ITestOutputHelper _output;\n+\n+        public GetCompatiblePlatform_Tests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            // PlatformLookupTable always takes priority. It is typically user-defined.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"x64;x86;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"win32\",\n+                PlatformLookupTable = \"win32=x64\",\n+                AnnotatedProjects = new TaskItem[] { projectReference }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x64\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaChildsPlatformLookupTable()\n+        {\n+            // A child's PlatformLookupTable takes priority over the current project's table.\n+            // This allows overrides on a per-ProjectItem basis.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"x64;x86;AnyCPU\");\n+\n+            // childproj will be assigned x86 because its table takes priority\n+            projectReference.SetMetadata(\"PlatformLookupTable\", \"win32=x86\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"win32\",\n+                PlatformLookupTable = \"win32=x64\",\n+                AnnotatedProjects = new TaskItem[] { projectReference }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x86\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            // No valid mapping via the lookup table, should default to AnyCPU when the parent\n+            // and child's platforms don't match.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"x64;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\", \n+                AnnotatedProjects = new TaskItem[] { projectReference }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"AnyCPU\");\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            // No valid mapping via the lookup table. If the child's platform\n+            // matches the parent's platform, it takes priority over AnyCPU default.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"x86;x64;AnyCPU\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { projectReference }\n+            };\n+\n+            task.Execute();\n+\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"x86\");\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve()\n+        {\n+            // No valid mapping via the lookup table, child project can't default to AnyCPU,\n+            // child can't match with parent, log a warning.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"x64\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { projectReference },\n+            };\n+\n+            task.Execute();\n+            // When the task logs a warning, it does not set NearestPlatform\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"\");\n+            ((MockEngine)task.BuildEngine).AssertLogContains(\"MSB3981\");\n+        }\n+\n+        [Fact]\n+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()\n+        {\n+            // Task should log a warning when a ProjectReference has no options to build as.\n+            // It will continue and have no NearestPlatform metadata.\n+            TaskItem projectReference = new TaskItem(\"foo.bar\");\n+            projectReference.SetMetadata(\"Platforms\", \"\");\n+\n+            GetCompatiblePlatform task = new GetCompatiblePlatform()\n+            {\n+                BuildEngine = new MockEngine(_output),\n+                CurrentProjectPlatform = \"x86\",\n+                PlatformLookupTable = \"AnyCPU=x64\",\n+                AnnotatedProjects = new TaskItem[] { projectReference },\n+            };\n+\n+            task.Execute();\n+            // When the task logs a warning, it does not set NearestPlatform\n+            task.AssignedProjectsWithPlatform[0].GetMetadata(\"NearestPlatform\").ShouldBe(\"\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I have decreed that we avoid \"parent\" and \"child\" wording because people can't agree which direction the relationship goes and get confused if they think the other way. Can you say \"current\" here?",
              "createdAt": "2021-07-27T20:03:04Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "also check \r\n```suggestion\r\n                if (keyVal.Length <= 1 || keyVal.Length > 2)\r\n```",
              "createdAt": "2021-07-27T20:04:27Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);\n+\n+                // Invalid table, don't use it.\n+                if (keyVal.Length <= 1)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does `RemoveEmptyEntries` buy you here?",
              "createdAt": "2021-07-27T20:04:50Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Only unnecessary ~~errors~~ warnings in strange translation tables like `A=Z;;B=G` that are \"technically\" correct. I could see table entries added via properties that may or may not have values, but may be easier to include at once for convenience.",
              "createdAt": "2021-07-28T04:48:01Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "For the semicolon split I'm totally on board. For the equals I'm still pretty skeptical.",
              "createdAt": "2021-07-28T11:04:16Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Sounds reasonable to enforce proper formatting for individual entries. Will allow empty entries on splitting the equals.",
              "createdAt": "2021-07-28T15:30:29Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Allowing empty entries complicates the invalid check and doesn't get us much benefit. Disallowing empty entries guarantees `a=b` at minimum, and keeps the invalid check simpler (length <=1 or > 2 then invalid). Otherwise its an extra two string null/empty checks, which would have been handled by string.Split",
              "createdAt": "2021-07-28T16:09:34Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "But it also silently handles super confusing cases like `=x86========anycpu==`, which I think is bad.",
              "createdAt": "2021-07-28T16:12:54Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> But it also silently handles super confusing cases like =x86========anycpu==, which I think is bad.\r\n\r\nBlarg, blarg I say! (Translation: you're right, will fix)",
              "createdAt": "2021-07-28T17:04:18Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)\n+        {\n+            if (string.IsNullOrEmpty(stringTable))\n+            {\n+                return null;\n+            }\n+\n+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n+\n+            foreach (string s in stringTable.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                string[] keyVal = s.Split(MSBuildConstants.EqualsChar, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Traditionally we try to be tolerant of whitespace in strings that might be defined in properties/item metadata. Can you do that here?",
              "createdAt": "2021-07-27T20:05:52Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Possible improvement: consider keeping a cache of string->IReadOnlyDictionary and checking whether we've looked at the `stringTable` before. That way we don't have to do these splits for every project.",
              "createdAt": "2021-07-27T20:07:02Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> Traditionally we try to be tolerant of whitespace in strings that might be defined in properties/item metadata. Can you do that here?\r\n\r\nDo we typically trim the individual items in a semicolon-delimited list after we split it?\r\n\r\nEdit: Did it anyway. Don't see any harm to it.",
              "createdAt": "2021-07-28T04:43:20Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "> consider keeping a cache of string->IReadOnlyDictionary and checking whether we've looked at the stringTable before. That way we don't have to do these splits for every project.\r\n\r\nQuestion on task lifetimes: Would global variables survive between task calls from the same project? Multiple projects? I worry about caching the tables statically, since Project A could define table X=Y and project B could define Z=A",
              "createdAt": "2021-07-28T04:47:15Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "\n> Do we typically trim the individual items in a semicolon-delimited list after we split it?\n> \n> \n> \n> Edit: Did it anyway. Don't see any harm to it.\n\n\ud83d\udc4d\ud83c\udffb this helps if you want to do something like\n\n```xml\n<P>\n   Foo;\n   Bar;\n   $(P)\n</P>\n```",
              "createdAt": "2021-07-28T11:07:11Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> Question on task lifetimes: Would global variables survive between task calls from the same project? Multiple projects? I worry about caching the tables statically, since Project A could define table X=Y and project B could define Z=A\n\nGreat questions! Static variables live for the lifetime of the assembly load which is generally \"the lifetime of the process\" (you're not using an appdomain here and we don't use collectible ALCs on Core).\n\nThat might be ok and often is: if the data is small but recomputing it is expensive, spend the memory. Here recomputing is not super expensive so I dunno. On the flip side there aren't likely going to be like thousands of different input strings.\n\nThis can wait for sure.",
              "createdAt": "2021-07-28T11:14:19Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";\n+\n+                // If the referenced project has a translation table, it came from the ProjectReference item's metadata.\n+                // Prioritize that over the current project's translation table.\n+                if (childPlatformLookupTable != null &&\n+                        childPlatformLookupTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(childPlatformLookupTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = childPlatformLookupTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the referenced project's translation table.\");\n+                }\n+                // Current project's translation table follows\n+                else if (translationTable != null &&\n+                        translationTable.ContainsKey(CurrentProjectPlatform) &&\n+                        childPlatforms.Contains(translationTable[CurrentProjectPlatform]))\n+                {\n+                    buildChildProjectAs = translationTable[CurrentProjectPlatform];\n+                    Log.LogMessage($\"Found '{CurrentProjectPlatform}={buildChildProjectAs}' in the current project's translation table.\");\n+                }\n+                // Prefer matching platforms\n+                else if (childPlatforms.Contains(CurrentProjectPlatform))\n+                {\n+                    buildChildProjectAs = CurrentProjectPlatform;\n+                    Log.LogMessage($\"Child and parent have the same platform.\");\n+                }\n+                // AnyCPU if possible\n+                else if (childPlatforms.Contains(\"AnyCPU\"))\n+                {\n+                    buildChildProjectAs = \"AnyCPU\";\n+                    Log.LogMessage($\"Defaulting to AnyCPU.\");\n+                }\n+                else\n+                {\n+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine \n+                    // Platform/PlatformTarget when this is the case.\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoCompatiblePlatformFound\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                }\n+\n+                AssignedProjectsWithPlatform[i].SetMetadata(\"NearestPlatform\", buildChildProjectAs);\n+                Log.LogMessage($\"Project '{AssignedProjectsWithPlatform[i].ItemSpec}' will build with Platform: '{buildChildProjectAs}'\");\n+            }\n+\n+            return !Log.HasLoggedErrors;\n+        }\n+\n+        private Dictionary<string, string> ExtractLookupTable(string stringTable)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                string buildChildProjectAs = string.Empty;\r\n```",
              "createdAt": "2021-07-27T20:08:48Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+            }\n+\n+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];\n+            for (int i = 0; i < AnnotatedProjects.Length; i++)\n+            {\n+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);\n+\n+                string childPlatformOptions = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");\n+\n+                if (string.IsNullOrEmpty(childPlatformOptions))\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", AssignedProjectsWithPlatform[i].ItemSpec);\n+                    continue;\n+                }\n+\n+                // Pull platformlookuptable metadata from the referenced project. This allows custom\n+                // translations on a per-ProjectReference basis.\n+                Dictionary<string, string> childPlatformLookupTable = ExtractLookupTable(AssignedProjectsWithPlatform[i].GetMetadata(\"PlatformLookupTable\"));\n+\n+                if (childPlatformLookupTable != null)\n+                {\n+                    Log.LogMessage($\"Referenced Project's Translation Table: {string.Join(\";\", childPlatformLookupTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");\n+                }\n+\n+                HashSet<string> childPlatforms = new HashSet<string>();\n+                foreach (string s in childPlatformOptions.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    childPlatforms.Add(s);\n+                }\n+\n+                string buildChildProjectAs = \"\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a new file! Can we apply `#nullable enable`?",
              "createdAt": "2021-07-27T20:09:23Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These seem pretty verbose. Can they at least be Low pri?",
              "createdAt": "2021-07-27T20:10:08Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "They also need to be localizable.",
              "createdAt": "2021-07-27T20:14:07Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> They also need to be localizable.\r\n\r\nEven for low pri messages?",
              "createdAt": "2021-07-28T00:05:42Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes, any message. The only exceptions are things like internal errors where the strings are really only for us, the dev team.",
              "createdAt": "2021-07-28T03:02:12Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'm not sure why I thought ResolveAssemblyReferences logged un-localized messages. Will add resources for this.",
              "createdAt": "2021-07-28T03:15:36Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Performs SetPlatform negotiation for all project references when opted\n+    /// in via the EnableDynamicPlatformResolution property.\n+    /// \n+    /// See ProjectReference-Protocol.md for details.\n+    /// </summary>\n+    public class GetCompatiblePlatform : TaskExtension\n+    {\n+        /// <summary>\n+        /// All ProjectReference items.\n+        /// </summary>\n+        public ITaskItem[] AnnotatedProjects { get; set; }\n+\n+        /// <summary>\n+        /// The platform the current project is building as. \n+        /// </summary>\n+        public string CurrentProjectPlatform { get; set; }\n+\n+        /// <summary>\n+        /// Optional parameter that defines translations from parent platforms to\n+        /// what the ProjectReference should build as.\n+        /// Win32=x86, for example.\n+        /// </summary>\n+        public string PlatformLookupTable { get; set; }\n+\n+        /// <summary>\n+        /// The resulting items with NearestPlatform metadata set.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] AssignedProjectsWithPlatform { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            Dictionary<string, string> translationTable = ExtractLookupTable(PlatformLookupTable);\n+\n+            if (translationTable != null)\n+            {\n+                Log.LogMessage($\"Current Project's Translation Table: {string.Join(\";\", translationTable.Select(kvp => $\"{kvp.Key}={kvp.Value}\"))}\");",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      }
    ]
  }
}