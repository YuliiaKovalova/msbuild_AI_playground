{
  "number": 8213,
  "title": "Add support for symlink files embedding to binlog",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/6773\r\n\r\n### Context\r\nSymlinked files were not embedded into binlog\r\n\r\n\r\n### Changes Made\r\nAdd detection of symlinked files and switch to their target\r\nSupport not added for full FW\r\n\r\n### Testing\r\nUnit test added, attempting to embed symlinked file (failing without the fix)\r\n",
  "state": "MERGED",
  "createdAt": "2022-12-02T14:50:38Z",
  "updatedAt": "2023-01-04T16:23:12Z",
  "closedAt": "2023-01-03T16:15:57Z",
  "mergedAt": "2023-01-03T16:15:57Z",
  "additions": 238,
  "deletions": 61,
  "changedFiles": 7,
  "headRefName": "proto/bl-embed-symlinks",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f3a9a6996a4e172622622290622d8c7ecfa74cd3",
          "message": "Add support for symlink files embedding to binlog",
          "committedDate": "2022-12-02T14:47:34Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b6341a1a1df9153ec3752305e974dc0becc40f3",
          "message": "Merge remote-tracking branch 'upstream/main' into proto/bl-embed-symlinks",
          "committedDate": "2022-12-09T11:10:16Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "296ba008c8856dffdea0a18da8bec21d957255cb",
          "message": "Make symlink functionality available for FullFW as well",
          "committedDate": "2022-12-09T16:55:17Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c1e837b392d2ae26db91ce70091a8fa76aac6f06",
          "message": "Add null check",
          "committedDate": "2022-12-09T16:57:48Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "884fde8061e11d3d3d575dcee716fb532e9e4567",
          "message": "Simplify the change, add doc",
          "committedDate": "2022-12-13T14:09:53Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "202a929aeaf74fe5bd9bbaba2ccaf67b5c9b9b2d",
          "message": "Fix wording",
          "committedDate": "2022-12-13T19:45:19Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95706ab24553d554a412c70585ca64e734fb9ee7",
          "message": "Merge branch 'main' into proto/bl-embed-symlinks",
          "committedDate": "2022-12-13T19:46:57Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "krivanek.j@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "870155c1001ccaa4d0166bf2359b7cdcf39d6be3",
          "message": "Fix platform constraint",
          "committedDate": "2022-12-14T17:44:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "93504d7fa3798371d3bc483422c952e60d5d77c6",
          "message": "Clarify wiki",
          "committedDate": "2022-12-15T10:02:36Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b94eadd6b8e354307e224ca16879f3f1c3f3a0ad",
          "message": "Add support for recursive symlinks",
          "committedDate": "2022-12-16T17:36:25Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee5fc55513b455d171680f75e7510247081705f7",
          "message": "Switched options in doc",
          "committedDate": "2022-12-19T15:28:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this work if there's a chain of symlinks, or does it peel back only one layer?",
              "createdAt": "2022-12-02T16:33:06Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -131,6 +131,14 @@ private void AddFileCore(string filePath)\n             }\n \n             var fileInfo = new FileInfo(filePath);\n+\n+#if FEATURE_SYMLINK_TARGET\n+            if (fileInfo.Length == 0 && fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget))\n+            {\n+                fileInfo = new FileInfo(fileInfo.LinkTarget);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Interesting point.\r\nI tried it and it's just single level - so I'll make it recursive",
              "createdAt": "2022-12-05T15:46:04Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -131,6 +131,14 @@ private void AddFileCore(string filePath)\n             }\n \n             var fileInfo = new FileInfo(filePath);\n+\n+#if FEATURE_SYMLINK_TARGET\n+            if (fileInfo.Length == 0 && fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget))\n+            {\n+                fileInfo = new FileInfo(fileInfo.LinkTarget);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this core only?",
              "createdAt": "2022-12-02T23:03:44Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -131,6 +131,14 @@ private void AddFileCore(string filePath)\n             }\n \n             var fileInfo = new FileInfo(filePath);\n+\n+#if FEATURE_SYMLINK_TARGET\n+            if (fileInfo.Length == 0 && fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`LinkTarget` is not available in Full FW - so supporting this functionality in full FW would require involved, special-cased code. I'd do that once this is asked by at least single user, that needs in on full FW.",
              "createdAt": "2022-12-05T10:24:11Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -131,6 +131,14 @@ private void AddFileCore(string filePath)\n             }\n \n             var fileInfo = new FileInfo(filePath);\n+\n+#if FEATURE_SYMLINK_TARGET\n+            if (fileInfo.Length == 0 && fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a great improvement but I'd really like to see it work for full-framework MSBuild too, since that's the VS scenario. We used some win32 tricks to \"see through\" the symlinks in #648. Looks like we could get a `SafeFileHandle` and pass it through to the stream.",
              "createdAt": "2022-12-05T15:00:34Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -131,6 +131,14 @@ private void AddFileCore(string filePath)\n             }\n \n             var fileInfo = new FileInfo(filePath);\n+\n+#if FEATURE_SYMLINK_TARGET",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Thank you for great suggestion!\r\nI've reworked based on that",
              "createdAt": "2022-12-09T16:56:22Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -131,6 +131,14 @@ private void AddFileCore(string filePath)\n             }\n \n             var fileInfo = new FileInfo(filePath);\n+\n+#if FEATURE_SYMLINK_TARGET",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this be simplified? I think you can check the reparse point on any framework and platform, and it's just as fast, right? Like you should be able to do this everywhere:\r\n(File.GetAttributes(destFile) & FileAttributes.ReparsePoint) != 0",
              "createdAt": "2022-12-09T19:17:44Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,94 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool IsSymLink(string fullPath)\n+    {\n+#if NET\n+        var fileInfo = new FileInfo(fullPath);\n+\n+        return fileInfo.Exists && fileInfo.Length == 0 && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fullPath, 0, ref data) &&",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The `FileInfo` takes care about proper handling the logic on other platforms (e.g. https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/IO/FileSystem.Unix.cs#L653). So I believe simplification is not possible without impact on functionality.\r\nPlease let me know if I misunderstood.",
              "createdAt": "2022-12-13T12:17:49Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,94 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool IsSymLink(string fullPath)\n+    {\n+#if NET\n+        var fileInfo = new FileInfo(fullPath);\n+\n+        return fileInfo.Exists && fileInfo.Length == 0 && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fullPath, 0, ref data) &&",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "But - there can be another simplification\r\n\r\nI realized and verified that `FileStream` ctor already does the proper 'see through' thing with the symlinks.\r\nSo the change can be limited to just verifying that `FileInfo` has nonzero content or it's a symlink.... Updated.",
              "createdAt": "2022-12-13T14:11:01Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,94 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool IsSymLink(string fullPath)\n+    {\n+#if NET\n+        var fileInfo = new FileInfo(fullPath);\n+\n+        return fileInfo.Exists && fileInfo.Length == 0 && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fullPath, 0, ref data) &&",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For these sorts of errors, you should be able to add `[SupportedOSPlatform(\"windows\")]` to the relevant methods.",
              "createdAt": "2022-12-09T20:11:54Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,94 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool IsSymLink(string fullPath)\n+    {\n+#if NET\n+        var fileInfo = new FileInfo(fullPath);\n+\n+        return fileInfo.Exists && fileInfo.Length == 0 && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fullPath, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;\n+#endif\n+    }\n+\n+    internal static void ReadFileThroughSymlinks(string filePath, Action<FileStream> contentConsumer)\n+    {\n+        filePath = Path.GetFullPath(filePath);\n+\n+        if (IsSymLink(filePath))\n+        {\n+            using SafeFileHandle handle = OpenFileThroughSymlinks(filePath);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there still a test that fails if you run elevated then run not-elevated? If so, might want to mention that and how to fix it.",
              "createdAt": "2022-12-15T18:53:29Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Creating symlinks require elevation or developer mode on each run.\r\n\r\nWould you suggest different wording informing about this behavior?",
              "createdAt": "2022-12-16T17:21:20Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I'd put the option to enable developer mode first, and I'd add a warning for running tests elevated that if you then run not elevated, you have to do the following steps (and list out any tests that fail with running elevated --> not elevated along with an explanation of how to fix it\u2014I think there was just one, and it could be fixed by deleting some directory...or you could fix the test to clean up properly.)",
              "createdAt": "2022-12-16T20:01:05Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Switched the order of options.\r\n\r\nI'm not aware of issues with tests when switching elevation mode. The newly added test - `BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput` - uses transient files. The pre-existing test that uses symlinks - [`DoNotFollowRecursiveSymlinks`](https://github.com/dotnet/msbuild/blob/main/src/Shared/UnitTests/FileMatcher_Tests.cs#L72) cleans-up after itself as well.\r\nAm I missing any other case?\r\nIf we have any - I'd definitely prefer to do a proper cleanup in tests rather than scare reader by extra steps in wiki. Please point me :-)",
              "createdAt": "2022-12-19T15:32:42Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "@Forgind I've run all tests elevated and then without elevation and I do not observe any issues. Did you have any specific test or code issue in mind?\r\nIf not - do you feel there is any further improvement that can be made to the touched code or doc?",
              "createdAt": "2022-12-21T11:29:00Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "TestCache2 was the one I had in mind that had failed recently due to admin --> not admin running of the test. I believe it specifically failed if a particular folder did not exist prior to the test's execution, then you ran the test as an admin, then you ran the test as a normal user. It's possible that's been fixed since that came up, though; it was a while ago.",
              "createdAt": "2022-12-22T21:30:47Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This seems to be addressed here: https://github.com/dotnet/msbuild/pull/8122\r\n\r\nDo you feel there are any further improvement that can be made in scope of this PR?",
              "createdAt": "2022-12-23T12:33:57Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yup; I forgot about that. That's all I can think of.",
              "createdAt": "2022-12-27T17:01:56Z",
              "path": "documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md",
              "diffHunk": "@@ -25,6 +25,10 @@ To run the unit tests from Visual Studio:\n \n To build MSBuild and run all unit tests from the command line, use `.\\build.cmd -test`.\n \n+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:\n+* Run those tests elevated",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If it's a symlink, shouldn't we still check that the thing it points to is nonempty?",
              "createdAt": "2022-12-15T18:55:18Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,60 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        return fileInfo.Exists && (fileInfo.Length > 0 || IsSymLink(fileInfo));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good point.\r\nAdded support for traversal to final link target and checking it's existence and nonemptiness.",
              "createdAt": "2022-12-16T17:16:48Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,60 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        return fileInfo.Exists && (fileInfo.Length > 0 || IsSymLink(fileInfo));",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is going to conflict with #8238, fyi",
              "createdAt": "2022-12-15T18:56:45Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,60 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        return fileInfo.Exists && (fileInfo.Length > 0 || IsSymLink(fileInfo));\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;\n+#endif\n+    }\n+\n+    internal static bool IsSymLink(string path)\n+    {\n+        return IsSymLink(new FileInfo(path));\n+    }\n+\n+    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)\n+    {\n+        bool symbolicLinkCreated;\n+        if (IsWindows)\n+        {\n+            Version osVersion = Environment.OSVersion.Version;\n+            SymbolicLink flags = SymbolicLink.File;\n+            if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))\n+            {\n+                flags |= SymbolicLink.AllowUnprivilegedCreate;\n+            }\n+\n+            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);\n+            errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+        }\n+        else\n+        {\n+            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;\n+            errorMessage = symbolicLinkCreated ? null : \"The link() library call failed with the following error code: \" + Marshal.GetLastWin32Error();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks for pointing!\r\nShould be straightforward (and required) merge.",
              "createdAt": "2022-12-16T17:18:43Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1042,60 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        return fileInfo.Exists && (fileInfo.Length > 0 || IsSymLink(fileInfo));\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;\n+#endif\n+    }\n+\n+    internal static bool IsSymLink(string path)\n+    {\n+        return IsSymLink(new FileInfo(path));\n+    }\n+\n+    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)\n+    {\n+        bool symbolicLinkCreated;\n+        if (IsWindows)\n+        {\n+            Version osVersion = Environment.OSVersion.Version;\n+            SymbolicLink flags = SymbolicLink.File;\n+            if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))\n+            {\n+                flags |= SymbolicLink.AllowUnprivilegedCreate;\n+            }\n+\n+            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);\n+            errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+        }\n+        else\n+        {\n+            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;\n+            errorMessage = symbolicLinkCreated ? null : \"The link() library call failed with the following error code: \" + Marshal.GetLastWin32Error();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This could incorrectly return true for a file that is a reparse point but not a symbolic link.\r\n\r\nOne could use either [GetFileInformationByHandleEx](https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfileinformationbyhandleex) [FILE_ATTRIBUTE_TAG_INFO](https://learn.microsoft.com/windows/win32/api/winbase/ns-winbase-file_attribute_tag_info) or [DeviceIoControl](https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) [FSCTL_GET_REPARSE_POINT](https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_get_reparse_point) for reading the attributes and the reparse tag, and then compare to [IO_REPARSE_TAG_SYMLINK](https://learn.microsoft.com/windows/win32/fileio/reparse-point-tags); [PowerShell uses FSCTL_GET_REPARSE_POINT](https://github.com/PowerShell/PowerShell/blob/555c1a6e79df670ee179a82dfdf2cf88f7b25110/src/System.Management.Automation/namespaces/FileSystemProvider.cs#L8170-L8178). However, these functions would require first opening the file.\r\n\r\nTo get the file attributes and reparse tag without opening the file, one can use either [FindFirstFileW](https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfilew) or, starting from Windows 10 version 1709, [NtQueryInformationByName](https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryinformationbyname) [FILE_STAT_INFORMATION](https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_file_stat_information). I assume that NtQueryInformationByName would be the most efficient of these, because it doesn't require opening and closing a handle to the parent directory.",
              "createdAt": "2023-01-04T10:22:10Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1043,123 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        // File exist and has some content\n+        return fileInfo.Exists &&\n+               (fileInfo.Length > 0 ||\n+                    // Or final destination of the link is nonempty file\n+                    (\n+                        IsSymLink(fileInfo) &&\n+                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&\n+                        File.Exists(finalTarget) &&\n+                        new FileInfo(finalTarget).Length > 0\n+                    )\n+               );\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "@KalleOlaviNiemitalo Thank you for pointing to this and for the detailed suggestion!\r\n\r\nI'm thinking about keeping the attribute check to filter out 'normal files' scenarios and in case of detecting reparse point querying further (like by obtaining reparse tag via DeviceIoControl - similarly how this is done in runtime: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/IO/FileSystem.Windows.cs#L574-L609).\r\n\r\nThe `FindFirstFile` seems to be very neat way to get this info in single shot. This feels unnecessary heavy though. I haven't done any measuring though.",
              "createdAt": "2023-01-04T13:54:17Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1043,123 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        // File exist and has some content\n+        return fileInfo.Exists &&\n+               (fileInfo.Length > 0 ||\n+                    // Or final destination of the link is nonempty file\n+                    (\n+                        IsSymLink(fileInfo) &&\n+                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&\n+                        File.Exists(finalTarget) &&\n+                        new FileInfo(finalTarget).Length > 0\n+                    )\n+               );\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The methods in PowerShell and .NET Runtime use FSCTL_GET_REPARSE_POINT which also retrieves the target string of the symbolic link. If you don't need that, I suspect GetFileInformationByHandleEx FILE_ATTRIBUTE_TAG_INFO could be lighter weight as it could avoid the string copy.",
              "createdAt": "2023-01-04T14:07:39Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1043,123 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        // File exist and has some content\n+        return fileInfo.Exists &&\n+               (fileInfo.Length > 0 ||\n+                    // Or final destination of the link is nonempty file\n+                    (\n+                        IsSymLink(fileInfo) &&\n+                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&\n+                        File.Exists(finalTarget) &&\n+                        new FileInfo(finalTarget).Length > 0\n+                    )\n+               );\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It's the `symlink` call, not the `link` call. Not a new bug, though.",
              "createdAt": "2023-01-04T14:35:16Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1043,123 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        // File exist and has some content\n+        return fileInfo.Exists &&\n+               (fileInfo.Length > 0 ||\n+                    // Or final destination of the link is nonempty file\n+                    (\n+                        IsSymLink(fileInfo) &&\n+                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&\n+                        File.Exists(finalTarget) &&\n+                        new FileInfo(finalTarget).Length > 0\n+                    )\n+               );\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;\n+#endif\n+    }\n+\n+    internal static bool IsSymLink(string path)\n+    {\n+        return IsSymLink(new FileInfo(path));\n+    }\n+\n+    internal static bool TryGetFinalLinkTarget(FileInfo fileInfo, out string finalTarget, out string errorMessage)\n+    {\n+        if (!IsWindows)\n+        {\n+            errorMessage = null;\n+#if NET\n+            while(!string.IsNullOrEmpty(fileInfo.LinkTarget))\n+            {\n+                fileInfo = new FileInfo(fileInfo.LinkTarget);\n+            }\n+            finalTarget = fileInfo.FullName;\n+            return true;\n+#else\n+\n+            finalTarget = null;\n+            return false;\n+#endif\n+        }\n+\n+        using SafeFileHandle handle = OpenFileThroughSymlinks(fileInfo.FullName);\n+        if (handle.IsInvalid)\n+        {\n+            // Link is broken.\n+            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+            finalTarget = null;\n+            return false;\n+        }\n+\n+        const int initialBufferSize = 4096;\n+        char[] targetPathBuffer = new char[initialBufferSize];\n+        uint result = GetFinalPathNameByHandle(handle, targetPathBuffer);\n+\n+        // Buffer too small\n+        if (result > targetPathBuffer.Length)\n+        {\n+            targetPathBuffer = new char[(int)result];\n+            result = GetFinalPathNameByHandle(handle, targetPathBuffer);\n+        }\n+\n+        // Error\n+        if (result == 0)\n+        {\n+            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+            finalTarget = null;\n+            return false;\n+        }\n+\n+        // Normalize \\\\?\\ and \\??\\ syntax.\n+        finalTarget = new string(targetPathBuffer, 0, (int)result).TrimStart(new char[] { '\\\\', '?' });\n+        errorMessage = null;\n+        return true;\n+    }\n+\n+    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)\n+    {\n+        bool symbolicLinkCreated;\n+        if (IsWindows)\n+        {\n+            Version osVersion = Environment.OSVersion.Version;\n+            SymbolicLink flags = SymbolicLink.File;\n+            if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))\n+            {\n+                flags |= SymbolicLink.AllowUnprivilegedCreate;\n+            }\n+\n+            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);\n+            errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+        }\n+        else\n+        {\n+            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;\n+            errorMessage = symbolicLinkCreated ? null : \"The link() library call failed with the following error code: \" + Marshal.GetLastWin32Error();",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "Very valid. Linked this to a PR taking care of localizing the message",
              "createdAt": "2023-01-04T16:23:12Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1035,6 +1043,123 @@ internal static MemoryStatus GetMemoryStatus()\n         return null;\n     }\n \n+    internal static bool ExistAndHasContent(string path)\n+    {\n+        var fileInfo = new FileInfo(path);\n+\n+        // File exist and has some content\n+        return fileInfo.Exists &&\n+               (fileInfo.Length > 0 ||\n+                    // Or final destination of the link is nonempty file\n+                    (\n+                        IsSymLink(fileInfo) &&\n+                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&\n+                        File.Exists(finalTarget) &&\n+                        new FileInfo(finalTarget).Length > 0\n+                    )\n+               );\n+    }\n+\n+    internal static bool IsSymLink(FileInfo fileInfo)\n+    {\n+#if NET\n+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);\n+#else\n+        if (!IsWindows)\n+        {\n+            return false;\n+        }\n+\n+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();\n+\n+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&\n+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&\n+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;\n+#endif\n+    }\n+\n+    internal static bool IsSymLink(string path)\n+    {\n+        return IsSymLink(new FileInfo(path));\n+    }\n+\n+    internal static bool TryGetFinalLinkTarget(FileInfo fileInfo, out string finalTarget, out string errorMessage)\n+    {\n+        if (!IsWindows)\n+        {\n+            errorMessage = null;\n+#if NET\n+            while(!string.IsNullOrEmpty(fileInfo.LinkTarget))\n+            {\n+                fileInfo = new FileInfo(fileInfo.LinkTarget);\n+            }\n+            finalTarget = fileInfo.FullName;\n+            return true;\n+#else\n+\n+            finalTarget = null;\n+            return false;\n+#endif\n+        }\n+\n+        using SafeFileHandle handle = OpenFileThroughSymlinks(fileInfo.FullName);\n+        if (handle.IsInvalid)\n+        {\n+            // Link is broken.\n+            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+            finalTarget = null;\n+            return false;\n+        }\n+\n+        const int initialBufferSize = 4096;\n+        char[] targetPathBuffer = new char[initialBufferSize];\n+        uint result = GetFinalPathNameByHandle(handle, targetPathBuffer);\n+\n+        // Buffer too small\n+        if (result > targetPathBuffer.Length)\n+        {\n+            targetPathBuffer = new char[(int)result];\n+            result = GetFinalPathNameByHandle(handle, targetPathBuffer);\n+        }\n+\n+        // Error\n+        if (result == 0)\n+        {\n+            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+            finalTarget = null;\n+            return false;\n+        }\n+\n+        // Normalize \\\\?\\ and \\??\\ syntax.\n+        finalTarget = new string(targetPathBuffer, 0, (int)result).TrimStart(new char[] { '\\\\', '?' });\n+        errorMessage = null;\n+        return true;\n+    }\n+\n+    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)\n+    {\n+        bool symbolicLinkCreated;\n+        if (IsWindows)\n+        {\n+            Version osVersion = Environment.OSVersion.Version;\n+            SymbolicLink flags = SymbolicLink.File;\n+            if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))\n+            {\n+                flags |= SymbolicLink.AllowUnprivilegedCreate;\n+            }\n+\n+            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);\n+            errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;\n+        }\n+        else\n+        {\n+            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;\n+            errorMessage = symbolicLinkCreated ? null : \"The link() library call failed with the following error code: \" + Marshal.GetLastWin32Error();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}