{
  "number": 3331,
  "title": "Speed up Copy task by 2-3X",
  "body": "For #3330 \r\n- Kept original single-thread copy task for single-thread operation and added new TPL ActionBlock based parallel implementation.\r\n- All UTs pass with old and new implementations\r\n- See empirical time comparison numbers in table in Copy.cs. ~2X faster for SSD and ~3x for spinny disk.\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2018-05-19T01:40:18Z",
  "updatedAt": "2021-10-12T00:01:39Z",
  "closedAt": "2018-05-30T23:50:49Z",
  "mergedAt": "2018-05-30T23:50:49Z",
  "additions": 681,
  "deletions": 424,
  "changedFiles": 8,
  "headRefName": "dev/erikmav/fasterCopyTask",
  "isDraft": false,
  "author": {
    "login": "erikmav"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "721682b3a6d9be87423aa2cb7cd7727d04ee8e9f",
          "message": "Speed up Copy task by 2-3X\n- Kept original single-thread copy task for single-thread operation and added new TPL ActionBlock based parallel implementation.\n- All UTs pass with old and new implementations\n- See empirical time comparison numbers in table in Copy.cs. ~2X faster for SSD and ~3x for spinny disk.",
          "committedDate": "2018-05-19T01:36:35Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0e9ca120c0d705ccb77e3311af15654bd7e4ed31",
          "message": "Move to finite (4 or 6) parallelism per PR comment.",
          "committedDate": "2018-05-21T21:36:09Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a9820986c54a24837c345dcc6219fcf27cc048f1",
          "message": "Use single-threaded algorithm for single file copies as well as parallelism==1",
          "committedDate": "2018-05-21T21:42:12Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5e7331ab2e9d7b0ace250464dc71fa37803971c",
          "message": "PR comment: Move to lockless array for tracking copy success",
          "committedDate": "2018-05-21T21:46:10Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "29dcd933c34f8b12f09586f5422e56e31eb304f3",
          "message": "Fix mock logger and engine to handle parallel calls from unit tests",
          "committedDate": "2018-05-21T23:22:08Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e95c6ee7fcf5c34763a796ba11b211d957231e0a",
          "message": "No-op R# changes to force rerunning failing PR build",
          "committedDate": "2018-05-21T23:44:36Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c559fa34769e330d493c5f230bbf4d24a65f9623",
          "message": "PR comments",
          "committedDate": "2018-05-30T18:01:22Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4bf532b3e1cd7f9c3578598ae143337293e186da",
          "message": "PR comment: Move to CancellationTokenSource in Copy task",
          "committedDate": "2018-05-30T18:19:56Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "af68cb63bfe0aabdc3b43b02a796896ebf0ab64c",
          "message": "PR comments",
          "committedDate": "2018-05-30T18:31:57Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c0f4c85ba4355bfff36af9c33ff3df010931bc78",
          "message": "Refactor Copy_Tests to add a UseSingleThreadedCopy flag and subclass to set that case",
          "committedDate": "2018-05-30T18:46:20Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a1dbf02ffd3b8c8a4c5c65d11c163efe0e552e9",
          "message": "Move copy parallelism override env var to Traits",
          "committedDate": "2018-05-30T19:03:33Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e15194ff14ee76ab7bfc17f423926a77744c5ee7",
          "message": "step",
          "committedDate": "2018-05-30T19:07:43Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "70b1a4562f7895e681c058da5113c69d0adbb1ea",
          "message": "Fix UT",
          "committedDate": "2018-05-30T22:31:52Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "In general I like this! The only thing we have to make sure of is how this works with large repos + `/m` and how it behaves in VS. @lifengl @cdmihai I know we've had issues before using too many threads when building in VS. Do you see an issue with this approach?\r\n\r\nThis may warrant a experimental branch so we can do a test insertion to VS and get some mileage on it.",
        "createdAt": "2018-05-19T03:13:03Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "Agreed wrt the possible ramifications. Since the copy calls are File.Copy() (synchronous, each holding a threadpool thread but mostly pended in the kernel on I/O waits) it can cause threadpool starvation at least until the TP manager decides it needs to inject more threads to the pool.\r\n\r\nI selected int.MaxValue based on performance only, presenting the greatest possible list of simultaneous pending disk operations to the OS's kernel I/O scheduler; there are sweet spots at n=4 and 6 that are suitable while setting a maximum tax on the TP usage that should be fine to move to as a default if there are starvation problems.",
        "createdAt": "2018-05-19T04:37:43Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "One aside: We could move to manually implemented async I/O (async readfile with large buffers on the order of 256K-1M, then async write t o destination) for the copies, but there are advantages to keeping the (unfortunately synchronous) File.Copy() calls, as they directly map to a Win32 CopyFile() call which avoid kernel-user ring transitions copying partial file buffers around. \r\n\r\nIf there's ever a mapping from a hypothetical File.CopyAsync() that maps to CopyFile() with overlapped I/O then we'd get the best of both worlds.",
        "createdAt": "2018-05-19T04:42:02Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "VC and traditional CSProj still does some design time build inside VS, but I guess Copy task is likely very limited inside design time build, so using more threads might be less concern for this task than others (especially code used in project evaluation phase.) @svetkereMS, do you agree?\r\n\r\nFor this change, I have a few feedbacks:\r\n First, it sounds a nice idea to make the task more efficient, and I do like the idea to use the ActionBlock, so throttling it is very easy.\r\n\r\n  I think you always want to retain the single thread function, and always use it when it only need copy one file.  I believe that is quite common to copy a single file, and the new implementation adds lots of overhead and requires two threads to do the work, which will regress the performance in that scenario.\r\n\r\n It is always better to throttle the number of parallel tasks you create.  It is great to see the action block there.  Generally, I don't see a big benefit to use a number higher than the physical core on the machine, so maybe limit it to 4 threads will be a good default.  The thread pool is not very efficient to handle works generated in large busts.  The idle threads left can waste lots of time to spin CPU to wait new tasks, which no longer comes.  We saw those idle spinning consumes 30% CPU in some traces.  When you are using parallel, measuring and making a single function faster is not always the best way to improve the overall performance.  In the real usage scenario, there will be multiple msbuild nodes building multiple projects at the same time, plus the control node inside VS, so some usage/testing in a more complex scenario might help, (but it also makes it hard to measure the performance).  Otherwise, I will start with a smaller cap (4 sounds reasonable, instead of Int.MaxValue\r\n\r\n I am not sure we want to change it to async, allocating a large buffer is tricky, because it will add memory/GC pressure to the project.  Those large allocations will be in LOH, and won't go away until Gen2 GC, so we need recycle them, and still need throttle the number of tasks in that case.  (We saw each of msbuild process reaches 2G memory allocation for some large solutions, and an aggressive allocation pattern might bring it down.)",
        "createdAt": "2018-05-21T18:29:09Z",
        "author": {
          "login": "lifengl"
        }
      },
      {
        "body": "For next iter, based on discussion above, moved to default parallelism == 4 or 6 (4 for # CPUs 4, 6 for >4).",
        "createdAt": "2018-05-21T21:47:28Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "Working on a VS build. FYI If you want to re-test, write `@dotnet-bot test this please` as the first line of a comment. Can replace `this` with `OSX10.13 Build for CoreCLR` or whatever if you don't want to retest all of them.",
        "createdAt": "2018-05-22T02:21:49Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "@dotnet-bot test Ubuntu14.04 Build for CoreCLR please",
        "createdAt": "2018-05-22T18:40:06Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "I think I'm good with this. I was able to get a green perf run on the internal VS stuff. @rainersigwald you good with this going in?\r\n\r\nOne last thing though, could you add an escape hatch? Add it to [Traits ](https://github.com/Microsoft/msbuild/blob/master/src/Shared/Traits.cs). Something like `MSBUILDCOPYTASKPARALLELISM` and use that value if it exists? The user could in theory set it to 1 to get the legacy behavior (or more likely set it to 1 to rule this out in perf issues that come up). If you're feeling more ambitious you could move `MSBUILDALWAYSRETRY` and `MSBUILDALWAYSOVERWRITEREADONLYFILES` there as well :)",
        "createdAt": "2018-05-30T02:48:33Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "@AndyGerlicher next iteration moves the env var check logic to Traits. (Or place it on EscapeHatches? I was unclear, but Traits seems like the better place.)",
        "createdAt": "2018-05-30T19:03:13Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "Leaving the AlwaysRetry and other flags in Copy.cs for now. Might move them over in another PR.",
        "createdAt": "2018-05-30T19:07:31Z",
        "author": {
          "login": "erikmav"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Always use CopySingleThreaded when we only copy a single file.",
              "createdAt": "2018-05-21T18:30:34Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -323,29 +349,51 @@ CopyFileWithState copyFile\n                 return false;\n             }\n \n-            bool success = true;\n-\n             // Environment variable stomps on user-requested value if it's set. \n-            if (Environment.GetEnvironmentVariable(\"MSBUILDALWAYSOVERWRITEREADONLYFILES\") != null)\n+            if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)\n             {\n                 OverwriteReadOnlyFiles = true;\n             }\n \n-            // Build up the sucessfully copied subset\n-            var destinationFilesSuccessfullyCopied = new List<ITaskItem>();\n+            // Track successfully copied subset.\n+            List <ITaskItem> destinationFilesSuccessfullyCopied;\n+            bool success = parallelism == 1\n+                ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "Done in next iteration",
              "createdAt": "2018-05-21T21:46:22Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -323,29 +349,51 @@ CopyFileWithState copyFile\n                 return false;\n             }\n \n-            bool success = true;\n-\n             // Environment variable stomps on user-requested value if it's set. \n-            if (Environment.GetEnvironmentVariable(\"MSBUILDALWAYSOVERWRITEREADONLYFILES\") != null)\n+            if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)\n             {\n                 OverwriteReadOnlyFiles = true;\n             }\n \n-            // Build up the sucessfully copied subset\n-            var destinationFilesSuccessfullyCopied = new List<ITaskItem>();\n+            // Track successfully copied subset.\n+            List <ITaskItem> destinationFilesSuccessfullyCopied;\n+            bool success = parallelism == 1\n+                ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think we don't need a ConcurrentBag here and sort out the result.  Why just allocate one array isSuccessful[SourceFiles.Length], and set isSuccesful[fileIndex] = true, when one file is copied successfully?  It will be more efficient than ConcurrentBag, and no conflict is expected.",
              "createdAt": "2018-05-21T18:34:39Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +422,136 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successIndices = new ConcurrentBag<int>();",
              "author": {
                "login": "lifengl"
              }
            },
            {
              "body": "Makes sense but only if a bool is the size of a processor word (32 or 64 bits). May instead need an int[] to ensure atomicity",
              "createdAt": "2018-05-21T19:50:31Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +422,136 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successIndices = new ConcurrentBag<int>();",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "Used IntPtr array in next iteration",
              "createdAt": "2018-05-21T21:46:35Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +422,136 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successIndices = new ConcurrentBag<int>();",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`_` instead of `obj` to indicate discard?",
              "createdAt": "2018-05-30T14:39:04Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -419,19 +458,18 @@ internal void AssertLogDoesntContain(string contains)\n \n         public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime)\n         {\n-            _objectCashe.TryGetValue(key, out object obj);\n+            _objectCache.TryGetValue(key, out object obj);\n             return obj;\n         }\n \n         public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection)\n         {\n-            _objectCashe[key] = obj;\n+            _objectCache[key] = obj;\n         }\n \n         public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime)\n         {\n-            var obj = _objectCashe[key];\n-            _objectCashe.Remove(key);\n+            _objectCache.TryRemove(key, out object obj);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It's returned from the method in the next line.",
              "createdAt": "2018-05-30T17:49:09Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -419,19 +458,18 @@ internal void AssertLogDoesntContain(string contains)\n \n         public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime)\n         {\n-            _objectCashe.TryGetValue(key, out object obj);\n+            _objectCache.TryGetValue(key, out object obj);\n             return obj;\n         }\n \n         public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection)\n         {\n-            _objectCashe[key] = obj;\n+            _objectCache[key] = obj;\n         }\n \n         public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime)\n         {\n-            var obj = _objectCashe[key];\n-            _objectCashe.Remove(key);\n+            _objectCache.TryRemove(key, out object obj);",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You switched this to pattern matching but left the rest of these alone. Intentional?\r\n\r\n(No need to go back and do this cleanup more uniformly if it was just missed, just want to make sure I'm not missing something.)",
              "createdAt": "2018-05-30T14:41:08Z",
              "path": "src/Shared/UnitTests/MockLogger.cs",
              "diffHunk": "@@ -228,129 +236,132 @@ public MockLogger(ITestOutputHelper testOutputHelper)\n          */\n         internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)\n         {\n-            AllBuildEvents.Add(eventArgs);\n-\n-            foreach (var handler in AdditionalHandlers)\n+            lock (_lockObj)\n             {\n-                handler(sender, eventArgs);\n-            }\n-\n-            if (eventArgs is BuildWarningEventArgs)\n-            {\n-                BuildWarningEventArgs w = (BuildWarningEventArgs) eventArgs;\n+                AllBuildEvents.Add(eventArgs);\n \n-                // hack: disregard the MTA warning.\n-                // need the second condition to pass on ploc builds\n-                if (w.Code != \"MSB4056\" && !w.Message.Contains(\"MSB4056\"))\n+                foreach (var handler in AdditionalHandlers)\n                 {\n-                    string logMessage = string.Format(\"{0}({1},{2}): {3} warning {4}: {5}\",\n-                        w.File,\n-                        w.LineNumber,\n-                        w.ColumnNumber,\n-                        w.Subcategory,\n-                        w.Code,\n-                        w.Message);\n+                    handler(sender, eventArgs);\n+                }\n \n+                if (eventArgs is BuildWarningEventArgs w)\n+                {\n+                    // hack: disregard the MTA warning.\n+                    // need the second condition to pass on ploc builds\n+                    if (w.Code != \"MSB4056\" && !w.Message.Contains(\"MSB4056\"))\n+                    {\n+                        string logMessage = string.Format(\n+                            \"{0}({1},{2}): {3} warning {4}: {5}\",\n+                            w.File,\n+                            w.LineNumber,\n+                            w.ColumnNumber,\n+                            w.Subcategory,\n+                            w.Code,\n+                            w.Message);\n+\n+                        _fullLog.AppendLine(logMessage);\n+                        _testOutputHelper?.WriteLine(logMessage);\n+\n+                        ++WarningCount;\n+                        Warnings.Add(w);\n+                    }\n+                }\n+                else if (eventArgs is BuildErrorEventArgs)\n+                {\n+                    BuildErrorEventArgs e = (BuildErrorEventArgs) eventArgs;\n+\n+                    string logMessage = string.Format(\n+                        \"{0}({1},{2}): {3} error {4}: {5}\",\n+                        e.File,\n+                        e.LineNumber,\n+                        e.ColumnNumber,\n+                        e.Subcategory,\n+                        e.Code,\n+                        e.Message);\n                     _fullLog.AppendLine(logMessage);\n                     _testOutputHelper?.WriteLine(logMessage);\n \n-                    ++WarningCount;\n-                    Warnings.Add(w);\n+                    ++ErrorCount;\n+                    Errors.Add(e);\n                 }\n-            }\n-            else if (eventArgs is BuildErrorEventArgs)\n-            {\n-                BuildErrorEventArgs e = (BuildErrorEventArgs) eventArgs;\n-\n-                string logMessage = string.Format(\"{0}({1},{2}): {3} error {4}: {5}\",\n-                    e.File,\n-                    e.LineNumber,\n-                    e.ColumnNumber,\n-                    e.Subcategory,\n-                    e.Code,\n-                    e.Message);\n-                _fullLog.AppendLine(logMessage);\n-                _testOutputHelper?.WriteLine(logMessage);\n-\n-                ++ErrorCount;\n-                Errors.Add(e);\n-            }\n-            else\n-            {\n-                // Log the message unless we are a build finished event and logBuildFinished is set to false.\n-                bool logMessage = !(eventArgs is BuildFinishedEventArgs) ||\n-                                  (eventArgs is BuildFinishedEventArgs && LogBuildFinished);\n-                if (logMessage)\n+                else\n                 {\n-                    _fullLog.AppendLine(eventArgs.Message);\n-                    _testOutputHelper?.WriteLine(eventArgs.Message);\n+                    // Log the message unless we are a build finished event and logBuildFinished is set to false.\n+                    bool logMessage = !(eventArgs is BuildFinishedEventArgs) ||\n+                                      (eventArgs is BuildFinishedEventArgs && LogBuildFinished);\n+                    if (logMessage)\n+                    {\n+                        _fullLog.AppendLine(eventArgs.Message);\n+                        _testOutputHelper?.WriteLine(eventArgs.Message);\n+                    }\n                 }\n-            }\n \n-            if (eventArgs is ExternalProjectStartedEventArgs)\n-            {\n-                this.ExternalProjectStartedEvents.Add((ExternalProjectStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is ExternalProjectFinishedEventArgs)\n-            {\n-                this.ExternalProjectFinishedEvents.Add((ExternalProjectFinishedEventArgs)eventArgs);\n-            }\n-\n-            if (eventArgs is ProjectStartedEventArgs)\n-            {\n-                this.ProjectStartedEvents.Add((ProjectStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is ProjectFinishedEventArgs)\n-            {\n-                this.ProjectFinishedEvents.Add((ProjectFinishedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TargetStartedEventArgs)\n-            {\n-                this.TargetStartedEvents.Add((TargetStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TargetFinishedEventArgs)\n-            {\n-                this.TargetFinishedEvents.Add((TargetFinishedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TaskStartedEventArgs)\n-            {\n-                this.TaskStartedEvents.Add((TaskStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TaskFinishedEventArgs)\n-            {\n-                this.TaskFinishedEvents.Add((TaskFinishedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is BuildMessageEventArgs)\n-            {\n-                this.BuildMessageEvents.Add((BuildMessageEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is BuildStartedEventArgs)\n-            {\n-                this.BuildStartedEvents.Add((BuildStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is BuildFinishedEventArgs)\n-            {\n-                this.BuildFinishedEvents.Add((BuildFinishedEventArgs)eventArgs);\n-\n-                if (!AllowTaskCrashes)\n+                if (eventArgs is ExternalProjectStartedEventArgs args)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was trying to minimize churn in favor of the substantive changes in this PR. I'll sweep back through here in my other series related to formatting and upgrading to .NET 2+ data structures.",
              "createdAt": "2018-05-30T17:52:08Z",
              "path": "src/Shared/UnitTests/MockLogger.cs",
              "diffHunk": "@@ -228,129 +236,132 @@ public MockLogger(ITestOutputHelper testOutputHelper)\n          */\n         internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)\n         {\n-            AllBuildEvents.Add(eventArgs);\n-\n-            foreach (var handler in AdditionalHandlers)\n+            lock (_lockObj)\n             {\n-                handler(sender, eventArgs);\n-            }\n-\n-            if (eventArgs is BuildWarningEventArgs)\n-            {\n-                BuildWarningEventArgs w = (BuildWarningEventArgs) eventArgs;\n+                AllBuildEvents.Add(eventArgs);\n \n-                // hack: disregard the MTA warning.\n-                // need the second condition to pass on ploc builds\n-                if (w.Code != \"MSB4056\" && !w.Message.Contains(\"MSB4056\"))\n+                foreach (var handler in AdditionalHandlers)\n                 {\n-                    string logMessage = string.Format(\"{0}({1},{2}): {3} warning {4}: {5}\",\n-                        w.File,\n-                        w.LineNumber,\n-                        w.ColumnNumber,\n-                        w.Subcategory,\n-                        w.Code,\n-                        w.Message);\n+                    handler(sender, eventArgs);\n+                }\n \n+                if (eventArgs is BuildWarningEventArgs w)\n+                {\n+                    // hack: disregard the MTA warning.\n+                    // need the second condition to pass on ploc builds\n+                    if (w.Code != \"MSB4056\" && !w.Message.Contains(\"MSB4056\"))\n+                    {\n+                        string logMessage = string.Format(\n+                            \"{0}({1},{2}): {3} warning {4}: {5}\",\n+                            w.File,\n+                            w.LineNumber,\n+                            w.ColumnNumber,\n+                            w.Subcategory,\n+                            w.Code,\n+                            w.Message);\n+\n+                        _fullLog.AppendLine(logMessage);\n+                        _testOutputHelper?.WriteLine(logMessage);\n+\n+                        ++WarningCount;\n+                        Warnings.Add(w);\n+                    }\n+                }\n+                else if (eventArgs is BuildErrorEventArgs)\n+                {\n+                    BuildErrorEventArgs e = (BuildErrorEventArgs) eventArgs;\n+\n+                    string logMessage = string.Format(\n+                        \"{0}({1},{2}): {3} error {4}: {5}\",\n+                        e.File,\n+                        e.LineNumber,\n+                        e.ColumnNumber,\n+                        e.Subcategory,\n+                        e.Code,\n+                        e.Message);\n                     _fullLog.AppendLine(logMessage);\n                     _testOutputHelper?.WriteLine(logMessage);\n \n-                    ++WarningCount;\n-                    Warnings.Add(w);\n+                    ++ErrorCount;\n+                    Errors.Add(e);\n                 }\n-            }\n-            else if (eventArgs is BuildErrorEventArgs)\n-            {\n-                BuildErrorEventArgs e = (BuildErrorEventArgs) eventArgs;\n-\n-                string logMessage = string.Format(\"{0}({1},{2}): {3} error {4}: {5}\",\n-                    e.File,\n-                    e.LineNumber,\n-                    e.ColumnNumber,\n-                    e.Subcategory,\n-                    e.Code,\n-                    e.Message);\n-                _fullLog.AppendLine(logMessage);\n-                _testOutputHelper?.WriteLine(logMessage);\n-\n-                ++ErrorCount;\n-                Errors.Add(e);\n-            }\n-            else\n-            {\n-                // Log the message unless we are a build finished event and logBuildFinished is set to false.\n-                bool logMessage = !(eventArgs is BuildFinishedEventArgs) ||\n-                                  (eventArgs is BuildFinishedEventArgs && LogBuildFinished);\n-                if (logMessage)\n+                else\n                 {\n-                    _fullLog.AppendLine(eventArgs.Message);\n-                    _testOutputHelper?.WriteLine(eventArgs.Message);\n+                    // Log the message unless we are a build finished event and logBuildFinished is set to false.\n+                    bool logMessage = !(eventArgs is BuildFinishedEventArgs) ||\n+                                      (eventArgs is BuildFinishedEventArgs && LogBuildFinished);\n+                    if (logMessage)\n+                    {\n+                        _fullLog.AppendLine(eventArgs.Message);\n+                        _testOutputHelper?.WriteLine(eventArgs.Message);\n+                    }\n                 }\n-            }\n \n-            if (eventArgs is ExternalProjectStartedEventArgs)\n-            {\n-                this.ExternalProjectStartedEvents.Add((ExternalProjectStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is ExternalProjectFinishedEventArgs)\n-            {\n-                this.ExternalProjectFinishedEvents.Add((ExternalProjectFinishedEventArgs)eventArgs);\n-            }\n-\n-            if (eventArgs is ProjectStartedEventArgs)\n-            {\n-                this.ProjectStartedEvents.Add((ProjectStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is ProjectFinishedEventArgs)\n-            {\n-                this.ProjectFinishedEvents.Add((ProjectFinishedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TargetStartedEventArgs)\n-            {\n-                this.TargetStartedEvents.Add((TargetStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TargetFinishedEventArgs)\n-            {\n-                this.TargetFinishedEvents.Add((TargetFinishedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TaskStartedEventArgs)\n-            {\n-                this.TaskStartedEvents.Add((TaskStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is TaskFinishedEventArgs)\n-            {\n-                this.TaskFinishedEvents.Add((TaskFinishedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is BuildMessageEventArgs)\n-            {\n-                this.BuildMessageEvents.Add((BuildMessageEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is BuildStartedEventArgs)\n-            {\n-                this.BuildStartedEvents.Add((BuildStartedEventArgs)eventArgs);\n-            }\n-            else if (eventArgs is BuildFinishedEventArgs)\n-            {\n-                this.BuildFinishedEvents.Add((BuildFinishedEventArgs)eventArgs);\n-\n-                if (!AllowTaskCrashes)\n+                if (eventArgs is ExternalProjectStartedEventArgs args)",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this need to be a property? Could it just be a `const`?",
              "createdAt": "2018-05-30T14:43:43Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -26,6 +28,13 @@ public class Copy_Tests : IDisposable\n \n         public bool UseSymbolicLinks { get; protected set; }\n \n+        /// <summary>\n+        /// Max copy parallelism to provide to the Copy task.\n+        /// </summary>\n+        public int ParallelismThreadCount { get; set; } = int.MaxValue;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "-> private const. It had started out more complex before it got to this PR",
              "createdAt": "2018-05-30T17:52:29Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -26,6 +28,13 @@ public class Copy_Tests : IDisposable\n \n         public bool UseSymbolicLinks { get; protected set; }\n \n+        /// <summary>\n+        /// Max copy parallelism to provide to the Copy task.\n+        /// </summary>\n+        public int ParallelismThreadCount { get; set; } = int.MaxValue;",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For this pattern, would it be better to just have two subclasses of this class, one parallel and one single-threaded, and not parameterize the tests?",
              "createdAt": "2018-05-30T14:45:04Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -63,20 +72,31 @@ public Copy_Tests(ITestOutputHelper testOutputHelper)\n         /// </summary>\n         public void Dispose()\n         {\n-            Environment.SetEnvironmentVariable(\"MSBUILDALWAYSOVERWRITEREADONLYFILES\", _alwaysOverwriteReadOnlyFiles);\n-            Environment.SetEnvironmentVariable(\"MSBUILDALWAYSRETRY\", _alwaysRetry);\n+            Environment.SetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar, _alwaysOverwriteReadOnlyFiles);\n+            Environment.SetEnvironmentVariable(Copy.AlwaysRetryEnvVar, _alwaysRetry);\n \n             Copy.RefreshInternalEnvironmentValues();\n         }\n \n+        [Fact]\n+        public void DontCopyOverSameFile_Parallel()\n+        {\n+            DontCopyOverSameFile(ParallelismThreadCount);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you reference Shouldly (which we've moved some tests to) and Linq, you could simplify this to:\r\n\r\n```c#\r\nfilesActuallyCopied.Select(f => f.Key.Name).ShouldBe(new[] { \"a.cs\", \"b.cs\" }, ignoreOrder: true);\r\n```",
              "createdAt": "2018-05-30T14:56:50Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -1346,25 +1377,49 @@ public void CopyWithDuplicatesUsingFolder()\n \n             bool success = t.Execute(delegate (FileState source, FileState dest)\n             {\n-                filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));\n+                lock (filesActuallyCopied)\n+                {\n+                    filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));\n+                }\n                 return true;\n-            });\n+            }, parallelism);\n \n             Assert.True(success);\n             Assert.Equal(2, filesActuallyCopied.Count);\n             Assert.Equal(4, t.CopiedFiles.Length);\n-            Assert.Equal(Path.Combine(tempPath, \"a.cs\"), filesActuallyCopied[0].Key.Name);\n-            Assert.Equal(Path.Combine(tempPath, \"b.cs\"), filesActuallyCopied[1].Key.Name);\n+\n+            // Copy calls to different destinations can come in any order when running in parallel.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Updated",
              "createdAt": "2018-05-30T17:55:16Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -1346,25 +1377,49 @@ public void CopyWithDuplicatesUsingFolder()\n \n             bool success = t.Execute(delegate (FileState source, FileState dest)\n             {\n-                filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));\n+                lock (filesActuallyCopied)\n+                {\n+                    filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));\n+                }\n                 return true;\n-            });\n+            }, parallelism);\n \n             Assert.True(success);\n             Assert.Equal(2, filesActuallyCopied.Count);\n             Assert.Equal(4, t.CopiedFiles.Length);\n-            Assert.Equal(Path.Combine(tempPath, \"a.cs\"), filesActuallyCopied[0].Key.Name);\n-            Assert.Equal(Path.Combine(tempPath, \"b.cs\"), filesActuallyCopied[1].Key.Name);\n+\n+            // Copy calls to different destinations can come in any order when running in parallel.",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment still relevant?",
              "createdAt": "2018-05-30T14:59:01Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -1927,10 +2054,7 @@ public void CopyToDestinationFolderWithHardLinkCheck()\n             string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));\n             try\n             {\n-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.\n-                {\n-                    sw.Write(\"This is a source temp file.\");\n-                }\n+                File.WriteAllText(sourceFile, \"This is a source temp file.\"); // HIGHCHAR: Test writes in UTF8 without preamble.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "removed",
              "createdAt": "2018-05-30T18:26:39Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -1927,10 +2054,7 @@ public void CopyToDestinationFolderWithHardLinkCheck()\n             string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));\n             try\n             {\n-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.\n-                {\n-                    sw.Write(\"This is a source temp file.\");\n-                }\n+                File.WriteAllText(sourceFile, \"This is a source temp file.\"); // HIGHCHAR: Test writes in UTF8 without preamble.",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this is actually expected; I think it's here to hide \"infrastructure\" failures.",
              "createdAt": "2018-05-30T15:00:52Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -2020,19 +2134,22 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()\n             }\n             catch (Exception)\n             {\n-                Console.WriteLine(\"CopyToDestinationFolderWithHardLinkFallbackNetwork test could not access the network.\");\n+                Console.WriteLine(\"CopyToDestinationFolderWithHardLinkFallbackNetwork test could not access the network as expected.\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oops. Removed",
              "createdAt": "2018-05-30T18:27:45Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -2020,19 +2134,22 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()\n             }\n             catch (Exception)\n             {\n-                Console.WriteLine(\"CopyToDestinationFolderWithHardLinkFallbackNetwork test could not access the network.\");\n+                Console.WriteLine(\"CopyToDestinationFolderWithHardLinkFallbackNetwork test could not access the network as expected.\");",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "No relevant order problems here?",
              "createdAt": "2018-05-30T15:02:25Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -2048,52 +2165,47 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()\n                 bool success = t.Execute();\n \n                 Assert.True(success); // \"success\"\n-                Assert.True(File.Exists(destFile)); // \"destination exists\"\n+                Assert.True(File.Exists(destFile1)); // \"destination exists\"\n+                Assert.True(File.Exists(destFile2)); // \"destination exists\"\n                 MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;\n \n-                me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.HardLinkComment\", sourceFile, destFile);\n+                me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.HardLinkComment\", sourceFile1, destFile1);\n \n                 // Can't do this below, because the real message doesn't end with String.Empty, it ends with a CLR exception string, and so matching breaks in PLOC.\n-                // Instead look for the HRESULT that CLR unfortunately puts inside its exception string. Something like this\n-                // The system cannot move the file to a different disk drive. (Exception from HRESULT: 0x80070011)\n+                // Instead look for the HRESULT that CLR unfortunately puts inside its exception string. Something like this:\n+                //   The system cannot move the file to a different disk drive. (Exception from HRESULT: 0x80070011)\n                 // me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.RetryingAsFileCopy\", sourceFile, destFile, String.Empty);\n                 me.AssertLogContains(\"0x80070011\");\n \n-                string destinationFileContents;\n-                using (StreamReader sr = FileUtilities.OpenRead(destFile))\n-                {\n-                    destinationFileContents = sr.ReadToEnd();\n-                }\n-\n-                Assert.Equal(\"This is a source temp file.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n+                string destinationFileContents = File.ReadAllText(destFile1);\n+                Assert.Equal(\"This is source temp file 1.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n+                destinationFileContents = File.ReadAllText(destFile2);\n+                Assert.Equal(\"This is source temp file 2.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n \n-                Assert.Equal(1, t.DestinationFiles.Length);\n-                Assert.Equal(1, t.CopiedFiles.Length);\n-                Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);\n-                Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);\n+                Assert.Equal(2, t.DestinationFiles.Length);\n+                Assert.Equal(2, t.CopiedFiles.Length);\n+                Assert.Equal(destFile1, t.DestinationFiles[0].ItemSpec);\n+                Assert.Equal(destFile2, t.DestinationFiles[1].ItemSpec);\n+                Assert.Equal(destFile1, t.CopiedFiles[0].ItemSpec);\n+                Assert.Equal(destFile2, t.CopiedFiles[1].ItemSpec);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "No, in fact if these for some reason came out in a different order it's a bug: These outputs must be ordered in the same order as the inputs as part of the contract. Which is why the parallel code has some complexity in applying logic partitions by destination file path.",
              "createdAt": "2018-05-30T18:29:48Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -2048,52 +2165,47 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()\n                 bool success = t.Execute();\n \n                 Assert.True(success); // \"success\"\n-                Assert.True(File.Exists(destFile)); // \"destination exists\"\n+                Assert.True(File.Exists(destFile1)); // \"destination exists\"\n+                Assert.True(File.Exists(destFile2)); // \"destination exists\"\n                 MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;\n \n-                me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.HardLinkComment\", sourceFile, destFile);\n+                me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.HardLinkComment\", sourceFile1, destFile1);\n \n                 // Can't do this below, because the real message doesn't end with String.Empty, it ends with a CLR exception string, and so matching breaks in PLOC.\n-                // Instead look for the HRESULT that CLR unfortunately puts inside its exception string. Something like this\n-                // The system cannot move the file to a different disk drive. (Exception from HRESULT: 0x80070011)\n+                // Instead look for the HRESULT that CLR unfortunately puts inside its exception string. Something like this:\n+                //   The system cannot move the file to a different disk drive. (Exception from HRESULT: 0x80070011)\n                 // me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.RetryingAsFileCopy\", sourceFile, destFile, String.Empty);\n                 me.AssertLogContains(\"0x80070011\");\n \n-                string destinationFileContents;\n-                using (StreamReader sr = FileUtilities.OpenRead(destFile))\n-                {\n-                    destinationFileContents = sr.ReadToEnd();\n-                }\n-\n-                Assert.Equal(\"This is a source temp file.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n+                string destinationFileContents = File.ReadAllText(destFile1);\n+                Assert.Equal(\"This is source temp file 1.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n+                destinationFileContents = File.ReadAllText(destFile2);\n+                Assert.Equal(\"This is source temp file 2.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n \n-                Assert.Equal(1, t.DestinationFiles.Length);\n-                Assert.Equal(1, t.CopiedFiles.Length);\n-                Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);\n-                Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);\n+                Assert.Equal(2, t.DestinationFiles.Length);\n+                Assert.Equal(2, t.CopiedFiles.Length);\n+                Assert.Equal(destFile1, t.DestinationFiles[0].ItemSpec);\n+                Assert.Equal(destFile2, t.DestinationFiles[1].ItemSpec);\n+                Assert.Equal(destFile1, t.CopiedFiles[0].ItemSpec);\n+                Assert.Equal(destFile2, t.CopiedFiles[1].ItemSpec);",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "Makes sense!",
              "createdAt": "2018-05-30T18:32:44Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -2048,52 +2165,47 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()\n                 bool success = t.Execute();\n \n                 Assert.True(success); // \"success\"\n-                Assert.True(File.Exists(destFile)); // \"destination exists\"\n+                Assert.True(File.Exists(destFile1)); // \"destination exists\"\n+                Assert.True(File.Exists(destFile2)); // \"destination exists\"\n                 MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;\n \n-                me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.HardLinkComment\", sourceFile, destFile);\n+                me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.HardLinkComment\", sourceFile1, destFile1);\n \n                 // Can't do this below, because the real message doesn't end with String.Empty, it ends with a CLR exception string, and so matching breaks in PLOC.\n-                // Instead look for the HRESULT that CLR unfortunately puts inside its exception string. Something like this\n-                // The system cannot move the file to a different disk drive. (Exception from HRESULT: 0x80070011)\n+                // Instead look for the HRESULT that CLR unfortunately puts inside its exception string. Something like this:\n+                //   The system cannot move the file to a different disk drive. (Exception from HRESULT: 0x80070011)\n                 // me.AssertLogContainsMessageFromResource(resourceDelegate, \"Copy.RetryingAsFileCopy\", sourceFile, destFile, String.Empty);\n                 me.AssertLogContains(\"0x80070011\");\n \n-                string destinationFileContents;\n-                using (StreamReader sr = FileUtilities.OpenRead(destFile))\n-                {\n-                    destinationFileContents = sr.ReadToEnd();\n-                }\n-\n-                Assert.Equal(\"This is a source temp file.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n+                string destinationFileContents = File.ReadAllText(destFile1);\n+                Assert.Equal(\"This is source temp file 1.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n+                destinationFileContents = File.ReadAllText(destFile2);\n+                Assert.Equal(\"This is source temp file 2.\", destinationFileContents); //\"Expected the destination file to contain the contents of source file.\"\n \n-                Assert.Equal(1, t.DestinationFiles.Length);\n-                Assert.Equal(1, t.CopiedFiles.Length);\n-                Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);\n-                Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);\n+                Assert.Equal(2, t.DestinationFiles.Length);\n+                Assert.Equal(2, t.CopiedFiles.Length);\n+                Assert.Equal(destFile1, t.DestinationFiles[0].ItemSpec);\n+                Assert.Equal(destFile2, t.DestinationFiles[1].ItemSpec);\n+                Assert.Equal(destFile1, t.CopiedFiles[0].ItemSpec);\n+                Assert.Equal(destFile2, t.CopiedFiles[1].ItemSpec);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this necessary? I'd expect it to be rolled into `Microsoft.NETCore.App`.",
              "createdAt": "2018-05-30T15:04:50Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -961,6 +962,7 @@\n     <PackageReference Include=\"System.Reflection.Metadata\" Version=\"1.3.0\" />\n     <PackageReference Include=\"System.Reflection.TypeExtensions\" Version=\"4.1.0\" />\n     <PackageReference Include=\"System.Resources.Writer\" Version=\"4.0.0\" />\n+    <PackageReference Include=\"System.Threading.Tasks.Dataflow\" Version=\"4.6.0\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was mirroring what the engine core csproj does exactly to avoid different file versions colliding with each other. If the core engine upgrades it's packages this will need to be done as well",
              "createdAt": "2018-05-30T18:30:54Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -961,6 +962,7 @@\n     <PackageReference Include=\"System.Reflection.Metadata\" Version=\"1.3.0\" />\n     <PackageReference Include=\"System.Reflection.TypeExtensions\" Version=\"4.1.0\" />\n     <PackageReference Include=\"System.Resources.Writer\" Version=\"4.0.0\" />\n+    <PackageReference Include=\"System.Threading.Tasks.Dataflow\" Version=\"4.6.0\" />",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "?\r\n\r\nhttps://github.com/Microsoft/msbuild/blob/8c2c86bd5ca84b8fd6f6e555111dd55d750024d7/src/Tasks/Microsoft.Common.CurrentVersion.targets#L4180\r\n\r\nand several others. Is it missing somewhere? Should we just add it there?",
              "createdAt": "2018-05-30T15:18:07Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -29,14 +51,23 @@ public Copy()\n         #region Properties\n \n         private bool _canceling;\n-        private readonly HashSet<string> _directoriesKnownToExist = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n+\n+        // Bool is just a placeholder, we're mainly interested in a threadsafe key set.\n+        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);\n \n         /// <summary>\n         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since \n         /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually \n         /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.  \n         /// </summary>\n-        private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(\"MSBUILDALWAYSRETRY\") != null;\n+        private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(AlwaysRetryEnvVar) != null;\n+\n+        /// <summary>\n+        /// Global flag to force on UseSymboliclinksIfPossible since Microsoft.Common.targets doesn't expose the functionality.\n+        /// </summary>\n+        private static readonly bool s_forceSymlinks = Environment.GetEnvironmentVariable(\"MSBuildUseSymboliclinksIfPossible\") != null;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was unsure what to do here: Was it a deliberate choice to avoid exposing this functionality? It's not in the .targets so I figured to make it reachable by env var. I can pull this from this PR as well, as I have an experiment to do after this PR to try ReFS copy-on-write Clones instead of File.Copy(), as a Windows-specific flag and functionality, and would be touching this area again.",
              "createdAt": "2018-05-30T17:58:23Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -29,14 +51,23 @@ public Copy()\n         #region Properties\n \n         private bool _canceling;\n-        private readonly HashSet<string> _directoriesKnownToExist = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n+\n+        // Bool is just a placeholder, we're mainly interested in a threadsafe key set.\n+        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);\n \n         /// <summary>\n         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since \n         /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually \n         /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.  \n         /// </summary>\n-        private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(\"MSBUILDALWAYSRETRY\") != null;\n+        private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(AlwaysRetryEnvVar) != null;\n+\n+        /// <summary>\n+        /// Global flag to force on UseSymboliclinksIfPossible since Microsoft.Common.targets doesn't expose the functionality.\n+        /// </summary>\n+        private static readonly bool s_forceSymlinks = Environment.GetEnvironmentVariable(\"MSBuildUseSymboliclinksIfPossible\") != null;",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: space between type and type param",
              "createdAt": "2018-05-30T15:19:25Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -323,29 +354,53 @@ CopyFileWithState copyFile\n                 return false;\n             }\n \n-            bool success = true;\n-\n             // Environment variable stomps on user-requested value if it's set. \n-            if (Environment.GetEnvironmentVariable(\"MSBUILDALWAYSOVERWRITEREADONLYFILES\") != null)\n+            if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)\n             {\n                 OverwriteReadOnlyFiles = true;\n             }\n \n-            // Build up the sucessfully copied subset\n-            var destinationFilesSuccessfullyCopied = new List<ITaskItem>();\n+            // Track successfully copied subset.\n+            List <ITaskItem> destinationFilesSuccessfullyCopied;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "fixed",
              "createdAt": "2018-05-30T17:58:50Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -323,29 +354,53 @@ CopyFileWithState copyFile\n                 return false;\n             }\n \n-            bool success = true;\n-\n             // Environment variable stomps on user-requested value if it's set. \n-            if (Environment.GetEnvironmentVariable(\"MSBUILDALWAYSOVERWRITEREADONLYFILES\") != null)\n+            if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)\n             {\n                 OverwriteReadOnlyFiles = true;\n             }\n \n-            // Build up the sucessfully copied subset\n-            var destinationFilesSuccessfullyCopied = new List<ITaskItem>();\n+            // Track successfully copied subset.\n+            List <ITaskItem> destinationFilesSuccessfullyCopied;",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you plumb cancellation through here too? I think you should switch `_canceling` to be a `CancellationTokenSource`, then pass that through here. Jeff did something similar in https://github.com/Microsoft/msbuild/pull/3291/commits/4501ce63d7fe623021fef602943eb4b21c40a2bb.",
              "createdAt": "2018-05-30T15:28:56Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +429,137 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successFlags = new IntPtr[DestinationFiles.Length];  // Lockless flags updated from each thread.\n+            var actionBlockOptions = new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = parallelism };",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done in next iteration. But I did not use Yield() as it was unclear that was the right thing to do given the number of TP threads this logic now holds.",
              "createdAt": "2018-05-30T18:24:31Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +429,137 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successFlags = new IntPtr[DestinationFiles.Length];  // Lockless flags updated from each thread.\n+            var actionBlockOptions = new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = parallelism };",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "To more closely match our style elsewhere, I'd say\r\n\r\n```c#\r\nErrorUtilities.VerifyThrow(partitionAccepted,\r\n    \"Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.\");\r\n```\r\n\r\nThat throws an `InternalErrorException` which is handled semi-specially.",
              "createdAt": "2018-05-30T15:33:49Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +429,137 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successFlags = new IntPtr[DestinationFiles.Length];  // Lockless flags updated from each thread.\n+            var actionBlockOptions = new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = parallelism };\n+            var partitionCopyActionBlock = new ActionBlock<List<int>>(\n+                async (List<int> partition) =>\n+                {\n+                    // Break from synchronous thread context of caller to get onto thread pool thread.\n+                    await System.Threading.Tasks.Task.Yield();\n+\n+                    for (int partitionIndex = 0; partitionIndex < partition.Count; partitionIndex++)\n+                    {\n+                        int fileIndex = partition[partitionIndex];\n+                        ITaskItem sourceItem = SourceFiles[fileIndex];\n+                        ITaskItem destItem = DestinationFiles[fileIndex];\n+                        string sourcePath = sourceItem.ItemSpec;\n+\n+                        // Check if we just copied from this location to the destination, don't copy again.\n+                        bool copyComplete = partitionIndex > 0 &&\n+                                            String.Equals(\n+                                                sourcePath,\n+                                                SourceFiles[partition[partitionIndex - 1]].ItemSpec,\n+                                                StringComparison.OrdinalIgnoreCase);\n+\n+                        if (!copyComplete)\n+                        {\n+                            if (DoCopyIfNecessary(\n+                                new FileState(sourceItem.ItemSpec),\n+                                new FileState(destItem.ItemSpec),\n+                                copyFile))\n+                            {\n+                                copyComplete = true;\n+                            }\n+                            else\n+                            {\n+                                // Thread race to set outer variable but they race to set the same (false) value.\n+                                success = false;\n+                            }\n+                        }\n+\n+                        if (copyComplete)\n+                        {\n+                            sourceItem.CopyMetadataTo(destItem);\n+                            successFlags[fileIndex] = (IntPtr)1;\n+                        }\n+                    }\n+                },\n+                actionBlockOptions);\n+\n+            foreach (List<int> partition in partitionsByDestination.Values)\n+            {\n+                bool partitionAccepted = partitionCopyActionBlock.Post(partition);\n+                if (!partitionAccepted)\n+                {\n+                    // Retail assert...\n+                    throw new InvalidOperationException(\n+                        \"BUGCHECK: Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "fixed",
              "createdAt": "2018-05-30T17:59:44Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +429,137 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successFlags = new IntPtr[DestinationFiles.Length];  // Lockless flags updated from each thread.\n+            var actionBlockOptions = new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = parallelism };\n+            var partitionCopyActionBlock = new ActionBlock<List<int>>(\n+                async (List<int> partition) =>\n+                {\n+                    // Break from synchronous thread context of caller to get onto thread pool thread.\n+                    await System.Threading.Tasks.Task.Yield();\n+\n+                    for (int partitionIndex = 0; partitionIndex < partition.Count; partitionIndex++)\n+                    {\n+                        int fileIndex = partition[partitionIndex];\n+                        ITaskItem sourceItem = SourceFiles[fileIndex];\n+                        ITaskItem destItem = DestinationFiles[fileIndex];\n+                        string sourcePath = sourceItem.ItemSpec;\n+\n+                        // Check if we just copied from this location to the destination, don't copy again.\n+                        bool copyComplete = partitionIndex > 0 &&\n+                                            String.Equals(\n+                                                sourcePath,\n+                                                SourceFiles[partition[partitionIndex - 1]].ItemSpec,\n+                                                StringComparison.OrdinalIgnoreCase);\n+\n+                        if (!copyComplete)\n+                        {\n+                            if (DoCopyIfNecessary(\n+                                new FileState(sourceItem.ItemSpec),\n+                                new FileState(destItem.ItemSpec),\n+                                copyFile))\n+                            {\n+                                copyComplete = true;\n+                            }\n+                            else\n+                            {\n+                                // Thread race to set outer variable but they race to set the same (false) value.\n+                                success = false;\n+                            }\n+                        }\n+\n+                        if (copyComplete)\n+                        {\n+                            sourceItem.CopyMetadataTo(destItem);\n+                            successFlags[fileIndex] = (IntPtr)1;\n+                        }\n+                    }\n+                },\n+                actionBlockOptions);\n+\n+            foreach (List<int> partition in partitionsByDestination.Values)\n+            {\n+                bool partitionAccepted = partitionCopyActionBlock.Post(partition);\n+                if (!partitionAccepted)\n+                {\n+                    // Retail assert...\n+                    throw new InvalidOperationException(\n+                        \"BUGCHECK: Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity\");",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I _think_ I understand why you're doing this but I'd like a more verbose comment, please, because that's probably optimism.",
              "createdAt": "2018-05-30T15:34:48Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +429,137 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successFlags = new IntPtr[DestinationFiles.Length];  // Lockless flags updated from each thread.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Was in the PR conversation but I didn't transcribe well. Added: // Lockless flags updated from each thread - each needs to be a processor word for atomicity.",
              "createdAt": "2018-05-30T18:00:54Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -374,15 +429,137 @@ CopyFileWithState copyFile\n                 }\n             }\n \n-            // copiedFiles contains only the copies that were successful.\n-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();\n+            return success;\n+        }\n \n-            return success && !_canceling;\n+        /// <summary>\n+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.\n+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send\n+        /// to CopyTask as we get further and further down the dependency graph.\n+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get\n+        /// it all done.\n+        /// </summary>\n+        private bool CopyParallel(\n+            CopyFileWithState copyFile,\n+            int parallelism,\n+            out List<ITaskItem> destinationFilesSuccessfullyCopied)\n+        {\n+            bool success = true;\n+\n+            // We must supply the same semantics as the single-threaded version above:\n+            //\n+            // - For copy operations in the list that have the same destination, we must\n+            //   provide for in-order copy attempts that allow re-copying different files\n+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.\n+            //   We must also add a destination file copy item for each attempt.\n+            // - The order of entries in destinationFilesSuccessfullyCopied must match\n+            //   the order of entries passed in, along with copied metadata.\n+            // - Metadata must not be copied to destination item if the copy operation failed.\n+            //\n+            // We split the work into different Tasks:\n+            //\n+            // - Entries with unique destination file paths each get their own parallel operation.\n+            // - Each subset of copies into the same destination get their own Task to run\n+            //   the single-threaded logic in order.\n+            //\n+            // At the end we reassemble the result list in the same order as was passed in.\n+\n+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).\n+            var partitionsByDestination = new Dictionary<string, List<int>>(\n+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)\n+            {\n+                ITaskItem destItem = DestinationFiles[i];\n+                string destPath = destItem.ItemSpec;\n+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))\n+                {\n+                    // Use 1 for list length - common case is for no destination overlap.\n+                    sourceIndices = new List<int>(1);\n+                    partitionsByDestination[destPath] = sourceIndices;\n+                }\n+                sourceIndices.Add(i);\n+            }\n+\n+            var successFlags = new IntPtr[DestinationFiles.Length];  // Lockless flags updated from each thread.",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      }
    ]
  }
}