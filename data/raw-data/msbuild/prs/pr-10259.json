{
  "number": 10259,
  "title": "Wasm/WASI tasks spec",
  "body": "This is a PR for the proposed WASI-Build feature spec, only documentation\r\n\r\nWIP implementation: https://github.com/JanProvaznik/MSBuildWasm",
  "state": "MERGED",
  "createdAt": "2024-06-18T14:43:23Z",
  "updatedAt": "2024-08-12T13:38:39Z",
  "closedAt": "2024-08-12T13:38:38Z",
  "mergedAt": "2024-08-12T13:38:38Z",
  "additions": 442,
  "deletions": 0,
  "changedFiles": 2,
  "headRefName": "dev/janpro/wasi-tasks-spec",
  "isDraft": false,
  "author": {
    "login": "JanProvaznik"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "JanProvaznik"
      }
    ]
  },
  "labels": [
    "Area: Tasks"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c1a00caa8cf252654ad57a82dbc5361072d5f418",
          "message": "initial spec background and context",
          "committedDate": "2024-06-18T11:07:43Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "104218b0731cb9445b2d4e3874098953e4db0c2e",
          "message": "update spec with findings, interpretations, questions",
          "committedDate": "2024-06-19T16:29:46Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8685c1f2a3603772b8de51a6db4fcce818fe258e",
          "message": "ascertain goals, address feedback",
          "committedDate": "2024-06-20T16:19:14Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e951885df65830a56105085fb8d5d5e4457e6263",
          "message": "Update spec with details after experiments in the ecosystem",
          "committedDate": "2024-06-25T12:42:49Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janpro@janpro.dev"
          }
        }
      },
      {
        "commit": {
          "oid": "4e4aeffd36ef54fa20ecb6588ef1ea21c38f755a",
          "message": "add API specification in WIT\nclarify spec, update with info about communication between host and tasks",
          "committedDate": "2024-07-01T16:32:25Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "42d1f06224353c1ecad4dcab18df8a67472a55ab",
          "message": "rename to Wasm-tasks",
          "committedDate": "2024-07-01T16:33:02Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f8541c378fa5e478442a828331f71a90e0a1c647",
          "message": "update spec with better understanding of Wasm, and lessons from\nattempted implementation",
          "committedDate": "2024-07-12T16:02:38Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "89fe99751ea3afc2fdf48fed860fc48849506fdb",
          "message": "address comments",
          "committedDate": "2024-07-17T11:22:56Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbf0267103ed968680a5f18190aa2c3665bae897",
          "message": "fix details about logging",
          "committedDate": "2024-07-17T11:24:03Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7aba7ab3980d41f46379e3fe2dc8aa81daa25af4",
          "message": "update with communication details, WASIp1/p2 diff",
          "committedDate": "2024-07-24T13:39:50Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "85752181edee19783a2d126d09553e1f0adf201d",
          "message": "update proposed WIT\nformatting",
          "committedDate": "2024-07-26T13:06:30Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "40fc3465e38bd4ed255fed2d7fcc4afbf9dce124",
          "message": "clarify diagram",
          "committedDate": "2024-07-26T14:04:33Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e093d912574a71cc7bf9edd1ea203c4109f18621",
          "message": "add links to docs, address feedback\nformat and fix WIT so it can generate bindings",
          "committedDate": "2024-07-29T10:28:22Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f72d9d56e94c4c219edb443e90fbf52b0cef4ab5",
          "message": "update JSON communication format, future work and fixing details",
          "committedDate": "2024-08-07T12:12:57Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "t-jprovaznk@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "475c31a1bcc3902158d626dedb23e87e1aa88088",
          "message": "Merge branch 'main' into dev/janpro/wasi-tasks-spec",
          "committedDate": "2024-08-12T12:18:57Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@lambdageek @lewing y'all might be interested in this project.",
        "createdAt": "2024-07-25T22:28:05Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- WASI tasks can be sandboxed\r\n```",
              "createdAt": "2024-06-19T22:08:23Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- Task authoring in other (non-.NET) languages\r\n```",
              "createdAt": "2024-06-19T22:08:50Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n1. specify WASI interface for writing tasks and returning MSBuild information\r\n```",
              "createdAt": "2024-06-19T22:09:25Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n2. Write an `ITaskFactory` that takes a `.wasm` file implementing that interface and runs it as an MSBuild task\r\n```",
              "createdAt": "2024-06-19T22:10:01Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would only look past https://github.com/bytecodealliance/wasmtime-dotnet if it goes _very_ badly.",
              "createdAt": "2024-06-19T22:10:33Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a great intermediate state but I'm not sure how much value it has over \"custom .NET CLI application can invoke the `.wasm` file\"--personally I'd start with the CLI app.",
              "createdAt": "2024-06-19T22:11:37Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we want this; instead I think we want a new task factory that enables a task definition like\r\n\r\n```xml\r\n<UsingTask TaskName=\"FancyWasiTask\"\r\n           AssemblyFile=\"path/to/your/thing.dll\"\r\n           TaskFactory=\"WasiTaskFactory\">\r\n  <Task>\r\n    <WasiModule>path/to/implementation.wasm</WasiModule>\r\n  </Task>\r\n</UsingTask>\r\n```\r\n\r\nThen, when a target like\r\n\r\n```xml\r\n<Target Name=\"InvokeIt\">\r\n  <FancyWasiTask Input1=\"whatever\" />\r\n</Target>\r\n```\r\n\r\nis invoked, MSBuild would call your factory to get a .NET object that represents the task. The factory would load the WASI runtime, do any inspection/reflection needed to figure out what to do, and return a proxy .NET object. Then the engine would call `Execute()` on the .NET side and your code would call the WASM stuff.",
              "createdAt": "2024-06-19T22:17:09Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ooh, this could get interesting. Definitely not for the first version though!",
              "createdAt": "2024-06-19T22:20:17Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this is interesting, I really like keeping the boundary of this work as \"task\".",
              "createdAt": "2024-06-19T22:20:42Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I really strongly prefer doing diagrams with [GitHub's inline Mermaid support](https://docs.github.com/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams); they're way easier to edit over time.",
              "createdAt": "2024-06-19T22:21:56Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d\ud83c\udffb",
              "createdAt": "2024-06-19T22:22:14Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you add an item for \"figure out what the sandboxing capabilities of the selected runtime are?\"\r\n\r\nThis makes a great tech demo with no sandboxing, but if we can predict inputs and outputs using MSBuild-layer concepts and enforce them at runtime through WASI sandboxing, that's where it starts to get awesome.",
              "createdAt": "2024-06-19T22:24:00Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations ",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "What do you mean by \"MSBuild-layer\" concepts?",
              "createdAt": "2024-06-20T12:57:39Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations ",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Today, MSBuild targets can have `Inputs=` and `Outputs=` lists that define what files are read and written by the target, so that we can skip the target if all of the outputs are up-to-date with all of the inputs. Today that's not passed to targets at all. What I'm thinking though is: what if sandboxed tasks inside a target were _only allowed to access those files_? Then incremental behavior would be guaranteed correct, and it'd also be much easier to audit what files were accessed.\r\n\r\nThis comment was thinking to that time: you'll need to understand the sandboxing on the WASI side and figure out what info you need to provide on the MSBuild engine side to activate it.",
              "createdAt": "2024-06-20T13:11:23Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations ",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That's the default behavior of `wasmtime` (CLI): restrict all resources; and all visible files/dirs need to be configured. \r\nspecifying Inputs and Outputs is an important requirement \ud83d\udc4d\r\nI expect that to be easy in the API.",
              "createdAt": "2024-06-20T14:30:05Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations ",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Great! The MSBuild side will require some new design work since it's not information we carry today.",
              "createdAt": "2024-06-20T14:32:50Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "the \"the output is unstable\" part of this makes me think this might need to be \"whatever hacky thing works\" for now.",
              "createdAt": "2024-06-19T22:24:47Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this should start off as a NuGet package that delivers the task factory including the runtime--then it's nicely decoupled and doesn't have most of the downsides here while still keeping the upsides. If it works great we can see about rolling it into MSBuild proper.",
              "createdAt": "2024-06-19T22:25:49Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "There will _definitely_ be compat/licensing concerns about bundling a WASI runtime with dotnet that we'll need to get answered to fully take this thing to production, but that's something that Rainer, myself and others can be poking on while you stay on the fun stuff @JanProvaznik \ud83d\udc4d ",
              "createdAt": "2024-06-20T01:00:36Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd also like an item for investigation/a stretch goal \"run an arbitrary .NET task distributed as a DLL but in the WASI sandbox (via WASM mono interpreter or similar)\". Since I see sandboxing as the biggest win for this project, it'd be great if we could easily apply it to an arbitrary task.",
              "createdAt": "2024-06-19T22:27:32Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Feel free to pick one (IMO Linux or Windows makes the most sense, definitely check on wasmtime support before deciding) to focus on, and make TODO comments when appropriate for things that look fishy.",
              "createdAt": "2024-06-19T22:29:44Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?\n+\n+#### Related issues making other environments for running tasks:\n+https://github.com/dotnet/msbuild/issues/711\n+https://github.com/dotnet/msbuild/issues/4834\n+https://github.com/dotnet/msbuild/issues/7257\n+\n+### Requirements gathering\n+What are the needs that WASI tasks would address?\n+WASI task host? security?\n+\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime\n+\n+[wasm in vscode](https://github.com/microsoft/vscode-wasm)\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet)\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) - compile dotnet to Wasm - likely stale\n+- copy their properties as those would be similar\n+\n+[wasm in dotnet runtime](https://github.com/dotnet/runtime/tree/main/src/mono/wasm)\n+https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105\n+https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) nuget package to make Wasi bundle from c#, released a week ago\n+\n+### Random\n+System.Runtime.InteropServices\n+\n+windows/linux/mac all seem like they will have some specifics",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "hopefully not a problem here, should be able to treat as single-threaded (for now). Another place where a couple of `// TODO thread safety` are probably fine.",
              "createdAt": "2024-06-19T22:58:58Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?\n+\n+#### Related issues making other environments for running tasks:\n+https://github.com/dotnet/msbuild/issues/711\n+https://github.com/dotnet/msbuild/issues/4834\n+https://github.com/dotnet/msbuild/issues/7257\n+\n+### Requirements gathering\n+What are the needs that WASI tasks would address?\n+WASI task host? security?\n+\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime\n+\n+[wasm in vscode](https://github.com/microsoft/vscode-wasm)\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet)\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) - compile dotnet to Wasm - likely stale\n+- copy their properties as those would be similar\n+\n+[wasm in dotnet runtime](https://github.com/dotnet/runtime/tree/main/src/mono/wasm)\n+https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105\n+https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) nuget package to make Wasi bundle from c#, released a week ago\n+\n+### Random\n+System.Runtime.InteropServices\n+\n+windows/linux/mac all seem like they will have some specifics\n+\n+threadsafety?",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "IIRC we're forced to single-threaded execution until threads land in WASI.",
              "createdAt": "2024-06-20T01:02:04Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?\n+\n+#### Related issues making other environments for running tasks:\n+https://github.com/dotnet/msbuild/issues/711\n+https://github.com/dotnet/msbuild/issues/4834\n+https://github.com/dotnet/msbuild/issues/7257\n+\n+### Requirements gathering\n+What are the needs that WASI tasks would address?\n+WASI task host? security?\n+\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime\n+\n+[wasm in vscode](https://github.com/microsoft/vscode-wasm)\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet)\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) - compile dotnet to Wasm - likely stale\n+- copy their properties as those would be similar\n+\n+[wasm in dotnet runtime](https://github.com/dotnet/runtime/tree/main/src/mono/wasm)\n+https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105\n+https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) nuget package to make Wasi bundle from c#, released a week ago\n+\n+### Random\n+System.Runtime.InteropServices\n+\n+windows/linux/mac all seem like they will have some specifics\n+\n+threadsafety?",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Ah yeah good point, there are two sides of thread safety:\r\n\r\n1. _Inside_ the task\r\n2. In MSBuild _outside_ the task.\r\n\r\nProbably fine to deprioritize both, inside for @baronfel's reason and outside because task execution should appear single-threaded (due to MSBuild's multi-process instead of multi-thread model).",
              "createdAt": "2024-06-20T13:12:50Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?\n+\n+#### Related issues making other environments for running tasks:\n+https://github.com/dotnet/msbuild/issues/711\n+https://github.com/dotnet/msbuild/issues/4834\n+https://github.com/dotnet/msbuild/issues/7257\n+\n+### Requirements gathering\n+What are the needs that WASI tasks would address?\n+WASI task host? security?\n+\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime\n+\n+[wasm in vscode](https://github.com/microsoft/vscode-wasm)\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet)\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) - compile dotnet to Wasm - likely stale\n+- copy their properties as those would be similar\n+\n+[wasm in dotnet runtime](https://github.com/dotnet/runtime/tree/main/src/mono/wasm)\n+https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105\n+https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) nuget package to make Wasi bundle from c#, released a week ago\n+\n+### Random\n+System.Runtime.InteropServices\n+\n+windows/linux/mac all seem like they will have some specifics\n+\n+threadsafety?",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Might be interesting to have a WASM program that does something \"build-y\" like read a list of files and write an output. The actual transformation doesn't have to be interesting, concatenation would be fine.",
              "createdAt": "2024-06-19T23:00:40Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I generally like this section way up at the top of the doc:\r\n\r\n1. What problems are we solving?\r\n2. What's the general approach?",
              "createdAt": "2024-06-19T23:01:40Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,182 @@\n+# WASI tasks in MSBuild (WasiBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+\n+*...*\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm.\n+- [**Wasmtime**](https://wasmtime.dev) : WASI runtime implementation \n+\n+The WebAssembly standard defines an intermediate language for a WASM runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this intermediate language and run them on any platform with this interpreter. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasi-console`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ for example: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- WASI tasks are sandboxed\n+- Easier interoperability outside of C#\n+- WASI executables are packaged with no outside dependencies \n+- Users from other languages\n+\n+## Goals for the WASI task feature\n+1. specify interface for writing tasks in other languages\n+2. running Wasm \n+3. Rust demo task\n+\n+\n+### Steps (???)\n+1. figure out the best options for hosting a WASI sandbox from .NET (probably p/invoke into some Rust thing)\n+2. write a TaskHost that uses it\n+3. write a WASM interface spec to map to the task model\n+4. do the invocation stuff\n+5. demos\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+- [ ] WasmTask class extending ToolTask taking a .wasm file as a parameter\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Rust example\n+    - [ ] Possibly needs a TaskHost TBD\n+\n+### Advanced features\n+- [ ] RunWasmCode task which takes a .wasm file which exports a function and parameterized to which function to run\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- [ ] C# code using wasm exported functions inside xml\n+- [ ] Wasm-supported language code inside XML (possibly too ambitious/flaky) [open question](#open-questions-and-considerations)\n+    - would need to include the tooling for getting wasm out of the languages which is under heavy development \n+\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+\n+### Choosing WASI runtime [(open questions)](#open-questions-and-considerations)\n+https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. \n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+\n+### Open questions and considerations \n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - security\ud83d\udc4d we don't have control over external runtime\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is constantly changing\n+    - lot of work \ud83d\udc4e\n+\n+\n+- **Interacting with the tooling for creating .wasi files**\n+    - hard, unstable\n+    - separate project?\n+    - out of scope?\n+    - if yes - inclusion in msbuild? how to handle missing?\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - if no how to handle missing?\n+\n+#### Related issues making other environments for running tasks:\n+https://github.com/dotnet/msbuild/issues/711\n+https://github.com/dotnet/msbuild/issues/4834\n+https://github.com/dotnet/msbuild/issues/7257\n+\n+### Requirements gathering\n+What are the needs that WASI tasks would address?\n+WASI task host? security?",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "_definition for how to write them._ please explain what exactly you mean here.",
              "createdAt": "2024-06-27T12:58:28Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,242 @@\n+# Wasm/WASI tasks in MSBuild (WasmBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+Also it brings sandboxing possibilities.\n+\n+\n+## Stories for requirements\n+Currently tasks have unrestricted access to resources, Wasm/WASI runtimes provide a way to sandbox tasks (by default executables don't have access to any resources). This can be acheived by specifying Inputs and Outputs of these tasks and other resources they can access.\n+\n+ We want to be able to run tasks written in other languages than C# in MSBuild. Those tasks will need a definition for how to write them. Invoking a Wasm runtime can easily run pre-compiled tasks. ",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I love this example, thanks!",
              "createdAt": "2024-06-27T12:59:45Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,242 @@\n+# Wasm/WASI tasks in MSBuild (WasmBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+Also it brings sandboxing possibilities.\n+\n+\n+## Stories for requirements\n+Currently tasks have unrestricted access to resources, Wasm/WASI runtimes provide a way to sandbox tasks (by default executables don't have access to any resources). This can be acheived by specifying Inputs and Outputs of these tasks and other resources they can access.\n+\n+ We want to be able to run tasks written in other languages than C# in MSBuild. Those tasks will need a definition for how to write them. Invoking a Wasm runtime can easily run pre-compiled tasks. \n+ (Advanced) Integrating compiling other languages to WASI would enable an easy workflow. \n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+\n+The WebAssembly standard defines an language for a Wasm runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this language and run them on any platform with virtual machine. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't manipulate files\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I believe this section is slightly outdated after the recent sync. ",
              "createdAt": "2024-06-27T13:03:34Z",
              "path": "documentation/specs/proposed/WASI-tasks.md",
              "diffHunk": "@@ -0,0 +1,242 @@\n+# Wasm/WASI tasks in MSBuild (WasmBuild)\n+We want to make it easier to work with the WebAssembly ecosystem in MSBuild.\n+MSBuild Tasks are the point where this makes sense. \n+Also it brings sandboxing possibilities.\n+\n+\n+## Stories for requirements\n+Currently tasks have unrestricted access to resources, Wasm/WASI runtimes provide a way to sandbox tasks (by default executables don't have access to any resources). This can be acheived by specifying Inputs and Outputs of these tasks and other resources they can access.\n+\n+ We want to be able to run tasks written in other languages than C# in MSBuild. Those tasks will need a definition for how to write them. Invoking a Wasm runtime can easily run pre-compiled tasks. \n+ (Advanced) Integrating compiling other languages to WASI would enable an easy workflow. \n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+\n+The WebAssembly standard defines an language for a Wasm runtime that can be implemented in a browser or as a standalone program. \n+We can compile programs to this language and run them on any platform with virtual machine. \n+- Note that .NET programs usually still run as the runtime bundled with CIL of the program.\n+\n+### Current state\n+We can use the Exec task in this manner to run an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't manipulate files\n+\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm\" />\n+</Target>\n+</Project>\n+```\n+5. dotnet build\n+\n+\n+Rust example:\n+1. install wasmtime\n+2. compile Rust to .wasm (won't elaborate here, GPT can explain without problems)\n+3. .proj\n+```xml\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+- In principle it's possible to compile to .wasm with a few Exec tasks too.\n+\n+We can make this more user friendly.\n+\n+### Utility for MSBuild\n+- resources for Wasm tasks have to be managed explicitly which provides sandboxing if desired\n+- Easier interoperability outside of .NET\n+    - Task authoring in non-.NET languages\n+- Wasm tasks can be packaged with no outside dependencies \n+\n+## Goals for the Wasm task feature\n+1. specify Wasm/WASI interface for writing tasks in other languages and returning MSBuild information\n+2. Write an `ITaskFactory` that takes a `.wasm` file implementing that interface and runs it as an MSBuild task  \n+3. Rust demo task\n+\n+### Prototype features\n+- [ ] WasmExec class extending ToolTask taking a .wasm file as a parameter - just runs the file with wasmtime\n+    -  [ ] parametrizing access to resources (will apply to all subsequent parts)\n+- [ ] WasmTaskFactory - creating tasks from .wasm files\n+    - [ ] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] Taskhost\n+    - example usage:\n+```xml\n+<UsingTask TaskName=\"FancyWasiTask\"\n+           AssemblyFile=\"path/to/your/thing.dll\"\n+           TaskFactory=\"WasiTaskFactory\">\n+  <Task>\n+    <WasiModule>compiled_task_implementation.wasm</WasiModule>\n+  </Task>\n+</UsingTask>\n+```\n+- [ ] Rust example\n+- [ ] .NET example\n+\n+### Advanced features\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in other languages\n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+    - On code in XML level (maybe out of scope)\n+        - [ ] RustCodeTaskFactory\n+        - exploring other languages\n+- [ ] Wasm code inside XML \n+    - [ ] WasmCodeFactory \n+- investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+\n+\n+## Design\n+### diagram\n+\n+![diagram](wasi-diagram.svg)\n+### Wasm/WASI interface\n+The .wasm task file has to export a function execute(), import extern function getMetadata from host, **TBD more details** \n+\n+### Task parameters\n+every resource has to be explicit, wasmtime is a sandbox by default\n+- *implicitly: Executable=\"path/to/executable.wasm\" created by the factory*\n+- Inputs=\"list_of_input_files\"\n+- Outputs=\"list_of_output_files\"\n+- InheritEnv=default to false, \n+- Environment=\"list_of_variables\"\n+- StdIOE=default to true\n+- Directories=\"directories on host that can be accessed\"\n+- Args=\"for the wasm program\" \n+- TmpDir=\"somethign like temporary working directory\"\n+- HostFunctions=\"list of functions exported to wasm code\"\n+\n+\n+### Testing\n+- **TBD**\n+- E2E tests - building projects in different languages most important\n+\n+<!-- Integration tests for logging -->\n+<!-- mirror MSBuild\\src\\Build.UnitTests\\BackEnd\\TaskHost_Tests.cs --> \n+### Other\n+The sandboxing of files will require changes to msbuild proper but the rest would preferrably be a NuGet package where community is more responsible for maintaining that the tools for using other languages are integrated well.\n+\n+## User Experience\n+API should be clear and the Rust task provide an example of how to implement it.\n+Then the user adds the task to their .proj file and it runs and logs as if it were a C# task.\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); \n+// add delegates to linker that the wasm file can use\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); \n+// enable resources: Environment, InheritEnvironment, PreopenedDirectory(ies), Standard(I/O/E), \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+### TODO for this doc\n+- create in depth explanations for Wasm/WASI and how its concepts map to MSBuild concepts\n+- discuss with people who understand MSBuild internals, WASI and dotnet interaction, users of MSBuild\n+- elaborate how to give resources using wasmtime-dotnet\n+\n+\n+### Tentatively resolved considerations \n+- **Inside MSBuild or as a NuGet package?\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, nuget package can have some install scripts doing that*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> mostly use Wasm-tasks unless Wasm/WASI is more appropriate for that situation*\n+\n+### Open questions",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please clarify, that access to resources is possible after changing the existing BuildEngine, so you will be able to pass from MSBuild what kind of permissions is required for this specific task run.",
              "createdAt": "2024-07-15T13:02:34Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,284 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Current state\n+We can use the Exec task an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't e.g. manipulate files",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Not what this section was about. addressed in ###Task parameters section",
              "createdAt": "2024-07-17T11:21:25Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,284 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Current state\n+We can use the Exec task an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't e.g. manipulate files",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "if it's not too much work, please prepare a script that automates all these steps. ",
              "createdAt": "2024-07-15T13:03:45Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,284 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Current state\n+We can use the Exec task an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't e.g. manipulate files\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this list up to date?",
              "createdAt": "2024-07-15T13:07:29Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,284 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Current state\n+We can use the Exec task an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't e.g. manipulate files\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. .proj\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm task feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` that given a `.wasm` file implementing that interface and runs it as an MSBuild task\n+3. Rust demo task\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime ",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I love it!",
              "createdAt": "2024-07-15T13:09:03Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,284 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Current state\n+We can use the Exec task an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't e.g. manipulate files\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. .proj\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm task feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` that given a `.wasm` file implementing that interface and runs it as an MSBuild task\n+3. Rust demo task\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources, but does not do anything interesting\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that gets custom parameters from the xml\n+- [ ] Rust example\n+- [ ] .NET example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output>...</Output>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in other languages\n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+\n+\n+## Design\n+### diagram",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please explain what exactly you mean under \"install scripts\" here",
              "createdAt": "2024-07-15T13:15:54Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,284 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Current state\n+We can use the Exec task an executable .wasm file (.NET example):\n+- note that this execution does not get any resources so it can't e.g. manipulate files\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet add workflow wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. .proj\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. dotnet build\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm task feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` that given a `.wasm` file implementing that interface and runs it as an MSBuild task\n+3. Rust demo task\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources, but does not do anything interesting\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that gets custom parameters from the xml\n+- [ ] Rust example\n+- [ ] .NET example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output>...</Output>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in other languages\n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int,int), LogWarning(int,int), LogMessage(int,int,int), where 1. is the pointer to passed string in shared memory and 2. is the length of the string. 3. in LogMessage is the message importance integer (0=high, 1=medium, 2=low).\n+\n+The .wasm task file has to export functions GetTaskInfo(), Execute()->int. Where the return type is 0 for success and 1 for failure.\n+\n+\n+\n+### Task parameters \n+What parameters the task has is read from GetTaskInfo in the Task module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with those properties.\n+Task parameters are passed into the wasm module as a JSON string in stdin.\n+\n+We describe the proposed [API description in WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for refactoring. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource has to be explicit, Wasmtime is a sandbox by default.\n+Additional parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Environment=\"list_of_variables\"\n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: Environment Variables, InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, nuget package can have some install scripts doing that*",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What do the arrows represent in this diagram? I thought it was \"controls\" or inputs but now I don't think I understand.",
              "createdAt": "2024-07-25T22:18:47Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "How calls/information flow. I reworded it and added ordering. ",
              "createdAt": "2024-07-26T14:07:24Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since you have comments, we can avoid making them red:\r\n\r\n````suggestion\r\n```jsonc\r\n````",
              "createdAt": "2024-07-25T22:20:12Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```json",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "````suggestion\r\n```jsonc\r\n````",
              "createdAt": "2024-07-25T22:20:21Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```json\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```json",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd appreciate some summary comments on the interfaces describing their intended use. I understand `host-logger` but not all of the others.",
              "createdAt": "2024-07-25T22:24:04Z",
              "path": "documentation/specs/proposed/wasmtask.wit",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeffpackage msbuildtask:v0\n+\n+record str-kv-pair {\n+    key: string\n+    value: string\n+}\n+\n+type str-dictionary = list<str-kv-pair>\n+\n+record TaskItem {\n+    ItemSpec: string\n+    Metadata: str-dictionary\n+}\n+\n+type TaskItems = list<TaskItem>\n+type Bools = list<bool>\n+type Strings = list<string>\n+\n+interface host-data {\n+    GetHostData: func() -> str-dictionary\n+}\n+\n+\n+interface host-logger {",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I like this change, taking it from \"create instance of object, set properties, call method\" to a single function call is very nice.",
              "createdAt": "2024-07-26T14:10:20Z",
              "path": "documentation/specs/proposed/wasmtask.wit",
              "diffHunk": "@@ -1,62 +1,88 @@\n-\ufeffpackage msbuildtask:v0\n+\ufeffpackage MSBuildWasm:v0\n \n-record str-kv-pair {\n-    key: string\n-    value: string\n+// WIT doesn't have maps/dictionaries\n+record StringKVPair {\n+    Key: string\n+    Value: string\n }\n+type StringMap = list<StringKVPair>\n \n-type str-dictionary = list<str-kv-pair>\n+// mirroring TaskItem in MSBuild - it's a description of a file or directory\n+record TaskItem { \n+    // Path inside the sandbox\n+    WasmPath: string;\n+    Metadata: StringMap\n+}\n+// enum for types of properties in Tasks\n+enum PropertyType {\n+    BoolType,\n+    StringType,\n+    TaskItemType,\n+    BoolArrayType,\n+    StringArrayType,\n+    TaskItemArrayType\n+}\n+\n+// variant contains one of the possible types of properties\n+variant PropertyValue {\n+    Bool(bool);\n+    String(string);\n+    TaskItem(TaskItem);\n+    BoolArray(BoolList);\n+    StringArray(StringList);\n+    TaskItemArray(TaskItemList);\n+}\n \n-record TaskItem {\n-    ItemSpec: string\n-    Metadata: str-dictionary\n+type TaskItemList = list<TaskItem>\n+type BoolList = list<bool>\n+type StringList = list<string>\n+\n+// mirrors MSBuild's TaskPropertyInfo\n+record TaskPropertyInfo {\n+    Name: string;\n+    Type: PropertyType;\n+    Output: bool;\n+    Required: bool;\n }\n \n-type TaskItems = list<TaskItem>\n-type Bools = list<bool>\n-type Strings = list<string>\n+// information about a task passed from the Task to MSBuild\n+record TaskInfo {\n+    Name: string; \n+    Parameters: list<TaskPropertyInfo>; \n+    Metadata: StringMap; // e.g. requirements for the host environment\n+}\n \n-interface host-data {\n-    GetHostData: func() -> str-dictionary\n+// information about the host environment passed from MSBuild to the Task\n+record HostInfo {\n+    PreopenedDirectories: TaskItemList;\n }\n \n+// input to Execute \n+// (in MSBuild normally the task already magically has set its properties to the values from the project file, but here we need to pass them explicitly)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I see a typo.",
              "createdAt": "2024-07-28T14:25:05Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>",
              "author": {
                "login": "cataggar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are there plans to add it? Link?",
              "createdAt": "2024-07-28T14:34:33Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.",
              "author": {
                "login": "cataggar"
              }
            },
            {
              "body": "wasmtime-dotnet does not have a roadmap now afaik. I had made an issue for it, and now added it to this spec: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324",
              "createdAt": "2024-07-29T10:34:42Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ugh \ud83d\ude24. What happened?",
              "createdAt": "2024-07-28T14:45:08Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "cataggar"
              }
            },
            {
              "body": "it was never officially supported and now they switched the Mono WASI effort to target WASIp2  https://github.com/dotnet/runtime/pull/104683",
              "createdAt": "2024-07-29T10:36:53Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Do you have a guess about how much work would be wasted if we used .NET 9-preview5 to build a WASIp1 thing, then converted it to a later WASIp2 system? I would assume _most_ of the .NET work would be transferrable, since it shouldn't directly care about the module/component part, right?",
              "createdAt": "2024-07-29T13:55:59Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "To be clear this is about the *guest code* in the Task. ~all of that can't be reused because it'd be generated from the WIT file by https://github.com/bytecodealliance/wit-bindgen which is the point/value of WASIp2 and users would just implement the insides of Execute and GetTaskInfo functions.",
              "createdAt": "2024-07-29T14:37:41Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "We transitioned to preview2 and components and we are still in process of adopting it. WASI/dotnet is very experimental.\r\nI'm not sure how easy it is to implement host components (plugins into wasmtime) in dotnet",
              "createdAt": "2024-07-29T14:53:06Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "pavelsavara"
              }
            },
            {
              "body": "> Do you have a guess about how much work would be wasted if we used .NET 9-preview5 to build a WASIp1 thing\r\n\r\nAdded value of wit-bindgen is marshaling all the method parameters. \r\n\r\nIn p1 you are on your own with memory as array of bytes or you need to use C/rust.\r\nDoing all the marshaling by hands is wasted effort.\r\n",
              "createdAt": "2024-07-29T15:03:37Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "pavelsavara"
              }
            },
            {
              "body": "Yeah but that's a sunk cost with the nice work @JanProvaznik has already done, so that part of the cost should be fairly minimal.",
              "createdAt": "2024-07-29T15:10:30Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\n+\n+The .wasm module has to import functions from \"module\" msbuild-log: LogError(int str_ptr,int str_len), LogWarning(int str_ptr,int str_len), LogMessage(int MessageImportance,int str_ptr,int str_len). \n+The .wasm task file has to export functions void GetTaskInfo(), int Execute(). Where the return type is 0 for success and 1 for failure.\n+\n+### Task parameters \n+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a corresponding C# type with corresponding properties.\n+Task parameter values are passed into the wasm module as a JSON string in stdin.\n+\n+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers.\n+\n+Every resource available to the Wasm/WASI runtime has to be explicit, Wasmtime is a sandbox by default, and WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), \n+Parameters that specify execution environment for the task can be specified in the XML: \n+- InheritEnv=default to false, \n+- Directories=\"directories on host that can be accessed\"\n+After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.\n+\n+### Json format for parameter spec\n+They mirror MSBuild Task parameters as they need to be reflected to a C# class.\n+```jsonc\n+{\n+    \"Properties\": {\n+        \"Param1\": {\n+            \"type\": \"string\", \n+            \"required\": true, // required attribute in C#\n+            \"output\": false // output attribute in C#\n+        },\n+        \"Param2\": {\n+            \"type\": \"bool\",\n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param3\": {\n+            \"type\": \"ITaskItem\", \n+            \"required\": false,\n+            \"output\": false\n+        },\n+        \"Param4\": {\n+            \"type\": \"ITaskItem[]\",\n+            \"required\": false,\n+            \"output\": true \n+        }\n+    }\n+}\n+\n+```\n+### Json format for parameter values\n+```jsonc\n+{\n+    \"Properties\" : {\n+        \"Param1\": \"hello\",\n+        \"Param2\": true,\n+        \"Param3\": {\n+            \"ItemSpec\": \"C:\\\\real\\\\path\\\\file.txt\",\n+            \"WasmPath\" : \"file.txt\", // guest runtime path\n+            \"More dotnet metadata\": \"...\"\n+            } \n+    }\n+}\n+```\n+\n+### Json format for task output\n+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.\n+```jsonc\n+{\n+        \"Param4\": [\n+            {\n+                \"WasmPath\" : \"also/can/be/dir\"\n+            },\n+            {\n+                \"WasmPath\" : \"dir2\"\n+            }\n+        ]\n+}\n+```\n+\n+\n+### Testing\n+#### Unit tests\n+- [ ] setting parameters in the task\n+- [ ] parsing outputs\n+- [ ] examples contain expected functions\n+\n+#### E2E tests\n+- Using Wasm/WASI Tasks in a build\n+- [ ] Rust tasks\n+    - [ ] logging\n+    - [ ] accessing environment variables\n+    - [ ] passing parameters\n+    - [ ] accessing files\n+\n+\n+## Implementation details\n+### wasmtime-dotnet bindings and basic usage\n+```csharp\n+using var engine = new Engine();\n+using var module = Module.FromFile(engine, WasmFilePath);\n+using var linker = new Linker(engine);\n+linker.DefineWasi(); // linking WASI\n+linker.Define(\"namespace\", \"function\", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm\n+using var store = new Store(engine);\n+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO \n+store.SetWasiConfiguration(wasiConfigBuilder);\n+Instance instance = linker.Instantiate(store, module);\n+Action fn = instance.GetAction(\"Execute\");\n+fn.Invoke();\n+```\n+\n+\n+## Development remarks (in-progress)\n+\n+\n+### Architectural decision record\n+- **Inside MSBuild or as an external package?**\n+    - the feature seems largely independent\n+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*\n+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*\n+\n+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**\n+    - customizable\ud83d\udc4d\n+    - hard to maintain\ud83d\udc4e, wasi is changing\n+    - lot of work \ud83d\udc4e\n+    - *-> resolved to use wasmtime*\n+    - Choosing Wasm/WASI runtime \n+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.\n+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.\n+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).\n+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other dotnet projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API\n+\n+- **bundling wasm runtime with MSBuild?**\n+    - compatibility\ud83d\udc4d\n+    - ease of use \ud83d\udc4d\n+    - size\ud83d\udc4e\n+    - maintenance\ud83d\udc4e\n+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*\n+\n+- **Interacting with the tooling for creating .wasi files from other languages?**\n+    - hard, unstable\n+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*\n+\n+- **start with windows or UNIX?**\n+    - *-> most different is the investigation about how to bundle tooling for other languages*\n+\n+- **renaming this feature from WASI-... to Wasm-...**\n+    - file extensions are called .wasm \ud83d\udc4d\n+    - WASI is a standard building on Wasm \ud83d\udc4d\n+    - the compilation target is called wasm-wasi \ud83d\udc4d\ud83d\udc4e\n+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*\n+\n+- **communication between host and a wasm module**\n+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO \n+    - eventually with Wasm/WASI component model better data-structures  \n+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) \n+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279\n+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*\n+     \n+- **TaskExecutionHost?**\n+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, \n+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost\n+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet\n+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*\n+\n+### Related projects\n+\n+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - a nonprofit, Microsoft is a member\n+\n+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#\n+\n+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a Wasm/WASI component from a C#.NET project, released short time ago, created by people from Microsoft, right now we can't use it because components are a different system than modules and we can't switch because wasmtime-dotnet does not support it yet.\n+\n+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) \n+- compile dotnet to Wasm\n+- moved to sdk and runtime repos `dotnet workload install wasi-experimental`\n+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)\n+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2\n+\n+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)\n+\n+### Random\n+\n+<!-- https://learn.microsoft.com/en-us/visualstudio/msbuild/configure-tasks?view=vs-2022 -->\n+<!-- - configuring tasks to run outside the env of the rest of the project, probably not relevant because wasi is too specific-->\n+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually https://github.com/bytecodealliance/wasmtime-dotnet/pull/320\n+\n+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports. .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks but the code was removed in preview 7 and won't come back.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "MS Learn guidelines are to remove the lang-culture from URLs. Then the user\u2019s browser preferred language(s) are used.",
              "createdAt": "2024-07-28T16:18:31Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.",
              "author": {
                "login": "heaths"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this would also have to contain definition of security features, which are enabled for the `compiled_task_implementation.wasm`\r\n\r\nby default it's just CPU+MEMORY, if you need console, current time, network, http or anything else, you need to explicitly say so.",
              "createdAt": "2024-07-29T14:59:51Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "pavelsavara"
              }
            },
            {
              "body": "@JanProvaznik this is something we should write down super clearly. IIUC the situation is that we disallow all of that stuff and have only CPU+MEMORY + explicit filesystem stuff based on the input items, right? So maybe we don't need to have arguments like this?",
              "createdAt": "2024-07-29T15:11:37Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@pavelsavara is there a doc/list of the capabilities exposed today? We should probably make an up/down decision on what we want to allow (like @rainersigwald says) but I'd be tempted to allow current time in addition to CPU, Memory, and specific filesystem access.",
              "createdAt": "2024-07-29T15:14:23Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Nooooooo, time is evil! Do you have a specific scenario you'd like to enable with it? IME it just results in bad incrementality downstream by embedding a never-the-same value in a build output.",
              "createdAt": "2024-07-29T15:17:18Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Fair point - my knee-jerk thought was that making cache file names would be a natural place to put a timestamp.",
              "createdAt": "2024-07-29T15:18:50Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "https://github.com/WebAssembly/WASI/blob/main/preview2/README.md#wasi-preview-2-contents this is preview2\r\n\r\nNote that none of this is 100% unix/posix/windows compatible.\r\nFor example file system doesn't support symbolic links and doesn't support absolute path. File handles are complex topic.\r\n\r\nAlso you can limit memory consumption and CPU time.",
              "createdAt": "2024-07-29T15:42:41Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "pavelsavara"
              }
            },
            {
              "body": "the flags would be \"host\" specific, where your host would be `wasmtime` probably. There are other WASM hosts.\r\n\r\ntry `wasmtime run -h`",
              "createdAt": "2024-07-29T15:45:32Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "pavelsavara"
              }
            },
            {
              "body": "For reference today:\r\n\r\n<details>\r\n<summary>Help output for wasmtime options for version 14.0.0</summary>\r\n\r\n```console\r\n> wasmtime run -h\r\nRuns a WebAssembly module\r\n\r\nUsage: wasmtime.exe run [OPTIONS] <WASM>...\r\n\r\nArguments:\r\n  <WASM>...  The WebAssembly module to run and arguments to pass to it\r\n\r\nOptions:\r\n  -O, --optimize <KEY[=VAL[,..]]>    Optimization and tuning related options for wasm performance, `-O help` to see all\r\n  -C, --codegen <KEY[=VAL[,..]]>     Codegen-related configuration options, `-C help` to see all\r\n  -D, --debug <KEY[=VAL[,..]]>       Debug-related configuration options, `-D help` to see all\r\n  -W, --wasm <KEY[=VAL[,..]]>        Options for configuring semantic execution of WebAssembly, `-W help` to see all\r\n  -S, --wasi <KEY[=VAL[,..]]>        Options for configuring WASI and its proposals, `-S help` to see all\r\n      --allow-precompiled            Allow executing precompiled WebAssembly modules as `*.cwasm` files\r\n      --dir <GUEST_DIR[::HOST_DIR]>  Grant access of a host directory to a guest\r\n      --env <NAME[=VAL]>             Pass an environment variable to the program\r\n      --invoke <FUNCTION>            The name of the function to run\r\n      --preload <NAME=MODULE_PATH>   Load the given WebAssembly module before the main module\r\n      --profile <STRATEGY>           Profiling strategy (valid options are: perfmap, jitdump, vtune, guest)\r\n  -h, --help                         Print help (see more with '--help')\r\n> wasmtime run -W help\r\nAvailable wasm options:\r\n\r\n  -W       nan-canonicalization[=y|n] -- Enable canonicalization of all NaN values.\r\n  -W                           fuel=N -- Enable execution fuel with N units fuel, trapping after running out of fuel.\r\n  -W         epoch-interruption[=y|n] -- Yield when a global epoch counter changes, allowing for async operation without blocking the executor.\r\n  -W                 max-wasm-stack=N -- Maximum stack size, in bytes, that wasm is allowed to consume before a stack overflow is reported.\r\n  -W      unknown-exports-allow[=y|n] -- Allow unknown exports when running commands.\r\n  -W       unknown-imports-trap[=y|n] -- Allow the main module to import unknown functions, using an implementation that immediately traps, when running commands.\r\n  -W    unknown-imports-default[=y|n] -- Allow the main module to import unknown functions, using an implementation that returns default values, when running commands.\r\n  -W                  wmemcheck[=y|n] -- Enables memory error checking. (see wmemcheck.md for more info)\r\n  -W                max-memory-size=N -- Maximum size, in bytes, that a linear memory is allowed to reach.\r\n  -W             max-table-elements=N -- Maximum size, in table elements, that a table is allowed to reach.\r\n  -W                  max-instances=N -- Maximum number of WebAssembly instances allowed to be created.\r\n  -W                     max-tables=N -- Maximum number of WebAssembly tables allowed to be created.\r\n  -W                   max-memories=N -- Maximum number of WebAssembly linear memories allowed to be created.\r\n  -W       trap-on-grow-failure[=y|n] -- Force a trap to be raised on `memory.grow` and `table.grow` failure instead of returning -1 from these instructions.\r\n  -W              timeout=N|Ns|Nms|.. -- Maximum execution time of wasm code before timing out (1, 2s, 100ms, etc)\r\n  -W              all-proposals[=y|n] -- Configures support for all WebAssembly proposals implemented.\r\n  -W                bulk-memory[=y|n] -- Configure support for the bulk memory proposal.\r\n  -W               multi-memory[=y|n] -- Configure support for the multi-memory proposal.\r\n  -W                multi-value[=y|n] -- Configure support for the multi-value proposal.\r\n  -W            reference-types[=y|n] -- Configure support for the reference-types proposal.\r\n  -W                       simd[=y|n] -- Configure support for the simd proposal.\r\n  -W               relaxed-simd[=y|n] -- Configure support for the relaxed-simd proposal.\r\n  -W relaxed-simd-deterministic[=y|n] -- Configure forcing deterministic and host-independent behavior of the relaxed-simd instructions.\r\n  -W                  tail-call[=y|n] -- Configure support for the tail-call proposal.\r\n  -W                    threads[=y|n] -- Configure support for the threads proposal.\r\n  -W                   memory64[=y|n] -- Configure support for the memory64 proposal.\r\n  -W            component-model[=y|n] -- Configure support for the component-model proposal.\r\n  -W        function-references[=y|n] -- Configure support for the function-references proposal.\r\n\r\npass `-W help-long` to see longer-form explanations\r\n> wasmtime run -S help\r\nAvailable wasi options:\r\n\r\n  -S             common[=y|n] -- Enable support for WASI common APIs\r\n  -S                 nn[=y|n] -- Enable suport for WASI neural network API (experimental)\r\n  -S            threads[=y|n] -- Enable suport for WASI threading API (experimental)\r\n  -S               http[=y|n] -- Enable suport for WASI HTTP API (experimental)\r\n  -S           listenfd[=y|n] -- Inherit environment variables and file descriptors following the systemd listen fd specification (UNIX only)\r\n  -S            tcplisten=val -- Grant access to the given TCP listen socket\r\n  -S           preview2[=y|n] -- Implement WASI with preview2 primitives (experimental).\r\n  -S nn-graph=<format>::<dir> -- Pre-load machine learning graphs (i.e., models) for use by wasi-nn.\r\n  -S    inherit-network[=y|n] -- Flag for WASI preview2 to inherit the host's network within the guest so it has full access to all addresses/ports/etc.\r\n\r\npass `-S help-long` to see longer-form explanations\r\n```\r\n</details>",
              "createdAt": "2024-07-29T15:56:37Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Many of these options are not exposed through the [Wasm/wasmtime c-api](https://docs.wasmtime.dev/c-api/wasi_8h.html) on which wasmtime-dotnet depends. Also wasmtime version 14.0.0 is quite old now (last year)",
              "createdAt": "2024-07-29T18:36:49Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,343 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+- note that this does not interact with MSBuild and just runs the wasm file as a standalone executable inefficiently (dotnet runtime inside wasm runtime)\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nWithout WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that can be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.\r\n```",
              "createdAt": "2024-07-29T19:27:05Z",
              "path": "documentation/specs/proposed/Wasm-tasks.md",
              "diffHunk": "@@ -0,0 +1,344 @@\n+# Wasm/WASI tasks in MSBuild\n+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.\n+\n+## Stories \n+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.\n+\n+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features we need are Rust and C/C++.\n+\n+## Terminology and context\n+-  **WebAssembly (abbreviated Wasm)**\n+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)\n+\n+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.\n+    - WASIp1 filesystem, environment variables, stdIO, programs are \"Modules\"\n+    - WASIp2 rich interface data types, networking, programs are \"Components\"\n+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI\n+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host\n+\n+### Diagram of a Wasm execution from a host\n+```mermaid \n+flowchart TD\n+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]\n+\n+    A[Engine]  --> E[Linker]\n+    \n+    E -->|Define host functions & WASI| H[Instance]\n+\n+    H <---> Mem[Shared Memory]\n+    \n+    K[Module] -->|Piece of functionality| H\n+    \n+    L[Store] -->|Config for runtime| H\n+    \n+    H -->|Invoke module functions| M[Execution]\n+\n+    subgraph \" \"\n+    A\n+    K\n+    L\n+    end\n+\n+    subgraph \"Single execution\"\n+    H\n+    E\n+    M\n+    Mem\n+    end\n+\n+```\n+\n+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks\n+In a build, we can use the [`Exec` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.\n+\n+#### .NET example\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev)\n+1. `dotnet workload install wasi-experimental`\n+2. `dotnet new wasiconsole`\n+3. add `<WasmSingleFileBundle>true</WasmSingleFileBundle>` to .csproj,\n+ this example runs the compiled program after building: \n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFramework>net8.0</TargetFramework>\n+    <RsiuntimeIdentifier>wasi-wasm</RuntimeIdentifier>\n+    <OutputType>Exe</OutputType>\n+    <WasmSingleFileBundle>true</WasmSingleFileBundle>\n+  </PropertyGroup>\n+\n+  <Target Name=\"RunWasmtime\" AfterTargets=\"Build\">\n+    <Exec Command=\"wasmtime run bin/$(Configuration)/$(TargetFramework)/wasi-wasm/AppBundle/$(AssemblyName).wasm --additional-parameters-for-wasmtime\" />\n+</Target>\n+</Project>\n+```\n+5. `dotnet build`\n+\n+\n+#### Rust example:\n+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)\n+3. write your Rust program\n+3. `project.csproj`\n+```xml\n+  <Target Name=\"CompileAndRun\" BeforeTargets=\"Build\">\n+    <Exec Command=\"cargo build --target wasm32-wasi --release\">\n+    <Exec Command=\"wasmtime run path_to_compiled_rust_program.wasm\" />\n+</Target>\n+```\n+4. `dotnet build`\n+\n+This is quite cumbersome and does not provide a way to pass parameters to the \"task\" or get outputs from it.\n+\n+## Goals for the Wasm tasks feature\n+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task\n+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task\n+3. Demos/examples\n+\n+### Prototype features\n+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)\n+- [ ] WasmExec class taking a .wasm file as a parameter - just runs the file with Wasmtime \n+    - nudges the user to parametrize access to resources\n+- [ ] WasmTask - creating tasks from .wasm files\n+    - [x] Specification for what should this .wasm file export and how it will be ran\n+    - [ ] ITaskFactory that let's msbuild use task parameters defined inside the .wasm module\n+- [ ] Rust example\n+#### User Experience\n+1. The user Writes a task in Rust based on the template.\n+2. The user adds the task to their .proj file and it runs and logs as if it were a C# task. \n+```xml\n+<UsingTask TaskName=\"FancyWasmTask\"\n+           AssemblyFile=\"path/MSBuildWasm.dll\"\n+           TaskFactory=\"WasmTaskFactory\">\n+  <Task>\n+    <WasmModule>compiled_task_implementation.wasm</WasmModule>\n+  </Task>\n+</UsingTask>\n+\n+<Target Name=\"name\">\n+<FancyWasmTask Param=\"...\" Param2=\"asdf\">\n+<Output .../>\n+</FancyWasiTask>\n+</Target>\n+```\n+\n+### Advanced features\n+- [ ] ~~.NET example~~ (WASIp1 will not be supported in .NET)\n+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust \n+    - [ ] investigate integrating tools compiling languages to Wasm/WASI\n+    - On task level\n+        - [ ] RustTaskFactory\n+        - exploring other languages (Go, C/C++, Zig)\n+- [x] investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (\ud83d\udc40 Mono runtime)\n+    - Due to implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2\n+\n+\n+## Design\n+### diagram\n+\n+```mermaid\n+flowchart TD\n+    A[MSBuild] -->|Evaluation| B[WasmTaskFactory]\n+    A -->|Target execution| C[TaskExecutionHost]\n+    C -->|instantiate and\\n set parameters from XML| D[WasmTask]\n+    H[Rust/C#/Go] -->|\"compile using wasi-sdk\"| G\n+    D -->|gather output \\nfor use in other tasks| C \n+    D -->|execute| E[wasmtime-dotnet]\n+    E <--> F[Wasmtime]\n+\n+    B -->|Create Type for a specific WasmTask| D\n+    B -->|read what the task expects as parameters| E\n+    B -->|save path to task parameters| G[.wasm module]\n+    E -->|read output from task stdout| D\n+    %%B, C, D%%\n+    style B fill:#ffff00\n+    style C fill:#ffff00\n+    style D fill:#ffff00\n+```\n+C# classes are yellow.\n+\n+\n+### Wasm/WASI communication with MSBuild\n+Without WASIp2 WIT (not implemented in wasmtime-dotnet), the only data type that an be a Wasm function parameter and output is a number. Tasks have parameters which are of the following types: string, bool, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.",
              "author": {
                "login": "heaths"
              }
            }
          ]
        }
      }
    ]
  }
}