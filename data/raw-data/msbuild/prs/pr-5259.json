{
  "number": 5259,
  "title": "Update static graph docs",
  "body": "The changes reflects the state of things with #5222's changes. As potential extra changes go into #5222, I'll also update this PR.\r\n\r\nMore specifically, #5222 implements this region of the docs:  https://github.com/microsoft/msbuild/compare/master...cdmihai:cacheAndIsolationDocumentation?expand=1#diff-5de82af4d8f52787d69b38fd58c509caR44",
  "state": "CLOSED",
  "createdAt": "2020-04-08T23:27:31Z",
  "updatedAt": "2021-01-16T01:49:04Z",
  "closedAt": "2021-01-16T01:49:04Z",
  "mergedAt": null,
  "additions": 109,
  "deletions": 38,
  "changedFiles": 2,
  "headRefName": "cacheAndIsolationDocumentation",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": {
    "title": "MSBuild 16.7 Preview 2"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Static Graph"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d91f7d1a66ea268ef0cb140b50cd96d144d11266",
          "message": "Update static graph docs",
          "committedDate": "2020-04-08T23:17:31Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d39951116656235efe4255e81fbe2f858e31b4bc",
          "message": "multitargeting -> crosstargeting",
          "committedDate": "2020-04-16T01:35:15Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9487df8df8592b9faaa8f7a0993a4780d8ba7468",
          "message": "detail project graph construction and target execution",
          "committedDate": "2020-04-16T01:44:30Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "76f0867ed601bdf997736feb7f4f3e56214fd232",
          "message": "crosstarget -> multitarget",
          "committedDate": "2020-04-30T02:45:11Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30445fc8af1813ab3e46272e1d54638abad9c098",
          "message": "Update documentation/specs/static-graph-implementation-details.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:25:09Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "793d2c0e288e98d6d43035808ddce157be1d2c0a",
          "message": "Update documentation/specs/static-graph-implementation-details.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:26:49Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c9d1435f286629e7f441da71461df689a31f0b2",
          "message": "Update documentation/specs/static-graph-implementation-details.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:27:46Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59fc63beb51784d326d0832864ce31577c510100",
          "message": "Update documentation/specs/static-graph-implementation-details.md",
          "committedDate": "2020-05-04T21:34:48Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ad4acb40390c8c589b2a370f56a06eb9e4ec0e43",
          "message": "Update documentation/specs/static-graph-implementation-details.md",
          "committedDate": "2020-05-04T21:48:29Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4841fde87505a7f19d6d9e9defec6191deafb476",
          "message": "Update documentation/specs/static-graph-implementation-details.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:49:24Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "78a55246b9d53640ffa5a31cbfd150f3296629b0",
          "message": "Update documentation/specs/static-graph-implementation-details.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:50:00Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e361607c357e52524ba591533da477253e2fd21f",
          "message": "Update documentation/specs/static-graph-implementation-details.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:50:13Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c6ff616f5e526468b5bd5eea1a5333ed2c7de2c",
          "message": "Update documentation/specs/static-graph.md\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-05-04T21:51:32Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a009ee4950f6e56c4b16382f6e7db6b80679273b",
          "message": "updates",
          "committedDate": "2020-05-04T22:09:46Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I appreciated that, but I don't think it belongs in documentation. Similar below.\r\n```suggestion\r\n    - [How isolation exemption complicates everything](#how-isolation-exemption-complicates-everything)\r\n```",
              "createdAt": "2020-04-30T17:48:59Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe input cache files contain the cached results of all the targets that a project calls on its references. When a project executes, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves them from the provided input caches. In an isolated project build, only the current project should build targets. Any other referenced projects should be provided from the input caches. \r\n```",
              "createdAt": "2020-04-30T21:19:14Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. ",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.\r\n```\r\n?",
              "createdAt": "2020-04-30T21:20:02Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This can be useful when one wants to replay a build from previous caches.\r\n```\r\n\r\nBy \"replay a build from previous caches,\" do you mean going through the steps of a build as in seeing at what point it went wrong?",
              "createdAt": "2020-04-30T21:22:56Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": ">By \"replay a build from previous caches,\" do you mean going through the steps of a build as in seeing at what point it went wrong?\r\n\r\nMore like executing a project without executing its references. For example, the VS feature of re-building just one project could be implemented this way with caches.\r\n",
              "createdAt": "2020-05-04T21:32:58Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "```suggestion\r\nThe output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.\r\n```",
              "createdAt": "2020-05-04T21:34:33Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I like that.",
              "createdAt": "2020-05-04T22:33:31Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For the last line, isn't it the opposite? That BuildResults are composed of instances of TargetResults?",
              "createdAt": "2020-04-30T21:35:01Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). ",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "```suggestion\r\nThe cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \r\n```",
              "createdAt": "2020-05-04T21:48:10Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). ",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`project path` and `global properties` are wrapped in a `BuildRequestConfiguration`?\r\n\r\nSince I don't think you've mentioned it yet, it might also be good to note the difference between BuildResult and TargetResult.",
              "createdAt": "2020-05-01T21:45:25Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \n+\n+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and they last from `BuildManager.BeginBuild` to `BuildManager.EndBuild`. On command line builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.\r\n```",
              "createdAt": "2020-05-01T21:47:38Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \n+\n+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.\n+\n+<!-- cache lifetime -->\n+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nEntries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache (isolation exemption complicates this, more on that [below](#how-isolation-exemption-complicates-everything)). The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration. Checking the two override caches on each cache read before writing to the current cache ensures that this constraint remains true.\r\n```",
              "createdAt": "2020-05-01T22:39:41Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \n+\n+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.\n+\n+<!-- cache lifetime -->\n+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.\n+\n+<!-- constraints -->\n+\n+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.\n+The following constraints are enforced during cache aggregation:\n+- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`\n+- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)\n+- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the \"first one wins\" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.\n+\n+The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.\n+\n+<!-- How input / output cache entries are separated with the override caches -->\n+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache (isolation exemption complicates this, more on that [further down](#how-isolation-exemption-complicates-everything)). The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.\r\n```",
              "createdAt": "2020-05-01T22:45:08Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \n+\n+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.\n+\n+<!-- cache lifetime -->\n+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.\n+\n+<!-- constraints -->\n+\n+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.\n+The following constraints are enforced during cache aggregation:\n+- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`\n+- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)\n+- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the \"first one wins\" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.\n+\n+The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.\n+\n+<!-- How input / output cache entries are separated with the override caches -->\n+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache (isolation exemption complicates this, more on that [further down](#how-isolation-exemption-complicates-everything)). The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.\n+\n+## Isolation implementation\n+\n+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures all `MSBuild` tasks are made on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures all `MSBuild` tasks are cache hits.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:\r\n```",
              "createdAt": "2020-05-01T22:47:44Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \n+\n+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.\n+\n+<!-- cache lifetime -->\n+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.\n+\n+<!-- constraints -->\n+\n+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.\n+The following constraints are enforced during cache aggregation:\n+- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`\n+- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)\n+- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the \"first one wins\" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.\n+\n+The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.\n+\n+<!-- How input / output cache entries are separated with the override caches -->\n+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache (isolation exemption complicates this, more on that [further down](#how-isolation-exemption-complicates-everything)). The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.\n+\n+## Isolation implementation\n+\n+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures all `MSBuild` tasks are made on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures all `MSBuild` tasks are cache hits.\n+\n+### How isolation exemption complicates everything :(\n+<!-- Potential cache scenarios caused by exemption -->\n+Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.\n+\n+The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.\n+\n+The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact, due to multiple reasons:",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.\r\n```",
              "createdAt": "2020-05-01T22:51:45Z",
              "path": "documentation/specs/static-graph-implementation-details.md",
              "diffHunk": "@@ -0,0 +1,63 @@\n+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)\n+  - [Input / Output cache implementation](#input--output-cache-implementation)\n+  - [Isolation implementation](#isolation-implementation)\n+    - [How isolation exemption complicates everything :(](#how-isolation-exemption-complicates-everything)\n+\n+# Single project isolated builds: implementation details\n+\n+<!-- workflow -->\n+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.\n+\n+The input cache files should contain the cached results all the targets that a project calls on its references. When a project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. In isolated builds, the engine, instead of executing these tasks, will serve them from the provided input caches. In an isolated project build, only the current project should be building targets. Any other referenced projects should be provided form the input caches. \n+\n+The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n+The output cache file can be omitted in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+\n+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).\n+\n+## Input / Output cache implementation\n+<!-- cache structure -->\n+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which compose instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). \n+\n+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.\n+\n+<!-- cache lifetime -->\n+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.\n+\n+<!-- constraints -->\n+\n+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.\n+The following constraints are enforced during cache aggregation:\n+- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`\n+- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)\n+- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the \"first one wins\" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.\n+\n+The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.\n+\n+<!-- How input / output cache entries are separated with the override caches -->\n+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache (isolation exemption complicates this, more on that [further down](#how-isolation-exemption-complicates-everything)). The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.\n+\n+## Isolation implementation\n+\n+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures all `MSBuild` tasks are made on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures all `MSBuild` tasks are cache hits.\n+\n+### How isolation exemption complicates everything :(\n+<!-- Potential cache scenarios caused by exemption -->\n+Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.\n+\n+The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.\n+\n+The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact, due to multiple reasons:\n+1. the same project can be exempt by several references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It seems like some of this could be replaced with references to the new doc you wrote. (Doing so would make it less likely our docs would stay stale if this changes.)",
              "createdAt": "2020-05-01T22:58:40Z",
              "path": "documentation/specs/static-graph.md",
              "diffHunk": "@@ -297,56 +311,50 @@ Because referenced projects and their entry targets are guaranteed to be in the\n ### Isolated graph builds\n When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.\n \n-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.\n+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'll do a pass and try to reduce duplicates.",
              "createdAt": "2020-05-04T21:54:07Z",
              "path": "documentation/specs/static-graph.md",
              "diffHunk": "@@ -297,56 +311,50 @@ Because referenced projects and their entry targets are guaranteed to be in the\n ### Isolated graph builds\n When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.\n \n-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.\n+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Upon looking over it, not much can be reduced. My intention was to keep high level information in this document, and move all code implementation details into the other one.",
              "createdAt": "2020-05-04T22:08:05Z",
              "path": "documentation/specs/static-graph.md",
              "diffHunk": "@@ -297,56 +311,50 @@ Because referenced projects and their entry targets are guaranteed to be in the\n ### Isolated graph builds\n When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.\n \n-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.\n+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Ok, sounds good. My best idea for how to completely eliminate any duplicate information would also be a nightmare to maintain, so... \ud83d\ude04",
              "createdAt": "2020-05-04T22:29:17Z",
              "path": "documentation/specs/static-graph.md",
              "diffHunk": "@@ -297,56 +311,50 @@ Because referenced projects and their entry targets are guaranteed to be in the\n ### Isolated graph builds\n When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.\n \n-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.\n+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nFor now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.\r\n```",
              "createdAt": "2020-05-01T23:01:26Z",
              "path": "documentation/specs/static-graph.md",
              "diffHunk": "@@ -297,56 +311,50 @@ Because referenced projects and their entry targets are guaranteed to be in the\n ### Isolated graph builds\n When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.\n \n-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.\n+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.\n \n This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.\n \n ### Single project isolated builds\n When building a single project in isolation, all project references' build results must be provided to the project externally. Specifically, the results will need to be [deserialized](#deserialization) from files and loaded into the build result cache in memory.\n \n-Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).\n-\n-There is also the possibility for these higher-order build engines and even Visual Studio to enable extremely fast incremental builds for a project. For example, when all project references' build results are provided (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets on any other project.\n+When MSBuild runs in isolation mode, it fails the build when it detects:\n+1. `MSBuild` task calls which cannot be served from the cache. Cache misses are illegal.\n+2. `MSBuild` task calls to project files which were not defined in the `ProjectReference` item.\n \n-These incremental builds can even be extended to multiple projects by keeping a project graph in memory as well as the last build result for each node and whether that build result is valid. The higher-order build engine can then itself traverse the graph and do single project isolated builds for projects which are not currently up to date.\n-\n-### Single project isolated builds: implementation details\n-\n-<!-- workflow -->\n-Single project builds can be achieved by providing MSBuild with input and output cache files.\n+Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).\n \n-The input cache files contain the cached results of all of the current project's references. This way, when the current project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. The engine, instead of executing these tasks, will serve them from the provided input caches. \n+There is also the possibility for these higher-order build engines and even Visual Studio to enable faster incremental builds for a project. For example, when a project's references' build results are provided via file caches (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets for any reference.\n \n-The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.\n-The output cache file can be ommited in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.\n+These incremental builds could be extended to the entire graph by keeping a project graph in memory as well as the last build result cache files for each node and whether a node's results are up to date. The higher-order build engine can then itself traverse the graph and do single project isolated builds only for projects which are not currently up to date.\n \n-The presence of either input or output caches turns on the isolated build constraints. The engine will fail the build on:\n-- `MSBuild` task calls to project files which were not defined in the `ProjectReference` item at evaluation time.\n-- `MSBuild` task calls which cannot be served from the cache\n+#### APIs\n+Cache file information is provided via [BuildParameters](https://github.com/Microsoft/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.\n \n-<!-- cache structure -->\n-These cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results.\n+Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/microsoft/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.\n \n-Cache structure: `(project path, global properties) -> results`\n+#### Command line\n+Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.\n+Isolation constraints are turned on via `/isolate` (they are also implicitly activated when either input or output caches are used).\n \n-<!-- cache lifetime -->\n-The caches are applicable for the entire duration of the MSBuild.exe process. The input and output caches have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. Since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime.\n+#### Exempting references from isolation constraints\n+In certain situations one may want to exempt a reference from isolation constraints. A few potential cases:\n+- debugging / onboarding to isolation constraints\n+- exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)\n+- relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)\n \n-<!-- constraints -->\n-The following are cache file constraints enforced by the engine.\n+A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:\n+```xml\n+<ItemGroup>\n+  <GraphIsolationExemptReference Include=\"/Full/Path/To/B.csproj\" />\n+</ItemGroup>\n+```\n \n-Input cache files constraints:\n-- A ConfigCache / ResultsCache mapping must be unique between all input caches (multiple input caches cannot provide information for the same cache entry)\n-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`\n-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache\n+A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.\n \n-Output cache file constraints:\n-- the output cache file contains results only for additional work performed in the current BeginBuild / EndBuild session. Entries from input caches are not transferred to the output cache.\n+For now, self builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}