{
  "number": 8424,
  "title": "Added support for logging interpolated strings in tasks.",
  "body": "Fixes #7875\r\n\r\nThis PR replaces #8410\r\n\r\n### Context\r\nEnables to log interpolated strings from tasks.\r\n\r\n### Changes Made\r\nAdded new interpolated string handler with overloads in TaskLoggingHelper.\r\n\r\n### Testing\r\nNew unit tests added.\r\n\r\n### Notes\r\nI tried to use ```FormattableString```, but old overload had precedence.\r\nHandler is mutable value type, but mutating methods should be invoked by compiler generated code. If you are not comfortable with it, we can change it to reference type with heap allocation.",
  "state": "MERGED",
  "createdAt": "2023-02-08T13:56:04Z",
  "updatedAt": "2023-02-22T15:11:31Z",
  "closedAt": "2023-02-17T07:35:57Z",
  "mergedAt": "2023-02-17T07:35:57Z",
  "additions": 206,
  "deletions": 1,
  "changedFiles": 4,
  "headRefName": "dev/mipavlik/task-logger-improvements2",
  "isDraft": false,
  "author": {
    "login": "MichalPavlik"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f005120e74875461d98075ea646cde6e11f74386",
          "message": "Added support for logging interpolated strings in tasks.",
          "committedDate": "2023-02-08T13:54:31Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a25fa17481ef9f9f0344ee780d13a814e7d9af2",
          "message": "Added precise length computation. Renamed file to match class name.",
          "committedDate": "2023-02-09T09:55:27Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "974f39e09da89d02a37f3a92b90136a483ff8e33",
          "message": "Resolved \"Possible null reference assignment\" issue",
          "committedDate": "2023-02-09T10:03:40Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8004e8afac4f0ef65d2286a316093270db3003aa",
          "message": "Removed argument count limitation. Removed allocations in case there are less than 10 arguments. Added method binding tests.",
          "committedDate": "2023-02-10T12:09:44Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b54e3eb33bf1b7c2b86e87a26742d4e0da1628b2",
          "message": "Removed floating point operation",
          "committedDate": "2023-02-14T10:19:54Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e90e8c354301c38b3fdee3aeecdbb8e7e2771ef1",
          "message": "Resolved comments",
          "committedDate": "2023-02-14T13:37:08Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@MichalPavlik, have you considered an alternative approach where `LogInterpolatingHandler` keeps an array of literals and objects (possibly both in one array) and instead of calling `string.Format`, it would materialize the string using a `StringBuilder` by simply concatenating everything? It would be interesting to see how it compares with respect to allocations and run-time in typical logging scenarios.",
        "createdAt": "2023-02-09T11:32:09Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> @MichalPavlik, have you considered an alternative approach where `LogInterpolatingHandler` keeps an array of literals and objects (possibly both in one array) and instead of calling `string.Format`, it would materialize the string using a `StringBuilder` by simply concatenating everything? It would be interesting to see how it compares with respect to allocations and run-time in typical logging scenarios.\r\n\r\nCould you please elaborate? I created custom logic that creates string format and keeps arguments, because underlying event contains these two elements :) Implemented overloads allows to use interpolated strings without changing existing events.\r\n\r\nThere is no formatting in the handler (except constructing the format itself).",
        "createdAt": "2023-02-09T17:04:57Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "I was thinking about something like this:\r\n\r\n```C#\r\n    public LogInterpolatedStringHandler(int literalLength, int formattedCount)\r\n    {\r\n        Arguments = new object[literalLength + formattedCount];\r\n    }\r\n\r\n    public void AppendLiteral(string s)\r\n    {\r\n        Arguments[position++] = s;\r\n    }\r\n\r\n    public void AppendFormatted<T>(T t)\r\n    {\r\n        Arguments[position++] = t;\r\n    }\r\n\r\n    internal string GetFormattedString()\r\n    {\r\n        StringBuilder sb = new(); // we can estimate initial size as an optimization\r\n        for (int i = 0; i < position; i++)\r\n        {\r\n            sb.Append(Arguments[i].ToString());\r\n        }\r\n        return sb.ToString();\r\n    }\r\n```\r\n\r\nWe would be doing less work in `LogInterpolatedStringHandler` so would likely be faster if the event is filtered out and `GetFormattedString` is not called. It could also be faster in the other case when we end up logging the string, although we would have to measure.\r\n\r\nI understand that `LogInterpolatedStringHandler` would have to be plumbed through more code, which makes this less attractive and probably not worth the effort.\r\n\r\nEdit: `literalLength` is the number of characters, not number of strings, so we unnecessarily over-allocate in the snippet above.",
        "createdAt": "2023-02-09T20:58:35Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I see. We can definitely think about it, but I would say it's out of scope of this effort now. Please create new issue for extending functionality.",
        "createdAt": "2023-02-10T12:36:02Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "> Would any of the new unit tests fail if `LogInterpolatedStringHandler` does not exist / is not picked up by the compiler?\r\n\r\nYes, I extended tests to check if correct overload is used.",
        "createdAt": "2023-02-14T10:25:02Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "When you define public MSBuild API that is not available for all target frameworks, how does learn.microsoft.com display that? I found only one preexisting case: Microsoft.NET.StringTools.Strings.WeakIntern(ReadOnlySpan\\<char\\> str), but that class doesn't seem to be documented at learn.microsoft.com.",
        "createdAt": "2023-02-17T08:12:43Z",
        "author": {
          "login": "KalleOlaviNiemitalo"
        }
      },
      {
        "body": "> When you define public MSBuild API that is not available for all target frameworks, how does learn.microsoft.com display that? I found only one preexisting case: Microsoft.NET.StringTools.Strings.WeakIntern(ReadOnlySpan<char> str), but that class doesn't seem to be documented at learn.microsoft.com.\r\n\r\nI believe that it's exposed with this UI:\r\n\r\n![image](https://user-images.githubusercontent.com/12206368/220399173-1b7f3ea0-594b-4035-8ec4-b3b90b4f68d5.png)\r\n\r\n`MSBuild` - MSBuild.exe included in VS.\r\n`MSBuild (.NET Core)` - MSBuild included in .NET Core SDK.",
        "createdAt": "2023-02-21T16:15:22Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Alternatively we can allocate exact - most cases will have under 10 args anyways\r\n\r\n```suggestion\r\n            buffer = new char[literalLength + 3 * (formattedCount % 10) + 4 * (formattedCount - (formattedCount % 10))];\r\n```\r\n(removing brackets for multiplication to make it less bracket crazy)",
              "createdAt": "2023-02-08T15:03:06Z",
              "path": "src/Framework/LogInterpolatingHandler.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object[] Arguments { get; } = Array.Empty<object>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Length is computed with reserved space for \"{x}\" and \"{xx}\" placeholders \n+            buffer = new char[literalLength + (4 * formattedCount)];",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes, we can be more precise. I modified code based on your comment, but thinking about it, the array lifetime is very short and it will most likely not survive Gen0 collection anyway. Maybe we can use ```ArrayPool``` to remove allocations, but I'm not sure if the memory saving outweighs added runtime complexity . @ladipro ?",
              "createdAt": "2023-02-09T10:01:24Z",
              "path": "src/Framework/LogInterpolatingHandler.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object[] Arguments { get; } = Array.Empty<object>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Length is computed with reserved space for \"{x}\" and \"{xx}\" placeholders \n+            buffer = new char[literalLength + (4 * formattedCount)];",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Okay, thinking about it even more, using ```ArrayPool``` isn't probably possible in this case as we don't know when to return rented array back to the pool :)",
              "createdAt": "2023-02-09T10:13:47Z",
              "path": "src/Framework/LogInterpolatingHandler.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object[] Arguments { get; } = Array.Empty<object>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Length is computed with reserved space for \"{x}\" and \"{xx}\" placeholders \n+            buffer = new char[literalLength + (4 * formattedCount)];",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "If we go this route of composing a string for `string.Format`, then I think it's fine to have a reasonable upper bound. Even `(formattedCount * (2 + numberOfDigitsInFormattedCount))` could be OK.",
              "createdAt": "2023-02-09T11:28:21Z",
              "path": "src/Framework/LogInterpolatingHandler.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object[] Arguments { get; } = Array.Empty<object>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Length is computed with reserved space for \"{x}\" and \"{xx}\" placeholders \n+            buffer = new char[literalLength + (4 * formattedCount)];",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I wanted to keep it simple for >10 args scenario, so I used ```formattedCount * (maxNumberOfDigits + 2)``` in new commit.",
              "createdAt": "2023-02-10T12:46:29Z",
              "path": "src/Framework/LogInterpolatingHandler.cs",
              "diffHunk": "@@ -0,0 +1,62 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object[] Arguments { get; } = Array.Empty<object>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Length is computed with reserved space for \"{x}\" and \"{xx}\" placeholders \n+            buffer = new char[literalLength + (4 * formattedCount)];",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can be `readonly`.",
              "createdAt": "2023-02-09T10:09:58Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Looks like you're optimizing a lot in this class so why not do something like:\r\n\r\n```C#\r\n  if (indexString >= 10) buffer[position++] = '0' + (indexString / 10);\r\n  buffer[position++] = '0' + indexString % 10;\r\n```\r\n\r\ninstead of the string allocation.",
              "createdAt": "2023-02-09T10:33:57Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Buffer size is computed with reserved space for \"{x}\" and \"{xx}\" placeholders\n+            int bufferSize = formattedCount < 10 ?\n+                literalLength + (3 * formattedCount) :\n+                literalLength + 3 * (formattedCount % 10) + 4 * (formattedCount - (formattedCount % 10));\n+\n+            buffer = new char[bufferSize];\n+\n+            if (formattedCount > 0)\n+            {\n+                Arguments = new object[formattedCount];\n+            }\n+        }\n+\n+        public void AppendLiteral(string s)\n+        {\n+            s.AsSpan().CopyTo(buffer.AsSpan().Slice(position));\n+            position += s.Length;\n+        }\n+\n+        public void AppendFormatted<T>(T t)\n+        {\n+            string indexString = argPosition.ToString();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Only thing I don't like is... that I didn't do it myself before I created this PR :D Good catch.",
              "createdAt": "2023-02-09T17:14:16Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)\n+            {\n+                throw new ArgumentOutOfRangeException(\"Number of formatted arguments must be less than 100.\");\n+            }\n+\n+            // Buffer size is computed with reserved space for \"{x}\" and \"{xx}\" placeholders\n+            int bufferSize = formattedCount < 10 ?\n+                literalLength + (3 * formattedCount) :\n+                literalLength + 3 * (formattedCount % 10) + 4 * (formattedCount - (formattedCount % 10));\n+\n+            buffer = new char[bufferSize];\n+\n+            if (formattedCount > 0)\n+            {\n+                Arguments = new object[formattedCount];\n+            }\n+        }\n+\n+        public void AppendLiteral(string s)\n+        {\n+            s.AsSpan().CopyTo(buffer.AsSpan().Slice(position));\n+            position += s.Length;\n+        }\n+\n+        public void AppendFormatted<T>(T t)\n+        {\n+            string indexString = argPosition.ToString();",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we want to ship with this limitation. Should be easy to support any number. I was going to write the function to calculate `bufferSize` but ChatGPT is not available at the moment :wink:",
              "createdAt": "2023-02-09T11:17:45Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I like the idea. It's easy to compute number of digits in ```formattedCount``` with ```Log10```, but in that case, I would drop the exact buffer size computation for sake of simplicity and runtime complexity. I believe that cases with 10 and more arguments are very rare and saving few bytes doesn't worth it.",
              "createdAt": "2023-02-09T17:11:50Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "By `Log10` I assume you mean `while (formattedCount > 0) { numOfDigits++; formattedCount /= 10 }`, not the actual floating point `Math.Log10`. Floating point arithmetic can be very costly on some CPUs.",
              "createdAt": "2023-02-09T20:43:15Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I used ```Log10``` for cases where we have more than 10 arguments. I still believe that these cases are very rare. I don't have an opportunity to do measurements on various CPUs, but I found perf results for this task: https://i.stack.imgur.com/YUfLu.png. It was published few years ago. If you insist to use a loop, I will rewrite it :)\r\n",
              "createdAt": "2023-02-10T12:18:45Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Thank you! I would favor the loop but I may be too floating point averse. @rainersigwald, what do you think?\r\n\r\nNotes:\r\n- The benchmark probably used random integer values while ours are expected to be very small.\r\n- With the loop there would be no need for the `if (formattedCount < 10)` special case.",
              "createdAt": "2023-02-10T13:03:35Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Okay, no problem. I removed ```Log10``` :)",
              "createdAt": "2023-02-14T10:22:17Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            if (formattedCount > 99)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The type should have a comment. It's public so it will show in the official API reference docs as well.",
              "createdAt": "2023-02-14T10:42:57Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `static`",
              "createdAt": "2023-02-14T10:43:29Z",
              "path": "src/Framework/LogInterpolatedStringHandler.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NET6_0_OR_GREATER\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    [InterpolatedStringHandler]\n+    public ref struct LogInterpolatedStringHandler\n+    {\n+        private readonly char[] buffer;\n+        private int position = 0;\n+        private int argPosition = 0;\n+\n+        public readonly object?[] Arguments { get; } = Array.Empty<object?>();\n+\n+        public LogInterpolatedStringHandler(int literalLength, int formattedCount)\n+        {\n+            // Buffer size is computed with reserved space for \"{x..x}\" placeholders\n+            int maxNumberOfDigits = GetNumberOfDigits(formattedCount);\n+            int bufferSize = literalLength + (formattedCount * (maxNumberOfDigits + 2));\n+\n+            buffer = new char[bufferSize];\n+\n+            if (formattedCount > 0)\n+            {\n+                Arguments = new object[formattedCount];\n+            }\n+        }\n+\n+        public void AppendLiteral(string s)\n+        {\n+            s.AsSpan().CopyTo(buffer.AsSpan().Slice(position));\n+            position += s.Length;\n+        }\n+\n+        public void AppendFormatted<T>(T t)\n+        {\n+            buffer[position++] = '{';\n+\n+            if (argPosition < 10)\n+            {\n+                buffer[position++] = (char)('0' + argPosition);\n+            }\n+            else\n+            {\n+                string indexString = argPosition.ToString();\n+                indexString.AsSpan().CopyTo(buffer.AsSpan().Slice(position));\n+                position += indexString.Length;\n+            }\n+\n+            buffer[position++] = '}';\n+\n+            Arguments[argPosition++] = t;\n+        }\n+\n+        internal string GetFormat()\n+        {\n+            string result = new string(buffer, 0, position);\n+\n+            return result;\n+        }\n+\n+        private int GetNumberOfDigits(int value)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A great thing about InterpolatedStringHandlers is that you can move these `if` conditions into the handler itself, and when the condition is false, you can opt-out of any processing of the string at all.\r\n\r\nSee https://github.com/dotnet/runtime/blob/a4c92435ebc331d4f5e107c37d2fe759a3199a32/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Debug.cs#L274-L291 for an example.\r\n\r\nYou can change this to be:\r\n\r\n```C#\r\npublic void LogMessage(MessageImportance importance, [InterpolatedStringHandlerArgument(\"\", nameof(importance))] LogInterpolatedStringHandler stringHandler)\r\n{\r\n```\r\n\r\nand then in the constructor of `LogInterpolatedStringHandler`:\r\n\r\n```C#\r\npublic LogInterpolatedStringHandler(int literalLength, int formattedCount, TaskLoggingHelper taskLoggingHelper, MessageImportance importance, out bool shouldAppend)\r\n{\r\n    if (taskLoggingHelper.LogsMessagesOfImportance(importance))\r\n    {\r\n        // Do normal processing/allocating\r\n        shouldAppend = true;\r\n    }\r\n    else\r\n    {\r\n        shouldAppend = false;\r\n    }\r\n}\r\n```\r\n\r\ncc @stephentoub ",
              "createdAt": "2023-02-21T14:52:24Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -258,6 +258,33 @@ public bool LogsMessagesOfImportance(MessageImportance importance)\n                 || buildEngine10.EngineServices.LogsMessagesOfImportance(importance);\n         }\n \n+#if NET6_0_OR_GREATER\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(LogInterpolatedStringHandler stringHandler)\n+        {\n+            LogMessage(MessageImportance.Normal, stringHandler);\n+        }\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance level of the message.</param>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(MessageImportance importance, LogInterpolatedStringHandler stringHandler)\n+        {\n+            if (LogsMessagesOfImportance(importance))\n+            {\n+                LogMessage(importance, stringHandler.GetFormat(), stringHandler.Arguments);",
              "author": {
                "login": "eerhardt"
              }
            },
            {
              "body": "Thank you, how could we have missed this!\r\n\r\nIf we frontload the importance check to our interpolated string handler constructor, we don't have to optimize for the case where `AppendLiteral` and `AppendFormatted` have been called but the string is not needed at the end. This radically changes the design of the handler. Definitely make sense to compose our handler out of a default one and just add the early check, just like in `Debug.Write*`.\r\n\r\n(Note: this PR is being reverted in #8479 because the requirement to run MSBuild tasks built against this change on MSBuild with this change resulted in source build break. We'll have to redo this anyway.)",
              "createdAt": "2023-02-22T12:27:36Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -258,6 +258,33 @@ public bool LogsMessagesOfImportance(MessageImportance importance)\n                 || buildEngine10.EngineServices.LogsMessagesOfImportance(importance);\n         }\n \n+#if NET6_0_OR_GREATER\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(LogInterpolatedStringHandler stringHandler)\n+        {\n+            LogMessage(MessageImportance.Normal, stringHandler);\n+        }\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance level of the message.</param>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(MessageImportance importance, LogInterpolatedStringHandler stringHandler)\n+        {\n+            if (LogsMessagesOfImportance(importance))\n+            {\n+                LogMessage(importance, stringHandler.GetFormat(), stringHandler.Arguments);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "FWIW...\r\n\r\nYou're reverting it anyway, so it doesn't really matter, but as I mentioned offline to @eerhardt, I wouldn't be surprised if the new version (without the severity check) was also more expensive in many situations than if you didn't have the custom handler at all.  If someone just wrote an interpolated string and that got compiled down using the default handler, you'd get a single string allocation in the common case.  With the interpolated handler here, you're allocating one or more char[]s in order to then produce a string, you're allocating an object[] to store all the arguments, you're boxing each value type argument to store into that object[], etc.  If that's really the path you wanted to go, because you needed a composite format string and the object[] for some other reason (e.g. maybe the logging infrastructure requires the ability to perform custom conversions on the args or something), you could just use the old-school `FormattableString`, where the compiler generates the composite format string for you at compile time and handles the creation of the object[].  But, if it's fine to just produce the result string after a severity check, you're much better off doing what was discussed above, and having the handler do the severity check and then delegate to the default handler.",
              "createdAt": "2023-02-22T14:37:59Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -258,6 +258,33 @@ public bool LogsMessagesOfImportance(MessageImportance importance)\n                 || buildEngine10.EngineServices.LogsMessagesOfImportance(importance);\n         }\n \n+#if NET6_0_OR_GREATER\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(LogInterpolatedStringHandler stringHandler)\n+        {\n+            LogMessage(MessageImportance.Normal, stringHandler);\n+        }\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance level of the message.</param>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(MessageImportance importance, LogInterpolatedStringHandler stringHandler)\n+        {\n+            if (LogsMessagesOfImportance(importance))\n+            {\n+                LogMessage(importance, stringHandler.GetFormat(), stringHandler.Arguments);",
              "author": {
                "login": "stephentoub"
              }
            },
            {
              "body": "Thanks Eric and Stephen. We had a plan to do more optimizations for the handler. I wanted to use ```FormattableString```, but compiler was favorizing the old overload with ```params object[]```. The solution would be to use new method name (which would probably prevent the issue with source build break), but I didn't like the idea as it could be confusing for developers. Now we have opportunity to take a second look with fresh mind and gained experience :) And we should probably review our whole logging pipeline, and make more fundamental changes to support interpolated strings. ",
              "createdAt": "2023-02-22T15:09:48Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -258,6 +258,33 @@ public bool LogsMessagesOfImportance(MessageImportance importance)\n                 || buildEngine10.EngineServices.LogsMessagesOfImportance(importance);\n         }\n \n+#if NET6_0_OR_GREATER\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(LogInterpolatedStringHandler stringHandler)\n+        {\n+            LogMessage(MessageImportance.Normal, stringHandler);\n+        }\n+\n+        /// <summary>\n+        /// Logs a message using the specified interpolated string.\n+        /// Thread safe.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance level of the message.</param>\n+        /// <param name=\"stringHandler\">The message interpolated string.</param>\n+        public void LogMessage(MessageImportance importance, LogInterpolatedStringHandler stringHandler)\n+        {\n+            if (LogsMessagesOfImportance(importance))\n+            {\n+                LogMessage(importance, stringHandler.GetFormat(), stringHandler.Arguments);",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      }
    ]
  }
}