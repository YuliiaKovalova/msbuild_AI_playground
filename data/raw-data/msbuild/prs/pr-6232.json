{
  "number": 6232,
  "title": "Ignore comments and whitespace when parsing read-only XML files",
  "body": "Fixes #2576\r\n\r\n### Context\r\n\r\nThe code already has support for parsing project files as read-only when we know that we're not going to be asked to write them back to disk. This flag is currently unused because the initial implementation in #3584 introduced a regression related to whitespace in attribute values (#4210).\r\n\r\n### Changes Made\r\n\r\nTrivially reverted part of #4213 that addressed the regression and added a hack to make `XmlReader` behave the same as `XmlTextReader`.\r\n\r\n### Testing\r\n\r\nExisting unit tests for correctness and ETW for performance. `XmlDocumentWithLocation.Load()` is ~26% faster with this change compared to baseline when building .NET Core projects. This translates to about 10 ms per one incremental CLI build of a Hello world application.\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2021-03-09T14:12:22Z",
  "updatedAt": "2021-07-13T20:57:02Z",
  "closedAt": "2021-04-27T18:44:53Z",
  "mergedAt": "2021-04-27T18:44:53Z",
  "additions": 64,
  "deletions": 5,
  "changedFiles": 1,
  "headRefName": "2576-ignore-xml-comments",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "48396ed95fd1e097a00a8bd4c3cd11c3e459e59d",
          "message": "Ignore comments when parsing read-only XML files",
          "committedDate": "2021-03-09T14:02:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f09660e4dd1c370816d853d49cf3f8eaca57f0e1",
          "message": "Ignore whitespace as well and poke the right internal property to bring back XmlTextReader behavior",
          "committedDate": "2021-03-09T19:54:12Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b5172c8357d7d5db668a7ff1762bad173f4119b4",
          "message": "Fix whitespace and add comment",
          "committedDate": "2021-03-10T06:07:38Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "14fc6ccc331d4a1ca93e879d6c20a5813cd18b55",
          "message": "PR feedback",
          "committedDate": "2021-04-23T12:26:36Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa87136b9b0cb9b68967e4cfc51f719febe4ed42",
          "message": "PR feedback",
          "committedDate": "2021-04-26T07:55:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "13c5c4f359679cd3e6ab8270f6328645740ac33a",
          "message": "PR feedback: Put changes behind a changewave check",
          "committedDate": "2021-04-27T08:19:30Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3ba96173c8e4be2660734882092adc115677b000",
          "message": "Switch from changewave 17.0 to 16.10",
          "committedDate": "2021-04-27T15:02:20Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I should have read the issues more carefully. The problem is in the difference between `new XmlTextReader()` and `XmlReader.Create()` regardless of the `XmlReaderSettings` passed to the latter. Needs more work!",
        "createdAt": "2021-03-09T16:00:37Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "None of my comments are a deal breaker, so fix if you like or not, use your judgement.",
        "createdAt": "2021-04-23T21:32:48Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "[Post-mortem] The change hasn't proved impactful in the perf lab with any project types used in the runs. Consequently the runtime team is not moving forward with exposing `Normalization`. In the unlikely case that we hit issues in the future, this PR can be reverted without much loss.\r\n\r\nMicro benchmarks are showing an improvement but the 10 ms end-to-end win I see on my machine is apparently not happening in the lab.\r\n\r\nParsing Microsoft.Common.CurrentVersion.targets (~6k lines of XML):\r\n![image](https://user-images.githubusercontent.com/12206368/117107195-7d545f80-ad81-11eb-9125-704a12e533a6.png)\r\n",
        "createdAt": "2021-05-05T07:09:46Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "When I run `dotnet build` with locally build runtime libs in Debug mode (with asserts) this causes the build to crash:\r\n```\r\nProcess terminated. Assertion failed.\r\nXmlTextReaderImpl.Normalization property cannot be changed on reader created via XmlReader.Create.\r\n   at System.Xml.XmlTextReaderImpl.set_Normalization(Boolean value) in /home/manicka/repositories/runtime/src/libraries/System.Private.Xml/src/System/Xml/Core/XmlTextReaderImpl.cs:line 2093\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Span`1& arguments, Signature sig, Boolean constructor, Boolean wrapExceptions)\r\n   at System.Reflection.RuntimeMethodInfo.InvokeOneParameter(Object obj, BindingFlags invokeAttr, Binder binder, Object parameter, CultureInfo culture) in /home/manicka/repositories/runtime/src/coreclr/System.Private.CoreLib/src/System/Reflection/RuntimeMethodInfo.cs:line 470\r\n   at System.Reflection.RuntimePropertyInfo.SetValue(Object obj, Object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture) in /home/manicka/repositories/runtime/src/coreclr/System.Private.CoreLib/src/System/Reflection/RuntimePropertyInfo.cs:line 369\r\n   at System.Reflection.RuntimePropertyInfo.SetValue(Object obj, Object value, Object[] index) in /home/manicka/repositories/runtime/src/coreclr/System.Private.CoreLib/src/System/Reflection/RuntimePropertyInfo.cs:line 350\r\n   at System.Reflection.PropertyInfo.SetValue(Object obj, Object value) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Reflection/PropertyInfo.cs:line 52\r\n   at Microsoft.Build.Internal.XmlReaderExtension.GetXmlReader(String file, StreamReader input, Boolean loadAsReadOnly, Encoding& encoding) in Microsoft.Build.dll:token 0x6000c62+0x6c\r\n   at Microsoft.Build.Internal.XmlReaderExtension..ctor(String file, Boolean loadAsReadOnly) in Microsoft.Build.dll:token 0x6000c5d+0x2c\r\n   at Microsoft.Build.Construction.ProjectRootElement.LoadDocument(String fullPath, Boolean preserveFormatting, Boolean loadAsReadOnly) in Microsoft.Build.dll:token 0x60002da+0x39\r\n   at Microsoft.Build.Construction.ProjectRootElement..ctor(String path, ProjectRootElementCacheBase projectRootElementCache, Boolean preserveFormatting) in Microsoft.Build.dll:token 0x600024a+0x51\r\n   at Microsoft.Build.Construction.ProjectRootElement.CreateProjectFromPath(String projectFile, ProjectRootElementCacheBase projectRootElementCache, Boolean preserveFormatting) in Microsoft.Build.dll:token 0x60002d9+0x28\r\n   at Microsoft.Build.Construction.ProjectRootElement.<>c.<OpenProjectOrSolution>b__208_0(String path, ProjectRootElementCacheBase cache) in Microsoft.Build.dll:token 0x6001e13+0x0\r\n   at Microsoft.Build.Evaluation.ProjectRootElementCache.Get(String projectFile, OpenProjectRootElement openProjectRootElement, Boolean isExplicitlyLoaded, Nullable`1 preserveFormatting) in Microsoft.Build.dll:token 0x6000ae5+0x135\r\n   at Microsoft.Build.Construction.ProjectRootElement.OpenProjectOrSolution(String fullPath, IDictionary`2 globalProperties, String toolsVersion, ProjectRootElementCacheBase projectRootElementCache, Boolean isExplicitlyLoaded) in Microsoft.Build.dll:token 0x60002cc+0x21\r\n   at Microsoft.Build.Execution.ProjectInstance..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, Int32 submissionId, Nullable`1 projectLoadSettings) in Microsoft.Build.dll:token 0x6000e3a+0x23\r\n   at Microsoft.Build.BackEnd.BuildRequestConfiguration.<>c__DisplayClass60_0.<LoadProjectIntoConfiguration>b__0() in Microsoft.Build.dll:token 0x60024a0+0x14e\r\n   at Microsoft.Build.BackEnd.BuildRequestConfiguration.InitializeProject(BuildParameters buildParameters, Func`1 loadProjectFromFile) in Microsoft.Build.dll:token 0x60014f7+0x10\r\n   at Microsoft.Build.BackEnd.BuildRequestConfiguration.LoadProjectIntoConfiguration(IBuildComponentHost componentHost, BuildRequestDataFlags buildRequestDataFlags, Int32 submissionId, Int32 nodeId) in Microsoft.Build.dll:token 0x60014f6+0x60\r\n   at Microsoft.Build.BackEnd.RequestBuilder.BuildProject() in Microsoft.Build.dll:token 0x600140f+0x0\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine& stateMachine) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs:line 38\r\n   at Microsoft.Build.BackEnd.RequestBuilder.BuildProject() in Microsoft.Build.dll:token 0x600140f+0x1c\r\n   at Microsoft.Build.BackEnd.RequestBuilder.BuildAndReport() in Microsoft.Build.dll:token 0x6001406+0x26\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine& stateMachine) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs:line 38\r\n   at Microsoft.Build.BackEnd.RequestBuilder.BuildAndReport() in Microsoft.Build.dll:token 0x6001406+0x1c\r\n   at Microsoft.Build.BackEnd.RequestBuilder.RequestThreadProc(Boolean setThreadParameters) in Microsoft.Build.dll:token 0x6001405+0x22\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine& stateMachine) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs:line 38\r\n   at Microsoft.Build.BackEnd.RequestBuilder.RequestThreadProc(Boolean setThreadParameters) in Microsoft.Build.dll:token 0x6001405+0x24\r\n   at Microsoft.Build.BackEnd.RequestBuilder.<StartBuilderThread>b__52_2() in Microsoft.Build.dll:token 0x600141c+0x0\r\n   at System.Threading.Tasks.Task`1.InnerInvoke() in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Future.cs:line 503\r\n   at System.Threading.Tasks.Task.<>c.<.cctor>b__284_0(Object obj) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs:line 2369\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/ExecutionContext.cs:line 183\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task& currentTaskSlot, Thread threadPoolThread) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs:line 2327\r\n   at System.Threading.Tasks.Task.ExecuteEntry() in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs:line 2240\r\n   at System.Threading.Tasks.TaskScheduler.TryExecuteTask(Task task) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskScheduler.cs:line 408\r\n   at Microsoft.Build.BackEnd.RequestBuilder.DedicatedThreadsTaskScheduler.<InjectThread>b__6_0() in Microsoft.Build.dll:token 0x6002467+0x1a\r\n   at System.Threading.Thread.StartHelper.Callback(Object state) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/Thread.cs:line 42\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) in /home/manicka/repositories/runtime/src/libraries/System.Private.CoreLib/src/System/Threading/ExecutionContext.cs:line 183\r\n   at System.Threading.Thread.StartCallback() in /home/manicka/repositories/runtime/src/coreclr/System.Private.CoreLib/src/System/Threading/Thread.CoreCLR.cs:line 105\r\nAborted (core dumped)\r\n```\r\n\r\nI know that normally people do not run Debug builds, but I assume the assert was put there on purpose (it's been there for a long time):\r\nhttps://github.com/dotnet/runtime/blob/ae64899ca74968c1c0dd2d81564c1b9fab12e2b4/src/libraries/System.Private.Xml/src/System/Xml/Core/XmlTextReaderImpl.cs#L2093",
        "createdAt": "2021-07-13T20:30:04Z",
        "author": {
          "login": "ManickaP"
        }
      },
      {
        "body": "Opened #6669 to revert this PR.",
        "createdAt": "2021-07-13T20:57:02Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I would just create a local for PropertyInfo returned by `GetNormalizationPropertyInfo`, and check that for null, and fallback to the old behavior if it is null, otherwise call SetValue. Don't think there's a need for try/catch. Maybe also cache the result of `reader.GetType()`?\r\n\r\nDoubt it's worth creating a delegate here (reflection is slow, but we're only calling it once per file, so doubt it will show in profiles at all). Maybe worth a try if we're being completely thorough.",
              "createdAt": "2021-03-15T15:58:51Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +73,44 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        private static volatile PropertyInfo _normalizationPropertyInfo;\n+\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+            if (_normalizationPropertyInfo == null)\n+            {\n+                _normalizationPropertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+            }\n+            else if (xmlReaderType != _normalizationPropertyInfo.ReflectedType)\n+            {\n+                Debug.Fail(\"GetNormalizationPropertyInfo can only take one type\");\n+                return xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+            }\n+            return _normalizationPropertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader;\n+            if (loadAsReadOnly)\n+            {\n+                XmlReaderSettings xrs = new XmlReaderSettings\n+                {\n+                    DtdProcessing = DtdProcessing.Ignore,\n+                    IgnoreComments = true,\n+                    IgnoreWhitespace = true,\n+                };\n+                reader = XmlReader.Create(input, xrs, uri);\n+                // HACK: Set Normalization to false to behave the same as XmlTextReader.\n+                GetNormalizationPropertyInfo(reader.GetType()).SetValue(reader, false);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Done, thank you!",
              "createdAt": "2021-04-23T12:27:41Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +73,44 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        private static volatile PropertyInfo _normalizationPropertyInfo;\n+\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+            if (_normalizationPropertyInfo == null)\n+            {\n+                _normalizationPropertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+            }\n+            else if (xmlReaderType != _normalizationPropertyInfo.ReflectedType)\n+            {\n+                Debug.Fail(\"GetNormalizationPropertyInfo can only take one type\");\n+                return xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+            }\n+            return _normalizationPropertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader;\n+            if (loadAsReadOnly)\n+            {\n+                XmlReaderSettings xrs = new XmlReaderSettings\n+                {\n+                    DtdProcessing = DtdProcessing.Ignore,\n+                    IgnoreComments = true,\n+                    IgnoreWhitespace = true,\n+                };\n+                reader = XmlReader.Create(input, xrs, uri);\n+                // HACK: Set Normalization to false to behave the same as XmlTextReader.\n+                GetNormalizationPropertyInfo(reader.GetType()).SetValue(reader, false);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Whenever one uses `volatile` one should add a comment explaining what is going on ;) ",
              "createdAt": "2021-04-23T21:27:21Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -26,6 +28,9 @@ internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)\n         private readonly Stream _stream;\n         private readonly StreamReader _streamReader;\n \n+        private static volatile PropertyInfo _normalizationPropertyInfo;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I wonder if explicitly calling `Volatile.Read` and `Volatile.Write` would make it more obvious. Comment added!",
              "createdAt": "2021-04-26T07:46:20Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -26,6 +28,9 @@ internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)\n         private readonly Stream _stream;\n         private readonly StreamReader _streamReader;\n \n+        private static volatile PropertyInfo _normalizationPropertyInfo;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You could also reuse the logic from the else branch if you just set reader back to null, and check if reader == null then instantiate the \"full\" reader at the end, instead of it being here and in the else branch. \r\n\r\nBut doesn't matter much so don't block on it.",
              "createdAt": "2021-04-23T21:30:08Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +76,59 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader;\n+            if (loadAsReadOnly && !_disableReadOnlyLoad)\n+            {\n+                // Create an XML reader with IgnoreComments and IgnoreWhitespace set if we know that we won't be asked\n+                // to write the DOM back to a file. This is a performance optimization.\n+                XmlReaderSettings xrs = new XmlReaderSettings\n+                {\n+                    DtdProcessing = DtdProcessing.Ignore,\n+                    IgnoreComments = true,\n+                    IgnoreWhitespace = true,\n+                };\n+                reader = XmlReader.Create(input, xrs, uri);\n+\n+                // Try to set Normalization to false. We do this to remain compatible with earlier versions of MSBuild\n+                // where we constructed the reader with 'new XmlTextReader()' which has normalization enabled by default.\n+                PropertyInfo normalizationPropertyInfo = GetNormalizationPropertyInfo(reader.GetType());\n+                if (normalizationPropertyInfo != null)\n+                {\n+                    normalizationPropertyInfo.SetValue(reader, false);\n+                }\n+                else\n+                {\n+                    // Fall back to using XmlTextReader if the prop could not be bound.\n+                    Debug.Fail(\"Could not set Normalization to false on the result of XmlReader.Create\");\n+                    _disableReadOnlyLoad = true;\n+\n+                    reader.Dispose();\n+                    reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Done as suggested, thank you.",
              "createdAt": "2021-04-26T07:46:59Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +76,59 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader;\n+            if (loadAsReadOnly && !_disableReadOnlyLoad)\n+            {\n+                // Create an XML reader with IgnoreComments and IgnoreWhitespace set if we know that we won't be asked\n+                // to write the DOM back to a file. This is a performance optimization.\n+                XmlReaderSettings xrs = new XmlReaderSettings\n+                {\n+                    DtdProcessing = DtdProcessing.Ignore,\n+                    IgnoreComments = true,\n+                    IgnoreWhitespace = true,\n+                };\n+                reader = XmlReader.Create(input, xrs, uri);\n+\n+                // Try to set Normalization to false. We do this to remain compatible with earlier versions of MSBuild\n+                // where we constructed the reader with 'new XmlTextReader()' which has normalization enabled by default.\n+                PropertyInfo normalizationPropertyInfo = GetNormalizationPropertyInfo(reader.GetType());\n+                if (normalizationPropertyInfo != null)\n+                {\n+                    normalizationPropertyInfo.SetValue(reader, false);\n+                }\n+                else\n+                {\n+                    // Fall back to using XmlTextReader if the prop could not be bound.\n+                    Debug.Fail(\"Could not set Normalization to false on the result of XmlReader.Create\");\n+                    _disableReadOnlyLoad = true;\n+\n+                    reader.Dispose();\n+                    reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd name it `settings`, `readerSettings` or `xmlReaderSettings`",
              "createdAt": "2021-04-23T21:30:53Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +76,59 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader;\n+            if (loadAsReadOnly && !_disableReadOnlyLoad)\n+            {\n+                // Create an XML reader with IgnoreComments and IgnoreWhitespace set if we know that we won't be asked\n+                // to write the DOM back to a file. This is a performance optimization.\n+                XmlReaderSettings xrs = new XmlReaderSettings",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Sounds good, `settings` it is.",
              "createdAt": "2021-04-26T07:46:43Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +76,59 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader;\n+            if (loadAsReadOnly && !_disableReadOnlyLoad)\n+            {\n+                // Create an XML reader with IgnoreComments and IgnoreWhitespace set if we know that we won't be asked\n+                // to write the DOM back to a file. This is a performance optimization.\n+                XmlReaderSettings xrs = new XmlReaderSettings",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "When I was on Roslyn we had a StyleCop rule that I liked, to leave an empty line after a closing curly in a statement. Now I see it everywhere :) Maybe I should propose an editorconfig change to add that, but I don't know if folks will like that.",
              "createdAt": "2021-04-23T21:31:59Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +76,59 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+            return propertyInfo;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2021-04-26T07:46:32Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +76,59 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+            return propertyInfo;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you need to pass this in as an argument? It's only called once, so you could replace its use with `typeof(XmlReader)`, right? It's private, so this doesn't really matter, but that would mean you could turn this into a property with a getter, which would be a little cleaner, and it would mean you couldn't accidentally call this with an invalid type, which would mean propertyInfo would be guaranteed not-null, and you could remove the debug else check below. (Keeping it isn't too bad, as it is good to know when your code is acting unexpectedly.) As a small side bonus, if you remove it, I don't think reader could be null, so you could replace `if (reader == null)` with `else`.",
              "createdAt": "2021-04-26T14:57:33Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Reading over your comments, is Normalization still not accessible on Core? That would make this hit the debug case fairly regularly, then, right?",
              "createdAt": "2021-04-26T14:58:35Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The object returned from `XmlReader.Create` is a BCL-internal subclass of `XmlReader`, so its type is different than `typeof(XmlReader)` and the property is not virtual.\r\n\r\n`Normalization` is available on Core, Framework, and Mono, so on all supported runtimes this code works today. The debug/assert is there to catch the unlikely regression where a runtime refactors its XML library and the property disappears.",
              "createdAt": "2021-04-26T19:11:50Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: why do you need to introduce a propertyInfo local variable as opposed to just modifying _normalizationPropertyInfo as relevant?",
              "createdAt": "2021-04-26T14:59:15Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's a volatile field so I want to access it only when I really need to to avoid unnecessary memory barriers.\r\n\r\n```C#\r\nif (_normalizationPropertyInfo == null)\r\n{\r\n  ..\r\n}\r\nreturn _normalizationPropertyInfo;\r\n```\r\n\r\nwould read the field twice on the fast path. The cost is small, limited to still rather exotic platforms, and negligible in the grand scheme of things, but a good practice anyway.\r\n\r\n(In retrospect, explicit `Volatile.Read` and `Volatile.Write` may have been a better choice for readability.)\r\n",
              "createdAt": "2021-04-26T19:01:26Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Because I'm paranoid and because the last change here broke customers, please add a changewave check here.",
              "createdAt": "2021-04-26T20:17:30Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader = null;\n+            if (loadAsReadOnly && !_disableReadOnlyLoad)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2021-04-27T08:20:00Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +83,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader = null;\n+            if (loadAsReadOnly && !_disableReadOnlyLoad)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "17.0 or 16.10? Right now it's going into 16.10 so I'd expect that, but your call.",
              "createdAt": "2021-04-27T14:11:41Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +84,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader = null;\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && loadAsReadOnly && !_disableReadOnlyLoad)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Apologies, I've been under the assumption our main is inserting into 17.0, unless the particular change makes the bar. If we can comfortably get it into 16.10 I'll update.",
              "createdAt": "2021-04-27T14:21:30Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +84,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader = null;\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && loadAsReadOnly && !_disableReadOnlyLoad)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Cutover is late this week, I think.",
              "createdAt": "2021-04-27T14:23:46Z",
              "path": "src/Build/Xml/XmlReaderExtension.cs",
              "diffHunk": "@@ -71,15 +84,61 @@ public void Dispose()\n             _stream?.Dispose();\n         }\n \n+        /// <summary>\n+        /// Returns <see cref=\"PropertyInfo\"/> of the \"Normalization\" internal property on the given <see cref=\"XmlReader\"/>-derived type.\n+        /// </summary>\n+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)\n+        {\n+            PropertyInfo propertyInfo = _normalizationPropertyInfo;\n+            if (propertyInfo == null)\n+            {\n+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;\n+                propertyInfo = xmlReaderType.GetProperty(\"Normalization\", bindingFlags);\n+                _normalizationPropertyInfo = propertyInfo;\n+            }\n+\n+            return propertyInfo;\n+        }\n+\n         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)\n         {\n             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();\n \n-            \n-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes\n-            // of attribute text, specifically newline removal.\n-            // https://github.com/Microsoft/msbuild/issues/4210\n-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };\n+            XmlReader reader = null;\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && loadAsReadOnly && !_disableReadOnlyLoad)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}