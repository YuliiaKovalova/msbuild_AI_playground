{
  "number": 5538,
  "title": "5513 refactor createmanifestresourcename",
  "body": "fixes #5513 ",
  "state": "MERGED",
  "createdAt": "2020-07-23T02:34:39Z",
  "updatedAt": "2023-01-03T06:53:12Z",
  "closedAt": "2020-07-31T17:22:28Z",
  "mergedAt": "2020-07-31T17:22:28Z",
  "additions": 70,
  "deletions": 74,
  "changedFiles": 3,
  "headRefName": "5513-refactor-createmanifestresourcename",
  "isDraft": false,
  "author": {
    "login": "elachlan"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "828e6d61be8f3b5fe98697b71229f470c3e99a0b",
          "message": "passing StringBuilder down the calls and converted to voids, with additional shortcut logic",
          "committedDate": "2020-07-23T02:25:48Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "c7cf69addc5216f0ea6f34876e6c08d61fbfd2be",
          "message": "use SourceFileExtension in IsSourceFile",
          "committedDate": "2020-07-23T02:33:04Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "f7705ba44ecee004b279e039abf93372bf09b469",
          "message": "changes from review",
          "committedDate": "2020-07-24T23:36:34Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "aee4da88b3c733d4c5178885f8127d19a603504e",
          "message": "Include ref file changes",
          "committedDate": "2020-07-24T23:40:44Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "f98660a7cd1244e907759585d686d221bff4c4c8",
          "message": "use character instead of string when appending, switch for string.equals, simplify String to string",
          "committedDate": "2020-07-25T02:08:01Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "ae024dedc467e5ef41a240a39dff1ac04ff935a5",
          "message": "revert public API changes, simplify some code",
          "committedDate": "2020-07-25T06:23:01Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "998eb063790a7054ef54207dbf84d8b08462e7fb",
          "message": "Simplify some code",
          "committedDate": "2020-07-25T06:23:13Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "0aa25de5f97eccd04609596bb5b5d3b8b65294a5",
          "message": "remove internal string builder in MakeValidEverettFolderIdentifier",
          "committedDate": "2020-07-25T07:52:08Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "66c825750c5c3d1d6211c39636a4bd292dd18d06",
          "message": "refactored to keep the same public API",
          "committedDate": "2020-07-25T08:44:29Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "e6294ca6578946299b7f5a8a138823219fb65ec6",
          "message": "small refactors to reduce complexity",
          "committedDate": "2020-07-25T22:35:49Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "53c9b2d974c1b97149d551e0f301f49ac79cb060",
          "message": "Small refactor to remove else branch",
          "committedDate": "2020-07-25T22:45:20Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "27d1340f4ac5b1957a2a3d436e6b81e4bee93baf",
          "message": "use constants for resource file extensions",
          "committedDate": "2020-07-26T02:21:39Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "6c6ee5ea22fc7b612b8a55e347f8319e2e0dabdf",
          "message": "API Changes",
          "committedDate": "2020-07-26T05:26:47Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "c1ca02e6d0a96bed4660090be5521975cf125fea",
          "message": "change to constants so no changes are made to public API",
          "committedDate": "2020-07-26T20:58:21Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "024a693530571ae742138a20d032ed06383b0925",
          "message": "changes from code review",
          "committedDate": "2020-07-28T01:44:31Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      },
      {
        "commit": {
          "oid": "911d2610c048e6b08b07e1402da1bdc62fc111e2",
          "message": "Changes from review",
          "committedDate": "2020-07-30T00:30:28Z",
          "author": {
            "name": "Lachlan Ennis",
            "email": "lachlan@expert1.com.au"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@Forgind I have gone and implemented the changes we talked about. Are you able to have a quick look?",
        "createdAt": "2020-07-24T02:41:33Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "[![CLA assistant check](https://cla.dotnetfoundation.org/pull/badge/signed)](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=5538) <br/>All CLA requirements met.",
        "createdAt": "2020-07-24T23:37:00Z",
        "author": {
          "login": "dnfadmin"
        }
      },
      {
        "body": "[![CLA assistant check](https://cla.dotnetfoundation.org/pull/badge/not_signed)](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=5538) <br/>Thank you for your submission, we really appreciate it. Like many open source projects, we ask that you sign our [Contributor License Agreement](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=5538) before we can accept your contribution.<br/><br/>:x: elachlan [sign now](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=5538)<br/><sub>You have signed the CLA already but the status is still pending? Let us [recheck](https://cla.dotnetfoundation.org/check/dotnet/msbuild?pullRequest=5538) it.</sub>",
        "createdAt": "2020-07-24T23:37:00Z",
        "author": {
          "login": "dnfadmin"
        }
      },
      {
        "body": "@BenVillalobos have you got any ideas on MakeValidEverettFolderIdentifier? I wasn't able to remove its string builder. As it checks its value at the bottom for a single underscore. I think we would have to get a substring to do it, which might be worse performance than just having the string builder.",
        "createdAt": "2020-07-24T23:47:18Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "Also are there any guidelines on when to use MSBuildConstants? there are dots and underscore characters everywhere and I am wondering if they should use the constants.",
        "createdAt": "2020-07-25T01:00:20Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "Also maybe it would help to have constants for \".resx\" and the like?",
        "createdAt": "2020-07-25T01:02:06Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "I think the build failures are caused by the Public API not matching the methods in CreateManifestResourceName.",
        "createdAt": "2020-07-25T08:36:51Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "One change we should maybe look at is Execute:\r\nhttps://github.com/dotnet/msbuild/blob/e8338f5ad91d42c3196218648859e9e837099842/src/Tasks/CreateManifestResourceName.cs#L114-L256\r\n\r\nIt has a for each loop and makes the call to CreateManifestName, which in turn calls the associated CreateManifestNameImpl. I think it would be more performant if we can pass a string builder down through there and avoid a string builder creation within the for loop. We would just call StringBuilder.Clear() at the end of each iteration.",
        "createdAt": "2020-07-25T22:58:25Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "I don't think we can change the signature of CreateManifestName, since that could theoretically be a breaking change, although I find it hard to imagine anyone actually relies on that. It might be safer (and easier) to define a constant StringBuilder at the top of the file and reuse it between calls. On the other hand, that makes me start to wonder if it's overoptimizing\u2014do you know how often this code runs? Meaning how much would reusing the StringBuilder improve overall build performance for the average user?",
        "createdAt": "2020-07-26T01:58:37Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> I don't think we can change the signature of CreateManifestName, since that could theoretically be a breaking change, although I find it hard to imagine anyone actually relies on that. It might be safer (and easier) to define a constant StringBuilder at the top of the file and reuse it between calls. On the other hand, that makes me start to wonder if it's overoptimizing\u2014do you know how often this code runs? Meaning how much would reusing the StringBuilder improve overall build performance for the average user?\r\n\r\nI think you are correct on over-optimising. I'd imagine the code gets run once per embedded resource, and that wouldn't make much difference as the majority of the work would be in compilation or something along those lines.\r\n\r\nMaybe it can be optimised at a later date. There are probably other areas that need it more.",
        "createdAt": "2020-07-26T02:09:25Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "Should the const values be marked as internal? That way they don't change the Public API?",
        "createdAt": "2020-07-26T05:29:08Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "> Should the const values be marked as internal? That way they don't change the Public API?\r\n\r\nYes, that would be good.\r\n\r\nThe current failure is unrelated to you, by the way. It's #5520.",
        "createdAt": "2020-07-26T15:38:31Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> Thank you @elachlan for the PR! I have added a couple of comments inline.\r\n> \r\n> Do you think it would make sense to add a unit test to verify that `MakeValidEverettIdentifier()` behaves the same with your changes?\r\n\r\nI have made the changes you asked for. I don't know much about msbuild and how its unit tested to be honest. I might have to leave the tests to someone more knowledgeable than myself.",
        "createdAt": "2020-07-30T00:33:26Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "> I have made the changes you asked for. I don't know much about msbuild and how its unit tested to be honest. I might have to leave the tests to someone more knowledgeable than myself.\r\n\r\nThank you. The code you have refactored appears to be well covered by `CreateCSharpManifestResourceName_Tests` and `CreateVisualBasicManifestResourceName_Tests`, specifically with `Regress311473()` in the former. So a new unit test is not required.",
        "createdAt": "2020-07-30T12:34:13Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2020-07-30T12:34:42Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nNo pipelines are associated with this pull request.<br>\r\n\n</samp>",
        "createdAt": "2020-07-30T12:34:48Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "Thanks!",
        "createdAt": "2020-07-31T17:22:35Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: while you're here, you might as well make this a `String.Equals`",
              "createdAt": "2020-07-24T16:15:34Z",
              "path": "src/Tasks/CreateCSharpManifestResourceName.cs",
              "diffHunk": "@@ -206,7 +219,7 @@ TaskLoggingHelper log\n         protected override bool IsSourceFile(string fileName)\n         {\n             string extension = Path.GetExtension(fileName);\n-            return (String.Compare(extension, \".cs\", StringComparison.OrdinalIgnoreCase) == 0);\n+            return (String.Compare(extension, SourceFileExtension, StringComparison.OrdinalIgnoreCase) == 0);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `string` instead of `var`\r\n\r\nextra nit: setting directory name needs to happen regardless of which branch it goes down, why not bring it out? Same goes for calling MakeValidEverettIdentifier.",
              "createdAt": "2020-07-24T16:33:12Z",
              "path": "src/Tasks/CreateCSharpManifestResourceName.cs",
              "diffHunk": "@@ -177,7 +181,16 @@ TaskLoggingHelper log\n                 }\n                 else\n                 {\n-                    manifestName.Append(Path.Combine(everettCompatibleDirectoryName, Path.GetFileName(info.cultureNeutralFilename)));\n+                    var directoryName = Path.GetDirectoryName(info.cultureNeutralFilename);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should we just have a base case that returns on an empty `name`?",
              "createdAt": "2020-07-24T22:35:00Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -375,32 +373,31 @@ internal static string MakeValidEverettFolderIdentifier(string name)\n                 everettId.Append('_');\n             }\n \n-            return everettId.ToString();\n+            builder.Append(everettId.ToString());\n         }\n \n         /// <summary>\n         /// This method is provided for compatibility with Everett which used to convert parts of resource names into\n         /// valid identifiers\n         /// </summary>\n-        public static string MakeValidEverettIdentifier(string name)\n+        public static void MakeValidEverettIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            var everettId = new StringBuilder(name.Length);\n-\n             // split the name into folder names\n             string[] subNames = name.Split(MSBuildConstants.ForwardSlashBackslash);\n \n             // convert every folder name\n-            everettId.Append(MakeValidEverettFolderIdentifier(subNames[0]));\n+            if (!string.IsNullOrEmpty(subNames[0]))",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we should change the public API surface in this way, since there are likely people who rely on MakeValidEverettIdentifier working exactly as it has previously. Also, it looks a little strange to me to reveal a StringBuilder as part of a public method.",
              "createdAt": "2020-07-25T05:31:47Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -226,7 +226,7 @@ public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks\n         protected abstract string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream);\n         public override bool Execute() { throw null; }\n         protected abstract bool IsSourceFile(string fileName);\n-        public static string MakeValidEverettIdentifier(string name) { throw null; }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You still need to append this, right?",
              "createdAt": "2020-07-25T05:33:29Z",
              "path": "src/Tasks/CreateCSharpManifestResourceName.cs",
              "diffHunk": "@@ -139,25 +139,32 @@ TaskLoggingHelper log\n                 // Empty namespaces are allowed.\n                 if (!string.IsNullOrEmpty(rootNamespace))\n                 {\n-                    manifestName.Append(rootNamespace).Append(\".\");\n+                    manifestName.Append(rootNamespace).Append('.');\n                 }\n \n-                // Replace spaces in the directory name with underscores. Needed for compatibility with Everett.\n-                // Note that spaces in the file name itself are preserved.\n-                string everettCompatibleDirectoryName = MakeValidEverettIdentifier(Path.GetDirectoryName(info.cultureNeutralFilename));\n-\n                 // only strip extension for .resx and .restext files\n-\n                 string sourceExtension = Path.GetExtension(info.cultureNeutralFilename);\n+                string directoryName = Path.GetDirectoryName(info.cultureNeutralFilename);\n+\n+                // append the directory name\n+                MakeValidEverettIdentifier(manifestName, directoryName);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                    if (!string.IsNullOrEmpty(directoryName))\r\n                    {\r\n                        manifestName.Append('.');\r\n                    }\r\n     \r\n                    manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));\r\n```\r\n? Same below.",
              "createdAt": "2020-07-25T05:39:47Z",
              "path": "src/Tasks/CreateCSharpManifestResourceName.cs",
              "diffHunk": "@@ -139,25 +139,32 @@ TaskLoggingHelper log\n                 // Empty namespaces are allowed.\n                 if (!string.IsNullOrEmpty(rootNamespace))\n                 {\n-                    manifestName.Append(rootNamespace).Append(\".\");\n+                    manifestName.Append(rootNamespace).Append('.');\n                 }\n \n-                // Replace spaces in the directory name with underscores. Needed for compatibility with Everett.\n-                // Note that spaces in the file name itself are preserved.\n-                string everettCompatibleDirectoryName = MakeValidEverettIdentifier(Path.GetDirectoryName(info.cultureNeutralFilename));\n-\n                 // only strip extension for .resx and .restext files\n-\n                 string sourceExtension = Path.GetExtension(info.cultureNeutralFilename);\n+                string directoryName = Path.GetDirectoryName(info.cultureNeutralFilename);\n+\n+                // append the directory name\n+                MakeValidEverettIdentifier(manifestName, directoryName);\n                 if (\n-                        (0 == String.Compare(sourceExtension, \".resx\", StringComparison.OrdinalIgnoreCase))\n+                        string.Equals(sourceExtension, \".resx\", StringComparison.OrdinalIgnoreCase)\n                         ||\n-                        (0 == String.Compare(sourceExtension, \".restext\", StringComparison.OrdinalIgnoreCase))\n+                        string.Equals(sourceExtension, \".restext\", StringComparison.OrdinalIgnoreCase)\n                         ||\n-                        (0 == String.Compare(sourceExtension, \".resources\", StringComparison.OrdinalIgnoreCase))\n+                        string.Equals(sourceExtension, \".resources\", StringComparison.OrdinalIgnoreCase)\n                     )\n                 {\n-                    manifestName.Append(Path.Combine(everettCompatibleDirectoryName, Path.GetFileNameWithoutExtension(info.cultureNeutralFilename)));\n+\n+                    if (!string.IsNullOrEmpty(directoryName))\n+                    {\n+                        manifestName.Append('.').Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));\n+                    }\n+                    else\n+                    {\n+                        manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));\n+                    }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there any reason you need the else?",
              "createdAt": "2020-07-25T05:43:24Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you need this else?",
              "createdAt": "2020-07-25T05:46:36Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);\n \n-            // split folder name into subnames separated by '.', if any\n-            string[] subNames = name.Split(MSBuildConstants.DotChar);\n+                // split folder name into subnames separated by '.', if any\n+                string[] subNames = name.Split(MSBuildConstants.DotChar);\n \n-            // convert each subname separately\n-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));\n+                // convert each subname separately\n+                if (!string.IsNullOrEmpty(subNames[0]))\n+                {\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[0]);\n+                }\n \n-            for (int i = 1; i < subNames.Length; i++)\n-            {\n-                everettId.Append('.');\n-                everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[i]));\n-            }\n+                for (int i = 1; i < subNames.Length; i++)\n+                {\n+                    everettId.Append('.');\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[i]);\n+                }\n+\n+                // folder name cannot be a single underscore - add another underscore to it\n+                if (string.Equals(everettId.ToString(), \"_\"))\n+                {\n+                    everettId.Append('_');\n+                }\n \n-            // folder name cannot be a single underscore - add another underscore to it\n-            if (everettId.ToString() == \"_\")\n+                builder.Append(everettId.ToString());\n+            }\n+            else\n             {\n-                everettId.Append('_');\n+                return;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why make everettId when you're just appending it to builder? In other words, can you just append things to builder instead?\r\n\r\nYou mentioned needing to check if it's a single underscore. I'd do this:\r\n`if (builder.Length == 1 && builder.ToString().Equals(\"_\"))`",
              "createdAt": "2020-07-25T05:47:25Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Doing this breaks the tests, as its not comparing the whole path, but just the specific folder.",
              "createdAt": "2020-07-25T06:33:10Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "I think we can grab the length as the start and then use a substring or something.",
              "createdAt": "2020-07-25T06:33:54Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Good idea",
              "createdAt": "2020-07-25T16:39:34Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nYou have this check at the top of that function, so you don't need to do it here, too.",
              "createdAt": "2020-07-25T05:49:51Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);\n \n-            // split folder name into subnames separated by '.', if any\n-            string[] subNames = name.Split(MSBuildConstants.DotChar);\n+                // split folder name into subnames separated by '.', if any\n+                string[] subNames = name.Split(MSBuildConstants.DotChar);\n \n-            // convert each subname separately\n-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));\n+                // convert each subname separately\n+                if (!string.IsNullOrEmpty(subNames[0]))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This does an allocation. Looking at its length and (possibly) the first character would be more efficient.",
              "createdAt": "2020-07-25T05:50:59Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);\n \n-            // split folder name into subnames separated by '.', if any\n-            string[] subNames = name.Split(MSBuildConstants.DotChar);\n+                // split folder name into subnames separated by '.', if any\n+                string[] subNames = name.Split(MSBuildConstants.DotChar);\n \n-            // convert each subname separately\n-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));\n+                // convert each subname separately\n+                if (!string.IsNullOrEmpty(subNames[0]))\n+                {\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[0]);\n+                }\n \n-            for (int i = 1; i < subNames.Length; i++)\n-            {\n-                everettId.Append('.');\n-                everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[i]));\n-            }\n+                for (int i = 1; i < subNames.Length; i++)\n+                {\n+                    everettId.Append('.');\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[i]);\n+                }\n+\n+                // folder name cannot be a single underscore - add another underscore to it\n+                if (string.Equals(everettId.ToString(), \"_\"))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nAgain, don't need this check",
              "createdAt": "2020-07-25T05:52:56Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);\n \n-            // split folder name into subnames separated by '.', if any\n-            string[] subNames = name.Split(MSBuildConstants.DotChar);\n+                // split folder name into subnames separated by '.', if any\n+                string[] subNames = name.Split(MSBuildConstants.DotChar);\n \n-            // convert each subname separately\n-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));\n+                // convert each subname separately\n+                if (!string.IsNullOrEmpty(subNames[0]))\n+                {\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[0]);\n+                }\n \n-            for (int i = 1; i < subNames.Length; i++)\n-            {\n-                everettId.Append('.');\n-                everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[i]));\n-            }\n+                for (int i = 1; i < subNames.Length; i++)\n+                {\n+                    everettId.Append('.');\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[i]);\n+                }\n+\n+                // folder name cannot be a single underscore - add another underscore to it\n+                if (string.Equals(everettId.ToString(), \"_\"))\n+                {\n+                    everettId.Append('_');\n+                }\n \n-            // folder name cannot be a single underscore - add another underscore to it\n-            if (everettId.ToString() == \"_\")\n+                builder.Append(everettId.ToString());\n+            }\n+            else\n             {\n-                everettId.Append('_');\n+                return;\n             }\n-\n-            return everettId.ToString();\n         }\n \n         /// <summary>\n         /// This method is provided for compatibility with Everett which used to convert parts of resource names into\n         /// valid identifiers\n         /// </summary>\n-        public static string MakeValidEverettIdentifier(string name)\n+        public static void MakeValidEverettIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // split the name into folder names\n+                string[] subNames = name.Split(MSBuildConstants.ForwardSlashBackslash);\n \n-            var everettId = new StringBuilder(name.Length);\n-\n-            // split the name into folder names\n-            string[] subNames = name.Split(MSBuildConstants.ForwardSlashBackslash);\n-\n-            // convert every folder name\n-            everettId.Append(MakeValidEverettFolderIdentifier(subNames[0]));\n+                // convert every folder name\n+                if (!string.IsNullOrEmpty(subNames[0]))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "To clarify what I said earlier about changing the public API surface, I support changing the other methods' signatures as you did, since that means we can allocate fewer strings, making these functions more efficient overall. This is the only one I'd change and mostly because someone in the past decided to make it string --> string, not because what you made it instead is intrinsically bad.",
              "createdAt": "2020-07-25T05:55:08Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,111 +296,121 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_');\n+                        builder.Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n+            else\n+            {\n+                return;\n+            }\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))\n+            {\n+                // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n+                // original - if the name is a single underscore we add another underscore to it\n+                var everettId = new StringBuilder(name.Length + 1);\n \n-            // split folder name into subnames separated by '.', if any\n-            string[] subNames = name.Split(MSBuildConstants.DotChar);\n+                // split folder name into subnames separated by '.', if any\n+                string[] subNames = name.Split(MSBuildConstants.DotChar);\n \n-            // convert each subname separately\n-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));\n+                // convert each subname separately\n+                if (!string.IsNullOrEmpty(subNames[0]))\n+                {\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[0]);\n+                }\n \n-            for (int i = 1; i < subNames.Length; i++)\n-            {\n-                everettId.Append('.');\n-                everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[i]));\n-            }\n+                for (int i = 1; i < subNames.Length; i++)\n+                {\n+                    everettId.Append('.');\n+                    MakeValidEverettSubFolderIdentifier(everettId, subNames[i]);\n+                }\n+\n+                // folder name cannot be a single underscore - add another underscore to it\n+                if (string.Equals(everettId.ToString(), \"_\"))\n+                {\n+                    everettId.Append('_');\n+                }\n \n-            // folder name cannot be a single underscore - add another underscore to it\n-            if (everettId.ToString() == \"_\")\n+                builder.Append(everettId.ToString());\n+            }\n+            else\n             {\n-                everettId.Append('_');\n+                return;\n             }\n-\n-            return everettId.ToString();\n         }\n \n         /// <summary>\n         /// This method is provided for compatibility with Everett which used to convert parts of resource names into\n         /// valid identifiers\n         /// </summary>\n-        public static string MakeValidEverettIdentifier(string name)\n+        public static void MakeValidEverettIdentifier(StringBuilder builder, string name)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "last nit:\r\n```suggestion\r\n                    if (!string.IsNullOrEmpty(directoryName))\r\n                    {\r\n                        manifestName.Append('.');\r\n                    }\r\n                    \r\n                    manifestName.Append(Path.GetFileName(info.cultureNeutralFilename));\r\n```",
              "createdAt": "2020-07-25T16:38:16Z",
              "path": "src/Tasks/CreateCSharpManifestResourceName.cs",
              "diffHunk": "@@ -166,18 +171,25 @@ TaskLoggingHelper log\n                     // Append the culture if there is one.        \n                     if (!string.IsNullOrEmpty(info.culture))\n                     {\n-                        manifestName.Append(\".\").Append(info.culture);\n+                        manifestName.Append('.').Append(info.culture);\n                     }\n \n                     // If the original extension was .resources, add it back\n-                    if (String.Equals(sourceExtension, \".resources\", StringComparison.OrdinalIgnoreCase))\n+                    if (string.Equals(sourceExtension, \".resources\", StringComparison.OrdinalIgnoreCase))\n                     {\n                         manifestName.Append(sourceExtension);\n                     }\n                 }\n                 else\n                 {\n-                    manifestName.Append(Path.Combine(everettCompatibleDirectoryName, Path.GetFileName(info.cultureNeutralFilename)));\n+                    if (!string.IsNullOrEmpty(directoryName))\n+                    {\n+                        manifestName.Append('.').Append(Path.GetFileName(info.cultureNeutralFilename));\n+                    }\n+                    else\n+                    {\n+                        manifestName.Append(Path.GetFileName(info.cultureNeutralFilename));\n+                    }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks. I have made the change.",
              "createdAt": "2020-07-25T22:39:00Z",
              "path": "src/Tasks/CreateCSharpManifestResourceName.cs",
              "diffHunk": "@@ -166,18 +171,25 @@ TaskLoggingHelper log\n                     // Append the culture if there is one.        \n                     if (!string.IsNullOrEmpty(info.culture))\n                     {\n-                        manifestName.Append(\".\").Append(info.culture);\n+                        manifestName.Append('.').Append(info.culture);\n                     }\n \n                     // If the original extension was .resources, add it back\n-                    if (String.Equals(sourceExtension, \".resources\", StringComparison.OrdinalIgnoreCase))\n+                    if (string.Equals(sourceExtension, \".resources\", StringComparison.OrdinalIgnoreCase))\n                     {\n                         manifestName.Append(sourceExtension);\n                     }\n                 }\n                 else\n                 {\n-                    manifestName.Append(Path.Combine(everettCompatibleDirectoryName, Path.GetFileName(info.cultureNeutralFilename)));\n+                    if (!string.IsNullOrEmpty(directoryName))\n+                    {\n+                        manifestName.Append('.').Append(Path.GetFileName(info.cultureNeutralFilename));\n+                    }\n+                    else\n+                    {\n+                        manifestName.Append(Path.GetFileName(info.cultureNeutralFilename));\n+                    }",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Code styling nit: I couldn't find anything specific over at the [coding style document](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md) we refer to in our contributing guide, but I suggest turning this into something like `if(string.IsNullOrEmpty(name)) { return; }` to avoid nesting.",
              "createdAt": "2020-07-28T00:19:21Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,86 +299,77 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))\n             {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n-\n-            // the first character has stronger restrictions than the rest\n-            if (!IsValidEverettIdFirstChar(subName[0]))\n-            {\n-                // if the first character is not even a valid subsequent character, replace it with an underscore\n-                if (!IsValidEverettIdChar(subName[0]))\n+                // the first character has stronger restrictions than the rest\n+                if (!IsValidEverettIdFirstChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    // if the first character is not even a valid subsequent character, replace it with an underscore\n+                    if (!IsValidEverettIdChar(subName[0]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    // if it is a valid subsequent character, prepend an underscore to it\n+                    else\n+                    {\n+                        builder.Append('_').Append(subName[0]);\n+                    }\n                 }\n-                // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append(subName[0]);\n                 }\n-            }\n-            else\n-            {\n-                everettId.Append(subName[0]);\n-            }\n \n-            // process the rest of the subname\n-            for (int i = 1; i < subName.Length; i++)\n-            {\n-                if (!IsValidEverettIdChar(subName[i]))\n+                // process the rest of the subname\n+                for (int i = 1; i < subName.Length; i++)\n                 {\n-                    everettId.Append('_');\n-                }\n-                else\n-                {\n-                    everettId.Append(subName[i]);\n+                    if (!IsValidEverettIdChar(subName[i]))\n+                    {\n+                        builder.Append('_');\n+                    }\n+                    else\n+                    {\n+                        builder.Append(subName[i]);\n+                    }\n                 }\n             }\n-\n-            return everettId.ToString();\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            if (!string.IsNullOrEmpty(name))",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same as below.",
              "createdAt": "2020-07-28T00:19:30Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,86 +299,77 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n+            if (!string.IsNullOrEmpty(subName))",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "with respect to my other nits, have our \"base case\" come first and return. Followed by all code that would run under normal circumstances\r\n\r\n```suggestion\r\n            if (string.IsNullOrEmpty(name))\r\n            {\r\n                   return name;\r\n            }\r\n            \r\n            <rest of code goes here with no else>\r\n```\r\n",
              "createdAt": "2020-07-28T00:23:54Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -385,22 +379,28 @@ internal static string MakeValidEverettFolderIdentifier(string name)\n         public static string MakeValidEverettIdentifier(string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n+            if (!string.IsNullOrEmpty(name))",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This comment does not apply anymore.",
              "createdAt": "2020-07-29T12:52:48Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,86 +299,75 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n-            {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n+            if (string.IsNullOrEmpty(subName)) { return; }\n \n             // the first character has stronger restrictions than the rest\n             if (!IsValidEverettIdFirstChar(subName[0]))\n             {\n                 // if the first character is not even a valid subsequent character, replace it with an underscore\n                 if (!IsValidEverettIdChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    builder.Append('_');\n                 }\n                 // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append('_').Append(subName[0]);\n                 }\n             }\n             else\n             {\n-                everettId.Append(subName[0]);\n+                builder.Append(subName[0]);\n             }\n \n             // process the rest of the subname\n             for (int i = 1; i < subName.Length; i++)\n             {\n                 if (!IsValidEverettIdChar(subName[i]))\n                 {\n-                    everettId.Append('_');\n+                    builder.Append('_');\n                 }\n                 else\n                 {\n-                    everettId.Append(subName[i]);\n+                    builder.Append(subName[i]);\n                 }\n             }\n-\n-            return everettId.ToString();\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n+            if (string.IsNullOrEmpty(name)) { return; }\n+\n             // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Index into the `StringBuilder` instead of calling `ToString()` to avoid allocating a string:\r\n\r\n```suggestion\r\n            if ((builder.Length - length) == 1 && builder[length] == '_')\r\n```",
              "createdAt": "2020-07-29T12:56:28Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,86 +299,75 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n-            {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n+            if (string.IsNullOrEmpty(subName)) { return; }\n \n             // the first character has stronger restrictions than the rest\n             if (!IsValidEverettIdFirstChar(subName[0]))\n             {\n                 // if the first character is not even a valid subsequent character, replace it with an underscore\n                 if (!IsValidEverettIdChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    builder.Append('_');\n                 }\n                 // if it is a valid subsequent character, prepend an underscore to it\n                 else\n                 {\n-                    everettId.Append('_');\n-                    everettId.Append(subName[0]);\n+                    builder.Append('_').Append(subName[0]);\n                 }\n             }\n             else\n             {\n-                everettId.Append(subName[0]);\n+                builder.Append(subName[0]);\n             }\n \n             // process the rest of the subname\n             for (int i = 1; i < subName.Length; i++)\n             {\n                 if (!IsValidEverettIdChar(subName[i]))\n                 {\n-                    everettId.Append('_');\n+                    builder.Append('_');\n                 }\n                 else\n                 {\n-                    everettId.Append(subName[i]);\n+                    builder.Append(subName[i]);\n                 }\n             }\n-\n-            return everettId.ToString();\n         }\n \n         /// <summary>\n         /// Make a folder name into an Everett-compatible identifier\n         /// </summary>\n-        internal static string MakeValidEverettFolderIdentifier(string name)\n+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));\n \n+            if (string.IsNullOrEmpty(name)) { return; }\n+\n             // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n             // original - if the name is a single underscore we add another underscore to it\n-            var everettId = new StringBuilder(name.Length + 1);\n+            int length = builder.Length;\n \n             // split folder name into subnames separated by '.', if any\n             string[] subNames = name.Split(MSBuildConstants.DotChar);\n \n             // convert each subname separately\n-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));\n+            MakeValidEverettSubFolderIdentifier(builder, subNames[0]);\n \n             for (int i = 1; i < subNames.Length; i++)\n             {\n-                everettId.Append('.');\n-                everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[i]));\n+                builder.Append('.');\n+                MakeValidEverettSubFolderIdentifier(builder, subNames[i]);\n             }\n \n             // folder name cannot be a single underscore - add another underscore to it\n-            if (everettId.ToString() == \"_\")\n+            if ((builder.Length - length) == 1 && builder.ToString(length, builder.Length - length).StartsWith(\"_\"))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can do this before the `if` and have no `else' because it's common to both code paths.",
              "createdAt": "2020-07-29T12:59:51Z",
              "path": "src/Tasks/CreateManifestResourceName.cs",
              "diffHunk": "@@ -296,86 +299,75 @@ private static bool IsValidEverettIdChar(char c)\n         /// <summary>\n         /// Make a folder subname into an Everett-compatible identifier \n         /// </summary>\n-        private static string MakeValidEverettSubFolderIdentifier(string subName)\n+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));\n \n-            if (subName.Length == 0)\n-            {\n-                return subName;\n-            }\n-\n-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the\n-            // original - if the first character is an invalid first identifier character but a valid subsequent one,\n-            // we prepend an underscore to it.\n-            var everettId = new StringBuilder(subName.Length + 1);\n+            if (string.IsNullOrEmpty(subName)) { return; }\n \n             // the first character has stronger restrictions than the rest\n             if (!IsValidEverettIdFirstChar(subName[0]))\n             {\n                 // if the first character is not even a valid subsequent character, replace it with an underscore\n                 if (!IsValidEverettIdChar(subName[0]))\n                 {\n-                    everettId.Append('_');\n+                    builder.Append('_');",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}