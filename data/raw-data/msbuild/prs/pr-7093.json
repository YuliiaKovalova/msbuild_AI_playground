{
  "number": 7093,
  "title": "Improve string builder caches",
  "body": "Fixes #2697\r\n\r\n### Context\r\nSee [#2697](https://github.com/dotnet/msbuild/issues/2697#issuecomment-981140614)\r\n\r\n### Changes Made\r\n- ReuseableStringBuilder bracketed SB allocating\r\n  - SB is allocated with capacity bracketed to upper power of 2 bytes = 2^n where n = upper(log2(capacity)).\r\n  - When SB is returning and its capacity has increased it indicates that bigger SB was needed. Returning SB is abandoned and new SB, with capacity upper bounded to 2^n bytes based on returning capacity, is created and used as shared instance. Prove of past needs is used as prediction of future.\r\n  - When SB cross upper limit of 1M chars, it is abandoned, and new SB is created by next `new ReuseableStringBuilder`.\r\n  - This changes results into:\r\n     - Low ephemeral memory segments allocation - max log2(max) allocations\r\n     - Low LOH fragmentation - max log2(max) allocations\r\n     - Normal verbosity allocates about same as before\r\n     - Allocation traffic during diag verbosity file loggers was measured as ~-14%\r\n       ![image](https://user-images.githubusercontent.com/25249058/143879545-adc08239-3575-4d9f-ae6e-3f55c10dc58c.png)\r\n- ReuseableStringBuilder debug only ETW instrumentation. I have deleted old statistics as I have found new ETW more usable.\r\n- StringBuilderCache debug only ETW instrumentation.\r\n- ReuseableStringBuilder and StringBuilderCache  moved from Shared into Framework.\r\n- Change StringBuilderCache max size limit.\r\n\r\n### Testing\r\nLocal testing and measurements.\r\n\r\n### Notes\r\n- Bracketing capacity into 2^n bytes was inspired by ArrayPool<T> and \"Writing High-Performance .NET Code\" book.\r\n- We shall consider to use SpanBasedStringBuilders in most places as replacements for ReuseableStringBuilder and StringBuilderCache.",
  "state": "MERGED",
  "createdAt": "2021-11-29T14:05:58Z",
  "updatedAt": "2021-12-02T16:30:57Z",
  "closedAt": "2021-12-02T16:30:41Z",
  "mergedAt": "2021-12-02T16:30:40Z",
  "additions": 416,
  "deletions": 352,
  "changedFiles": 14,
  "headRefName": "rokonec/2697-improve-reusable-sb-factory",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a975e655594f254a5d77b016bb6f9fb72fc9904f",
          "message": "Temporary ETWs",
          "committedDate": "2021-11-25T10:36:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8954c9a18375c79075f2b2821c9d0e9b04db96c3",
          "message": "Set work aside",
          "committedDate": "2021-11-25T10:36:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2dbda742a4fc909db8dc3ef93cde61b518e63e06",
          "message": "Enlarge ReusableStringBuilderFactory limits and slightly change logic.",
          "committedDate": "2021-11-25T10:36:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9ea16234501cae6c2a40309eac10d1bc32a1d28d",
          "message": "Move string builder caches into Framework",
          "committedDate": "2021-11-25T10:48:08Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "176527e83d2033671e2b00571b74b2e98aa50f1f",
          "message": "Finish moving ReuseableStringBuilder into framework",
          "committedDate": "2021-11-25T11:05:22Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "024aba447e7443e73d39701af05288b6e5da67f3",
          "message": "Capacity bracketing",
          "committedDate": "2021-11-25T20:25:29Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f78ddd47b5aa3b0cdb2205f2b1489a076ab95460",
          "message": "Removing files from shared",
          "committedDate": "2021-11-25T21:29:56Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8fcec62aef114fd0cad3b2f88e22d29514739561",
          "message": "Minor changes in  StringBuilderCache",
          "committedDate": "2021-11-25T21:47:41Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed763f9b6673e9c4ee75fa5c33afb720e1db8951",
          "message": "Enlarge StrignBuilderCache MAX_BUILDER_SIZE to 512",
          "committedDate": "2021-11-26T14:36:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6eae7def24f7dec4eb09b414043a8f9b4d659858",
          "message": "ReuseableStringBuilder balance diagnostics",
          "committedDate": "2021-11-26T14:42:26Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "51d30e2cdea616c4e4815a568812889a04da5ede",
          "message": "Using ReusableStringBuilder in ConsoleOutputAligner",
          "committedDate": "2021-11-26T15:14:42Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "312540062b4218aa0eca60a101d7ac4e18ad9633",
          "message": "Dissable balance asserting.",
          "committedDate": "2021-11-29T09:38:11Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "47508ab47305b814ca2e1e77e09db97258b5d50d",
          "message": "Rename ETW event",
          "committedDate": "2021-11-29T12:27:08Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a17799168ea7074bae98e5b74283259189372230",
          "message": "Revert: Using ReusableStringBuilder in ConsoleOutputAligner",
          "committedDate": "2021-11-29T12:49:08Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8cedfdb4ff17ced1358dd0ecbd58616bae111efc",
          "message": "Change StringBuilderCache max limit",
          "committedDate": "2021-11-29T12:55:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8470a1f036ce99b21d51f4f53c171363084ed5e3",
          "message": "Disable StringBuilderCache assert ballance",
          "committedDate": "2021-11-29T14:23:34Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "da9c97f820960ab1f8d8e13d65229b011f89a1c4",
          "message": "Enable StringBuilderCache balance asserting",
          "committedDate": "2021-11-30T22:33:33Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80b3ab1da3a4743e20be499e1a45d0def34454a9",
          "message": "Comments in StringBuilderCache",
          "committedDate": "2021-12-01T13:50:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c262060bc91be327ea9e0c4b5840c73a88a1ce2",
          "message": "Imrove comments",
          "committedDate": "2021-12-01T14:22:06Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3db14b700f088dbfbb7b26caceeb3481ac961d18",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\nCo-authored-by: Drew Noakes <git@drewnoakes.com>\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2021-12-01T14:28:39Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59da9c08bec8c126e391a5de81936fc589e490dc",
          "message": "nullable enable",
          "committedDate": "2021-12-01T14:51:45Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b276fdabb618dba7f2e3733ec37c48d856f31ac",
          "message": "Merge branch 'rokonec/2697-improve-reusable-sb-factory' of https://github.com/rokonec/msbuild into rokonec/2697-improve-reusable-sb-factory",
          "committedDate": "2021-12-01T14:51:53Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43d7df90b50e7b876c368b87a227012854ea5d71",
          "message": "Make sure borrowed string builder can not be used after Release",
          "committedDate": "2021-12-01T15:14:40Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a3341791f450c53a40365b751071cfacc06ceb1",
          "message": "Modified SelectBracketedCapacity by Drew comment.",
          "committedDate": "2021-12-01T15:56:08Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4fd193517443d34e551126172992b77c381b5769",
          "message": "Commenting ETW",
          "committedDate": "2021-12-01T17:23:14Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "58ac763f440379c1370f18c260cc2d77b8c9d5a4",
          "message": "Comment typo",
          "committedDate": "2021-12-01T17:30:34Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "103abfd44bcfde86c7d237d5d1ef1949c66d9114",
          "message": "VerifyThrowInternalNull meesage",
          "committedDate": "2021-12-02T09:41:58Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Why move this line? Doesn't this mean you're essentially deallocating t_cachedInstance if it's not null but smaller than capacity?",
              "createdAt": "2021-11-29T15:20:21Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +55,44 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It was moved so line 88 works. There is no point to keep it in thread static variable because this SB is doomed anyway as it will be replaced by Release before anything would have chance to use it.",
              "createdAt": "2021-11-30T19:43:42Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +55,44 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "95%ile of what?",
              "createdAt": "2021-11-29T21:18:46Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -31,17 +31,21 @@\n **\n ===========================================================*/\n \n+//#define ASSERT_BALANCE\n+\n using System;\n+using System.Diagnostics;\n using System.Text;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+using Microsoft.Build.Eventing;\n+#endif\n \n-namespace Microsoft.Build.Shared\n+namespace Microsoft.Build.Framework\n {\n     internal static class StringBuilderCache\n     {\n-        // The value 360 was chosen in discussion with performance experts as a compromise between using\n-        // as little memory (per thread) as possible and still covering a large part of short-lived\n-        // StringBuilder creations on the startup path of VS designers.\n-        private const int MAX_BUILDER_SIZE = 360;\n+        // The value 512 was chosen empirically as 95% percentile",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "![image](https://user-images.githubusercontent.com/12969783/144148806-0d4f5b65-d806-4b06-9f96-dfd2f7d2df82.png)\r\n(From https://github.com/dotnet/msbuild/issues/2697#issuecomment-981140614)",
              "createdAt": "2021-12-01T00:17:48Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -31,17 +31,21 @@\n **\n ===========================================================*/\n \n+//#define ASSERT_BALANCE\n+\n using System;\n+using System.Diagnostics;\n using System.Text;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+using Microsoft.Build.Eventing;\n+#endif\n \n-namespace Microsoft.Build.Shared\n+namespace Microsoft.Build.Framework\n {\n     internal static class StringBuilderCache\n     {\n-        // The value 360 was chosen in discussion with performance experts as a compromise between using\n-        // as little memory (per thread) as possible and still covering a large part of short-lived\n-        // StringBuilder creations on the startup path of VS designers.\n-        private const int MAX_BUILDER_SIZE = 360;\n+        // The value 512 was chosen empirically as 95% percentile",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "\"Bellow is \"histogram\" of ReuseableStringBuilder returning length. Y axis is sum of returning length for given bucket.\"",
              "createdAt": "2021-12-01T00:18:21Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -31,17 +31,21 @@\n **\n ===========================================================*/\n \n+//#define ASSERT_BALANCE\n+\n using System;\n+using System.Diagnostics;\n using System.Text;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+using Microsoft.Build.Eventing;\n+#endif\n \n-namespace Microsoft.Build.Shared\n+namespace Microsoft.Build.Framework\n {\n     internal static class StringBuilderCache\n     {\n-        // The value 360 was chosen in discussion with performance experts as a compromise between using\n-        // as little memory (per thread) as possible and still covering a large part of short-lived\n-        // StringBuilder creations on the startup path of VS designers.\n-        private const int MAX_BUILDER_SIZE = 360;\n+        // The value 512 was chosen empirically as 95% percentile",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Changed to:\r\n`// The value 512 was chosen empirically as 95% percentile of returning string length.`",
              "createdAt": "2021-12-01T11:11:48Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -31,17 +31,21 @@\n **\n ===========================================================*/\n \n+//#define ASSERT_BALANCE\n+\n using System;\n+using System.Diagnostics;\n using System.Text;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+using Microsoft.Build.Eventing;\n+#endif\n \n-namespace Microsoft.Build.Shared\n+namespace Microsoft.Build.Framework\n {\n     internal static class StringBuilderCache\n     {\n-        // The value 360 was chosen in discussion with performance experts as a compromise between using\n-        // as little memory (per thread) as possible and still covering a large part of short-lived\n-        // StringBuilder creations on the startup path of VS designers.\n-        private const int MAX_BUILDER_SIZE = 360;\n+        // The value 512 was chosen empirically as 95% percentile",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we do this for all debug builds?",
              "createdAt": "2021-11-29T21:22:20Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +55,44 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;\n                 if (sb != null)\n                 {\n                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder\n                     // when the requested size is larger than the current capacity\n                     if (capacity <= sb.Capacity)\n                     {\n-                        StringBuilderCache.t_cachedInstance = null;\n                         sb.Length = 0; // Equivalent of sb.Clear() that works on .Net 3.5\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: sb.GetHashCode(), newCapacity: capacity, oldCapacity: sb.Capacity, type: \"sbc-hit\");\n+#endif\n                         return sb;\n                     }\n                 }\n             }\n-            return new StringBuilder(capacity);\n+\n+            StringBuilder stringBuilder = new StringBuilder(capacity);\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: stringBuilder.GetHashCode(), newCapacity: capacity, oldCapacity: stringBuilder.Capacity, type: \"sbc-miss\");\n+#endif\n+            return stringBuilder;\n         }\n \n         public static void Release(StringBuilder sb)\n         {\n             if (sb.Capacity <= MAX_BUILDER_SIZE)\n             {\n+#if ASSERT_BALANCE",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I had it that way but then it was failing at unit test in CI. I originally though, \"well, thats because xunit runs it in multithread\" but that was flawed explanation as it is ThreadStatic and concurrency shall not affect it.\r\nI have locally reproduced it and found bug in code which acquires two SB at once. I will fix it, and replace ASSERT_BALANCE by DEBUG as this really identify wrong usage patterns.",
              "createdAt": "2021-11-30T19:57:16Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +55,44 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;\n                 if (sb != null)\n                 {\n                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder\n                     // when the requested size is larger than the current capacity\n                     if (capacity <= sb.Capacity)\n                     {\n-                        StringBuilderCache.t_cachedInstance = null;\n                         sb.Length = 0; // Equivalent of sb.Clear() that works on .Net 3.5\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: sb.GetHashCode(), newCapacity: capacity, oldCapacity: sb.Capacity, type: \"sbc-hit\");\n+#endif\n                         return sb;\n                     }\n                 }\n             }\n-            return new StringBuilder(capacity);\n+\n+            StringBuilder stringBuilder = new StringBuilder(capacity);\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: stringBuilder.GetHashCode(), newCapacity: capacity, oldCapacity: stringBuilder.Capacity, type: \"sbc-miss\");\n+#endif\n+            return stringBuilder;\n         }\n \n         public static void Release(StringBuilder sb)\n         {\n             if (sb.Capacity <= MAX_BUILDER_SIZE)\n             {\n+#if ASSERT_BALANCE",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-12-01T11:08:44Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +55,44 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;\n                 if (sb != null)\n                 {\n                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder\n                     // when the requested size is larger than the current capacity\n                     if (capacity <= sb.Capacity)\n                     {\n-                        StringBuilderCache.t_cachedInstance = null;\n                         sb.Length = 0; // Equivalent of sb.Clear() that works on .Net 3.5\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: sb.GetHashCode(), newCapacity: capacity, oldCapacity: sb.Capacity, type: \"sbc-hit\");\n+#endif\n                         return sb;\n                     }\n                 }\n             }\n-            return new StringBuilder(capacity);\n+\n+            StringBuilder stringBuilder = new StringBuilder(capacity);\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: stringBuilder.GetHashCode(), newCapacity: capacity, oldCapacity: stringBuilder.Capacity, type: \"sbc-miss\");\n+#endif\n+            return stringBuilder;\n         }\n \n         public static void Release(StringBuilder sb)\n         {\n             if (sb.Capacity <= MAX_BUILDER_SIZE)\n             {\n+#if ASSERT_BALANCE",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: delete comment",
              "createdAt": "2021-11-29T21:27:58Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-12-01T09:21:30Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please comment a) about the methodology of the data collection (so our successors can repeat it in 10 years when .metroproj has changed everything again) and b) a bit more details on the power-of-2 constraint.",
              "createdAt": "2021-11-29T21:29:45Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It's a bit odd to event only on DEBUG. Is it super costly to do it all the time? Should we just check for is-event-enabled?",
              "createdAt": "2021-11-29T21:33:11Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "In Roslyn build it was ~600K events in default console verbosity and ~1.2M in diag file log verbosity.\r\nSince the limit in perfview is, IIRC, 20M this could harm some generation of production ETW trace collections.\r\nI considered these ETW usable only for development from time to time to verify that our presumption about ReusableStringBuilderFactory usage are still valid.",
              "createdAt": "2021-12-01T12:19:52Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Sounds reasonable. Can you comment that somewhere, maybe on the events themselves?",
              "createdAt": "2021-12-01T15:45:57Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    // In order to free memory usage by huge string builder, do not pool this one and let it be collected.\r\n```\r\n\r\n?",
              "createdAt": "2021-11-29T21:34:00Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        // This builder used more than pre-allocated capacity bracket.\r\n```",
              "createdAt": "2021-11-29T21:34:39Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: \"discard\");\n+#endif\n+                }\n+                else\n+                {\n+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)\n+                    {\n+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, \"Capacity can only increase\");\n+\n+                        // This builder used more that pre-allocated capacity bracket.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        // Below implementation has predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.\r\n```",
              "createdAt": "2021-11-29T21:35:10Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: \"discard\");\n+#endif\n+                }\n+                else\n+                {\n+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)\n+                    {\n+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, \"Capacity can only increase\");\n+\n+                        // This builder used more that pre-allocated capacity bracket.\n+                        // Let this builder be collected and put new builder, with reflecting bracket capacity, into the pool.\n+                        // If we would just return this builder into pool as is, it would allocated new array[capacity] anyway (current implementation of returningBuilder.Clear() does it)\n+                        //   and that could lead to unpredictable amount of LOH allocations and eventual LOH fragmentation.\n+                        // Bellow implementation have predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        // This can identify improper usage from multiple thread or bug in code - Get was reentered before Release.\r\n```",
              "createdAt": "2021-11-29T21:35:41Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: \"discard\");\n+#endif\n+                }\n+                else\n+                {\n+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)\n+                    {\n+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, \"Capacity can only increase\");\n+\n+                        // This builder used more that pre-allocated capacity bracket.\n+                        // Let this builder be collected and put new builder, with reflecting bracket capacity, into the pool.\n+                        // If we would just return this builder into pool as is, it would allocated new array[capacity] anyway (current implementation of returningBuilder.Clear() does it)\n+                        //   and that could lead to unpredictable amount of LOH allocations and eventual LOH fragmentation.\n+                        // Bellow implementation have predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.\n+                        int newCapacity = SelectBracketedCapacity(returningBuilder.Capacity);\n+                        returningBuilder = new StringBuilder(newCapacity);\n+                    }\n+\n+                    returningBuilder.Clear(); // Clear before pooling\n+\n+                    var oldSharedBuilder = Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);\n+                    if (oldSharedBuilder != null)\n+                    {\n+#if DEBUG\n+                        // This can identify in-proper usage from multiple thread or bug in code - Get was reentered before Release.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            // lazy initialization of the builder\r\n            _capacity = capacity;\r\n```\r\n\r\n?",
              "createdAt": "2021-12-01T00:22:56Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be the power of 2 greater than capacity?",
              "createdAt": "2021-12-01T00:29:14Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +53,41 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;\n                 if (sb != null)\n                 {\n                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder\n                     // when the requested size is larger than the current capacity\n                     if (capacity <= sb.Capacity)\n                     {\n-                        StringBuilderCache.t_cachedInstance = null;\n                         sb.Length = 0; // Equivalent of sb.Clear() that works on .Net 3.5\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: sb.GetHashCode(), newCapacity: capacity, oldCapacity: sb.Capacity, type: \"sbc-hit\");\n+#endif\n                         return sb;\n                     }\n                 }\n             }\n-            return new StringBuilder(capacity);\n+\n+            StringBuilder stringBuilder = new StringBuilder(capacity);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have applied power of 2 logic only to ReuseableStringBuilder as according to captured statistics, SB from `StringBuilderCache`  uses only small capacity and is not as heavily utilized.",
              "createdAt": "2021-12-01T12:24:49Z",
              "path": "src/Framework/StringBuilderCache.cs",
              "diffHunk": "@@ -51,27 +53,41 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap\n             if (capacity <= MAX_BUILDER_SIZE)\n             {\n                 StringBuilder sb = StringBuilderCache.t_cachedInstance;\n+                StringBuilderCache.t_cachedInstance = null;\n                 if (sb != null)\n                 {\n                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder\n                     // when the requested size is larger than the current capacity\n                     if (capacity <= sb.Capacity)\n                     {\n-                        StringBuilderCache.t_cachedInstance = null;\n                         sb.Length = 0; // Equivalent of sb.Clear() that works on .Net 3.5\n+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: sb.GetHashCode(), newCapacity: capacity, oldCapacity: sb.Capacity, type: \"sbc-hit\");\n+#endif\n                         return sb;\n                     }\n                 }\n             }\n-            return new StringBuilder(capacity);\n+\n+            StringBuilder stringBuilder = new StringBuilder(capacity);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            /// This constant might looks huge, but rather than lowering this constant,\r\n            /// we shall focus on eliminating code which requires creating such huge strings.\r\n```",
              "createdAt": "2021-12-01T00:56:26Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    // If user wants bigger capacity than maximum capacity, respect it.\r\n```",
              "createdAt": "2021-12-01T00:57:39Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`#nullable enable` would be less error-prone than capturing nullness in comments.",
              "createdAt": "2021-12-01T00:58:21Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-12-01T14:51:28Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Was this supposed to be:\r\n\r\n```suggestion\r\n                    returned = new StringBuilder(newCapacity);\r\n```\r\n\r\nIf not, why call `SelectBracketedCapacity` a second time, passing its own output to itself?",
              "createdAt": "2021-12-01T01:03:10Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "You are right. good catch.",
              "createdAt": "2021-12-01T12:27:08Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Making this explicit makes it easier to miss disposing instances of this type, as the `Dispose` method doesn't appear in IntelliSense.",
              "createdAt": "2021-12-01T01:05:57Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-12-01T14:36:42Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Some ideas to ensure correct usage:\r\n\r\n- Null out fields on `ReuseableStringBuilder ` to catch use-after-free errors.\r\n- Ensure those fields are non-null in this method, to catch double-free errors.\r\n\r\nMaybe just in debug builds.\r\n",
              "createdAt": "2021-12-01T01:09:15Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I have nulled those fields on `Release` and added some asserts.",
              "createdAt": "2021-12-01T15:13:48Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can be done without any allocation and with less branching:\r\n\r\n```suggestion\r\n                const int minimumCapacity = 0x100; // 256 characters, 512 bytes\r\n\r\n                if (requiredCapacity <= minimumCapacity)\r\n                    return minimumCapacity;\r\n\r\n                // If user wants bigger capacity than maximum respect it as it could be used as buffer in P/Invoke.\r\n                if (requiredCapacity >= MaxBuilderSizeCapacity)\r\n                    return requiredCapacity;\r\n\r\n                // Find next power of two http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\r\n                int v = requiredCapacity;\r\n\r\n                v--;\r\n                v |= v >> 1;\r\n                v |= v >> 2;\r\n                v |= v >> 4;\r\n                v |= v >> 8;\r\n                v |= v >> 16;\r\n                v++;\r\n\r\n                return v;\r\n```\r\n\r\nThe `s_capacityBrackets` field and the static constructor can then be removed, which IIRC can make working with the type a bit faster as the runtime isn't checking to see if the type has been initialised.",
              "createdAt": "2021-12-01T01:35:54Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: \"discard\");\n+#endif\n+                }\n+                else\n+                {\n+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)\n+                    {\n+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, \"Capacity can only increase\");\n+\n+                        // This builder used more that pre-allocated capacity bracket.\n+                        // Let this builder be collected and put new builder, with reflecting bracket capacity, into the pool.\n+                        // If we would just return this builder into pool as is, it would allocated new array[capacity] anyway (current implementation of returningBuilder.Clear() does it)\n+                        //   and that could lead to unpredictable amount of LOH allocations and eventual LOH fragmentation.\n+                        // Bellow implementation have predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.\n+                        int newCapacity = SelectBracketedCapacity(returningBuilder.Capacity);\n+                        returningBuilder = new StringBuilder(newCapacity);\n+                    }\n+\n+                    returningBuilder.Clear(); // Clear before pooling\n+\n+                    var oldSharedBuilder = Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);\n+                    if (oldSharedBuilder != null)\n+                    {\n+#if DEBUG\n+                        // This can identify in-proper usage from multiple thread or bug in code - Get was reentered before Release.\n+                        // User of ReuseableStringBuilder has to make sure that calling method call stacks do not also use ReuseableStringBuilder.\n+                        // Look at stack traces of ETW events which contains reported string builder hashes.\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryUnbalanced(oldHash: oldSharedBuilder.GetHashCode(), newHash: returningBuilder.GetHashCode());\n+#endif\n+                    }\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: returning._borrowedBuilder != returningBuilder ? \"return-new\" : \"return\");\n+#endif\n+                }\n+            }\n+\n+            private static int SelectBracketedCapacity(int requiredCapacity)\n+            {\n+                foreach (int bracket in s_capacityBrackets)\n+                {\n+                    if (requiredCapacity <= bracket)\n+                    {\n+                        return bracket;\n+                    }\n+                }\n+\n+                // If user wants bigger capacity than maximum respect it as it could be used as buffer in P/Invoke.\n+                return requiredCapacity;",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Clever!",
              "createdAt": "2021-12-01T15:27:19Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: \"discard\");\n+#endif\n+                }\n+                else\n+                {\n+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)\n+                    {\n+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, \"Capacity can only increase\");\n+\n+                        // This builder used more that pre-allocated capacity bracket.\n+                        // Let this builder be collected and put new builder, with reflecting bracket capacity, into the pool.\n+                        // If we would just return this builder into pool as is, it would allocated new array[capacity] anyway (current implementation of returningBuilder.Clear() does it)\n+                        //   and that could lead to unpredictable amount of LOH allocations and eventual LOH fragmentation.\n+                        // Bellow implementation have predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.\n+                        int newCapacity = SelectBracketedCapacity(returningBuilder.Capacity);\n+                        returningBuilder = new StringBuilder(newCapacity);\n+                    }\n+\n+                    returningBuilder.Clear(); // Clear before pooling\n+\n+                    var oldSharedBuilder = Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);\n+                    if (oldSharedBuilder != null)\n+                    {\n+#if DEBUG\n+                        // This can identify in-proper usage from multiple thread or bug in code - Get was reentered before Release.\n+                        // User of ReuseableStringBuilder has to make sure that calling method call stacks do not also use ReuseableStringBuilder.\n+                        // Look at stack traces of ETW events which contains reported string builder hashes.\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryUnbalanced(oldHash: oldSharedBuilder.GetHashCode(), newHash: returningBuilder.GetHashCode());\n+#endif\n+                    }\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: returning._borrowedBuilder != returningBuilder ? \"return-new\" : \"return\");\n+#endif\n+                }\n+            }\n+\n+            private static int SelectBracketedCapacity(int requiredCapacity)\n+            {\n+                foreach (int bracket in s_capacityBrackets)\n+                {\n+                    if (requiredCapacity <= bracket)\n+                    {\n+                        return bracket;\n+                    }\n+                }\n+\n+                // If user wants bigger capacity than maximum respect it as it could be used as buffer in P/Invoke.\n+                return requiredCapacity;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nice - It is condensed bits wizardry. I liked it. Done",
              "createdAt": "2021-12-01T15:34:45Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,346 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+//#define ASSERT_BALANCE\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            _capacity = capacity;\n+\n+            // lazy initialization of the builder\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        void IDisposable.Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to exactly 2^n (power of 2) where n = 4 ... 32\n+            /// </summary>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather that lowering this constant,\n+            ///   we shall focus on eliminating of code which requires to create such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / 2;\n+\n+            private static readonly IReadOnlyList<int> s_capacityBrackets;\n+\n+            static ReuseableStringBuilderFactory()\n+            {\n+                var brackets = new List<int>();\n+\n+                int bytes = 0x200; // Minimal capacity is 256 (512 bytes) as this was, according to captured traces, mean required capacity\n+                while (bytes <= MaxBuilderSizeBytes)\n+                {\n+                    // Allocation of arrays is optimized in byte[bytes] => bytes = 2^n.\n+                    // StringBuilder allocates chars[capacity] and each char is 2 bytes so lets have capacity brackets computed as `bytes/2` \n+                    brackets.Add(bytes/2); \n+                    bytes <<= 1;\n+                }\n+                Debug.Assert((bytes >> 1) == MaxBuilderSizeBytes, \"MaxBuilderSizeBytes has to be 2^n (power of 2)\");\n+\n+                s_capacityBrackets = brackets;\n+            }\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity that maximum capacity respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(SelectBracketedCapacity(newCapacity));\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder;\n+                int returningLength = returningBuilder.Length;\n+\n+                // It's possible for someone to cause the builder to\n+                // enlarge to such an extent that this static field\n+                // would be a leak. To avoid that, only accept\n+                // the builder if it's no more than a certain size.\n+                //\n+                // If some code has a bug and forgets to return their builder\n+                // (or we refuse it here because it's too big) the next user will\n+                // get given a new one, and then return it soon after. \n+                // So the shared builder will be \"replaced\".\n+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)\n+                {\n+                    // In order to free memory usage by huge string builder, do not pull this one and let it be collected.\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: \"discard\");\n+#endif\n+                }\n+                else\n+                {\n+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)\n+                    {\n+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, \"Capacity can only increase\");\n+\n+                        // This builder used more that pre-allocated capacity bracket.\n+                        // Let this builder be collected and put new builder, with reflecting bracket capacity, into the pool.\n+                        // If we would just return this builder into pool as is, it would allocated new array[capacity] anyway (current implementation of returningBuilder.Clear() does it)\n+                        //   and that could lead to unpredictable amount of LOH allocations and eventual LOH fragmentation.\n+                        // Bellow implementation have predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.\n+                        int newCapacity = SelectBracketedCapacity(returningBuilder.Capacity);\n+                        returningBuilder = new StringBuilder(newCapacity);\n+                    }\n+\n+                    returningBuilder.Clear(); // Clear before pooling\n+\n+                    var oldSharedBuilder = Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);\n+                    if (oldSharedBuilder != null)\n+                    {\n+#if DEBUG\n+                        // This can identify in-proper usage from multiple thread or bug in code - Get was reentered before Release.\n+                        // User of ReuseableStringBuilder has to make sure that calling method call stacks do not also use ReuseableStringBuilder.\n+                        // Look at stack traces of ETW events which contains reported string builder hashes.\n+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryUnbalanced(oldHash: oldSharedBuilder.GetHashCode(), newHash: returningBuilder.GetHashCode());\n+#endif\n+                    }\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: returning._borrowedBuilder != returningBuilder ? \"return-new\" : \"return\");\n+#endif\n+                }\n+            }\n+\n+            private static int SelectBracketedCapacity(int requiredCapacity)\n+            {\n+                foreach (int bracket in s_capacityBrackets)\n+                {\n+                    if (requiredCapacity <= bracket)\n+                    {\n+                        return bracket;\n+                    }\n+                }\n+\n+                // If user wants bigger capacity than maximum respect it as it could be used as buffer in P/Invoke.\n+                return requiredCapacity;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                            // If we are logging warnings append it into existing StringBuilder, otherwise build details by new StringBuilder.\r\n```",
              "createdAt": "2021-12-01T15:48:24Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1087,7 +1087,10 @@ List<Exception> generalResolutionExceptions\n                             bool logWarning = idealAssemblyRemappingsIdentities.Any(i => i.assemblyName.FullName.Equals(fusionName) && i.reference.GetConflictVictims().Count == 0);\n                             StringBuilder logConflict = StringBuilderCache.Acquire();\n                             LogConflict(conflictCandidate, fusionName, logConflict);\n-                            StringBuilder logDependencies = logWarning ? logConflict.AppendLine() : StringBuilderCache.Acquire();\n+\n+                            // If we logging warnings append it into existing StringBuilder, otherwise build details by new StringBuilder.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                StringBuilder returningBuilder = returning._borrowedBuilder;\r\n```\r\n\r\nThe `!` can be avoided here by annotating `VerifyThrowInternalNull` as:\r\n\r\n```c#\r\ninternal static void VerifyThrowInternalNull([NotNull] object? parameter, string parameterName)\r\n```\r\n\r\nThis looks a bit weird, but it means:\r\n\r\n- The argument may be null when it is passed in\r\n- The argument will not be null when normal flow continues\r\n\r\n---\r\n\r\nAs an aside (likely for another PR) if we're on C# 10 then it may be possible to use the `CallerArgumentExpressionAttribute` on `parameterName`:\r\n\r\n```c#\r\ninternal static void VerifyThrowInternalNull([NotNull] object? parameter, [CallerArgumentExpressionAttribute] string parameterName = null)\r\n```\r\n\r\nMeaning the call could be simplified to:\r\n\r\n```c#\r\nFrameworkErrorUtilities.VerifyThrowInternalNull(returning._borrowedBuilder);\r\n```",
              "createdAt": "2021-12-01T23:50:39Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,355 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder? _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            // lazy initialization of the builder\n+            _capacity = capacity;\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return _borrowedBuilder?.Length ?? 0; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        [MemberNotNull(nameof(_borrowedBuilder))]\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to be exactly 2^n (power of 2) where n = 4 ... 32 as GC is optimized to work with such block sizes.\n+            /// Same approach is used in ArrayPool or RecyclableMemoryStream so having same uniform allocation sizes will\n+            ///   reduce likelihood of heaps fragmentation.\n+            /// </summary>\n+            /// <remarks>\n+            /// In order to collect and analyze ETW ReusableStringBuilderFactory events developer could follow these steps:\n+            ///   - With compiled as Debug capture events by perfview; example: \"perfview collect /NoGui /OnlyProviders=*Microsoft-Build\"\n+            ///   - Open Events view and filter for ReusableStringBuilderFactory and pick ReusableStringBuilderFactory/Stop\n+            ///   - Display columns: returning length, type\n+            ///   - Set MaxRet limit to 1_000_000\n+            ///   - Right click and Open View in Excel\n+            ///   - Use Excel data analytic tools to extract required data from it. I recommend to use\n+            ///       Pivot Table/Chart with\n+            ///         filter: type=[return-se,discarder];\n+            ///         rows: returningLength grouped (right click and Group... into sufficient size bins)\n+            ///         value: sum of returningLength\n+            /// </remarks>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather than lowering this constant,\n+            /// we shall focus on eliminating code which requires creating such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / sizeof(char);\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder? s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder? returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity than maximum capacity, respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(newCapacity);\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE // Please define ASSERT_BALANCE if you need to analyze where we have cross thread competing usage of ReuseableStringBuilder\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+                FrameworkErrorUtilities.VerifyThrowInternalNull(returning._borrowedBuilder, nameof(returning._borrowedBuilder) + \" can not be null.\");\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder!;",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I would rather address this in another PR. \r\n`FrameworkErrorUtilities.VerifyThrowInternalNull` needs some rethinking. It should be supporting nullable, but currently the lines:\r\nhttps://github.com/dotnet/msbuild/blob/93e469310958da9f5a4feb473c3cb0ddddf22b75/src/Framework/ErrorUtilities.cs#L23\r\nalong with\r\nhttps://github.com/dotnet/msbuild/blob/93e469310958da9f5a4feb473c3cb0ddddf22b75/src/Framework/ErrorUtilities.cs#L69-L72\r\nbreaks the rules \"**The argument will not be null when normal flow continues**\".\r\nI would like to question usefulness of `MSBUILDDONOTTHROWINTERNAL` as this means \"lets MSBuild fail at next line when accessing null ref object\". \r\n@rainersigwald do people use it?\r\n",
              "createdAt": "2021-12-02T09:49:39Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,355 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder? _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            // lazy initialization of the builder\n+            _capacity = capacity;\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return _borrowedBuilder?.Length ?? 0; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        [MemberNotNull(nameof(_borrowedBuilder))]\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to be exactly 2^n (power of 2) where n = 4 ... 32 as GC is optimized to work with such block sizes.\n+            /// Same approach is used in ArrayPool or RecyclableMemoryStream so having same uniform allocation sizes will\n+            ///   reduce likelihood of heaps fragmentation.\n+            /// </summary>\n+            /// <remarks>\n+            /// In order to collect and analyze ETW ReusableStringBuilderFactory events developer could follow these steps:\n+            ///   - With compiled as Debug capture events by perfview; example: \"perfview collect /NoGui /OnlyProviders=*Microsoft-Build\"\n+            ///   - Open Events view and filter for ReusableStringBuilderFactory and pick ReusableStringBuilderFactory/Stop\n+            ///   - Display columns: returning length, type\n+            ///   - Set MaxRet limit to 1_000_000\n+            ///   - Right click and Open View in Excel\n+            ///   - Use Excel data analytic tools to extract required data from it. I recommend to use\n+            ///       Pivot Table/Chart with\n+            ///         filter: type=[return-se,discarder];\n+            ///         rows: returningLength grouped (right click and Group... into sufficient size bins)\n+            ///         value: sum of returningLength\n+            /// </remarks>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather than lowering this constant,\n+            /// we shall focus on eliminating code which requires creating such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / sizeof(char);\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder? s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder? returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity than maximum capacity, respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(newCapacity);\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE // Please define ASSERT_BALANCE if you need to analyze where we have cross thread competing usage of ReuseableStringBuilder\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+                FrameworkErrorUtilities.VerifyThrowInternalNull(returning._borrowedBuilder, nameof(returning._borrowedBuilder) + \" can not be null.\");\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder!;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I didn't realise it was conditional. Still, I think it would be ok to annotate it as though the return value is non-null given that's clearly the intent. NRT doesn't give hard guarantees. It's mostly about communicating intent in code and make bugs more obvious.",
              "createdAt": "2021-12-02T10:26:03Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,355 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder? _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            // lazy initialization of the builder\n+            _capacity = capacity;\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return _borrowedBuilder?.Length ?? 0; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        [MemberNotNull(nameof(_borrowedBuilder))]\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to be exactly 2^n (power of 2) where n = 4 ... 32 as GC is optimized to work with such block sizes.\n+            /// Same approach is used in ArrayPool or RecyclableMemoryStream so having same uniform allocation sizes will\n+            ///   reduce likelihood of heaps fragmentation.\n+            /// </summary>\n+            /// <remarks>\n+            /// In order to collect and analyze ETW ReusableStringBuilderFactory events developer could follow these steps:\n+            ///   - With compiled as Debug capture events by perfview; example: \"perfview collect /NoGui /OnlyProviders=*Microsoft-Build\"\n+            ///   - Open Events view and filter for ReusableStringBuilderFactory and pick ReusableStringBuilderFactory/Stop\n+            ///   - Display columns: returning length, type\n+            ///   - Set MaxRet limit to 1_000_000\n+            ///   - Right click and Open View in Excel\n+            ///   - Use Excel data analytic tools to extract required data from it. I recommend to use\n+            ///       Pivot Table/Chart with\n+            ///         filter: type=[return-se,discarder];\n+            ///         rows: returningLength grouped (right click and Group... into sufficient size bins)\n+            ///         value: sum of returningLength\n+            /// </remarks>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather than lowering this constant,\n+            /// we shall focus on eliminating code which requires creating such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / sizeof(char);\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder? s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder? returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity than maximum capacity, respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(newCapacity);\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE // Please define ASSERT_BALANCE if you need to analyze where we have cross thread competing usage of ReuseableStringBuilder\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+                FrameworkErrorUtilities.VerifyThrowInternalNull(returning._borrowedBuilder, nameof(returning._borrowedBuilder) + \" can not be null.\");\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder!;",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I agree about doing this in another PR (and closing dotnet/msbuild#5163 while we're at it). I pushed up a branch with a half-hearted attempt at annotating ErrorUtilities that I put aside when hitting some of these same issues.",
              "createdAt": "2021-12-02T14:58:47Z",
              "path": "src/Framework/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,355 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Diagnostics.CodeAnalysis;\n+using System.Text;\n+using System.Threading;\n+using Microsoft.Build.Eventing;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// A StringBuilder lookalike that reuses its internal storage.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.\n+    /// </remarks>\n+    internal sealed class ReuseableStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Captured string builder.\n+        /// </summary>\n+        private StringBuilder? _borrowedBuilder;\n+\n+        /// <summary>\n+        /// Capacity of borrowed string builder at the time of borrowing.\n+        /// </summary>\n+        private int _borrowedWithCapacity;\n+\n+        /// <summary>\n+        /// Capacity to initialize the builder with.\n+        /// </summary>\n+        private int _capacity;\n+\n+        /// <summary>\n+        /// Create a new builder, under the covers wrapping a reused one.\n+        /// </summary>\n+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16\n+        {\n+            // lazy initialization of the builder\n+            _capacity = capacity;\n+        }\n+\n+        /// <summary>\n+        /// The length of the target.\n+        /// </summary>\n+        public int Length\n+        {\n+            get { return _borrowedBuilder?.Length ?? 0; }\n+            set\n+            {\n+                LazyPrepare();\n+                _borrowedBuilder.Length = value;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Convert to a string.\n+        /// </summary>\n+        public override string ToString()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                return String.Empty;\n+            }\n+\n+            return _borrowedBuilder.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Dispose, indicating you are done with this builder.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            if (_borrowedBuilder != null)\n+            {\n+                ReuseableStringBuilderFactory.Release(this);\n+                _borrowedBuilder = null;\n+                _capacity = -1;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append a character.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(char value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a string.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Append a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Append(value, startIndex, count);\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n+        {\n+            LazyPrepare();\n+\n+            var separatorsRemaining = strings.Count - 1;\n+\n+            foreach (var s in strings)\n+            {\n+                _borrowedBuilder.Append(s);\n+\n+                if (separatorsRemaining > 0)\n+                {\n+                    _borrowedBuilder.Append(separator);\n+                }\n+\n+                separatorsRemaining--;\n+            }\n+\n+            return this;\n+        }\n+\n+        public ReuseableStringBuilder Clear()\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Clear();\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Remove a substring.\n+        /// </summary>\n+        internal ReuseableStringBuilder Remove(int startIndex, int length)\n+        {\n+            LazyPrepare();\n+            _borrowedBuilder.Remove(startIndex, length);\n+            return this;\n+        }\n+\n+        /// <summary>\n+        /// Grab a backing builder if necessary.\n+        /// </summary>\n+        [MemberNotNull(nameof(_borrowedBuilder))]\n+        private void LazyPrepare()\n+        {\n+            if (_borrowedBuilder == null)\n+            {\n+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n+\n+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n+                _borrowedWithCapacity = _borrowedBuilder.Capacity;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A utility class that mediates access to a shared string builder.\n+        /// </summary>\n+        /// <remarks>\n+        /// If this shared builder is highly contended, this class could add\n+        /// a second one and try both in turn.\n+        /// </remarks>\n+        private static class ReuseableStringBuilderFactory\n+        {\n+            /// <summary>\n+            /// Made up limit beyond which we won't share the builder\n+            /// because we could otherwise hold a huge builder indefinitely.\n+            /// This was picked empirically to save at least 95% of allocated data size.\n+            /// This constant has to be exactly 2^n (power of 2) where n = 4 ... 32 as GC is optimized to work with such block sizes.\n+            /// Same approach is used in ArrayPool or RecyclableMemoryStream so having same uniform allocation sizes will\n+            ///   reduce likelihood of heaps fragmentation.\n+            /// </summary>\n+            /// <remarks>\n+            /// In order to collect and analyze ETW ReusableStringBuilderFactory events developer could follow these steps:\n+            ///   - With compiled as Debug capture events by perfview; example: \"perfview collect /NoGui /OnlyProviders=*Microsoft-Build\"\n+            ///   - Open Events view and filter for ReusableStringBuilderFactory and pick ReusableStringBuilderFactory/Stop\n+            ///   - Display columns: returning length, type\n+            ///   - Set MaxRet limit to 1_000_000\n+            ///   - Right click and Open View in Excel\n+            ///   - Use Excel data analytic tools to extract required data from it. I recommend to use\n+            ///       Pivot Table/Chart with\n+            ///         filter: type=[return-se,discarder];\n+            ///         rows: returningLength grouped (right click and Group... into sufficient size bins)\n+            ///         value: sum of returningLength\n+            /// </remarks>\n+            /// <remarks>\n+            /// This constant might looks huge, but rather than lowering this constant,\n+            /// we shall focus on eliminating code which requires creating such huge strings.\n+            /// </remarks>\n+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars\n+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / sizeof(char);\n+\n+            /// <summary>\n+            /// The shared builder.\n+            /// </summary>\n+            private static StringBuilder? s_sharedBuilder;\n+\n+#if DEBUG && ASSERT_BALANCE\n+            /// <summary>\n+            /// Balance between calling Get and Release.\n+            /// Shall be always 0 as Get and 1 at Release.\n+            /// </summary>\n+            private static int s_getVsReleaseBalance;\n+#endif\n+\n+            /// <summary>\n+            /// Obtains a string builder which may or may not already\n+            /// have been used. \n+            /// Never returns null.\n+            /// </summary>\n+            internal static StringBuilder Get(int capacity)\n+            {\n+#if DEBUG && ASSERT_BALANCE\n+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 1, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+\n+                StringBuilder? returned = Interlocked.Exchange(ref s_sharedBuilder, null);\n+\n+                if (returned == null)\n+                {\n+                    // Currently loaned out so return a new one with capacity in given bracket.\n+                    // If user wants bigger capacity than maximum capacity, respect it.\n+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:\"miss\");\n+#endif\n+                }\n+                else if (returned.Capacity < capacity)\n+                {\n+                    // It's essential we guarantee the capacity because this\n+                    // may be used as a buffer to a PInvoke call.\n+                    int newCapacity = SelectBracketedCapacity(capacity);\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: \"miss-need-bigger\");\n+#endif\n+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]\n+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).\n+                    returned = new StringBuilder(newCapacity);\n+                }\n+                else\n+                {\n+#if DEBUG\n+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: \"hit\");\n+#endif\n+                }\n+\n+                return returned;\n+            }\n+\n+            /// <summary>\n+            /// Returns the shared builder for the next caller to use.\n+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **\n+            /// </summary>\n+            internal static void Release(ReuseableStringBuilder returning)\n+            {\n+#if DEBUG && ASSERT_BALANCE // Please define ASSERT_BALANCE if you need to analyze where we have cross thread competing usage of ReuseableStringBuilder\n+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);\n+                Debug.Assert(balance == 0, \"Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.\");\n+#endif\n+                FrameworkErrorUtilities.VerifyThrowInternalNull(returning._borrowedBuilder, nameof(returning._borrowedBuilder) + \" can not be null.\");\n+\n+                StringBuilder returningBuilder = returning._borrowedBuilder!;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}