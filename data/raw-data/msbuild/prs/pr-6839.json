{
  "number": 6839,
  "title": "Fix #6750 `SdkResultItem` equality",
  "body": "Fixes #6750 \r\n\r\n### Context\r\nThe issue #6750 describes that implementation of Equals and GetHashCode is still buggy, and it is not reliable. This change ensures that: \r\n\r\n1. Equals won't throw Exception,\r\n2. Equals compare Key and its value between each KeyValues in Metadata's Key and values\r\n3. Remove additional null check on Metadata, because Metadata property will not be null\r\n\r\n### Changes Made\r\nRefactor Equals and GetHashCode methods to ensure reliable comparison as suggested in https://github.com/dotnet/msbuild/issues/6750#issue-967522986\r\n\r\n### Testing\r\n\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2021-09-12T19:11:09Z",
  "updatedAt": "2022-01-19T05:02:30Z",
  "closedAt": "2021-11-29T17:56:19Z",
  "mergedAt": "2021-11-29T17:56:18Z",
  "additions": 71,
  "deletions": 18,
  "changedFiles": 2,
  "headRefName": "fix-SdkResultItem-equality",
  "isDraft": false,
  "author": {
    "login": "eriawan"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "22b905572a816572025eb2f555d3694cde1c2495",
          "message": "refactor SdkResultItem.Equals to always compare count of elements, the key first, then the value. Also remove the ? in comparing Metadata.Count because Metadata will never be null.",
          "committedDate": "2021-11-17T14:23:29Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6b3801709cbf55eab67ed2c246e8b445b9842519",
          "message": "Refactot GetHashCode to use XOR (^) instead to ensure that we ignore the order of the Metadata's Key",
          "committedDate": "2021-11-17T14:23:29Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "64de2e6f9a5f682c1d43fe3e84149b17ef736ae1",
          "message": "attempt to add more check in case metadata is set to null before calling GetHashCode",
          "committedDate": "2021-11-17T14:23:29Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0ce39984a0ffa66bbf55f5c7125e74f1408095df",
          "message": "Update src/Framework/Sdk/SdkResultItem.cs\r\n\r\napply suggestion from review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2021-11-17T14:23:30Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "387b6c58eb37a1d2b32497a0ce8ea4914b2e2845",
          "message": "add back null check within Equals method, and apply PR feedback on GetHashCode().",
          "committedDate": "2021-11-17T14:23:30Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "619d643de268f3b6c8af5b20c888f93eb51b6360",
          "message": "Create new unit test to test SdkResultItem comparirson of Equals and GetHashCode",
          "committedDate": "2021-11-17T14:23:30Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9e3108e6a86b55a4dd487851b775453f3ab10af4",
          "message": "Update src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-17T14:23:30Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c384fae8382c637945d09431706ef4d2d22bdd1",
          "message": "Update src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-17T14:23:31Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8d9d0973c11a8755f52295dc6b24db06d6ba2f1a",
          "message": "Update src/Framework/Sdk/SdkResultItem.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-17T14:23:31Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "91bdf751f0bc4c55b72e33a742302a5e4212afc0",
          "message": "Apply `#nullable enable` within SdkResultItem and apply foreach feedback in GetHashCode.",
          "committedDate": "2021-11-17T14:23:31Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce032db5382a7cbfb7502dca4e727552496a8a69",
          "message": "ensure return Metadata.All as suggested in Equals method",
          "committedDate": "2021-11-17T14:23:32Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "930159bce95cdeb4aa292215a06f8c183440e468",
          "message": "fix compile errors after applying PR latest feedback on GetHashCode",
          "committedDate": "2021-11-17T14:23:32Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "142ae79710bda14e8d87b7b00651e8de6d19d42b",
          "message": "fix ItemSpec must not be null in default constructor",
          "committedDate": "2021-11-17T14:23:32Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf0abb859ce438fc3a1127dcf80a0a4573e46ebd",
          "message": "fix dererence error after nullable enable further",
          "committedDate": "2021-11-17T14:23:33Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3cf49f6811e8d6015d793967d5cb67f9813cb7de",
          "message": "Fix unit test and continue using Shouldly on all 3 ubit tests",
          "committedDate": "2021-11-17T14:23:33Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7853161fc28fcab315828da786ab574a9859d8d9",
          "message": "fix unit test after I set the metadata in the constructor to be new Dictionary if the metadata passed is null",
          "committedDate": "2021-11-17T14:23:33Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0e52253135a4494744bd573714990c3dd1db8f97",
          "message": "Update src/Framework/Sdk/SdkResultItem.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-17T14:23:34Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a137cc2a13e92eeeaf60f9d913648d8f688820c",
          "message": "Update src/Framework/Sdk/SdkResultItem.cs\r\n\r\napply string.Empty suggestion\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-17T14:23:34Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7060d8ee0641bf223bc11eb240f84928d4d8593e",
          "message": "Refactor if compare in Equals method based on latest PR feedback as we want to keep Metadata to be nullable, and propose updated if with check for item.Metadata == null and update unit test to use Sho\n\nupdate constructor to pass metadata without null check",
          "committedDate": "2021-11-17T14:23:34Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5a5f5174538586d0503b3b10f9f05f5a2ddd597",
          "message": "make Metadata property to be nullable and use is not null instead of != in Equals method.",
          "committedDate": "2021-11-17T14:23:34Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e7f0240bc8339fb0bdcbf17b1cf8db05899bbf4e",
          "message": "setn metadata parameter in SdkResultItem's ctor to be nullable.",
          "committedDate": "2021-11-17T14:23:34Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d2c0a31a1dec0562f60e0f8859f876c5c77be4a5",
          "message": "update SdkResultItem.GetHashCode as suggested",
          "committedDate": "2021-11-17T16:06:42Z",
          "author": {
            "name": "eriawan",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "04b784a20073b1cec8e67aa9c321bbb7f79862ce",
          "message": "Update src/Framework/Sdk/SdkResultItem.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-17T17:06:24Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3ba44d0a35eff8c877025dd421bb5d4e7e54f4cc",
          "message": "Merge branch 'dotnet:main' into fix-SdkResultItem-equality",
          "committedDate": "2021-11-20T20:39:51Z",
          "author": {
            "name": "Eriawan Kusumawardhono",
            "email": "eriawan@live.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@BenVillalobos \r\nI think I had fixed the Equals and ensure the GetHashCode uses XOR to ensure returning the same hashcode for dictionary regardless the order of the keys.\r\n\r\nPlease review \ud83d\ude42 ",
        "createdAt": "2021-09-12T19:14:57Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "Looks like there are errors on as detected some unit tests related to `SdkResultItem`.\r\n\r\nI'll try to fix these now.",
        "createdAt": "2021-09-12T20:18:16Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "@BenVillalobos \r\nIt is green now! \r\n\r\nPlease revie, thanks in advance!",
        "createdAt": "2021-09-12T20:58:54Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "@Forgind \r\n\r\n> Looks good to me! Thanks @eriawan!\r\n\r\nThanks! Hang on, there are compile errors caused by having `#nullable enable`\r\nGoing to fix these error first. ",
        "createdAt": "2021-09-20T21:24:02Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "Strange, CI have build errors about Tests failed but no further information which tests failing:\r\n\r\n![image](https://user-images.githubusercontent.com/8773147/134264493-b33b61d4-22cb-4e98-909b-2a0043fc474c.png)\r\n\r\nFolks. what is the actual cause of this test failures?",
        "createdAt": "2021-09-22T00:23:48Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "Aha, I got the cause!\r\n\r\nupdating the unit test now, because now passed metadata in the constructor will not be null inside the constructor.",
        "createdAt": "2021-09-22T00:47:21Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "CI is almost green, Linux Core CI is red now:\r\n\r\n![image](https://user-images.githubusercontent.com/8773147/134269047-2950c487-7aae-47d0-8fde-e497bf351249.png)\r\n\r\nHmm... I have no clue what caused this...",
        "createdAt": "2021-09-22T01:27:51Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "ok, I'm waiting confirmation and further review from all of you, folks! \ud83d\ude4f \r\nThanks in advance!",
        "createdAt": "2021-09-22T01:29:23Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "> Linux Core CI is red now:\r\n> \r\n> ![image](https://user-images.githubusercontent.com/8773147/134269047-2950c487-7aae-47d0-8fde-e497bf351249.png)\r\n> \r\n> Hmm... I have no clue what caused this...\r\n\r\n@AR-May is investigating this. I reran that job.",
        "createdAt": "2021-09-22T02:13:59Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@eriawan, have you had a chance to get back to this? I think it's almost ready; just have to push a little change with the hashcode, and it should be good. I can do that if you don't have time.",
        "createdAt": "2021-11-17T00:14:50Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind \r\n\r\nthanks for the reminder! apologize I was buried with work and personal matters for 2 months.\r\nok, I'll rebase and update with your latest suggestions above and run the unit test again \r\nI'm going to visit this today.",
        "createdAt": "2021-11-17T14:20:50Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "@Forgind \r\n\r\nDone updating the `GetHashCode` based on your suggestion https://github.com/dotnet/msbuild/pull/6839#discussion_r721524223",
        "createdAt": "2021-11-17T16:08:15Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "@Forgind \r\ncode updated as suggested. thanks! \ud83d\ude42 ",
        "createdAt": "2021-11-17T17:07:35Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "@Forgind @rainersigwald \r\n\r\nFolks, are there any update on this PR review?",
        "createdAt": "2021-11-28T20:40:18Z",
        "author": {
          "login": "eriawan"
        }
      },
      {
        "body": "Yes! We agreed it's ready to merge, so probably soon. Thanks for your patience with this!",
        "createdAt": "2021-11-29T17:55:31Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "thanks folks! \ud83d\udc4d",
        "createdAt": "2021-11-30T19:34:18Z",
        "author": {
          "login": "eriawan"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: our usual style for newly touched code is\r\n\r\n```suggestion\r\n                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))\r\n```",
              "createdAt": "2021-09-13T13:58:03Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,18 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    var itemValue = \"\";\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out itemValue))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Thanks! Suggestion applied.",
              "createdAt": "2021-09-13T14:13:44Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,18 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    var itemValue = \"\";\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out itemValue))",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this inclusion to the hashcode should continue to be order-preserving (even though it's the first addition and this doesn't really matter).",
              "createdAt": "2021-09-13T13:59:02Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "CMIIW, I think my latest update now ensure that the key-value in the metadata ignore the orders of the key but still has the same hashcode returned.\r\n\r\nAm I still missing something else? I welcome suggestions \ud83d\ude42 ",
              "createdAt": "2021-09-20T20:19:13Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Doing this with xor as well as the below with xor means that there can be a collision between the two. I think it'd be this case:\r\n\r\n```\r\nItemSpec = \"Key: Value\"\r\nMetadata = { \"Key\" = \"Value\" }\r\n```\r\n\r\nInstead, ideally we would have an order-dependent addition of the itemspec and the metadata (where each key/value is combined into the metadata's hash in an order-independent way.",
              "createdAt": "2021-09-23T22:33:48Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If GetHashCode() considered only the ItemSpec and ignored the Metadata, would that improve performance (because of simpler computation) or hurt performance (because of more frequent hash collisions)?",
              "createdAt": "2021-09-27T09:09:38Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "I think we should consider GetHashCode for Metadata too. \r\nNow finding the best way to handle this.",
              "createdAt": "2021-09-27T16:45:58Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we really need to check `Count` here; `foreach` over an empty list is fast.\r\n\r\nAlso, `Metadata` is never null, right?",
              "createdAt": "2021-09-13T14:06:16Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It can be if you pass in null as the metadata when constructing it.",
              "createdAt": "2021-09-13T15:53:39Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@rainersigwald \r\nDone removing unnecessary Count check.\r\nI've added null check too, because the other constructor may accept Metadata parameter as null.",
              "createdAt": "2021-09-19T20:17:13Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Likewise here make sure the key/value relationship is order-preserving, while making the inclusion in the overall hashcode order-agnostic. That way these two items compare different:\r\n\r\n```\r\nItemSpec = \"ItemSpec\"\r\nMetadata = {\r\n  [\"Key\"] = \"value\"\r\n}\r\n```\r\n\r\nand\r\n\r\n```\r\nItemSpec = \"ItemSpec\"\r\nMetadata = {\r\n  [\"value\"] = \"Key\"\r\n}\r\n```",
              "createdAt": "2021-09-13T14:07:43Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Key.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Value.GetHashCode();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Just to confirm, the order of the Key in the keys are still ignoring the order, right?\r\nOk, I'll make the GetHashTable order-preserving for Key-Value more granular.\r\nI'm going to update that including the unit test additions.",
              "createdAt": "2021-09-13T14:41:36Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Key.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Value.GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Correct; the order of the key-value pairs in the enumeration should not matter, but within each one the key vs value should.",
              "createdAt": "2021-09-13T14:43:59Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Key.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Value.GetHashCode();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done fixing the Key-Value of GetHashCode. Currently adding \"K\" in hash code gen for Key, and adding \"V\" for hashcode gen for Value. Therefore Key and Value will always be different when we are getting hashcode of key and value of the enumerated Key-Value pair.\r\n\r\nhttps://github.com/eriawan/msbuild/blob/fix-SdkResultItem-equality/src/Framework/Sdk/SdkResultItem.cs#L66-L70\r\n\r\n",
              "createdAt": "2021-09-19T20:21:52Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Key.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Value.GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "@rainersigwald \r\n\r\nDone applying the suggestion and also in sync with feedback from others.",
              "createdAt": "2021-09-22T23:57:02Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +60,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n-            if (Metadata != null)\n+            if (Metadata != null && Metadata.Count > 0)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Key.GetHashCode();\n+                    hashCode = hashCode ^ kvp.Value.GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can Metadata not be null if using the second constructor with metadata passed as null? Not saying it's right, but it would be nice to not fail.",
              "createdAt": "2021-09-13T14:53:18Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Done re-adding Metadata null check. Thanks!",
              "createdAt": "2021-09-19T20:15:26Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Like @Forgind suggested, `Metadata` here can be null if the second constructor was called on `item` and null was passed for `metadata`.\r\n\r\nWe should just initialize `Metadata` to an empty set if this happens in the second constructor.\r\n\r\n```c#\r\n        public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\r\n        {\r\n            ItemSpec = itemSpec;\r\n            Metadata = metadata ?? new();\r\n        }\r\n```",
              "createdAt": "2021-09-13T22:54:44Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Thanks! It makes sense. Currently I'm going to add unit tests first as suggested by @rainersigwald",
              "createdAt": "2021-09-13T23:06:03Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Why should we initialize Metadata to null? I haven't seen people complaining about it being null, and it takes up more space as not-null than null. I just think it's important to not make assumptions.",
              "createdAt": "2021-09-13T23:37:44Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think either way we should consider making this file `#nullable enable` to formalize the decision and let the compiler complain if we get it wrong.",
              "createdAt": "2021-09-14T13:31:54Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "So that we can make the assumption that it isn't null instead of verifying it every time we use it. I figure it's something we've commented on many times at this point, so just initialize it and be done with it.",
              "createdAt": "2021-09-14T18:28:44Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'm curious if someone has found a way to rely on it being null...if so, it sounds like a bug, so I don't think it would be a big deal to break them. I'd prefer whatever is most performant.",
              "createdAt": "2021-09-14T21:35:43Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@rainersigwald @Forgind \r\n\r\nDone creating new unit test for SdkResolverItem and also done applying PR feedback, including re-adding Metadata null check.\r\nDo we still need to have `#nullable enable` in the SdkResultItem class?\r\n\r\n@BenVillalobos \r\nAbout this comment https://github.com/dotnet/msbuild/pull/6839#discussion_r707774092\r\nDo we have to ensure internally that if Metadata being passed is null then we should always have a non null Metadata in the constructor?\r\n\r\nIf we are going to have this:\r\n```\r\nMetadata = metadata ?? new();\r\n```\r\nThen I'm going to change my commit to remove all of the null check for Metadata, because as far as I know previous code before my PR has no check for null then instantiate new Metadata in the constructor. \r\nAlso CMIIW, previous code seems to always check Metadata for null value and everyone else suggesting to check for passed null value in Metadata when calling the second constructor. So I'm a bit confused, which fix I should take whether I keep the null check or having a guarantee for Metadata to be always non-null inside the second constructor.\r\nPlease confirm. \r\n\r\nI'm ok to add that too, if it's decided and agreed by all three of you. \ud83d\ude42 \r\n",
              "createdAt": "2021-09-19T20:35:41Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "> Do we still need to have `#nullable enable` in the SdkResultItem class?\r\n\r\nYes; it will help ensure we don't accidentally remove the null check later if we opt for allowing Metadata to be null.\r\n\r\nWe can talk about that on Monday. I'll post a response here afterwards. Thanks for all your work on this!",
              "createdAt": "2021-09-19T22:07:06Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Team triage:\r\nLet's keep the null checks (not initialize Metadata to an empty dictionary) and enable nullable. Thanks!",
              "createdAt": "2021-09-20T15:20:39Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind and teams,\r\n\r\nThanks for the heads up \ud83d\ude42 \r\nOk, I think my next code update is just enable nullable, CMIIW.\r\nGoing to update this today.",
              "createdAt": "2021-09-20T16:59:08Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Might need to tweak the hashcode, but otherwise sounds right to me!",
              "createdAt": "2021-09-20T19:33:14Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "hi @Forgind \r\n\r\nDone applying nullable and also refactor as suggested for GetHashCode and Equals.\r\nPlease review and thanks in advance! \ud83d\ude42 ",
              "createdAt": "2021-09-20T20:54:30Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,13 +34,17 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)\n                 {\n-                    foreach (var kvp in Metadata)\n+                    if (!item.Metadata.TryGetValue(kvp.Key, out var itemValue))",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n```",
              "createdAt": "2021-09-20T17:48:14Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "thanks!",
              "createdAt": "2021-09-20T20:05:27Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: We've been slowly updating to Shouldly:\r\n```suggestion\r\n            sdkResultItem1.ShouldBe(sdkResultItem2);\r\n```",
              "createdAt": "2021-09-20T17:49:59Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class SdkResultItemComparison_Tests\n+    {\n+        [Fact]\n+        public void SdkResultItem_Equal_WithDefaultCtor()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+\n+            Assert.True(sdkResultItem1.Equals(sdkResultItem2));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "thanks for the suggestion!",
              "createdAt": "2021-09-20T20:07:32Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class SdkResultItemComparison_Tests\n+    {\n+        [Fact]\n+        public void SdkResultItem_Equal_WithDefaultCtor()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+\n+            Assert.True(sdkResultItem1.Equals(sdkResultItem2));",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm tempted to suggest replacing this with:\r\n```suggestion\r\n                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\r\n```\r\n\r\nLooks cleaner to me, though it should technically be slower.",
              "createdAt": "2021-09-20T19:25:46Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,11 +36,15 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks!\r\nYes, it is a bit slower. Ok, going to apply your suggestion.",
              "createdAt": "2021-09-20T20:20:22Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,11 +36,15 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n+                foreach (var kvp in Metadata)",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't this mean that if I had item1 with { mKey1: mVal1, mKey2: mVal2 } and item2 with the same ItemSpec but { mKey1: mVal2, mKey2: mVal1 } that they'd have the same hash code? Might be better to hash them together.",
              "createdAt": "2021-09-20T19:29:56Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +59,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ $\"K{kvp.Key}\".GetHashCode();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "CMIIW, I already get the hashcode of the Itemspec in line 62, and the hashcode is reused and xor-ed again when iterating key-value items in Metadata. So I think I already hash them together.\r\n\r\nOr do you have other thinking/suggestion about hashing them together? Please elaborate.",
              "createdAt": "2021-09-20T20:16:31Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +59,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ $\"K{kvp.Key}\".GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Right, so I think the ItemSpec is included correctly, but xor shouldn't care about order, which could be problematic. Something like:\r\n```C#\r\nforeach (var kvp in Metadata)\r\n{\r\n    hashCode ^= $\"{kvp.Key.GetHashCode()}: {(kvp.Value ?? \"V\").GetHashCode()}\";\r\n}\r\n```\r\n\r\nmight work better.",
              "createdAt": "2021-09-20T20:24:11Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +59,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ $\"K{kvp.Key}\".GetHashCode();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Done applying above `foreach` suggestion. Thanks!",
              "createdAt": "2021-09-20T20:47:24Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -55,14 +59,14 @@ public override bool Equals(object obj)\n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode = hashCode ^ $\"K{kvp.Key}\".GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Missing a few `.ShouldBe` calls",
              "createdAt": "2021-09-21T17:53:16Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,56 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class SdkResultItemComparison_Tests\n+    {\n+        [Fact]\n+        public void SdkResultItem_Equal_WithDefaultCtor()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+\n+            sdkResultItem1.ShouldBe(sdkResultItem2);\n+        }\n+\n+        [Fact]\n+        public void SdkResultItem_Equal_CtorParam_MetadataNull()\n+        {\n+            var sdkResultItem1 = new SdkResultItem(\"anyspec\", new Dictionary<string, string>());\n+            var sdkResultItem2 = new SdkResultItem(\"anyspec\", null);\n+\n+            Assert.True(!sdkResultItem1.Equals(sdkResultItem2));",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Done",
              "createdAt": "2021-09-21T23:51:44Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,56 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class SdkResultItemComparison_Tests\n+    {\n+        [Fact]\n+        public void SdkResultItem_Equal_WithDefaultCtor()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+\n+            sdkResultItem1.ShouldBe(sdkResultItem2);\n+        }\n+\n+        [Fact]\n+        public void SdkResultItem_Equal_CtorParam_MetadataNull()\n+        {\n+            var sdkResultItem1 = new SdkResultItem(\"anyspec\", new Dictionary<string, string>());\n+            var sdkResultItem2 = new SdkResultItem(\"anyspec\", null);\n+\n+            Assert.True(!sdkResultItem1.Equals(sdkResultItem2));",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "See above",
              "createdAt": "2021-09-21T17:53:34Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,56 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class SdkResultItemComparison_Tests\n+    {\n+        [Fact]\n+        public void SdkResultItem_Equal_WithDefaultCtor()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+\n+            sdkResultItem1.ShouldBe(sdkResultItem2);\n+        }\n+\n+        [Fact]\n+        public void SdkResultItem_Equal_CtorParam_MetadataNull()\n+        {\n+            var sdkResultItem1 = new SdkResultItem(\"anyspec\", new Dictionary<string, string>());\n+            var sdkResultItem2 = new SdkResultItem(\"anyspec\", null);\n+\n+            Assert.True(!sdkResultItem1.Equals(sdkResultItem2));\n+        }\n+\n+        [Fact]\n+        public void SdkResultItem_GetHashCode_Compare_MetadataIgnoreKeyOrder()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var hashSdkItem1 = sdkResultItem1.GetHashCode();\n+\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+            var hashSdkItem2 = sdkResultItem2.GetHashCode();\n+\n+            Assert.True(hashSdkItem1 == hashSdkItem2);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Done, thanks!",
              "createdAt": "2021-09-21T23:51:57Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs",
              "diffHunk": "@@ -0,0 +1,56 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class SdkResultItemComparison_Tests\n+    {\n+        [Fact]\n+        public void SdkResultItem_Equal_WithDefaultCtor()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+\n+            sdkResultItem1.ShouldBe(sdkResultItem2);\n+        }\n+\n+        [Fact]\n+        public void SdkResultItem_Equal_CtorParam_MetadataNull()\n+        {\n+            var sdkResultItem1 = new SdkResultItem(\"anyspec\", new Dictionary<string, string>());\n+            var sdkResultItem2 = new SdkResultItem(\"anyspec\", null);\n+\n+            Assert.True(!sdkResultItem1.Equals(sdkResultItem2));\n+        }\n+\n+        [Fact]\n+        public void SdkResultItem_GetHashCode_Compare_MetadataIgnoreKeyOrder()\n+        {\n+            var sdkResultItem1 = new SdkResultItem();\n+            sdkResultItem1.ItemSpec = \"AnySpec\";\n+            sdkResultItem1.Metadata.Add(\"key1\", \"value1\");\n+            sdkResultItem1.Metadata.Add(\"key2\", \"value2\");\n+            var hashSdkItem1 = sdkResultItem1.GetHashCode();\n+\n+            var sdkResultItem2 = new SdkResultItem();\n+            sdkResultItem2.ItemSpec = \"AnySpec\";\n+            sdkResultItem2.Metadata.Add(\"key2\", \"value2\");\n+            sdkResultItem2.Metadata.Add(\"key1\", \"value1\");\n+            var hashSdkItem2 = sdkResultItem2.GetHashCode();\n+\n+            Assert.True(hashSdkItem1 == hashSdkItem2);",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                return Metadata.All(m => item.Metadata?.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\r\n```",
              "createdAt": "2021-09-21T23:17:44Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind \r\n\r\nif I apply your suggestion, I get this error compile\"\r\n``` \r\nOperator '&&' cannot be applied to operands of type 'bool?' and 'bool'\r\n```\r\n\r\nBecause I think this part `item.Metadata?.TryGetValue(m.Key, out var itemValue)` is evaluated to bool? instead of bool.\r\n\r\nPlease elaborate or confirm...\r\n",
              "createdAt": "2021-09-22T00:02:45Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "@Forgind \r\n\r\nPlease review the failing CI build too, if you don't mind..\r\nI have no clue which failing tests causing the error/failures.",
              "createdAt": "2021-09-22T00:35:26Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Never mind, I have found the cause. \r\nI welcome further review, and the confirmation about your suggested change above. \ud83d\ude42 ",
              "createdAt": "2021-09-22T00:48:02Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Ah, that's true. You can check if the TryGetValue equals true, and that should resolve it.",
              "createdAt": "2021-09-22T03:21:11Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks! resolving this now.",
              "createdAt": "2021-09-22T19:38:59Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();\r\n```",
              "createdAt": "2021-09-21T23:18:29Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key.GetHashCode()}: {(kvp.Value ?? \"V\").GetHashCode()}\".GetHashCode();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks! Applying your suggestion now.",
              "createdAt": "2021-09-21T23:53:09Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -36,33 +41,21 @@ public override bool Equals(object obj)\n                    ItemSpec == item.ItemSpec &&\n                    Metadata?.Count == item.Metadata?.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key.GetHashCode()}: {(kvp.Value ?? \"V\").GetHashCode()}\".GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                   Metadata?.Count == item.Metadata?.Count)\r\n```\r\n\r\nYou'll presumably need this too before removing the `?? new Dictionary...` part.",
              "createdAt": "2021-09-22T03:23:15Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind \r\n\r\nLet me see... \r\nSo do you think we should change the line `?? new DIctionary..` to be `Metadata = metadata` and then decide that Metadata may be passed with null value on the 2nd constructor that has Metadata as parameter?\r\n\r\nIf this is true, then I have to update the SdkResultItem unit test of this to ShouldNotBe like this (using diff):\r\n\r\n``` diff\r\n        [Fact]\r\n        public void SdkResultItem_Equal_CtorParam_MetadataNull()\r\n        {\r\n            var sdkResultItem1 = new SdkResultItem(\"anyspec\", new Dictionary<string, string>());\r\n            var sdkResultItem2 = new SdkResultItem(\"anyspec\", null);\r\n\r\n-            // Should bt the same, because passed null metadata will have value of new Dictionnary<String,String> like sdkResultItem1\r\n-            sdkResultItem1.ShouldBe(sdkResultItem2);\r\n+           // Should not be the same, because passing metadata = null is allowed and the Metadata property value allows null.\r\n+           sdkResultItem1.ShouldNotBe(sdkResultItem2);\r\n        }\r\n```\r\n\r\nPlease confirm. Thanks in advance!",
              "createdAt": "2021-09-22T20:30:12Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Yes, correct. We want to allow Metadata to be null.",
              "createdAt": "2021-09-22T20:41:46Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "ok, I have updated the code (but I haven't pushed yet) so now it looks like this:\r\n\r\n```\r\n        public override bool Equals(object obj)\r\n        {\r\n            if (obj is SdkResultItem item &&\r\n                   ItemSpec == item.ItemSpec &&\r\n                   Metadata?.Count == item.Metadata?.Count)\r\n            {\r\n                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\r\n            }\r\n            return false;\r\n        }\r\n```\r\nBut now this line: \r\n```\r\nreturn Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\r\n```\r\ncause this warning: `Dereference of a possibly null reference.` especially on `Item.Metadata.TryGetValue(...` which I think that warning in Visual Stdio and as error CI as pictured below:\r\n\r\n![image](https://user-images.githubusercontent.com/8773147/134422537-551466e4-4636-44e7-aca9-31294836ee35.png)\r\n\r\nin CI:\r\n\r\n![image](https://user-images.githubusercontent.com/8773147/134423605-d0e7a7d6-6e90-4542-bb1a-8a25313b4baf.png)\r\n\r\n\r\nIf I change to `item.Metadata?.TryGetValue(...` then I will get error of can't convert bool? to bool again.\r\nBelow is the error captured:\r\n\r\n![image](https://user-images.githubusercontent.com/8773147/134422774-7793eac0-a967-4806-b46b-4cfdfe3cf2b3.png)\r\n\r\nPlease confirm. I'm a bit confused now, because now I'm back to previous compile errors I mentioned before (both deference and the can't convert `bool?` to `bool` error)\r\n",
              "createdAt": "2021-09-22T21:03:06Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Ok, so we want Metadata to be able to be null. The compiler (with nullable enabled) looks for anything that can possibly be null and ensures that you verify that it isn't null before you try to dereference it because otherwise you could get an exception at runtime.\r\n\r\nIf Metadata can be null, then calling `TryGetValue` on item.Metadata is calling a function from something that might be null\u2014it's dereferencing a null value.\r\n\r\nWhen you add the `?`, that checks if it's null and only calls the function afterwards if it isn't. If it is, it skips the function call and replace it with null.\r\n\r\nBecause we are in a nullable-enabled environment, the compiler is still looking for things that can possibly be null and annotating them as such. TryGetValue normally returns a normal bool, i.e., not null. Because we had item.Metadata?.TryGetValue, it will either return a bool from TryGetValue _or_ skip the TryGetValue and return null because Metadata is null. Returning something that is either null or a bool is returning a bool? or nullable bool.\r\n\r\nThe && operator cannot take in null because it isn't exactly true but it also isn't exactly false. We need a way to convert a bool? into a bool without possibly throwing an error if it is null.\r\n\r\nNormally, it's pointless to say, for instance, `if (<bool value> == True)` because the bool value is already either true or false. However, with a bool?, it can be true, false, or null. Checking explicitly if it == True (or == False) is a check that it is _not_ null _and_ that it is the value you're checking. For them to be equal, we need all the metadata to be the same, which means it cannot be null if our metadata is not null, and it must have the value, so TryGetValue has to return true. Checking item.Metadata?.TryGetValue(m.Key, out var itemValue) == True covers both of those cases at the same time.\r\n\r\nIf you want to make this easier to understand, you can also explicitly check if either is null at the top, then cast them to non-null Dictionaries and compare them as such.\r\n\r\nDoes that make more sense?",
              "createdAt": "2021-09-22T21:23:57Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind \r\n\r\nMany thanks! Makes sense now, and my confusion is gone.\r\n\r\nbased on this:\r\n> If you want to make this easier to understand, you can also explicitly check if either is null at the top, then cast them to non-null Dictionaries and compare them as such.\r\n\r\nI have updated that code to be like this checking of `item.Metadata  == null` is within the if clauses) since this also remove the dereference warning (imho the logic feels cleaner cmiiw)\r\n\r\n```\r\n        public override bool Equals(object obj)\r\n        {\r\n            if (obj is SdkResultItem item &&\r\n                   ItemSpec == item.ItemSpec &&\r\n                   item.Metadata != null &&\r\n                   Metadata?.Count == item.Metadata.Count)\r\n            {\r\n                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\r\n            }\r\n            return false;\r\n        }\r\n```\r\nIf you are ok, I will commit that with the updated unit test to use `ShouldNotBe`.\r\n\r\nAgain, many thanks for the explanation and patience! ",
              "createdAt": "2021-09-22T21:42:26Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "I think I've committed my proposal now, including the updated unit test in commit https://github.com/dotnet/msbuild/pull/6839/commits/c9b444cd0a184ef12dc6f08f27527db26e701bcb\r\n\r\nSo we could quickly examine the change I proposed. Also I need to check the CI so to ensure I have no compile errors.\r\n\r\nIf you have additional feedback, I'll update them again.\r\n\r\nThanks in advance!\r\n_PS: I pushed again to include updated unit test, oh my I pushed too fast..._",
              "createdAt": "2021-09-22T22:05:43Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "It looks like you're still asserting that Metadata is not null by declaring it with:\r\n`public Dictionary<string, string> Metadata { get;}`\r\ninstead of\r\n`public Dictionary<string, string>? Metadata { get;}`\r\n\r\nIf you add that in and don't give it a starting value if it's null, it should break again at the top of equals because you never verify that this.Metadata is not null. (Also, tiny nit: you can technically override the `==` method, so we prefer to use `is null` and `is not null`.)",
              "createdAt": "2021-09-22T22:25:14Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nice catch! thanks!\r\n\r\nI've updated the code.",
              "createdAt": "2021-09-22T22:36:38Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "@Forgind \r\n\r\nDone updating the code and applying to use `is not null`. CI is green.\r\nPlease review.\r\n\r\nHopefully this meet the feedback \ud83d\ude42 \r\nThanks!",
              "createdAt": "2021-09-22T23:57:28Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Can you make the parameter metadata (for the second constructor on line 33) nullable?",
              "createdAt": "2021-09-23T15:30:35Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind \r\n\r\nDone. Thanks",
              "createdAt": "2021-09-23T15:50:38Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Looks good. If this passes CI, I'm happy \ud83d\ude42",
              "createdAt": "2021-09-23T15:56:17Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "CI is all green now \ud83d\ude42 ",
              "createdAt": "2021-09-23T16:34:04Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "@Forgind \r\nNow that the CI is all green, is there anything else I should check?",
              "createdAt": "2021-09-23T17:38:22Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "just to nudge/remind, \r\nanything else for me to check? or do I have to wait for other PR to be reviewed and merged before this PR?\r\nsorry to always asking you folks. \ud83d\ude4f \r\nit's ok if this PR may wait for other PRs or if you're busy. \ud83d\ude42 \r\nbecause my team need this fix, so hopefully next week I could use new msbuild that has this fix.\r\n\r\nokay, I'm going to step back and check this PR tomorrow. :wave:\r\nmany thanks for your guidance and patience, folks!\r\n\r\n@Forgind  @rainersigwald @BenVillalobos ",
              "createdAt": "2021-09-23T21:48:26Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "> my team need this fix\r\n\r\nCan you elaborate on how you're seeing this at all? From the original bug it looked like a code-inspection discovered problem that was purely theoretical.",
              "createdAt": "2021-09-23T22:11:49Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@rainersigwald \r\nI need this to compare `SdkResultItem` reliably, because ,my team and I have some scenarios that use comparison of this SdkResultItem. \r\nSorry, I could not disclose the further detail of the scenario. \ud83d\ude4f \r\n\r\nI'll use my own msbuild repo while waiting for this to be reviewed further, then. No need to rush, folks.\r\nThanks again! \ud83d\udc4d ",
              "createdAt": "2021-09-23T22:29:08Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "I'd wait for rainersigwald to sign off too; if he does, we can merge this.",
              "createdAt": "2021-09-23T23:42:18Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -27,42 +33,30 @@ public SdkResultItem()\n         public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)\n         {\n             ItemSpec = itemSpec;\n-            Metadata = metadata;\n+            Metadata = metadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n         }\n \n         public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   Metadata?.Count == item.Metadata.Count)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Hmm...I hadn't noticed this, but it implies that ItemSpec is supposed to be able to be null\u2014in theory, at least. With the #nullable check, that would prevent the second constructor from letting you pass in a null itemspec, right? I don't think anyone is doing that, but theoretically a breaking change? I don't think it's actually something we should really worry about, but tiny nit:\r\n```suggestion\r\n            ItemSpec = string.Empty;\r\n```\r\n\r\ndoesn't allocate a new string.",
              "createdAt": "2021-09-22T03:26:00Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -16,6 +21,7 @@ public class SdkResultItem\n \n         public SdkResultItem()\n         {\n+            ItemSpec = \"\";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks! apply this now.",
              "createdAt": "2021-09-22T19:37:18Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -16,6 +21,7 @@ public class SdkResultItem\n \n         public SdkResultItem()\n         {\n+            ItemSpec = \"\";",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a way to do this without allocating a new string? Allocation is generally a bad thing in `GetHashCode()` (I'm not sure it's critical here though).",
              "createdAt": "2021-09-23T22:29:18Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@rainersigwald \r\nCould I use StringBuilder to minimize allocations?",
              "createdAt": "2021-09-24T15:50:51Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "No, that doesn't really help (and probably hurts). The compiler turns this into a single call to `String.Concat` which can do this with a single allocation: https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABADAAgwRhQG4BYAKHIwGY8AmHAYRwG9yd28aDcBZACgDSMAJ4A1AIYAbAK4wACuICWUADzcANHnxYAfDgDWANwAOAShZsOVjAHYcAEgBEzI8YB0Q4QF8QLV24kZGBwAfhCcR1FHL0dSMisvci8gA=\r\n\r\nBut for computing the hashcode, there shouldn't be a need for any allocations.",
              "createdAt": "2021-09-24T15:55:51Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "You could probably change this to hashCode ^= kvp.Key.GetHashCode() * ((kvp.Value ?? \"V\").GetHashCode() + 1); and avoid allocations while ignoring order, maintaining association importance, and differentiating between keys and values.",
              "createdAt": "2021-09-24T16:03:20Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`kvp.Key.GetHashCode()` is wrong. Because the metadata dictionary uses OrdinalIgnoreCase comparison for the keys, GetHashCode() must do the same; please see <https://github.com/dotnet/msbuild/issues/6750#issuecomment-898233796>.\r\n\r\nDoes this project already reference an assembly that provides [HashCode.Combine](https://docs.microsoft.com/dotnet/api/system.hashcode.combine?view=dotnet-plat-ext-3.1#System_HashCode_Combine__2___0___1_)?",
              "createdAt": "2021-09-27T09:05:51Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "KalleOlaviNiemitalo"
              }
            },
            {
              "body": "You're right about the case sensitivity weirdness, and it would be good to fix that, but it wasn't correct before, and eriawan said they planned just to resolve the first few bullets, so I'm assuming we're leaving that for a later PR. Is that correct, @eriawan?\r\n\r\nNo, I don't think so, though I agree it would be nice here.",
              "createdAt": "2021-09-27T14:30:06Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind \r\n\r\nYes, my initial plan was to leave the case sensitivity issue in GetHashCode for later PR.\r\nDo you want that to be solved too?\r\nWe still have allocation problem in GetHashCode when we add \"V\" for example. This still needs to be solved, as suggested by @rainersigwald \r\n",
              "createdAt": "2021-09-27T16:41:40Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            },
            {
              "body": "Apparently you can just say OrdinalIgnoreCase.GetHashCode(<string>), and it will get you a case-insensitive hash.\r\n\r\n> hashCode ^= kvp.Key.GetHashCode() * ((kvp.Value ?? \"V\").GetHashCode() + 1);\r\n\r\nThis was my suggestion to get away from the allocation.",
              "createdAt": "2021-10-04T16:25:32Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind \r\n\r\nbranch rebased to main, and GetHashCode updated. \r\nThere were failing unit tests, but those failed tests aren't related to my updates at all.\r\nPlease review, thanks in advance! \ud83d\ude4f ",
              "createdAt": "2021-11-17T16:09:54Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= $\"{kvp.Key}: {kvp.Value ?? \"V\"}\".GetHashCode();",
              "author": {
                "login": "eriawan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this was the complete suggestion (to avoid the allocation)\r\n```suggestion\r\n                    hashCode ^= StringComparer.OrdinalIgnoreCase.GetHashCode(kvp.Key) * (StringComparer.OrdinalIgnoreCase.GetHashCode(kvp.Value ?? \"V\") + 1);\r\n```",
              "createdAt": "2021-11-17T16:41:54Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= StringComparer.OrdinalIgnoreCase.GetHashCode($\"{kvp.Key}: {kvp.Value ?? \"V\"}\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Did we discuss whether the value should be IgnoreCase or not? I agree the key should be but I'm less sure on the value.",
              "createdAt": "2021-11-23T23:28:29Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= StringComparer.OrdinalIgnoreCase.GetHashCode(kvp.Key) * (StringComparer.OrdinalIgnoreCase.GetHashCode(kvp.Value ?? \"V\") + 1);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't think we talked about it. Maybe doesn't matter? I'm not sure.",
              "createdAt": "2021-11-24T00:02:47Z",
              "path": "src/Framework/Sdk/SdkResultItem.cs",
              "diffHunk": "@@ -34,35 +40,24 @@ public override bool Equals(object obj)\n         {\n             if (obj is SdkResultItem item &&\n                    ItemSpec == item.ItemSpec &&\n-                   Metadata?.Count == item.Metadata?.Count)\n+                   item.Metadata is not null &&\n+                   Metadata?.Count == item.Metadata.Count)\n             {\n-                if (Metadata != null)\n-                {\n-                    foreach (var kvp in Metadata)\n-                    {\n-                        if (item.Metadata[kvp.Key] != kvp.Value)\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                }\n-\n-                return true;\n+                return Metadata.All(m => item.Metadata.TryGetValue(m.Key, out var itemValue) && itemValue == m.Value);\n             }\n             return false;\n         }\n \n         public override int GetHashCode()\n         {\n             int hashCode = -849885975;\n-            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);\n+            hashCode = hashCode ^ ItemSpec.GetHashCode();\n \n             if (Metadata != null)\n             {\n                 foreach (var kvp in Metadata)\n                 {\n-                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();\n-                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();\n+                    hashCode ^= StringComparer.OrdinalIgnoreCase.GetHashCode(kvp.Key) * (StringComparer.OrdinalIgnoreCase.GetHashCode(kvp.Value ?? \"V\") + 1);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}