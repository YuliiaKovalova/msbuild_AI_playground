{
  "number": 4463,
  "title": "[Static graph] Instantiate graph from solution",
  "body": "Supports:\r\n- convert solution projects to graph entry points\r\n- solution only dependencies are injected into the graph\r\n- solution configurations to project configurations mapping via global properties\r\n\r\nDoes not support:\r\n- solution only global properties like SolutionPath\r\n- nested solutions (ProjectReference to sln)\r\n- before / after solution magical imports\r\n- multiple entry points when a solution is present\r\n- select individual projects via solution (/t:\"1:Clean\")",
  "state": "MERGED",
  "createdAt": "2019-06-21T23:51:54Z",
  "updatedAt": "2020-12-30T22:53:52Z",
  "closedAt": "2019-08-06T20:20:57Z",
  "mergedAt": "2019-08-06T20:20:57Z",
  "additions": 2024,
  "deletions": 247,
  "changedFiles": 28,
  "headRefName": "solutionSupportForStaticGraph",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "16e08ea838277d3ad90abcfe670798712d383723",
          "message": "Clarify how project collection influences graph global properties",
          "committedDate": "2019-07-09T17:16:18Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9bca6ac70165c0fced0dc3920fd0439e5b1d77d3",
          "message": "Decrement pending count on exceptions",
          "committedDate": "2019-07-09T22:05:07Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59478bbd5ac4a0dc3a1af460d9477a89b85923f1",
          "message": "Solution support for ProjectGraph",
          "committedDate": "2019-07-09T22:05:23Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e51ee797dcdf4b56641a9d54316bd365d298d37",
          "message": "Separate edge connection from cycle detection\n\nThis separation allows adding multiple steps that add/remove edges followed by one single step of checking for cycles.",
          "committedDate": "2019-07-09T22:53:09Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "64c46da5400a28a874aac40d9db9050f4cc3c0d1",
          "message": "Integrate solution dependencies in static graph",
          "committedDate": "2019-07-09T23:09:07Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f6c4efc4bdcbabbba139cba95d7a671f9bd42f89",
          "message": "reset ProjectInSolution cached state on mutation",
          "committedDate": "2019-07-17T18:56:16Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "607723f865e4612882d15366350171d97d430906",
          "message": "whitespace updates",
          "committedDate": "2019-07-17T19:01:09Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "977c5545e158c0dc0bd88f4152e12b480b821831",
          "message": "update resx",
          "committedDate": "2019-07-17T20:08:04Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d44b39e8ae04f1ea7ee6b7ebc521c9df3285f072",
          "message": "extract SolutionFileBuilder",
          "committedDate": "2019-07-17T20:13:52Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "708be897d290f63ed3b706d45f02bd7899847e79",
          "message": "hardcode solution version",
          "committedDate": "2019-07-17T20:18:35Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39a9901336e74de1f59932abceddb2c04ea74751",
          "message": "fix typos",
          "committedDate": "2019-07-17T20:31:40Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Notes:\r\n\r\n* Caveats are ok\r\n* @AndyGerlicher reports that this works for this repo. But it shouldn't, because Arcade builds a solution as a ProjectReference. @cdmihai can you chase that down please?",
        "createdAt": "2019-07-16T20:33:06Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> @AndyGerlicher Andy Gerlicher FTE reports that this works for this repo. But it shouldn't, because Arcade builds a solution as a ProjectReference. @cdmihai Mihai Codoban FTE can you chase that down please?\r\n\r\nIt turns out the graph based build wasn't getting propagated to the actual build. Once we fixed that, it started failing for other reasons, so no connection to this PR.",
        "createdAt": "2019-07-17T20:31:00Z",
        "author": {
          "login": "cdmihai"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think `ToolsVersion` is actually part of it. Unless things changed from the initial design.",
              "createdAt": "2019-07-01T19:36:10Z",
              "path": "src/Build/Graph/ProjectGraphNode.cs",
              "diffHunk": "@@ -3,13 +3,15 @@\n \n using System.Collections.Generic;\n using System.Diagnostics;\n+using Microsoft.Build.BackEnd;\n using Microsoft.Build.Execution;\n using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.Experimental.Graph\n {\n     /// <summary>\n     /// Represents the node for a particular project in a project graph.\n+    /// A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "[They do contribute to the project's unique ID](https://github.com/cdmihai/msbuild/blob/2c7610b154bce223bfefadd147109aac2c631160/src/Build/BackEnd/Shared/ConfigurationMetadata.cs#L165-L168), but now that we're practically ignoring ToolsVersion all over the place it's not that important anymore.",
              "createdAt": "2019-07-01T19:46:55Z",
              "path": "src/Build/Graph/ProjectGraphNode.cs",
              "diffHunk": "@@ -3,13 +3,15 @@\n \n using System.Collections.Generic;\n using System.Diagnostics;\n+using Microsoft.Build.BackEnd;\n using Microsoft.Build.Execution;\n using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.Experimental.Graph\n {\n     /// <summary>\n     /// Represents the node for a particular project in a project graph.\n+    /// A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@ccastanedaucf I had to put the decrement in a finally block, otherwise an exception from `workItem.Value` would miss the decrement, and block the main thread forever. Probably a good idea to move this to qb as well?",
              "createdAt": "2019-07-09T23:23:33Z",
              "path": "src/Build/Graph/ParallelWorkSet.cs",
              "diffHunk": "@@ -188,8 +188,14 @@ private void ExecuteWorkItem()\n         {\n             if (_queue.TryDequeue(out Lazy<TResult> workItem))\n             {\n-                TResult _ = workItem.Value;\n-                Interlocked.Decrement(ref _pendingCount);\n+                try\n+                {\n+                    TResult _ = workItem.Value;\n+                }\n+                finally\n+                {\n+                    Interlocked.Decrement(ref _pendingCount);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Sounds good, I also caught this today in a branch I have where I'm filling out unit tests for ParallelWorkSet",
              "createdAt": "2019-07-09T23:28:30Z",
              "path": "src/Build/Graph/ParallelWorkSet.cs",
              "diffHunk": "@@ -188,8 +188,14 @@ private void ExecuteWorkItem()\n         {\n             if (_queue.TryDequeue(out Lazy<TResult> workItem))\n             {\n-                TResult _ = workItem.Value;\n-                Interlocked.Decrement(ref _pendingCount);\n+                try\n+                {\n+                    TResult _ = workItem.Value;\n+                }\n+                finally\n+                {\n+                    Interlocked.Decrement(ref _pendingCount);",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "Nice. Maybe worth considering pulling the class into a separate repo with it's own nuget package :)",
              "createdAt": "2019-07-10T00:14:05Z",
              "path": "src/Build/Graph/ParallelWorkSet.cs",
              "diffHunk": "@@ -188,8 +188,14 @@ private void ExecuteWorkItem()\n         {\n             if (_queue.TryDequeue(out Lazy<TResult> workItem))\n             {\n-                TResult _ = workItem.Value;\n-                Interlocked.Decrement(ref _pendingCount);\n+                try\n+                {\n+                    TResult _ = workItem.Value;\n+                }\n+                finally\n+                {\n+                    Interlocked.Decrement(ref _pendingCount);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For both of these, can the `ProjectInSolution` be mutated after the first call? Does there need to be invalidation of the `AsReadonly` member?",
              "createdAt": "2019-07-10T15:27:23Z",
              "path": "src/Build/Construction/Solution/ProjectInSolution.cs",
              "diffHunk": "@@ -176,13 +178,16 @@ internal set\n         /// List of guids, in \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\" form, mapping to projects \n         /// that this project has a build order dependency on, as defined in the solution file. \n         /// </summary>\n-        public IReadOnlyList<string> Dependencies => _dependencies.AsReadOnly();\n+        public IReadOnlyList<string> Dependencies => _dependenciesAsReadonly ?? (_dependenciesAsReadonly = _dependencies.AsReadOnly());",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "True, I'll reset them on mutation.",
              "createdAt": "2019-07-17T18:56:38Z",
              "path": "src/Build/Construction/Solution/ProjectInSolution.cs",
              "diffHunk": "@@ -176,13 +178,16 @@ internal set\n         /// List of guids, in \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\" form, mapping to projects \n         /// that this project has a build order dependency on, as defined in the solution file. \n         /// </summary>\n-        public IReadOnlyList<string> Dependencies => _dependencies.AsReadOnly();\n+        public IReadOnlyList<string> Dependencies => _dependenciesAsReadonly ?? (_dependenciesAsReadonly = _dependencies.AsReadOnly());",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n```",
              "createdAt": "2019-07-10T15:40:16Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -315,12 +305,49 @@ public void ConstructBigGraphWithCycle()\n                 CreateProjectFile(env, 8);\n                 CreateProjectFile(env, 9);\n                 CreateProjectFile(env, 10);\n-                var projectsInCycle = new List<string>(){proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };\n+                var projectsInCycle = new List<string> {proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };\n                 var errorMessage = GraphBuilder.FormatCircularDependencyError(projectsInCycle);\n                 Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(errorMessage.ToString());\n             }\n         }\n \n+        [Fact]\n+        public void ProjectCollectionShouldNotInfluenceGlobalProperties()\n+        {\n+            var entryFile1 = CreateProjectFile(_env, 1, new[] { 3 ,4 });\n+            var entryFile2 = CreateProjectFile(_env, 2, new []{ 4, 5 });\n+            CreateProjectFile(_env, 3);\n+            CreateProjectFile(_env, 4);\n+            CreateProjectFile(_env, 5);\n+\n+",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            var entryFile1 = CreateProjectFile(_env, 1, new[] { 3, 4 });\r\n```",
              "createdAt": "2019-07-10T15:40:32Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -315,12 +305,49 @@ public void ConstructBigGraphWithCycle()\n                 CreateProjectFile(env, 8);\n                 CreateProjectFile(env, 9);\n                 CreateProjectFile(env, 10);\n-                var projectsInCycle = new List<string>(){proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };\n+                var projectsInCycle = new List<string> {proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };\n                 var errorMessage = GraphBuilder.FormatCircularDependencyError(projectsInCycle);\n                 Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(errorMessage.ToString());\n             }\n         }\n \n+        [Fact]\n+        public void ProjectCollectionShouldNotInfluenceGlobalProperties()\n+        {\n+            var entryFile1 = CreateProjectFile(_env, 1, new[] { 3 ,4 });",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the case I'm not seeing where this fires but the first two conditions don't?",
              "createdAt": "2019-07-10T15:45:15Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -1276,19 +1274,21 @@ internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDic\n                 });\n         }\n \n-        internal static void ShouldBeEquivalentTo<K, V>(this IReadOnlyDictionary<K, V> a, IReadOnlyDictionary<K, V> b)\n+        internal static void ShouldBeEquivalentTo<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)\n         {\n             a.ShouldBeSubsetOf(b);\n             b.ShouldBeSubsetOf(a);\n+            a.Count.ShouldBe(b.Count);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Order does not matter, but count does. `[1,2,3]` is equivalent to `[3,2,1]`, but `[1,2,3]` is not equivalent to `[1, 1, 2, 2, 3, 3]`. For when neither order nor count is important, there's `ShouldBeSetEquivalentTo`",
              "createdAt": "2019-07-17T18:59:50Z",
              "path": "src/Shared/UnitTests/ObjectModelHelpers.cs",
              "diffHunk": "@@ -1276,19 +1274,21 @@ internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDic\n                 });\n         }\n \n-        internal static void ShouldBeEquivalentTo<K, V>(this IReadOnlyDictionary<K, V> a, IReadOnlyDictionary<K, V> b)\n+        internal static void ShouldBeEquivalentTo<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)\n         {\n             a.ShouldBeSubsetOf(b);\n             b.ShouldBeSubsetOf(a);\n+            a.Count.ShouldBe(b.Count);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    <value>MSB4261: A static graph that includes a solution must have that solution as its only entry point. Multiple entry points detected: {0}</value>\r\n```\r\n\r\n? I still don't love the clarity level.",
              "createdAt": "2019-07-10T15:46:57Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1769,13 +1769,35 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} and {1} are file paths\n     </comment>\n   </data>\n+  <data name=\"StaticGraphAcceptsSingleSolutionEntryPoint\" UESanitized=\"false\" Visibility=\"Public\">\n+    <value>MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</value>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "What about now?",
              "createdAt": "2019-07-17T20:32:31Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1769,13 +1769,35 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n       LOCALIZATION: {0} and {1} are file paths\n     </comment>\n   </data>\n+  <data name=\"StaticGraphAcceptsSingleSolutionEntryPoint\" UESanitized=\"false\" Visibility=\"Public\">\n+    <value>MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</value>",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "extract to its own file?",
              "createdAt": "2019-07-16T19:28:50Z",
              "path": "src/Build.UnitTests/Graph/GraphTestingUtilities.cs",
              "diffHunk": "@@ -0,0 +1,400 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+\n+namespace Microsoft.Build.Experimental.Graph.UnitTests\n+{\n+    internal static class GraphTestingUtilities\n+    {\n+        public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, \"true\"}}.ToImmutableDictionary();\n+\n+        public static readonly string InnerBuildPropertyName = \"InnerBuild\";\n+\n+        public static readonly string MultitargetingSpecification = $@\"<PropertyGroup>\n+                                                                        <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>\n+                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>\n+                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>\n+                                                                     </PropertyGroup>\";\n+\n+        public static void AssertOuterBuildAsNonRoot(\n+            ProjectGraphNode outerBuild,\n+            ProjectGraph graph,\n+            Dictionary<string, string> additionalGlobalProperties = null,\n+            int expectedInnerBuildCount = 2)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p) \n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(expectedInnerBuildCount);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+\n+                    innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);\n+                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);\n+\n+                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();\n+\n+                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];\n+                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];\n+\n+                    edgeToOuterBuild.ShouldBe(edgeToInnerBuild);\n+                }\n+            }\n+        }\n+\n+        public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();\n+        }\n+\n+        public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        public static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildPropertyName);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildPropertyName, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        internal static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        internal static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        internal static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        internal static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph graph, int projectNum)\n+        {\n+            return GetNodesWithProjectNumber(graph, projectNum).First();\n+        }\n+\n+        internal static IEnumerable<ProjectGraphNode> GetNodesWithProjectNumber(ProjectGraph graph, int projectNum)\n+        {\n+            return graph.ProjectNodes.Where(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        }\n+\n+        internal static ProjectGraphNode GetOuterBuild(ProjectGraph graph, int projectNumber)\n+        {\n+            return GetNodesWithProjectNumber(graph, projectNumber).FirstOrDefault(IsOuterBuild);\n+        }\n+\n+        internal static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGraph graph, int projectNumber)\n+        {\n+            var outerBuild = GetOuterBuild(graph, projectNumber);\n+\n+            if (outerBuild == null)\n+            {\n+                return ImmutableArray<ProjectGraphNode>.Empty;\n+            }\n+            else\n+            {\n+                var innerBuilds = GetNodesWithProjectNumber(graph, projectNumber)\n+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath.Equals(outerBuild.ProjectInstance.FullPath))\n+                    .ToArray();\n+\n+                innerBuilds.ShouldNotBeEmpty();\n+\n+                return innerBuilds;\n+            }\n+        }\n+\n+        internal static string GetProjectFileName(ProjectGraphNode node)\n+        {\n+            node.ShouldNotBeNull();\n+            return Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);\n+        }\n+\n+        internal static string GetProjectFileName(ConfigurationMetadata config)\n+        {\n+            config.ShouldNotBeNull();\n+            return Path.GetFileNameWithoutExtension(config.ProjectFullPath);\n+        }\n+\n+        internal static int GetProjectNumber(ProjectGraphNode node)\n+        {\n+            node.ShouldNotBeNull();\n+            return int.Parse(GetProjectFileName(node));\n+        }\n+\n+        internal static int GetProjectNumber(ConfigurationMetadata config)\n+        {\n+            config.ShouldNotBeNull();\n+            return int.Parse(GetProjectFileName(config));\n+        }\n+\n+        internal static string GetProjectPath(ProjectGraphNode node)\n+        {\n+            node.ShouldNotBeNull();\n+            return node.ProjectInstance.FullPath;\n+        }\n+\n+        internal static TransientTestFile CreateProjectFile(\n+            TestEnvironment env,\n+            int projectNumber,\n+            int[] projectReferences = null,\n+            Dictionary<string, string[]> projectReferenceTargets = null,\n+            string defaultTargets = null,\n+            string extraContent = null\n+            )\n+        {\n+            return Helpers.CreateProjectFile(\n+                env,\n+                projectNumber,\n+                projectReferences,\n+                projectReferenceTargets,\n+                // Use \"Build\" when the default target is unspecified since in practice that is usually the default target.\n+                defaultTargets ?? \"Build\",\n+                extraContent);\n+        }\n+    }\n+\n+    internal class SolutionFileBuilder",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since the content of the file is fairly fixed I think it'd be more accurate to pin this at the version that you took the format from.",
              "createdAt": "2019-07-16T19:32:07Z",
              "path": "src/Build.UnitTests/Graph/GraphTestingUtilities.cs",
              "diffHunk": "@@ -0,0 +1,400 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+\n+namespace Microsoft.Build.Experimental.Graph.UnitTests\n+{\n+    internal static class GraphTestingUtilities\n+    {\n+        public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, \"true\"}}.ToImmutableDictionary();\n+\n+        public static readonly string InnerBuildPropertyName = \"InnerBuild\";\n+\n+        public static readonly string MultitargetingSpecification = $@\"<PropertyGroup>\n+                                                                        <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>\n+                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>\n+                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>\n+                                                                     </PropertyGroup>\";\n+\n+        public static void AssertOuterBuildAsNonRoot(\n+            ProjectGraphNode outerBuild,\n+            ProjectGraph graph,\n+            Dictionary<string, string> additionalGlobalProperties = null,\n+            int expectedInnerBuildCount = 2)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p) \n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(expectedInnerBuildCount);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+\n+                    innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);\n+                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);\n+\n+                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();\n+\n+                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];\n+                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];\n+\n+                    edgeToOuterBuild.ShouldBe(edgeToInnerBuild);\n+                }\n+            }\n+        }\n+\n+        public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();\n+        }\n+\n+        public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        public static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildPropertyName);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildPropertyName, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        internal static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        internal static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        internal static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        internal static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph graph, int projectNum)\n+        {\n+            return GetNodesWithProjectNumber(graph, projectNum).First();\n+        }\n+\n+        internal static IEnumerable<ProjectGraphNode> GetNodesWithProjectNumber(ProjectGraph graph, int projectNum)\n+        {\n+            return graph.ProjectNodes.Where(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        }\n+\n+        internal static ProjectGraphNode GetOuterBuild(ProjectGraph graph, int projectNumber)\n+        {\n+            return GetNodesWithProjectNumber(graph, projectNumber).FirstOrDefault(IsOuterBuild);\n+        }\n+\n+        internal static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGraph graph, int projectNumber)\n+        {\n+            var outerBuild = GetOuterBuild(graph, projectNumber);\n+\n+            if (outerBuild == null)\n+            {\n+                return ImmutableArray<ProjectGraphNode>.Empty;\n+            }\n+            else\n+            {\n+                var innerBuilds = GetNodesWithProjectNumber(graph, projectNumber)\n+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath.Equals(outerBuild.ProjectInstance.FullPath))\n+                    .ToArray();\n+\n+                innerBuilds.ShouldNotBeEmpty();\n+\n+                return innerBuilds;\n+            }\n+        }\n+\n+        internal static string GetProjectFileName(ProjectGraphNode node)\n+        {\n+            node.ShouldNotBeNull();\n+            return Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);\n+        }\n+\n+        internal static string GetProjectFileName(ConfigurationMetadata config)\n+        {\n+            config.ShouldNotBeNull();\n+            return Path.GetFileNameWithoutExtension(config.ProjectFullPath);\n+        }\n+\n+        internal static int GetProjectNumber(ProjectGraphNode node)\n+        {\n+            node.ShouldNotBeNull();\n+            return int.Parse(GetProjectFileName(node));\n+        }\n+\n+        internal static int GetProjectNumber(ConfigurationMetadata config)\n+        {\n+            config.ShouldNotBeNull();\n+            return int.Parse(GetProjectFileName(config));\n+        }\n+\n+        internal static string GetProjectPath(ProjectGraphNode node)\n+        {\n+            node.ShouldNotBeNull();\n+            return node.ProjectInstance.FullPath;\n+        }\n+\n+        internal static TransientTestFile CreateProjectFile(\n+            TestEnvironment env,\n+            int projectNumber,\n+            int[] projectReferences = null,\n+            Dictionary<string, string[]> projectReferenceTargets = null,\n+            string defaultTargets = null,\n+            string extraContent = null\n+            )\n+        {\n+            return Helpers.CreateProjectFile(\n+                env,\n+                projectNumber,\n+                projectReferences,\n+                projectReferenceTargets,\n+                // Use \"Build\" when the default target is unspecified since in practice that is usually the default target.\n+                defaultTargets ?? \"Build\",\n+                extraContent);\n+        }\n+    }\n+\n+    internal class SolutionFileBuilder\n+    {\n+        public static readonly IReadOnlyCollection<SolutionConfigurationInSolution> SolutionConfigurationPlatformsDefaults = new[]\n+        {\n+            new SolutionConfigurationInSolution(\"Debug\", \"AnyCPU\"),\n+            new SolutionConfigurationInSolution(\"Release\", \"AnyCPU\")\n+        };\n+\n+        /// <summary>\n+        /// projectName -> projectPath\n+        /// </summary>\n+        public IReadOnlyDictionary<string, string> Projects { get; set; }\n+\n+        public IReadOnlyCollection<SolutionConfigurationInSolution> SolutionConfigurationPlatforms { get; set; } = SolutionConfigurationPlatformsDefaults;\n+\n+        public Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> ProjectConfigurations { get; set; }\n+\n+        public (string, string)[] SolutionDependencies { get; set; }\n+        public (string, string[])[] SolutionDependenciesProjectNameToGuids { get; set; }\n+\n+        private readonly struct ProjectInfo\n+        {\n+            private readonly List<ProjectInfo> _dependencies;\n+            private readonly List<string> _dependencyGuids;\n+            public string Name { get; }\n+            public string Path { get; }\n+            public string ProjectTypeGuid { get; }\n+            public string Guid { get; }\n+\n+            public IReadOnlyCollection<ProjectInfo> Dependencies => _dependencies;\n+\n+            public IReadOnlyCollection<string> DependencyGuids => _dependencyGuids;\n+\n+            public ProjectInfo(string name, string path, string projectTypeGuid, string guid)\n+            {\n+                Name = name;\n+                Path = path;\n+                ProjectTypeGuid = projectTypeGuid;\n+                Guid = guid;\n+                _dependencies = new List<ProjectInfo>();\n+                _dependencyGuids = new List<string>();\n+            }\n+\n+            public void AddDependency(ProjectInfo dependency)\n+            {\n+                _dependencies.Add(dependency);\n+            }\n+\n+            internal void AddGuidDependencies(string[] dependencyGuids)\n+            {\n+                _dependencyGuids.AddRange(dependencyGuids);\n+            }\n+        }\n+\n+        public static SolutionFileBuilder FromGraphEdges(\n+            TestEnvironment env,\n+            Dictionary<int, int[]> edges,\n+            (string, string[])[] solutionDependenciesProjectNameToGuids = null)\n+        {\n+            return FromGraph(Helpers.CreateProjectGraph(env, edges), solutionDependenciesProjectNameToGuids: solutionDependenciesProjectNameToGuids);\n+        }\n+\n+        public static SolutionFileBuilder FromGraph(\n+            ProjectGraph graph,\n+            Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> projectConfigurations = null,\n+            (string, string)[] solutionDependencies = null,\n+            (string, string[])[] solutionDependenciesProjectNameToGuids = null)\n+        {\n+            return new SolutionFileBuilder\n+            {\n+                Projects = graph.ProjectNodes.ToDictionary(\n+                    n => GraphTestingUtilities.GetProjectNumber(n).ToString(),\n+                    n => n.ProjectInstance.FullPath),\n+                ProjectConfigurations = projectConfigurations,\n+                SolutionDependencies = solutionDependencies,\n+                SolutionDependenciesProjectNameToGuids = solutionDependenciesProjectNameToGuids\n+            };\n+        }\n+\n+        public string BuildSolution()\n+        {\n+            var projectInfos = Projects.ToDictionary(\n+                kvp => kvp.Key,\n+                kvp => new ProjectInfo(\n+                    kvp.Key,\n+                    kvp.Value,\n+                    \"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\",\n+                    Guid.NewGuid()\n+                        .ToString(\"B\")));\n+\n+            if (SolutionDependencies != null && SolutionDependencies.Length > 0)\n+            {\n+                foreach (var (parent, dependency) in SolutionDependencies)\n+                {\n+                    projectInfos.ShouldContainKey(parent);\n+                    projectInfos.ShouldContainKey(dependency);\n+\n+                    projectInfos[parent].AddDependency(projectInfos[dependency]); \n+                }\n+            }\n+\n+            if (SolutionDependenciesProjectNameToGuids!= null && SolutionDependenciesProjectNameToGuids.Length > 0)\n+            {\n+                foreach (var (parent, dependencyGuids) in SolutionDependenciesProjectNameToGuids)\n+                {\n+                    projectInfos.ShouldContainKey(parent);\n+                    projectInfos[parent].AddGuidDependencies(dependencyGuids);\n+                }\n+            }\n+\n+            ProjectConfigurations = ProjectConfigurations ?? projectInfos.ToDictionary(\n+                p => p.Key,\n+                p => SolutionConfigurationPlatforms.ToDictionary(\n+                    sc => sc,\n+                    sc => new ProjectConfigurationInSolution(\n+                        sc.ConfigurationName,\n+                        sc.PlatformName,\n+                        true)\n+                    )\n+                );\n+\n+            var sb = new StringBuilder();\n+\n+            sb.AppendLine($@\"\n+Microsoft Visual Studio Solution File, Format Version 12.00\n+# Visual Studio Version {VisualStudioVersion.VersionLatest}\n+VisualStudioVersion = {VisualStudioVersion.VersionLatest}.0.0.0",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "node? \"not\"?",
              "createdAt": "2019-07-16T19:54:15Z",
              "path": "src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs",
              "diffHunk": "@@ -0,0 +1,731 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Experimental.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.UnitTests.Helpers;\n+\n+namespace Microsoft.Build.Experimental.Graph.UnitTests\n+{\n+    public class GraphLoadedFromSolutionTests : IDisposable\n+    {\n+        private TestEnvironment _env;\n+\n+        public GraphLoadedFromSolutionTests(ITestOutputHelper output)\n+        {\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [Theory]\n+        [InlineData(\"1.sln\", \"2.sln\")]\n+        [InlineData(\"1.sln\", \"2.proj\")]\n+        public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            for (var i = 0; i < files.Length; i++)\n+            {\n+                files[i] = _env.CreateFile(files[i], string.Empty).Path;\n+            }\n+\n+            var exception = Should.Throw<ArgumentException>(\n+                () =>\n+                {\n+                    new ProjectGraph(files);\n+                });\n+\n+            exception.Message.ShouldContain(\"MSB4261\");\n+        }\n+\n+        [Fact]\n+        public void GraphConstructionFailsOnNonExistentSolution()\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            var exception = Should.Throw<InvalidProjectFileException>(\n+                () =>\n+                {\n+                    new ProjectGraph(\"nonExistent.sln\");\n+                });\n+\n+            exception.Message.ShouldContain(\"The project file could not be loaded. Could not find file\");\n+        }\n+\n+        [Fact]\n+        public void StaticGraphShouldNotSupportNestedSolutions()\n+        {\n+            var solutionFile = _env.CreateFile(\"solutionReference.sln\", string.Empty).Path;\n+\n+            var referenceToSolution = $@\"<ItemGroup>\n+                                           <ProjectReference Include='{solutionFile}' />\n+                                       </ItemGroup>\".Cleanup();\n+\n+            var root = GraphTestingUtilities.CreateProjectFile(\n+                env: _env,\n+                projectNumber: 1,\n+                projectReferences: null,\n+                projectReferenceTargets: null,\n+                defaultTargets: null,\n+                extraContent: referenceToSolution);\n+\n+            _env.DoNotLaunchDebugger();\n+\n+            var exception = Should.Throw<InvalidOperationException>(\n+                () =>\n+                {\n+                    new ProjectGraph(root.Path);\n+                });\n+\n+            exception.Message.ShouldContain(\"MSB4263:\");\n+        }\n+\n+        public static IEnumerable<object[]> Graphs\n+        {\n+            get\n+            {\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>()\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                        {2, new []{3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{3, 2}},\n+                        {2, new []{3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {5, new []{3, 2}}\n+                    }\n+                };\n+            }\n+        }\n+\n+        public static IEnumerable<object[]> GraphsWithUniformSolutionConfigurations\n+        {\n+            get\n+            {\n+                foreach (var graph in Graphs)\n+                {\n+                    foreach (\n+                        var currentSolutionConfigurationPlatform in SolutionFileBuilder.SolutionConfigurationPlatformsDefaults.Concat(new SolutionConfigurationInSolution[] {null}))\n+                    {\n+                        yield return new[]\n+                        {\n+                            graph.First(),\n+                            currentSolutionConfigurationPlatform,\n+                            SolutionFileBuilder.SolutionConfigurationPlatformsDefaults\n+                        };\n+                    }\n+                }\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]\n+        public void GraphConstructionCanLoadEntryPointsFromSolution(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations)\n+        {\n+            AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations);\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]\n+        public void SolutionBasedGraphCanMatchProjectSpecificConfigurations(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations)\n+        {\n+            var graph = CreateProjectGraph(_env, edges);\n+\n+            var projectSpecificConfigurations = graph.ProjectNodes.ToDictionary(\n+                node => GetProjectNumber(node).ToString(),\n+                n => solutionConfigurations.ToDictionary(\n+                    sc => sc,\n+                    sc => new ProjectConfigurationInSolution(\n+                        configurationName: $\"{sc.ConfigurationName}_{GetProjectNumber(n)}\",\n+                        platformName: $\"{sc.PlatformName}_{GetProjectNumber(n)}\",\n+                        includeInBuild: true)));\n+\n+            AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations, projectSpecificConfigurations);\n+        }\n+\n+        [Fact]\n+        public void SolutionParserIgnoresProjectConfigurationsThatDoNotFullyMatchAnySolutionConfiguration()\n+        {\n+            var solutionContents = new SolutionFileBuilder\n+            {\n+                Projects = new Dictionary<string, string>\n+                {\n+                    {\"1\", _env.CreateFile(\"1.csproj\", string.Empty).Path}\n+                },\n+                SolutionConfigurationPlatforms = new[] {new SolutionConfigurationInSolution(\"Foo\", \"Bar\")},\n+                ProjectConfigurations = new Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>>\n+                {\n+                    {\n+                        \"1\", new Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>\n+                        {\n+                            {\n+                                new SolutionConfigurationInSolution(\"NonMatchingConfiguration\", \"NonMatchingPlatform\"),\n+                                new ProjectConfigurationInSolution(\"1a\", \"1b\", true)\n+                            },\n+                            {\n+                                new SolutionConfigurationInSolution(\"Foo\", \"NonMatchingPlatform\"),\n+                                new ProjectConfigurationInSolution(\"1c\", \"1d\", true)\n+                            }\n+                        }\n+                    }\n+                }\n+            }.BuildSolution();\n+\n+            var solutionFile = _env.CreateFile(\"solution.sln\", solutionContents).Path;\n+\n+            var graph = new ProjectGraph(solutionFile);\n+\n+            graph.ProjectNodes.ShouldBeEmpty();\n+        }\n+\n+        public static IEnumerable<object[]> SolutionOnlyDependenciesData\n+        {\n+            get\n+            {\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]> //graph nodes and ProjectReference edges\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    },\n+                    new[] {(1, 2)}, // solution only edges\n+                    false, // is there a cycle\n+                    false // solution edges overlap with graph edges\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    },\n+                    new[] {(1, 2), (2, 1)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (2, 4), (3,4), (4, 5)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 3)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 3), (2, 3), (3, 4), (3, 5), (5, 4), (2, 1)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(1, 2)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(1, 2), (1, 2)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(2, 1)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(3, 2)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (3, 2), (1, 5)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(3, 2), (5, 3)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(5, 3)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {2, new[] {3}},\n+                        {3, new[] {4}},\n+                    },\n+                    new[] {(1,3), (2, 4)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {2, new[] {3}},\n+                        {3, new[] {4}},\n+                    },\n+                    new[] {(1,3), (2, 4), (1, 2), (2, 3), (3, 4)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {3, null},\n+                        {4, null}\n+                    },\n+                    new[] {(3, 2), (2, 4)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {3, null},\n+                        {4, null}\n+                    },\n+                    new[] {(3, 2), (2, 4), (4, 1)},\n+                    true,\n+                    false\n+                };\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(SolutionOnlyDependenciesData))]\n+        public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> edges, (int, int)[] solutionDependencies, bool hasCycle, bool solutionEdgesOverlapGraphEdges)\n+        {\n+            // Use the same global properties as the solution would use so all ConfigurationMetadata objects would match on global properties.\n+            var graph = CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string>()\n+                {\n+                    {\"Configuration\", \"Debug\"},\n+                    {\"Platform\", \"AnyCPU\"}\n+                });\n+\n+            // Use ConfigutationMetadata because it is IEquatable, whereas ProjectGraphNode is node.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "An interesting idea. Why isn't the solution metaproject the entry point?",
              "createdAt": "2019-07-16T19:56:38Z",
              "path": "src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs",
              "diffHunk": "@@ -0,0 +1,731 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Experimental.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.UnitTests.Helpers;\n+\n+namespace Microsoft.Build.Experimental.Graph.UnitTests\n+{\n+    public class GraphLoadedFromSolutionTests : IDisposable\n+    {\n+        private TestEnvironment _env;\n+\n+        public GraphLoadedFromSolutionTests(ITestOutputHelper output)\n+        {\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [Theory]\n+        [InlineData(\"1.sln\", \"2.sln\")]\n+        [InlineData(\"1.sln\", \"2.proj\")]\n+        public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            for (var i = 0; i < files.Length; i++)\n+            {\n+                files[i] = _env.CreateFile(files[i], string.Empty).Path;\n+            }\n+\n+            var exception = Should.Throw<ArgumentException>(\n+                () =>\n+                {\n+                    new ProjectGraph(files);\n+                });\n+\n+            exception.Message.ShouldContain(\"MSB4261\");\n+        }\n+\n+        [Fact]\n+        public void GraphConstructionFailsOnNonExistentSolution()\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            var exception = Should.Throw<InvalidProjectFileException>(\n+                () =>\n+                {\n+                    new ProjectGraph(\"nonExistent.sln\");\n+                });\n+\n+            exception.Message.ShouldContain(\"The project file could not be loaded. Could not find file\");\n+        }\n+\n+        [Fact]\n+        public void StaticGraphShouldNotSupportNestedSolutions()\n+        {\n+            var solutionFile = _env.CreateFile(\"solutionReference.sln\", string.Empty).Path;\n+\n+            var referenceToSolution = $@\"<ItemGroup>\n+                                           <ProjectReference Include='{solutionFile}' />\n+                                       </ItemGroup>\".Cleanup();\n+\n+            var root = GraphTestingUtilities.CreateProjectFile(\n+                env: _env,\n+                projectNumber: 1,\n+                projectReferences: null,\n+                projectReferenceTargets: null,\n+                defaultTargets: null,\n+                extraContent: referenceToSolution);\n+\n+            _env.DoNotLaunchDebugger();\n+\n+            var exception = Should.Throw<InvalidOperationException>(\n+                () =>\n+                {\n+                    new ProjectGraph(root.Path);\n+                });\n+\n+            exception.Message.ShouldContain(\"MSB4263:\");\n+        }\n+\n+        public static IEnumerable<object[]> Graphs\n+        {\n+            get\n+            {\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>()\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                        {2, new []{3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{3, 2}},\n+                        {2, new []{3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {5, new []{3, 2}}\n+                    }\n+                };\n+            }\n+        }\n+\n+        public static IEnumerable<object[]> GraphsWithUniformSolutionConfigurations\n+        {\n+            get\n+            {\n+                foreach (var graph in Graphs)\n+                {\n+                    foreach (\n+                        var currentSolutionConfigurationPlatform in SolutionFileBuilder.SolutionConfigurationPlatformsDefaults.Concat(new SolutionConfigurationInSolution[] {null}))\n+                    {\n+                        yield return new[]\n+                        {\n+                            graph.First(),\n+                            currentSolutionConfigurationPlatform,\n+                            SolutionFileBuilder.SolutionConfigurationPlatformsDefaults\n+                        };\n+                    }\n+                }\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]\n+        public void GraphConstructionCanLoadEntryPointsFromSolution(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations)\n+        {\n+            AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations);\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]\n+        public void SolutionBasedGraphCanMatchProjectSpecificConfigurations(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations)\n+        {\n+            var graph = CreateProjectGraph(_env, edges);\n+\n+            var projectSpecificConfigurations = graph.ProjectNodes.ToDictionary(\n+                node => GetProjectNumber(node).ToString(),\n+                n => solutionConfigurations.ToDictionary(\n+                    sc => sc,\n+                    sc => new ProjectConfigurationInSolution(\n+                        configurationName: $\"{sc.ConfigurationName}_{GetProjectNumber(n)}\",\n+                        platformName: $\"{sc.PlatformName}_{GetProjectNumber(n)}\",\n+                        includeInBuild: true)));\n+\n+            AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations, projectSpecificConfigurations);\n+        }\n+\n+        [Fact]\n+        public void SolutionParserIgnoresProjectConfigurationsThatDoNotFullyMatchAnySolutionConfiguration()\n+        {\n+            var solutionContents = new SolutionFileBuilder\n+            {\n+                Projects = new Dictionary<string, string>\n+                {\n+                    {\"1\", _env.CreateFile(\"1.csproj\", string.Empty).Path}\n+                },\n+                SolutionConfigurationPlatforms = new[] {new SolutionConfigurationInSolution(\"Foo\", \"Bar\")},\n+                ProjectConfigurations = new Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>>\n+                {\n+                    {\n+                        \"1\", new Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>\n+                        {\n+                            {\n+                                new SolutionConfigurationInSolution(\"NonMatchingConfiguration\", \"NonMatchingPlatform\"),\n+                                new ProjectConfigurationInSolution(\"1a\", \"1b\", true)\n+                            },\n+                            {\n+                                new SolutionConfigurationInSolution(\"Foo\", \"NonMatchingPlatform\"),\n+                                new ProjectConfigurationInSolution(\"1c\", \"1d\", true)\n+                            }\n+                        }\n+                    }\n+                }\n+            }.BuildSolution();\n+\n+            var solutionFile = _env.CreateFile(\"solution.sln\", solutionContents).Path;\n+\n+            var graph = new ProjectGraph(solutionFile);\n+\n+            graph.ProjectNodes.ShouldBeEmpty();\n+        }\n+\n+        public static IEnumerable<object[]> SolutionOnlyDependenciesData\n+        {\n+            get\n+            {\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]> //graph nodes and ProjectReference edges\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    },\n+                    new[] {(1, 2)}, // solution only edges\n+                    false, // is there a cycle\n+                    false // solution edges overlap with graph edges\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    },\n+                    new[] {(1, 2), (2, 1)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (2, 4), (3,4), (4, 5)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 3)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 3), (2, 3), (3, 4), (3, 5), (5, 4), (2, 1)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(1, 2)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(1, 2), (1, 2)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(2, 1)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(3, 2)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (3, 2), (1, 5)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(3, 2), (5, 3)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(5, 3)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {2, new[] {3}},\n+                        {3, new[] {4}},\n+                    },\n+                    new[] {(1,3), (2, 4)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {2, new[] {3}},\n+                        {3, new[] {4}},\n+                    },\n+                    new[] {(1,3), (2, 4), (1, 2), (2, 3), (3, 4)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {3, null},\n+                        {4, null}\n+                    },\n+                    new[] {(3, 2), (2, 4)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {3, null},\n+                        {4, null}\n+                    },\n+                    new[] {(3, 2), (2, 4), (4, 1)},\n+                    true,\n+                    false\n+                };\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(SolutionOnlyDependenciesData))]\n+        public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> edges, (int, int)[] solutionDependencies, bool hasCycle, bool solutionEdgesOverlapGraphEdges)\n+        {\n+            // Use the same global properties as the solution would use so all ConfigurationMetadata objects would match on global properties.\n+            var graph = CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string>()\n+                {\n+                    {\"Configuration\", \"Debug\"},\n+                    {\"Platform\", \"AnyCPU\"}\n+                });\n+\n+            // Use ConfigutationMetadata because it is IEquatable, whereas ProjectGraphNode is node.\n+            var graphEdges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            var solutionContents =\n+                SolutionFileBuilder.FromGraph(\n+                    graph,\n+                    solutionDependencies: solutionDependencies.Select(dependency => (dependency.Item1.ToString(), dependency.Item2.ToString())).ToArray())\n+                    .BuildSolution();\n+            var solutionFile = _env.CreateFile(\"solution.sln\", solutionContents).Path;\n+\n+            Exception exception = null;\n+\n+            ProjectGraph graphFromSolution = null;\n+\n+            try\n+            {\n+                graphFromSolution = new ProjectGraph(solutionFile);\n+            }\n+            catch (Exception e)\n+            {\n+                exception = e;\n+            }\n+\n+            if (hasCycle)\n+            {\n+                exception.ShouldNotBeNull();\n+                exception.Message.ShouldContain(\"MSB4251\");\n+\n+                return;\n+            }\n+\n+            exception.ShouldBeNull();\n+\n+            var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            // Original edges get preserved.\n+            foreach (var graphEdge in graphEdges)\n+            {\n+                graphFromSolutionEdges.Keys.ShouldContain(graphEdge.Key);\n+            }\n+\n+            // Solution edges get added. Assert each solution dependency is found within the graph edges\n+            var solutionOnlyEdges = graphFromSolutionEdges.Keys.Except(graphEdges.Keys).ToList();\n+\n+            foreach (var solutionDependency in solutionDependencies)\n+            {\n+                if (!solutionEdgesOverlapGraphEdges)\n+                {\n+                    solutionOnlyEdges.ShouldContain(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));\n+                }\n+\n+                graphFromSolutionEdges.Keys.ShouldContain(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));\n+\n+                solutionOnlyEdges.RemoveAll(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));\n+            }\n+\n+            // no extra edges get added\n+            solutionOnlyEdges.ShouldBeEmpty();\n+        }\n+\n+        [Fact]\n+        public void SolutionEdgesShouldNotOverwriteProjectReferenceEdges()\n+        {\n+            var solutionContents = SolutionFileBuilder.FromGraphEdges(\n+                _env,\n+                new Dictionary<int, int[]>()\n+                {\n+                    {1, new[] {2}}\n+                }).BuildSolution();\n+\n+            var graph = new ProjectGraph(_env.CreateFile(\"solution.sln\", solutionContents).Path);\n+\n+            var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            edges.Count.ShouldBe(1);\n+\n+            edges.First().Value.ItemType.ShouldBe(ItemTypeNames.ProjectReference);\n+        }\n+\n+        [Fact]\n+        public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()\n+        {\n+            var solutionContents = new SolutionFileBuilder\n+            {\n+                Projects = new Dictionary<string, string>\n+                {\n+                    {\"1\", GraphTestingUtilities.CreateProjectFile(_env, 1, new[] {2}).Path},\n+                    {\"2\", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecification).Path},\n+                    {\"3\", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecification).Path},\n+                    {\"4\", GraphTestingUtilities.CreateProjectFile(_env, 4).Path}\n+                },\n+                SolutionDependencies = new[] {(\"1\", \"2\"), (\"3\", \"4\")}\n+            }.BuildSolution();\n+\n+            var graph = new ProjectGraph(_env.CreateFile(\"solution.sln\", solutionContents).Path);\n+\n+            var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+            edges.Count.ShouldBe(8);\n+\n+            var node1 = GetFirstNodeWithProjectNumber(graph, 1);\n+            node1.ProjectReferences.Count.ShouldBe(3);\n+            node1.ProjectReferences.Count(r => GetProjectNumber(r) == 2).ShouldBe(3);\n+            GetOutgoingEdgeItemsFromNode(node1, edges).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));\n+\n+            var outerBuild3 = GetOuterBuild(graph, 3);\n+            outerBuild3.ProjectReferences.Count.ShouldBe(3);\n+            outerBuild3.ProjectReferences.Count(r => GetProjectNumber(r) == 3).ShouldBe(2);\n+            outerBuild3.ProjectReferences.Count(r => GetProjectNumber(r) == 4).ShouldBe(1);\n+\n+            GetInnerBuilds(graph, 3).SelectMany(n => n.ProjectReferences).Count(r => GetProjectNumber(r) == 4).ShouldBe(2);\n+            GetInnerBuilds(graph, 3).SelectMany(n => GetIncomingEdgeItemsToNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));\n+            GetInnerBuilds(graph, 3).SelectMany(n => GetOutgoingEdgeItemsFromNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));\n+\n+            IEnumerable<ProjectItemInstance> GetOutgoingEdgeItemsFromNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)\n+            {\n+                return edgeInfos.Where(e => e.Key.Item1.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);\n+            }\n+\n+            IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)\n+            {\n+                return edgeInfos.Where(e => e.Key.Item2.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GraphConstructionShouldThrowOnMissingSolutionDependencies()\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            var solutionContents = SolutionFileBuilder.FromGraphEdges(\n+                _env,\n+                new Dictionary<int, int[]> {{1, null}, {2, null}},\n+                new[] {(\"1\", new[] {Guid.NewGuid().ToString(\"B\")})}).BuildSolution();\n+\n+            var solutionFile = _env.CreateFile(\n+                \"solution.sln\",\n+                solutionContents)\n+                .Path;\n+\n+            var exception = Should.Throw<InvalidProjectFileException>(\n+                () =>\n+                {\n+                    new ProjectGraph(solutionFile);\n+                });\n+\n+            exception.Message.ShouldContain(\"but a project with this GUID was not found in the .SLN file\");\n+        }\n+\n+        private static bool IsSolutionItemReference(ProjectItemInstance edgeItem)\n+        {\n+            return edgeItem.ItemType == GraphBuilder.SolutionItemReference;\n+        }\n+\n+        private static bool EdgeCompliesWithSolutionDependency((ConfigurationMetadata, ConfigurationMetadata) edge, (int, int) solutionDependency)\n+        {\n+            return GetProjectNumber(edge.Item1) == solutionDependency.Item1 && GetProjectNumber(edge.Item2) == solutionDependency.Item2;\n+        }\n+\n+        private void AssertSolutionBasedGraph(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations,\n+            Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> projectConfigurations = null)\n+        {\n+            var graph = CreateProjectGraph(_env, edges);\n+            var graphEdges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            var solutionFileBuilder = SolutionFileBuilder.FromGraph(graph, projectConfigurations);\n+\n+            var solutionContents = solutionFileBuilder.BuildSolution();\n+\n+            var solutionPath = _env.CreateFile(\"TheSolution.sln\", solutionContents).Path;\n+            var globalProperties = currentSolutionConfiguration != null\n+                ? new Dictionary<string, string>\n+                {\n+                    [\"Configuration\"] = currentSolutionConfiguration.ConfigurationName,\n+                    [\"Platform\"] = currentSolutionConfiguration.PlatformName\n+                }\n+                : new Dictionary<string, string>();\n+\n+            var graphFromSolution = new ProjectGraph(\n+                new ProjectGraphEntryPoint(\n+                    solutionPath,\n+                    globalProperties),\n+                _env.CreateProjectCollection().Collection);\n+\n+            // in the solution, all nodes are entry points",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I thought about that idea but the metaproj looks horrible and is full of arbitrary accumulated garbage. Also, the graph does not work with in memory projects.\r\nSo I decided to be explicit about what behaviour to cherry-pick into the graph. I'd be fine going back to a metaproj, but then I'd rather redesign the metaproj to make it more human readable.",
              "createdAt": "2019-07-17T20:27:14Z",
              "path": "src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs",
              "diffHunk": "@@ -0,0 +1,731 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Experimental.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.UnitTests.Helpers;\n+\n+namespace Microsoft.Build.Experimental.Graph.UnitTests\n+{\n+    public class GraphLoadedFromSolutionTests : IDisposable\n+    {\n+        private TestEnvironment _env;\n+\n+        public GraphLoadedFromSolutionTests(ITestOutputHelper output)\n+        {\n+            _env = TestEnvironment.Create(output);\n+        }\n+\n+        [Theory]\n+        [InlineData(\"1.sln\", \"2.sln\")]\n+        [InlineData(\"1.sln\", \"2.proj\")]\n+        public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            for (var i = 0; i < files.Length; i++)\n+            {\n+                files[i] = _env.CreateFile(files[i], string.Empty).Path;\n+            }\n+\n+            var exception = Should.Throw<ArgumentException>(\n+                () =>\n+                {\n+                    new ProjectGraph(files);\n+                });\n+\n+            exception.Message.ShouldContain(\"MSB4261\");\n+        }\n+\n+        [Fact]\n+        public void GraphConstructionFailsOnNonExistentSolution()\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            var exception = Should.Throw<InvalidProjectFileException>(\n+                () =>\n+                {\n+                    new ProjectGraph(\"nonExistent.sln\");\n+                });\n+\n+            exception.Message.ShouldContain(\"The project file could not be loaded. Could not find file\");\n+        }\n+\n+        [Fact]\n+        public void StaticGraphShouldNotSupportNestedSolutions()\n+        {\n+            var solutionFile = _env.CreateFile(\"solutionReference.sln\", string.Empty).Path;\n+\n+            var referenceToSolution = $@\"<ItemGroup>\n+                                           <ProjectReference Include='{solutionFile}' />\n+                                       </ItemGroup>\".Cleanup();\n+\n+            var root = GraphTestingUtilities.CreateProjectFile(\n+                env: _env,\n+                projectNumber: 1,\n+                projectReferences: null,\n+                projectReferenceTargets: null,\n+                defaultTargets: null,\n+                extraContent: referenceToSolution);\n+\n+            _env.DoNotLaunchDebugger();\n+\n+            var exception = Should.Throw<InvalidOperationException>(\n+                () =>\n+                {\n+                    new ProjectGraph(root.Path);\n+                });\n+\n+            exception.Message.ShouldContain(\"MSB4263:\");\n+        }\n+\n+        public static IEnumerable<object[]> Graphs\n+        {\n+            get\n+            {\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>()\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                        {2, new []{3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{3, 2}},\n+                        {2, new []{3}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}}\n+                    }\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {5, new []{3, 2}}\n+                    }\n+                };\n+            }\n+        }\n+\n+        public static IEnumerable<object[]> GraphsWithUniformSolutionConfigurations\n+        {\n+            get\n+            {\n+                foreach (var graph in Graphs)\n+                {\n+                    foreach (\n+                        var currentSolutionConfigurationPlatform in SolutionFileBuilder.SolutionConfigurationPlatformsDefaults.Concat(new SolutionConfigurationInSolution[] {null}))\n+                    {\n+                        yield return new[]\n+                        {\n+                            graph.First(),\n+                            currentSolutionConfigurationPlatform,\n+                            SolutionFileBuilder.SolutionConfigurationPlatformsDefaults\n+                        };\n+                    }\n+                }\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]\n+        public void GraphConstructionCanLoadEntryPointsFromSolution(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations)\n+        {\n+            AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations);\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]\n+        public void SolutionBasedGraphCanMatchProjectSpecificConfigurations(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations)\n+        {\n+            var graph = CreateProjectGraph(_env, edges);\n+\n+            var projectSpecificConfigurations = graph.ProjectNodes.ToDictionary(\n+                node => GetProjectNumber(node).ToString(),\n+                n => solutionConfigurations.ToDictionary(\n+                    sc => sc,\n+                    sc => new ProjectConfigurationInSolution(\n+                        configurationName: $\"{sc.ConfigurationName}_{GetProjectNumber(n)}\",\n+                        platformName: $\"{sc.PlatformName}_{GetProjectNumber(n)}\",\n+                        includeInBuild: true)));\n+\n+            AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations, projectSpecificConfigurations);\n+        }\n+\n+        [Fact]\n+        public void SolutionParserIgnoresProjectConfigurationsThatDoNotFullyMatchAnySolutionConfiguration()\n+        {\n+            var solutionContents = new SolutionFileBuilder\n+            {\n+                Projects = new Dictionary<string, string>\n+                {\n+                    {\"1\", _env.CreateFile(\"1.csproj\", string.Empty).Path}\n+                },\n+                SolutionConfigurationPlatforms = new[] {new SolutionConfigurationInSolution(\"Foo\", \"Bar\")},\n+                ProjectConfigurations = new Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>>\n+                {\n+                    {\n+                        \"1\", new Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>\n+                        {\n+                            {\n+                                new SolutionConfigurationInSolution(\"NonMatchingConfiguration\", \"NonMatchingPlatform\"),\n+                                new ProjectConfigurationInSolution(\"1a\", \"1b\", true)\n+                            },\n+                            {\n+                                new SolutionConfigurationInSolution(\"Foo\", \"NonMatchingPlatform\"),\n+                                new ProjectConfigurationInSolution(\"1c\", \"1d\", true)\n+                            }\n+                        }\n+                    }\n+                }\n+            }.BuildSolution();\n+\n+            var solutionFile = _env.CreateFile(\"solution.sln\", solutionContents).Path;\n+\n+            var graph = new ProjectGraph(solutionFile);\n+\n+            graph.ProjectNodes.ShouldBeEmpty();\n+        }\n+\n+        public static IEnumerable<object[]> SolutionOnlyDependenciesData\n+        {\n+            get\n+            {\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]> //graph nodes and ProjectReference edges\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    },\n+                    new[] {(1, 2)}, // solution only edges\n+                    false, // is there a cycle\n+                    false // solution edges overlap with graph edges\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null}\n+                    },\n+                    new[] {(1, 2), (2, 1)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (2, 4), (3,4), (4, 5)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 3)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, null},\n+                        {2, null},\n+                        {3, null},\n+                        {4, null},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 3), (2, 3), (3, 4), (3, 5), (5, 4), (2, 1)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(1, 2)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(1, 2), (1, 2)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2}},\n+                    },\n+                    new[] {(2, 1)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(3, 2)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(1, 2), (1, 3), (3, 2), (1, 5)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(3, 2), (5, 3)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new []{2, 3}},\n+                        {2, new []{4}},\n+                        {3, new []{4}},\n+                        {4, new []{5}},\n+                        {5, null}\n+                    },\n+                    new[] {(5, 3)},\n+                    true,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {2, new[] {3}},\n+                        {3, new[] {4}},\n+                    },\n+                    new[] {(1,3), (2, 4)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {2, new[] {3}},\n+                        {3, new[] {4}},\n+                    },\n+                    new[] {(1,3), (2, 4), (1, 2), (2, 3), (3, 4)},\n+                    false,\n+                    true\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {3, null},\n+                        {4, null}\n+                    },\n+                    new[] {(3, 2), (2, 4)},\n+                    false,\n+                    false\n+                };\n+\n+                yield return new object[]\n+                {\n+                    new Dictionary<int, int[]>\n+                    {\n+                        {1, new[] {2}},\n+                        {3, null},\n+                        {4, null}\n+                    },\n+                    new[] {(3, 2), (2, 4), (4, 1)},\n+                    true,\n+                    false\n+                };\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(SolutionOnlyDependenciesData))]\n+        public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> edges, (int, int)[] solutionDependencies, bool hasCycle, bool solutionEdgesOverlapGraphEdges)\n+        {\n+            // Use the same global properties as the solution would use so all ConfigurationMetadata objects would match on global properties.\n+            var graph = CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string>()\n+                {\n+                    {\"Configuration\", \"Debug\"},\n+                    {\"Platform\", \"AnyCPU\"}\n+                });\n+\n+            // Use ConfigutationMetadata because it is IEquatable, whereas ProjectGraphNode is node.\n+            var graphEdges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            var solutionContents =\n+                SolutionFileBuilder.FromGraph(\n+                    graph,\n+                    solutionDependencies: solutionDependencies.Select(dependency => (dependency.Item1.ToString(), dependency.Item2.ToString())).ToArray())\n+                    .BuildSolution();\n+            var solutionFile = _env.CreateFile(\"solution.sln\", solutionContents).Path;\n+\n+            Exception exception = null;\n+\n+            ProjectGraph graphFromSolution = null;\n+\n+            try\n+            {\n+                graphFromSolution = new ProjectGraph(solutionFile);\n+            }\n+            catch (Exception e)\n+            {\n+                exception = e;\n+            }\n+\n+            if (hasCycle)\n+            {\n+                exception.ShouldNotBeNull();\n+                exception.Message.ShouldContain(\"MSB4251\");\n+\n+                return;\n+            }\n+\n+            exception.ShouldBeNull();\n+\n+            var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            // Original edges get preserved.\n+            foreach (var graphEdge in graphEdges)\n+            {\n+                graphFromSolutionEdges.Keys.ShouldContain(graphEdge.Key);\n+            }\n+\n+            // Solution edges get added. Assert each solution dependency is found within the graph edges\n+            var solutionOnlyEdges = graphFromSolutionEdges.Keys.Except(graphEdges.Keys).ToList();\n+\n+            foreach (var solutionDependency in solutionDependencies)\n+            {\n+                if (!solutionEdgesOverlapGraphEdges)\n+                {\n+                    solutionOnlyEdges.ShouldContain(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));\n+                }\n+\n+                graphFromSolutionEdges.Keys.ShouldContain(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));\n+\n+                solutionOnlyEdges.RemoveAll(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));\n+            }\n+\n+            // no extra edges get added\n+            solutionOnlyEdges.ShouldBeEmpty();\n+        }\n+\n+        [Fact]\n+        public void SolutionEdgesShouldNotOverwriteProjectReferenceEdges()\n+        {\n+            var solutionContents = SolutionFileBuilder.FromGraphEdges(\n+                _env,\n+                new Dictionary<int, int[]>()\n+                {\n+                    {1, new[] {2}}\n+                }).BuildSolution();\n+\n+            var graph = new ProjectGraph(_env.CreateFile(\"solution.sln\", solutionContents).Path);\n+\n+            var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            edges.Count.ShouldBe(1);\n+\n+            edges.First().Value.ItemType.ShouldBe(ItemTypeNames.ProjectReference);\n+        }\n+\n+        [Fact]\n+        public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()\n+        {\n+            var solutionContents = new SolutionFileBuilder\n+            {\n+                Projects = new Dictionary<string, string>\n+                {\n+                    {\"1\", GraphTestingUtilities.CreateProjectFile(_env, 1, new[] {2}).Path},\n+                    {\"2\", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecification).Path},\n+                    {\"3\", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecification).Path},\n+                    {\"4\", GraphTestingUtilities.CreateProjectFile(_env, 4).Path}\n+                },\n+                SolutionDependencies = new[] {(\"1\", \"2\"), (\"3\", \"4\")}\n+            }.BuildSolution();\n+\n+            var graph = new ProjectGraph(_env.CreateFile(\"solution.sln\", solutionContents).Path);\n+\n+            var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+            edges.Count.ShouldBe(8);\n+\n+            var node1 = GetFirstNodeWithProjectNumber(graph, 1);\n+            node1.ProjectReferences.Count.ShouldBe(3);\n+            node1.ProjectReferences.Count(r => GetProjectNumber(r) == 2).ShouldBe(3);\n+            GetOutgoingEdgeItemsFromNode(node1, edges).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));\n+\n+            var outerBuild3 = GetOuterBuild(graph, 3);\n+            outerBuild3.ProjectReferences.Count.ShouldBe(3);\n+            outerBuild3.ProjectReferences.Count(r => GetProjectNumber(r) == 3).ShouldBe(2);\n+            outerBuild3.ProjectReferences.Count(r => GetProjectNumber(r) == 4).ShouldBe(1);\n+\n+            GetInnerBuilds(graph, 3).SelectMany(n => n.ProjectReferences).Count(r => GetProjectNumber(r) == 4).ShouldBe(2);\n+            GetInnerBuilds(graph, 3).SelectMany(n => GetIncomingEdgeItemsToNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));\n+            GetInnerBuilds(graph, 3).SelectMany(n => GetOutgoingEdgeItemsFromNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));\n+\n+            IEnumerable<ProjectItemInstance> GetOutgoingEdgeItemsFromNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)\n+            {\n+                return edgeInfos.Where(e => e.Key.Item1.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);\n+            }\n+\n+            IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)\n+            {\n+                return edgeInfos.Where(e => e.Key.Item2.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GraphConstructionShouldThrowOnMissingSolutionDependencies()\n+        {\n+            _env.DoNotLaunchDebugger();\n+\n+            var solutionContents = SolutionFileBuilder.FromGraphEdges(\n+                _env,\n+                new Dictionary<int, int[]> {{1, null}, {2, null}},\n+                new[] {(\"1\", new[] {Guid.NewGuid().ToString(\"B\")})}).BuildSolution();\n+\n+            var solutionFile = _env.CreateFile(\n+                \"solution.sln\",\n+                solutionContents)\n+                .Path;\n+\n+            var exception = Should.Throw<InvalidProjectFileException>(\n+                () =>\n+                {\n+                    new ProjectGraph(solutionFile);\n+                });\n+\n+            exception.Message.ShouldContain(\"but a project with this GUID was not found in the .SLN file\");\n+        }\n+\n+        private static bool IsSolutionItemReference(ProjectItemInstance edgeItem)\n+        {\n+            return edgeItem.ItemType == GraphBuilder.SolutionItemReference;\n+        }\n+\n+        private static bool EdgeCompliesWithSolutionDependency((ConfigurationMetadata, ConfigurationMetadata) edge, (int, int) solutionDependency)\n+        {\n+            return GetProjectNumber(edge.Item1) == solutionDependency.Item1 && GetProjectNumber(edge.Item2) == solutionDependency.Item2;\n+        }\n+\n+        private void AssertSolutionBasedGraph(\n+            Dictionary<int, int[]> edges,\n+            SolutionConfigurationInSolution currentSolutionConfiguration,\n+            IReadOnlyCollection<SolutionConfigurationInSolution> solutionConfigurations,\n+            Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> projectConfigurations = null)\n+        {\n+            var graph = CreateProjectGraph(_env, edges);\n+            var graphEdges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();\n+\n+            var solutionFileBuilder = SolutionFileBuilder.FromGraph(graph, projectConfigurations);\n+\n+            var solutionContents = solutionFileBuilder.BuildSolution();\n+\n+            var solutionPath = _env.CreateFile(\"TheSolution.sln\", solutionContents).Path;\n+            var globalProperties = currentSolutionConfiguration != null\n+                ? new Dictionary<string, string>\n+                {\n+                    [\"Configuration\"] = currentSolutionConfiguration.ConfigurationName,\n+                    [\"Platform\"] = currentSolutionConfiguration.PlatformName\n+                }\n+                : new Dictionary<string, string>();\n+\n+            var graphFromSolution = new ProjectGraph(\n+                new ProjectGraphEntryPoint(\n+                    solutionPath,\n+                    globalProperties),\n+                _env.CreateProjectCollection().Collection);\n+\n+            // in the solution, all nodes are entry points",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      }
    ]
  }
}