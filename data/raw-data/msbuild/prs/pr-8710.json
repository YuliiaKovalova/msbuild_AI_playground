{
  "number": 8710,
  "title": "Intrinsic arithmetic function overloads",
  "body": "Fixes #8698\r\n\r\n### Context\r\nThe [MSBuild property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions?view=vs-2022#msbuild-property-functions) for Add(), Subtract(), Multiply(), Divide(), and Modulo() have overloads for `long` and `double`. The 'fast path' resolution for the functions supports the `double` versions only. Both overloads should be supported.\r\n\r\n#### Design\r\nThe changes are focused on the 'fast path' for intrinsic functions. To determine which overload to call, the arguments are checked to see if they can be converted to a `long` or, for a `string`, parsed to a `long`. If the arguments can be `long`, the `long` overload is called. Otherwise, the `double` overload is called.\r\n\r\nFrom MSBuild XML, invocation of the `double` overload can be ensured by using a real literal, e.g. `$([MSBuild]::Add(1, 0.0))` invokes the `double` overload.\r\n\r\nWith the `long` overload an overflow result that wraps is kept, e.g. `-9223372036854775808` is the result of the following function call.\r\n\r\n```\r\n$([MSBuild]::Add($([System.Int64]::MaxValue), 1))\r\n```\r\n\r\n#### Preserve Existing Behavior for `Equals` and `CompareTo`\r\nThe following two code examples currently work because `Add()` always returns a `double` but there is an issue when the `long` override is invoked.\r\n\r\n```\r\n$([MSBuild]::Add(1,2).CompareTo(3.0))\r\n```\r\n\r\n```\r\n$([MSBuild]::Add(1,2).Equals(3.0))\r\n```\r\n\r\nThe `Microsoft.Build.Evaluation.Expander<P, I>.Function<T>.Execute()` method has an existing special case for handling `Equals` and `CompareTo` where the type of the argument to `Equals` or `CompareTo` is converted to match the type of the 'lhs' of the comparison. `3.0` can't be converted to a `long`. To preserve the existing behavior, the argument is tested and if it is a real literal the lhs of the comparison is converted to a `double`.\r\n\r\nIn the MSBuild XML the `double` to `double` comparison can be explicit by using a real literal or by converting to double as in the following examples.\r\n\r\n```\r\n$([MSBuild]::Add(1,2.0).CompareTo(3.0))\r\n```\r\n\r\n```\r\n$([System.Convert]::ToDouble($([MSBuild]::Add(1,2))).CompareTo(3.0))\r\n```\r\n\r\n### Changes Made\r\n#### Implementation\r\nModified the `Microsoft.Build.Evaluation.Expander<P, I>.Function<T>` class:\r\n- Added `TryConvertToLong()`.\r\n- Modified `TryConvertToInt()` and `TryConvertToDouble()`.\r\n- Added `IsFloatingPointRepresentation()`.\r\n- Added a set of `TryExecute*()` methods, e.g. `TryExecuteAdd()`.\r\n- Modified `TryExecuteWellKnownFunction()` to call the appropriate `TryExecute*()` method.\r\n- Modified `Execute()` to support existing behavior for comparisons with `Equals` and `CompareTo`.\r\n- Modified `LateBindExecute()` to support selecting the correct overload to call.\r\n- Added static class `IntrinsicFunctionOverload` to provide cached comparer for sorting candidate overloads.\r\n\r\n#### Unit Tests\r\nModified the `Microsoft.Build.UnitTests.Evaluation.Expander_Tests` class:\r\n- Removed a test from `PropertyFunctionStaticMethodIntrinsicMaths()` that was commented \"test for overflow wrapping\" but was testing for a `double` result. Overflow wrapping is covered in `PropertyFunctionMSBuildAdd()`.\r\n- Modified `Medley()` to add some tests. The change to `Medley()` are related to the comparison behavior with `Equals` and `CompareTo`.\r\n- Modified `PropertyFunctionMSBuildAdd()` to test `double` and `long` including integer overflow wrapping.\r\n- Modified `PropertyFunctionMSBuildSubtract()`, `PropertyFunctionMSBuildMultiply()`, `PropertyFunctionMSBuildDivide()` to test `long` and `double`.\r\n- Added `PropertyFunctionMSBuildModulo()`.\r\n\r\nAdded the `ExpanderFunction_Tests` unit test class.\r\n\r\nAdded the `IntrinsicFunctionOverload_Tests` unit test class.\r\n\r\n#### PR #8853\r\nThe changes in PR 8853 to use the InvariantCulture with double.TryParse have been included in this PR as well. If this PR is accepted and merged first, then issue #8798 and PR #8853 can also be closed based on this PR. But PR #8853 is smaller and can be accepted ahead of this PR.\r\n\r\n### Testing\r\nTested on Windows 11 and macOS 12.\r\n\r\nAdded new unit tests, extended existing tests, and ran all unit tests. The existing unit tests revealed the `Equals` / `CompareTo` comparison behavior.\r\n\r\nRan a test MSBuild XML project file. See below.\r\n\r\n### Notes\r\nNegates PR #8649.\r\n\r\n### Test Project File\r\n\r\n```xml\r\n<!-- IntrinsicFunctionsOverload.proj -->\r\n<Project>\r\n  <Target Name=\"Testing\" DependsOnTargets=\"Add;BadSubtract;Subtract;Multiply;Divide;Modulo;MedleyExamples\" />\r\n\r\n  <Target Name=\"Add\">\r\n    <!-- long -->\r\n    <Message Text=\"$([MSBuild]::Add(1, 0)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1, 1)) should be 2\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1, 2)) should be 3\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(-1, 2)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add($([System.Int32]::MaxValue), 1)) should be 2147483648\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(2147483648, 1)) should be 2147483649\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add($([System.Int64]::MaxValue), 1)) should be -9223372036854775808\" Importance=\"High\" />\r\n    <!-- double -->\r\n    <Message Text=\"$([MSBuild]::Add(1, 0.0)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1, 0.5)) should be 1.5\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1, .5)) should be 1.5\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(-1.0, 2)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1.0, 2.0)) should be 3\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add($([System.Int32]::MaxValue), 1.0)) should be 2147483648\" Importance=\"High\" />\r\n    <!-- Int64 MaxValue is 9223372036854775807 -->\r\n    <Message Text=\"$([MSBuild]::Add(9223372036854775808, 1)) should be 9.223372036854776E+18\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <Target Name=\"Test\">\r\n    <Message Text=\"$([MSBuild]::Add($([System.Int64]::MaxValue), 1)) should be -9223372036854775808\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(9223372036854775808, 1)) should be 9.223372036854776E+18\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply($([System.Int64]::MaxValue), 2)) should be -2\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Divide(65536, 10000)) should be 6\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(9223372036854775807, 9223372036854775806)) should be 1\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <!-- From Issue #8698 -->\r\n  <Target Name=\"BadSubtract\">\r\n    <Message Text=\"$([MSBuild]::Subtract(9223372036854775807, 9223372036854775806)) should be 1\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <Target Name=\"Subtract\">\r\n    <Message Text=\"$([MSBuild]::Subtract(1, 0)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(1, 1)) should be 0\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(2, 1)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(1, 0.0)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(1, 0.5)) should be 0.5\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(2, -1.0)) should be 3\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract(1.0, 2.0)) should be 3\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Subtract($([System.Int64]::MaxValue), 9223372036854775806)) should be 1\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <Target Name=\"Multiply\">\r\n    <Message Text=\"$([MSBuild]::Multiply(1, 0)) should be 0\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply(1, 1)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply(2, 1)) should be 2\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply(1, 0.0)) should be 0\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply(1, 0.5)) should be 0.5\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply(2, -1.0)) should be -2\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply(1.0, 2.0)) should be 2\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply($([System.Int64]::MaxValue), 1)) should be 9223372036854775807\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Multiply($([System.Int64]::MaxValue), 2)) should be -2\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <Target Name=\"Divide\">\r\n    <Message Text=\"$([MSBuild]::Divide(1, 1)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Divide(9, 3)) should be 3\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Divide(10, 3)) should be 3\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Divide(65536, 10000)) should be 6\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Divide(1, 0.5)) should be 2\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Divide(10.0, 3)) should be 3.33...\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <Target Name=\"Modulo\">\r\n    <Message Text=\"$([MSBuild]::Modulo(1, 1)) should be 0\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Modulo(9, 3)) should be 0\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Modulo(9, 2)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Modulo(9, 2.0)) should be 1\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Modulo(10.0, 3)) should be 1\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <!-- Long versus Double -->\r\n  <Target Name=\"MedleyFail\">\r\n    <Message Text=\"$([MSBuild]::Add(1,2).CompareTo(3.0))\" Importance=\"High\" />\r\n  </Target>\r\n\r\n  <!-- Examples from the 'Medley' test -->\r\n  <Target Name=\"MedleyExamples\">\r\n    <Message Text=\"$([MSBuild]::Add(1,2))\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1,2.0))\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1,2).CompareTo(3))\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1,2).CompareTo('3'))\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1,2).CompareTo(3.0))\" Importance=\"High\" />\r\n    <Message Text=\"$([MSBuild]::Add(1,2.0).CompareTo(3.0))\" Importance=\"High\" />\r\n    <Message Text=\"$([System.Convert]::ToDouble($([MSBuild]::Add(1,2))).CompareTo(3.0))\" Importance=\"High\" />\r\n  </Target>\r\n</Project>\r\n```",
  "state": "MERGED",
  "createdAt": "2023-04-27T03:17:39Z",
  "updatedAt": "2023-06-28T13:35:16Z",
  "closedAt": "2023-06-28T09:29:09Z",
  "mergedAt": "2023-06-28T09:29:09Z",
  "additions": 1029,
  "deletions": 63,
  "changedFiles": 6,
  "headRefName": "IntrinsicFunctionsOverload",
  "isDraft": false,
  "author": {
    "login": "jrdodds"
  },
  "milestone": {
    "title": "VS 17.8"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "202755bafc1ec195e5f5e7121622fc86ed95e93d",
          "message": "Support long and double for arithmetic operator functions",
          "committedDate": "2023-04-26T18:38:50Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d6b87e85cc1cd70b66c0a258f262bae639a368fa",
          "message": "Merge branch 'dotnet:main' into IntrinsicFunctionsOverload",
          "committedDate": "2023-04-26T19:39:24Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d01d30e5b64dea0791623e434f39d9256e47dc5b",
          "message": "added argument that exceeds the size of long",
          "committedDate": "2023-04-26T22:49:30Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb2d53f55be1fd9eec3c18abc9d6ab89b76cc627",
          "message": "use a const char for the decimal separator",
          "committedDate": "2023-04-28T02:19:16Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68b71d69247fdb48868169c314316336b9d910a4",
          "message": "Support comparison when the lhs is an integer",
          "committedDate": "2023-04-28T15:50:50Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a5375f3de7692c97cab4ab6f10a491c588204553",
          "message": "Order members by TypeCode; add tests and ChangeWave",
          "committedDate": "2023-05-06T01:41:26Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "16670c7e87a335e77940ab6c969ed715f2af5f58",
          "message": "Add change wave to fast path",
          "committedDate": "2023-05-06T02:06:21Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "78ba51fa5e00f7943ce4827f1b4c757e926a4fda",
          "message": "Merge remote-tracking branch 'upstream/main' into IntrinsicFunctionsOverload",
          "committedDate": "2023-05-06T02:16:49Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7de86f041c696c91d6e717bb861fd87e5f4326bf",
          "message": "add property in Expander_Tests; rename in other classes",
          "committedDate": "2023-05-06T02:43:37Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "49b0afdf8e501acdce6e2d829a0fba3060f687c7",
          "message": "reduce code repetition; try double if long fails in the same method",
          "committedDate": "2023-05-10T23:48:35Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "792e61a9899a50a1f88254d52b5e597385663da7",
          "message": "modify TryConvertToLong to check long min/max values before converting double to long; add tests for values that exceed long min/max",
          "committedDate": "2023-05-11T18:11:51Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "333f24273f2bb7fd37f27bab6e65e068d3c98233",
          "message": "modify TryConvertToInt to check int min/max before converting to double",
          "committedDate": "2023-05-11T18:11:51Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "278e3819e17eeaba7be8dc25bf3d45728ddc9d3b",
          "message": "Merge branch 'dotnet:main' into IntrinsicFunctionsOverload",
          "committedDate": "2023-05-12T12:25:27Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6369e80b073f43324ddc78944b8ae9b7f3a23475",
          "message": "change access to TryConvertToInt, TryConvertToLong, TryConvertToDouble; add unit tests; change functions based on unit test findings",
          "committedDate": "2023-05-20T22:30:18Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1e705f6cb23c8019f4f24ad5f926619bee3beca",
          "message": "chnages to rely on TryParse",
          "committedDate": "2023-05-20T23:13:32Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0f6ed65aea401b96a639c8b84db7d0688a48591d",
          "message": "modify test TryConvertToLongGivenDoubleWithLongMaxValue for Apple Silicon",
          "committedDate": "2023-05-21T14:49:41Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "de36cf09da5d5b9e0563fed51186ebc4fb129d34",
          "message": "Merge branch 'dotnet:main' into IntrinsicFunctionsOverload",
          "committedDate": "2023-05-21T19:05:34Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "158e6e64b7d99ebfb0330a42f634039daa7ca328",
          "message": "cache comparer for arithmetic overloads",
          "committedDate": "2023-05-22T15:59:51Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2cb002fb1c282af42ed1cf45458a8284ca457e3",
          "message": "change to use Type.FindMembers and Array.Sort",
          "committedDate": "2023-05-22T19:46:20Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "824825bb77ed537ac3fc6766a1d8f7753fced30b",
          "message": "add comment",
          "committedDate": "2023-05-23T02:52:38Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f64fa81d4e5c636fe333d3a3e116c8c3936a4a79",
          "message": "update TryParse to use invariant culture",
          "committedDate": "2023-05-25T23:26:25Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "23396810b918727f230a54f6ec3199ea8d349f90",
          "message": "change to accept thousands separator and add test for different locale",
          "committedDate": "2023-05-29T16:24:23Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d66331766b8ad4dd78821672b71e43c8327161a",
          "message": "use InvariantCulture with double.TryParse",
          "committedDate": "2023-06-07T14:04:15Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "22f8684303abadef7f69b21f9a3c12325a0356b9",
          "message": "add comments",
          "committedDate": "2023-06-07T15:11:37Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1c7115e08de1c1c77dbc59030f37ce86473a537",
          "message": "fix IDE0005 error that is not reported in local builds",
          "committedDate": "2023-06-07T19:30:55Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d15f2f5da63bf1693532a9f3b7d1eac4ded79eb",
          "message": "Merge branch 'dotnet:main' into IntrinsicFunctionsOverload",
          "committedDate": "2023-06-07T19:34:22Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4f21730ae383e052851a69b2816423b6d68befce",
          "message": "revert unintended whitespace formatting",
          "committedDate": "2023-06-08T01:11:15Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "65cea2f4fd56ebdec256098590df7bd30bddb831",
          "message": "Merge branch 'dotnet:main' into IntrinsicFunctionsOverload",
          "committedDate": "2023-06-27T23:18:23Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19b50397c0a1f95dd524d3c102bb72ab860ee9c9",
          "message": "fix nullable errors after merge",
          "committedDate": "2023-06-28T00:25:43Z",
          "author": {
            "name": "Jonathan Dodds",
            "email": "jrdodds@me.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Two things:\r\n\r\nBefore we merge this, it'd be nice to validate that the fast path code now aligns properly with what would happen without the fast path. To do that, can you try ripping it all out and making sure all the tests pass as expected? (We'd want the fast path back before merging, of course.)\r\n\r\nSecond, although long division truncating values is what we've advertised in our documentation, it isn't what we're currently doing, and someone may have taken a dependency on 10/3 being 3.33... Can you add a ChangeWave for division?\r\n\r\nI haven't looked too closely at your code yet, but the tests you posted in your comment look great to me. Thanks for working on this!",
        "createdAt": "2023-05-01T15:25:45Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "When testing with the fast path disabled, the `LateBindExecute` method stops searching when it finds the first method that could support the argument types and it finds the `double` versions of the arithmetic functions first.\r\n\r\nExample:\r\n```\r\n$([MSBuild]::Add($([System.Int64]::MaxValue), 1))\r\n```\r\nproduces a result of 9.22337203685478E+18 instead of the expected -9223372036854775808.\r\n\r\nI'll make a change to `LateBindExecute` to choose methods with types that match over types that can be coerced.\r\n\r\nI'll make the ChangeWave cover integer versus real for addition, subtraction, multiplication, and division.\r\n\r\n(I also need to add tests for multiplication overflow.)",
        "createdAt": "2023-05-01T17:13:13Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "> When testing with the fast path disabled, the LateBindExecute method stops searching when it finds the first method that could support the argument types and it finds the double versions of the arithmetic functions first.\r\n\r\nThis was a bit surprising to me, but I can see why it would do that. Rather than any overly complicated logic, can we just reorder the Add methods, for instance, such that it tries to coerce the arguments to integers, then longs, then doubles? I'm trying to minimize the impact of the change while still getting the desired outcome.",
        "createdAt": "2023-05-05T21:55:22Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Yes, the methods in the `IntrinsicFunctions` class could be re-ordered. I wasn't keen on doing that. Having functionality depend on the order of the methods in the source code seems brittle. It would need to be well commented or else it could be a very mysterious 'gotcha'. But more importantly there is a non-trivial behavior change that probably should be in a change wave. For the change wave mechanism, there needs to be a way to switch at runtime between the two behaviors.",
        "createdAt": "2023-05-06T01:38:40Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "The changes are using change wave 17.8 as a placeholder pending discussion.",
        "createdAt": "2023-05-06T10:42:47Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "@JanKrivanek Was there feedback on the decimal separator? ",
        "createdAt": "2023-05-12T13:04:12Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "> @JanKrivanek Jan Krivanek FTE Was there feedback on the decimal separator?\r\n\r\nNot yet. I suppose we'll discuss this on Monday\r\nPer our informal SOP the PR will need to be signed off by one another team member anyways",
        "createdAt": "2023-05-12T13:07:58Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "New commits to address #8798 within the scope of this work - i.e. code touched or changed by this PR now uses a different overload of `double.Parse`:\r\n\r\n```csharp\r\ndouble.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out arg)\r\n```\r\n\r\nThis may not close #8798. The issue could be in other places.",
        "createdAt": "2023-05-29T16:37:16Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "The description has been updated.",
        "createdAt": "2023-06-16T13:21:02Z",
        "author": {
          "login": "jrdodds"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "[`NumberFormatInfo.NumberDecimalSeparator`](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.numberformatinfo.numberdecimalseparator) - to make this safe for other locales",
              "createdAt": "2023-05-10T07:54:37Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,143 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I had a question about that myself.\r\n\r\nA [C# real literal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types#real-literals) uses `.`. Should MSBuild 'code' be invariant across locales? Or is that a moot question because locale specific string representations are already accepted? In which case should both the locale variant and invariant decimal separators be accepted?",
              "createdAt": "2023-05-10T12:12:59Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,143 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "This is good point. I suppose MSBuild script is treated invariant - but rather summoning @rainersigwald to confirm here.",
              "createdAt": "2023-05-11T11:38:29Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,143 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I have two asks for this code:\r\n\r\n1) can we extract this to prevent repetition?\r\n\r\n2) This code doesn't grace handle large integers (no decimals, value above long max) - e.g. \"12345678901234567890123456\". How about first trying to convert to long, and fallback to double if that is not possible?",
              "createdAt": "2023-05-10T08:02:44Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,143 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));\n+            }\n+\n+            private static bool TryExecuteAdd(object[] args, out object resultValue)\n+            {\n+                resultValue = null;\n+\n+                if (args.Length != 2)\n+                {\n+                    return false;\n+                }\n+\n+                if (!IsIntrinsicFunctionOverloadsEnabled() || IsFloatingPointRepresentation(args[0]) || IsFloatingPointRepresentation(args[1]))\n+                {\n+                    if (TryConvertToDouble(args[0], out double arg0) && TryConvertToDouble(args[1], out double arg1))\n+                    {\n+                        resultValue = IntrinsicFunctions.Add(arg0, arg1);\n+                        return true;\n+                    }\n+                }\n+                else if (TryConvertToLong(args[0], out long arg0) && TryConvertToLong(args[1], out long arg1))\n+                {\n+                    resultValue = IntrinsicFunctions.Add(arg0, arg1);\n+                    return true;\n+                }\n+\n+                return false;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "There is a lot of repetition in the handling of the intrinsic functions and there is an idea that has been floated that there should be a code generator for it.\r\n\r\nYes, the `TryExecute[Add|Subtract|Multiply|Divide|Modulo]` methods don't handle large integers and that case was always handled elsewhere in the code.\r\n\r\nThe `IsFloatingPointRepresentation()` method is intended to be a quick test without attempting a full parse. It can be used to skip first trying to convert to long.",
              "createdAt": "2023-05-10T12:39:35Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,143 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));\n+            }\n+\n+            private static bool TryExecuteAdd(object[] args, out object resultValue)\n+            {\n+                resultValue = null;\n+\n+                if (args.Length != 2)\n+                {\n+                    return false;\n+                }\n+\n+                if (!IsIntrinsicFunctionOverloadsEnabled() || IsFloatingPointRepresentation(args[0]) || IsFloatingPointRepresentation(args[1]))\n+                {\n+                    if (TryConvertToDouble(args[0], out double arg0) && TryConvertToDouble(args[1], out double arg1))\n+                    {\n+                        resultValue = IntrinsicFunctions.Add(arg0, arg1);\n+                        return true;\n+                    }\n+                }\n+                else if (TryConvertToLong(args[0], out long arg0) && TryConvertToLong(args[1], out long arg1))\n+                {\n+                    resultValue = IntrinsicFunctions.Add(arg0, arg1);\n+                    return true;\n+                }\n+\n+                return false;",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "Thanks for the current extraction of the common code!\r\nAs for handling large integers - this is fine now as well, I'd just like to see an explicit unit test for that (to prevent future breaks)",
              "createdAt": "2023-05-11T11:45:10Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,143 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));\n+            }\n+\n+            private static bool TryExecuteAdd(object[] args, out object resultValue)\n+            {\n+                resultValue = null;\n+\n+                if (args.Length != 2)\n+                {\n+                    return false;\n+                }\n+\n+                if (!IsIntrinsicFunctionOverloadsEnabled() || IsFloatingPointRepresentation(args[0]) || IsFloatingPointRepresentation(args[1]))\n+                {\n+                    if (TryConvertToDouble(args[0], out double arg0) && TryConvertToDouble(args[1], out double arg1))\n+                    {\n+                        resultValue = IntrinsicFunctions.Add(arg0, arg1);\n+                        return true;\n+                    }\n+                }\n+                else if (TryConvertToLong(args[0], out long arg0) && TryConvertToLong(args[1], out long arg1))\n+                {\n+                    resultValue = IntrinsicFunctions.Add(arg0, arg1);\n+                    return true;\n+                }\n+\n+                return false;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "FYI @ghogen - if this get's approved and merged in the current proposed functionality, we should probably explicitly document this here https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions#msbuild-property-functions, with advice to indicate double literal if scale over precision is preferred (as this is now prioritizing precision over scale, by respecting integer literals as longs)",
              "createdAt": "2023-05-11T11:28:33Z",
              "path": "src/Build.UnitTests/Evaluation/Expander_Tests.cs",
              "diffHunk": "@@ -3394,12 +3396,6 @@ public void PropertyFunctionStaticMethodIntrinsicMaths()\n             result = expander.ExpandIntoStringLeaveEscaped(@\"$([MSBuild]::Modulo(2345.5, 43))\", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);\n \n             Assert.Equal((2345.5 % 43).ToString(), result);\n-\n-            // test for overflow wrapping\n-            result = expander.ExpandIntoStringLeaveEscaped(@\"$([MSBuild]::Add(9223372036854775807, 20))\", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);\n-\n-            double expectedResult = 9223372036854775807D + 20D;\n-            Assert.Equal(expectedResult.ToString(), result);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can throw. We should first try to check that value is within allowed range (long Min/Max Value).\r\nIs there a way to invoke this case - to have it tested?",
              "createdAt": "2023-05-11T11:35:20Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4533,24 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added the min/max check to both TryConvertToLong and TryConvertToInt.\r\n\r\nTryConvertToLong  is only used by the arithmetic overloads.\r\n\r\nTryConvertToInt is used in many places and the change to add the min/max check is a separate commit in case it needs to be rolled back.",
              "createdAt": "2023-05-11T18:19:44Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4533,24 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We should add an explicit unit tests that uses an argument that is an integer value below and over the bounds.",
              "createdAt": "2023-05-11T11:42:28Z",
              "path": "src/Build.UnitTests/Evaluation/Expander_Tests.cs",
              "diffHunk": "@@ -4176,39 +4180,109 @@ public void PropertyFunctionMathMin()\n         }\n \n         [Fact]\n-        public void PropertyFunctionMSBuildAdd()\n+        public void PropertyFunctionMSBuildAddIntegerLiteral()\n         {\n             TestPropertyFunction(\"$([MSBuild]::Add($(X), 5))\", \"X\", \"7\", \"12\");\n         }\n \n+        [Fact]\n+        public void PropertyFunctionMSBuildAddRealLiteral()\n+        {\n+            TestPropertyFunction(\"$([MSBuild]::Add($(X), 0.5))\", \"X\", \"7\", \"7.5\");\n+        }\n+\n+        [Fact]\n+        public void PropertyFunctionMSBuildAddIntegerOverflow()\n+        {\n+            // Overflow wrapping - result exceeds size of long\n+            string expected = IsIntrinsicFunctionOverloadsEnabled ? \"-9223372036854775808\" : (long.MaxValue + 1.0).ToString();\n+            TestPropertyFunction(\"$([MSBuild]::Add($(X), 1))\", \"X\", long.MaxValue.ToString(), expected);\n+        }\n+",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added tests for under and over bounds",
              "createdAt": "2023-05-11T18:21:10Z",
              "path": "src/Build.UnitTests/Evaluation/Expander_Tests.cs",
              "diffHunk": "@@ -4176,39 +4180,109 @@ public void PropertyFunctionMathMin()\n         }\n \n         [Fact]\n-        public void PropertyFunctionMSBuildAdd()\n+        public void PropertyFunctionMSBuildAddIntegerLiteral()\n         {\n             TestPropertyFunction(\"$([MSBuild]::Add($(X), 5))\", \"X\", \"7\", \"12\");\n         }\n \n+        [Fact]\n+        public void PropertyFunctionMSBuildAddRealLiteral()\n+        {\n+            TestPropertyFunction(\"$([MSBuild]::Add($(X), 0.5))\", \"X\", \"7\", \"7.5\");\n+        }\n+\n+        [Fact]\n+        public void PropertyFunctionMSBuildAddIntegerOverflow()\n+        {\n+            // Overflow wrapping - result exceeds size of long\n+            string expected = IsIntrinsicFunctionOverloadsEnabled ? \"-9223372036854775808\" : (long.MaxValue + 1.0).ToString();\n+            TestPropertyFunction(\"$([MSBuild]::Add($(X), 1))\", \"X\", long.MaxValue.ToString(), expected);\n+        }\n+",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Your comment that even without the fast path, we were still only doing double arithmetic made me think hard about problems like this. Specifically, what is the \"right\" behavior when we would overflow post-operation? So like what is the correct value for Long.MaxValue + 1?\r\n\r\nI'm wondering whether it's a better design to prioritize long arithmetic, as we suggest we do in the docs, and say Long.MaxValue + 1 = Long.MinValue or quietly convert it to a double before doing the operation. Sorry if that was already discussed, and I missed it.",
              "createdAt": "2023-05-11T16:27:21Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));\n+            }\n+\n+            private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object resultValue)\n+            {\n+                resultValue = null;\n+\n+                if (args.Length != 2)\n+                {\n+                    return false;\n+                }\n+\n+                if (IsIntrinsicFunctionOverloadsEnabled() && !IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(args[1]))\n+                {\n+                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))\n+                    {\n+                        resultValue = integerOperation(argLong0, argLong1);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I suspect that converting to `double` on overflow would be adding a feature that may never be used in the field. I expect there is very little arithmetic performed in MSBuild and that most or nearly all of the arithmetic is with integer values that are well within the min and max values of `long`.",
              "createdAt": "2023-05-11T19:33:23Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));\n+            }\n+\n+            private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object resultValue)\n+            {\n+                resultValue = null;\n+\n+                if (args.Length != 2)\n+                {\n+                    return false;\n+                }\n+\n+                if (IsIntrinsicFunctionOverloadsEnabled() && !IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(args[1]))\n+                {\n+                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))\n+                    {\n+                        resultValue = integerOperation(argLong0, argLong1);",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "Since there is a workaround for this edge case (explicitly define any operand as double), I'm fine with the behavior. It just should be properly documented",
              "createdAt": "2023-05-12T12:57:00Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4694,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));\n+            }\n+\n+            private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object resultValue)\n+            {\n+                resultValue = null;\n+\n+                if (args.Length != 2)\n+                {\n+                    return false;\n+                }\n+\n+                if (IsIntrinsicFunctionOverloadsEnabled() && !IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(args[1]))\n+                {\n+                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))\n+                    {\n+                        resultValue = integerOperation(argLong0, argLong1);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't reliably detect the mantissa + exponent representation, for example `1e10`. Also, e.g. a comma makes the number a valid double even with English locale. So many potential traps here that I think it would be better to eliminate this method and instead rely only on the built-in `long.TryParse` and `double.TryParse`.",
              "createdAt": "2023-05-17T12:39:50Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4704,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "`long.TryParse` would always be attempted first and values that are `double` will always have the overhead of trying to parse twice. I was under the impression that parsing twice for `double` would be an issue from a performance perspective. But, having looked at usage of the arithmetic functions, I now think that was probably a premature optimization. The `double` overloads are used much less than the `long` overloads.\r\n\r\nThe `IsFloatingPointRepresentation` method is not intended to be 'air tight' and a false negative is not an issue in terms of behavior. But in terms of code maintenance, that's an easily missed nuance.\r\n\r\nI agree that it would be better to eliminate the `IsFloatingPointRepresentation` method.",
              "createdAt": "2023-05-18T13:36:31Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4704,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "Perf and maintainability is a delicate balance. I wish we had a magic formula to decide :-)\r\nThere was a consensus on the advice from @ladipro ",
              "createdAt": "2023-05-19T06:35:37Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4704,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "on the core libraries level we continue to make TryParse faster. Ideally it is not possible to do better and still have correctness. Number parsing is a subtle thing with a potential bug tail. I energetically recommend to defer to the libraries and open perf bugs against them if necessary \ud83d\ude04 ",
              "createdAt": "2023-05-19T15:04:27Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4704,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "new commit e1e705f to make changes to use TryParse",
              "createdAt": "2023-05-20T23:14:09Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4677,6 +4704,40 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)\n                 return false;\n             }\n \n+            private static bool IsFloatingPointRepresentation(object value)\n+            {\n+                const char numberDecimalSeparator = '.';\n+\n+                return value is double || (value is string str && str.Contains(numberDecimalSeparator));",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It would be nice to cache the comparer so it's not created over and over again. A small but avoidable allocation.",
              "createdAt": "2023-05-17T12:53:29Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5211,15 +5281,26 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n                 // search for a method with the right number of arguments\n                 if (memberInfo == null)\n                 {\n-                    MethodBase[] members;\n                     // Gather all methods that may match\n+                    IEnumerable<MethodBase> members;\n                     if (isConstructor)\n                     {\n                         members = _receiverType.GetConstructors(bindingFlags);\n                     }\n                     else\n                     {\n-                        members = _receiverType.GetMethods(bindingFlags);\n+                        members = _receiverType.GetMethods(bindingFlags).Where(m => string.Equals(m.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase));\n+\n+                        if (_receiverType == typeof(IntrinsicFunctions))\n+                        {\n+                            // Order by the TypeCode of the first parameter.\n+                            // When change wave is enabled, order long before double.\n+                            // Otherwise preserve prior behavior of double before long.\n+                            IComparer<TypeCode> comparer = IsIntrinsicFunctionOverloadsEnabled()\n+                                ? Comparer<TypeCode>.Create((key0, key1) => key0.CompareTo(key1))\n+                                : Comparer<TypeCode>.Create((key0, key1) => key1.CompareTo(key0));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "new commit 158e6e6 to cache to the comparer",
              "createdAt": "2023-05-22T16:02:33Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5211,15 +5281,26 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n                 // search for a method with the right number of arguments\n                 if (memberInfo == null)\n                 {\n-                    MethodBase[] members;\n                     // Gather all methods that may match\n+                    IEnumerable<MethodBase> members;\n                     if (isConstructor)\n                     {\n                         members = _receiverType.GetConstructors(bindingFlags);\n                     }\n                     else\n                     {\n-                        members = _receiverType.GetMethods(bindingFlags);\n+                        members = _receiverType.GetMethods(bindingFlags).Where(m => string.Equals(m.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase));\n+\n+                        if (_receiverType == typeof(IntrinsicFunctions))\n+                        {\n+                            // Order by the TypeCode of the first parameter.\n+                            // When change wave is enabled, order long before double.\n+                            // Otherwise preserve prior behavior of double before long.\n+                            IComparer<TypeCode> comparer = IsIntrinsicFunctionOverloadsEnabled()\n+                                ? Comparer<TypeCode>.Create((key0, key1) => key0.CompareTo(key1))\n+                                : Comparer<TypeCode>.Create((key0, key1) => key1.CompareTo(key0));",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since we're on a relatively hot path, I wonder if `Type.FindMembers` + in-place sort of the results wouldn't be faster.",
              "createdAt": "2023-05-17T13:52:09Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5211,15 +5281,26 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n                 // search for a method with the right number of arguments\n                 if (memberInfo == null)\n                 {\n-                    MethodBase[] members;\n                     // Gather all methods that may match\n+                    IEnumerable<MethodBase> members;\n                     if (isConstructor)\n                     {\n                         members = _receiverType.GetConstructors(bindingFlags);\n                     }\n                     else\n                     {\n-                        members = _receiverType.GetMethods(bindingFlags);\n+                        members = _receiverType.GetMethods(bindingFlags).Where(m => string.Equals(m.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase));\n+\n+                        if (_receiverType == typeof(IntrinsicFunctions))\n+                        {\n+                            // Order by the TypeCode of the first parameter.\n+                            // When change wave is enabled, order long before double.\n+                            // Otherwise preserve prior behavior of double before long.\n+                            IComparer<TypeCode> comparer = IsIntrinsicFunctionOverloadsEnabled()\n+                                ? Comparer<TypeCode>.Create((key0, key1) => key0.CompareTo(key1))\n+                                : Comparer<TypeCode>.Create((key0, key1) => key1.CompareTo(key0));\n+                            members = members.OrderBy(SelectTypeOfFirstParameter, comparer);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "new commit f2cb002 to use `Type.FindMembers` and `Array.Sort`",
              "createdAt": "2023-05-22T19:49:29Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -5211,15 +5281,26 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o\n                 // search for a method with the right number of arguments\n                 if (memberInfo == null)\n                 {\n-                    MethodBase[] members;\n                     // Gather all methods that may match\n+                    IEnumerable<MethodBase> members;\n                     if (isConstructor)\n                     {\n                         members = _receiverType.GetConstructors(bindingFlags);\n                     }\n                     else\n                     {\n-                        members = _receiverType.GetMethods(bindingFlags);\n+                        members = _receiverType.GetMethods(bindingFlags).Where(m => string.Equals(m.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase));\n+\n+                        if (_receiverType == typeof(IntrinsicFunctions))\n+                        {\n+                            // Order by the TypeCode of the first parameter.\n+                            // When change wave is enabled, order long before double.\n+                            // Otherwise preserve prior behavior of double before long.\n+                            IComparer<TypeCode> comparer = IsIntrinsicFunctionOverloadsEnabled()\n+                                ? Comparer<TypeCode>.Create((key0, key1) => key0.CompareTo(key1))\n+                                : Comparer<TypeCode>.Create((key0, key1) => key1.CompareTo(key0));\n+                            members = members.OrderBy(SelectTypeOfFirstParameter, comparer);",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Convert will throw for `Convert.ToInt64((double)long.MaxValue)` (credit to @rokonec for discovering this)\r\n\r\nPlease use `long.CreateTruncating(d)` instead - as it grace handles those boundaries.\r\nSame for the Int32 above.",
              "createdAt": "2023-05-18T09:38:18Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4538,29 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        if (d >= long.MinValue && d <= long.MaxValue)\n+                        {\n+                            arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Or reuse the code from runtime - so that it works for fullFW as well:\r\n\r\n```\r\narg0 = (d >= long.MaxValue) ? long.MaxValue : (d <= long.MinValue) ? long.MinValue : (long)d;\r\n```",
              "createdAt": "2023-05-18T09:48:03Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4538,29 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        if (d >= long.MinValue && d <= long.MaxValue)\n+                        {\n+                            arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The two functions should not throw but also should return false instead of truncating when a `double` can't be narrowed.",
              "createdAt": "2023-05-18T14:21:26Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4538,29 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        if (d >= long.MinValue && d <= long.MaxValue)\n+                        {\n+                            arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "They should not (would `Convert` behave to its specification), but unfortunately they do...\r\n\r\n```csharp\r\n\ttry\r\n\t{\r\n\t\tTryConvertToLong((double)long.MaxValue, out _);\r\n\t}\r\n\tcatch(OverflowException)\r\n\t{\r\n\t\tConsole.WriteLine(\"This should never happen!! Or it might? ;-) ...\");\r\n\t}\r\n```\r\n\r\nBtw. we should add a test that exercises that (then add the fixing check for boundary values). Extracting + exposing functions for easier testability is fine.",
              "createdAt": "2023-05-19T06:44:13Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4538,29 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        if (d >= long.MinValue && d <= long.MaxValue)\n+                        {\n+                            arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "> Convert will throw for Convert.ToInt64((double)long.MaxValue) (credit to @rokonec for discovering this)\r\n\r\nThe above quote may have been simplifying but `Convert.ToInt64(double)` will throw an OverflowException for values >= (long.MaxValue - 511) and <= long.MaxValue.",
              "createdAt": "2023-05-20T19:40:26Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4538,29 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        if (d >= long.MinValue && d <= long.MaxValue)\n+                        {\n+                            arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "New commit 6369e80 for unit tests and changes to TryConvertToInt, TryConvertToLong, TryConvertToDouble functions.",
              "createdAt": "2023-05-20T22:32:12Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4534,6 +4538,29 @@ private static bool TryConvertToInt(object value, out int arg0)\n                 return false;\n             }\n \n+            private static bool TryConvertToLong(object value, out long arg0)\n+            {\n+                switch (value)\n+                {\n+                    case double d:\n+                        if (d >= long.MinValue && d <= long.MaxValue)\n+                        {\n+                            arg0 = Convert.ToInt64(d);",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "out of scope for this PR, but Expander is now jumbonormous. It might be good to explore simplifying things, eg., pull intrinsic functions into its own class or at least partial class, or the whole binder as well maybe.",
              "createdAt": "2023-05-19T15:05:45Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -3463,21 +3463,25 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,\n                     // that it matches the left hand side ready for the default binder\u2019s method invoke.\n                     if (objectInstance != null && args.Length == 1 && (String.Equals(\"Equals\", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals(\"CompareTo\", _methodMethodName, StringComparison.OrdinalIgnoreCase)))\n                     {\n+                        // Support comparison when the lhs is an integer\n+                        if (IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(objectInstance))\n+                        {\n+                            objectInstance = Convert.ChangeType(objectInstance, typeof(double), CultureInfo.InvariantCulture);\n+                            _receiverType = objectInstance.GetType();\n+                        }\n+\n                         // change the type of the final unescaped string into the destination\n                         args[0] = Convert.ChangeType(args[0], objectInstance.GetType(), CultureInfo.InvariantCulture);\n                     }\n \n                     if (_receiverType == typeof(IntrinsicFunctions))",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "marking as resolved because out of scope for this PR but agree that Expander needs to be factored",
              "createdAt": "2023-05-20T23:16:25Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -3463,21 +3463,25 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,\n                     // that it matches the left hand side ready for the default binder\u2019s method invoke.\n                     if (objectInstance != null && args.Length == 1 && (String.Equals(\"Equals\", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals(\"CompareTo\", _methodMethodName, StringComparison.OrdinalIgnoreCase)))\n                     {\n+                        // Support comparison when the lhs is an integer\n+                        if (IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(objectInstance))\n+                        {\n+                            objectInstance = Convert.ChangeType(objectInstance, typeof(double), CultureInfo.InvariantCulture);\n+                            _receiverType = objectInstance.GetType();\n+                        }\n+\n                         // change the type of the final unescaped string into the destination\n                         args[0] = Convert.ChangeType(args[0], objectInstance.GetType(), CultureInfo.InvariantCulture);\n                     }\n \n                     if (_receiverType == typeof(IntrinsicFunctions))",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please provide an example of when this would behave differently than the original `return arg == d`?",
              "createdAt": "2023-06-16T06:51:04Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4516,40 +4515,99 @@ private static bool TryConvertToVersion(object value, out Version arg0)\n                 return true;\n             }\n \n-            private static bool TryConvertToInt(object value, out int arg0)\n+            /// <summary>\n+            /// Try to convert value to int.\n+            /// </summary>\n+            internal static bool TryConvertToInt(object value, out int arg)\n             {\n                 switch (value)\n                 {\n                     case double d:\n-                        arg0 = Convert.ToInt32(d);\n-                        return arg0 == d;\n+                        if (d >= int.MinValue && d <= int.MaxValue)\n+                        {\n+                            arg = Convert.ToInt32(d);\n+                            if (Math.Abs(arg - d) == 0)\n+                            {\n+                                return true;\n+                            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That commit was about 4 weeks ago but if I recall correctly the `TryConvertToIntGivenDoubleWithIntMaxValue` unit test would fail because of [the issue with `Convert.ToInt64(double)`](https://github.com/dotnet/msbuild/pull/8710#discussion_r1199652007).",
              "createdAt": "2023-06-16T12:30:51Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4516,40 +4515,99 @@ private static bool TryConvertToVersion(object value, out Version arg0)\n                 return true;\n             }\n \n-            private static bool TryConvertToInt(object value, out int arg0)\n+            /// <summary>\n+            /// Try to convert value to int.\n+            /// </summary>\n+            internal static bool TryConvertToInt(object value, out int arg)\n             {\n                 switch (value)\n                 {\n                     case double d:\n-                        arg0 = Convert.ToInt32(d);\n-                        return arg0 == d;\n+                        if (d >= int.MinValue && d <= int.MaxValue)\n+                        {\n+                            arg = Convert.ToInt32(d);\n+                            if (Math.Abs(arg - d) == 0)\n+                            {\n+                                return true;\n+                            }",
              "author": {
                "login": "jrdodds"
              }
            },
            {
              "body": "Ah, sorry, I remember now. This looks non-obvious enough to deserve a code comment. Not blocking, only if you end up making other changes.",
              "createdAt": "2023-06-17T20:07:28Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4516,40 +4515,99 @@ private static bool TryConvertToVersion(object value, out Version arg0)\n                 return true;\n             }\n \n-            private static bool TryConvertToInt(object value, out int arg0)\n+            /// <summary>\n+            /// Try to convert value to int.\n+            /// </summary>\n+            internal static bool TryConvertToInt(object value, out int arg)\n             {\n                 switch (value)\n                 {\n                     case double d:\n-                        arg0 = Convert.ToInt32(d);\n-                        return arg0 == d;\n+                        if (d >= int.MinValue && d <= int.MaxValue)\n+                        {\n+                            arg = Convert.ToInt32(d);\n+                            if (Math.Abs(arg - d) == 0)\n+                            {\n+                                return true;\n+                            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good point. I'll add a comment if I make other changes. Thanks.",
              "createdAt": "2023-06-17T22:30:43Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -4516,40 +4515,99 @@ private static bool TryConvertToVersion(object value, out Version arg0)\n                 return true;\n             }\n \n-            private static bool TryConvertToInt(object value, out int arg0)\n+            /// <summary>\n+            /// Try to convert value to int.\n+            /// </summary>\n+            internal static bool TryConvertToInt(object value, out int arg)\n             {\n                 switch (value)\n                 {\n                     case double d:\n-                        arg0 = Convert.ToInt32(d);\n-                        return arg0 == d;\n+                        if (d >= int.MinValue && d <= int.MaxValue)\n+                        {\n+                            arg = Convert.ToInt32(d);\n+                            if (Math.Abs(arg - d) == 0)\n+                            {\n+                                return true;\n+                            }",
              "author": {
                "login": "jrdodds"
              }
            }
          ]
        }
      }
    ]
  }
}