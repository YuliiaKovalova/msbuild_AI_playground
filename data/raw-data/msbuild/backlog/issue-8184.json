{
  "number": 8184,
  "title": "Microsoft.Build API exception: Could not load file or assembly Microsoft.Build.Framework, Version=15.1.0.0 ",
  "body": "\r\nI am attempting to use the Microsoft.Build API to build projects and solution for use in an application within my company that is converting thousands of csproj files to the SDK format and verifying the build before and after.  I am running into an exception with WPF projects that are in the Framework format.  If I convert the project to  SDK, the build succeeds.  I do not have this issue building within Visual Studio 2022 or using MSBuild in 2022 Developer Command prompt.  When I dig into the the exception I find that the root cause is an FileNotFoundException loading 'Microsoft.Build.Framework, Version=15.1.0.0,...'  \r\n\r\nI am not sure if there is a problem with my installation or something with my code/setup.  I have attached the results of [EnumerateMSBuild.ps1](https://github.com/microsoft/msbuild/blob/2d82e1a861d890fce68c8e2d42b569e5bbaf5687/scripts/EnumerateMSBuild.ps1) and included as much detail as I can think of below.  Please let me know if you require any more information and thank you in advance for any guidance.  \r\n\r\n[msbuild_versions.txt](https://github.com/dotnet/msbuild/files/10056181/msbuild_versions.txt)\r\n\r\nThe Error I get from the build is:\r\n```\r\nC:\\windows\\Microsoft.NET\\Framework\\v4.0.30319\\Microsoft.WinFx.targets(268,9): error MC1000: Unknown build error, 'Object reference not set to an instance of an object.' \r\n    0 Warning(s)\r\n    1 Error(s)\r\n```\r\n\r\nThe diagnostic level log (abridged) has this information around the error:\r\n```\r\n Using \"MarkupCompilePass1\" task from assembly \"PresentationBuildTasks, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\".\r\n  Task \"MarkupCompilePass1\"\r\n...\r\n    Input: Assembly Reference file: 'C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\Facades\\System.Xml.XPath.XDocument.dll'.\r\n    C:\\windows\\Microsoft.NET\\Framework\\v4.0.30319\\Microsoft.WinFx.targets(268,9): error MC1000: Unknown build error, 'Object reference not set to an instance of an object.' \r\n  Done executing task \"MarkupCompilePass1\" -- FAILED.\r\nDone building target \"MarkupCompilePass1\" in project \"G1.UI.WPF.csproj\" -- FAILED.\r\n```\r\n\r\nWhen I attach a debugger and decompile symbols, I find the null ref is in the error handler on the \"linePos\" line, but the actual exception \"e\" is a file not found.\r\n``` C#\r\n\\\\MS.Internal.MarkupCompiler\r\n    internal void OnError(Exception e)\r\n    {\r\n      if (this.Error == null)\r\n        return;\r\n      int lineNum = e is XamlParseException xamlParseException ? xamlParseException.LineNumber : 0;\r\n      int linePos = xamlParseException != null ? xamlParseException.LinePosition : 0;\r\n      string originalFilePath = this.SourceFileInfo.OriginalFilePath;\r\n      this.Error((object) this, new MarkupErrorEventArgs(e, lineNum, linePos, originalFilePath));\r\n    }\r\n```\r\n\r\nActual exception:\r\n```\r\nSystem.IO.FileNotFoundException\r\n  HResult=0x80070002\r\n  Message=Could not load file or assembly 'Microsoft.Build.Framework, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The system cannot find the file specified.\r\n  Source=PresentationBuildTasks\r\n  StackTrace:\r\n   at MS.Internal.CompilerWrapper.OnSourceFileResolve(Object sender, SourceFileResolveEventArgs e)\r\n   at MS.Internal.MarkupCompiler.OnSourceFileResolve(FileUnit file)\r\n\r\nInner Exception 1:\r\nFileNotFoundException: Could not load file or assembly 'Microsoft.Build.Framework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The system cannot find the file specified.\r\n\r\nCall Stack:\r\nPresentationBuildTasks.dll!MS.Internal.MarkupCompiler.OnSourceFileResolve(MS.Internal.FileUnit file)\r\nPresentationBuildTasks.dll!MS.Internal.MarkupCompiler.Initialize(MS.Internal.FileUnit sourceFile)\r\nPresentationBuildTasks.dll!MS.Internal.MarkupCompiler.Compile(MS.Internal.CompilationUnit cu)\r\nPresentationBuildTasks.dll!MS.Internal.CompilerWrapper.DoCompilation(string assemblyName, string language, string rootNamespace, MS.Internal.FileUnit[] fileList, bool isSecondPass)\r\n[AppDomain (SlnToSdk.exe, #1) -> AppDomain (markupCompilationAppDomain, #2)]\r\n```\r\n\r\nModules (abridged):\r\n| Name | Version | AppDomain | Path |\r\n|---|---|---|---|\r\n|PresentationBuildTasks.dll\t| PresentationBuildTasks.dll \t4.8.4084.0 built by: NET48REL1\t| [2] markupCompilationAppDomain |\tC:\\windows\\Microsoft.Net\\assembly\\GAC_MSIL\\PresentationBuildTasks\\v4.0_4.0.0.0__31bf3856ad364e35\\PresentationBuildTasks.dll |\r\n| Microsoft.Build.Utilities.v4.0.dll |\tMicrosoft.Build.Utilities.v4.0.dll\t4.8.4084.0 built by: NET48REL1\t| [2] markupCompilationAppDomain\t|C:\\windows\\Microsoft.Net\\assembly\\GAC_MSIL\\Microsoft.Build.Utilities.v4.0\\v4.0_4.0.0.0__b03f5f7f11d50a3a\\Microsoft.Build.Utilities.v4.0.dll\t|\r\n|Microsoft.Build.Locator.dll |\tMicrosoft.Build.Locator.dll\t1.05.5.21636\t| [1] SlnToSdk.exe\t| C:\\src\\etdev\\NET6Migration\\SlnToSdk\\bin\\Debug\\net48\\Microsoft.Build.Locator.dll\t|\r\n| Microsoft.Build.dll\t| Microsoft.Build.dll\t17.02.1.25201\t| [1] SlnToSdk.exe\t| C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Build.dll\t|\r\n| Microsoft.Build.Framework.dll\t| Microsoft.Build.Framework.dll\t17.02.1.25201\t| [1] SlnToSdk.exe\t| C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Build.Framework.dll\t|\r\n| SlnToSdk.exe\t| SlnToSdk.exe\t1.00.0.0\t| [1] SlnToSdk.exe\t| C:\\src\\etdev\\NET6Migration\\SlnToSdk\\bin\\Debug\\net48\\SlnToSdk.exe\t|\r\n\r\nMy code: \r\n``` Xml\r\n<!-- Directory.Packages.props -->\r\n<Project>\r\n    <PropertyGroup>\r\n        <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\r\n    </PropertyGroup>\r\n    <ItemGroup>\r\n\t   <PackageVersion Include=\"Microsoft.Build\" Version=\"17.2.2\" />\r\n       <PackageVersion Include=\"Microsoft.Build.Locator\" Version=\"1.5.5\" />\r\n </ItemGroup>\r\n</Project>\r\n\r\n<!-- Directory.Build.targets -->\r\n<Project>\r\n <Target Name=\"NukeAll\">\r\n        <RemoveDir Directories=\"$(BaseOutputPath)\" /> \r\n        <RemoveDir Directories=\"$(BaseIntermediateOutputPath)\" /> \r\n    </Target>\r\n</Project>\r\n\r\n<!-- .csproj --> \r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFrameworks>net48</TargetFrameworks>\r\n    <Nullable>enable</Nullable>\r\n    <LangVersion>latest</LangVersion>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.Build\" ExcludeAssets=\"runtime\" />\r\n    <PackageReference Include=\"Microsoft.Build.Locator\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n``` C#\r\n//Program\r\nvar latestInstance = MSBuildLocator.QueryVisualStudioInstances().MaxBy(x => x.Version);\r\nMSBuildLocator.RegisterInstance(latestInstance);\r\nBuild(args[0]);\r\n\r\nBuildResult Build(string solutionOrProjectFile)\r\n{\r\n    var pc = new ProjectCollection();\r\n    var parameters = new BuildParameters(pc)\r\n    {\r\n        Loggers = new[]\r\n        {\r\n            new Microsoft.Build.Logging.ConsoleLogger(),\r\n            new Microsoft.Build.Logging.FileLogger()\r\n            {\r\n                Verbosity = LoggerVerbosity.Diagnostic\r\n            }\r\n        } \r\n    };\r\n\r\n    var request = new BuildRequestData(\r\n        projectFullPath: solutionOrProjectFile,\r\n        globalProperties: new Dictionary<string, string>\r\n        {\r\n            {\"Configuration\", \"Release\"},\r\n        },\r\n        toolsVersion: null,\r\n        targetsToBuild: new string[]\r\n        {\r\n            \"NukeAll\",\r\n            \"Restore\",\r\n            \"Build\"\r\n        },\r\n        hostServices: null,\r\n        flags: BuildRequestDataFlags.ProvideProjectStateAfterBuild);\r\n\r\n    var buildResult = BuildManager.DefaultBuildManager.Build(parameters, request);\r\n    return buildResult;\r\n}\r\n```",
  "state": "OPEN",
  "createdAt": "2022-11-21T14:19:38Z",
  "updatedAt": "2024-01-31T08:15:36Z",
  "closedAt": null,
  "author": {
    "login": "mattaquinn"
  },
  "labels": [
    "backlog",
    "Area: API",
    "Priority:2",
    "triaged",
    "Area: MSBuildLocator"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "Digging into this deeper I am noticing that Microsoft.Build.* assemblies in C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\ have **FileName = 17.2.1.25201**, but are signed as Microsoft.Build, **Version=15.1.0.0**, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\r\n\r\nI am not sure if this is expected or a contributing factor.\r\n\r\n\r\nI'll also note that if I GAC these assemblies, then they are found.  Should they be GAC'd?  I see other lower versioned Microsoft.Build.* assemblies in the GAC.",
        "createdAt": "2022-11-22T15:13:16Z",
        "updatedAt": "2022-11-22T15:13:16Z",
        "author": {
          "login": "mattaquinn"
        }
      },
      {
        "body": "Very interesting. I repro, and on my test project I can fix by adding\r\n\r\n```c#\r\nDisableInProcNode = true,\r\n```\r\n\r\nto the `BuildParameters`. That forces the actual task execution into a copy of `MSBuild.exe` spawned by the API as a worker node, rather than running it in-proc, which appears to work around a problem inside the task (I'm guessing caused by doing something with an `AppDomain` inside the task).\r\n\r\n**Can you try that?**\r\n\r\n\r\n\r\n> Digging into this deeper I am noticing that Microsoft.Build.* assemblies in C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\ have **FileName = 17.2.1.25201**, but are signed as Microsoft.Build, **Version=15.1.0.0**, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\r\n> \r\n> I am not sure if this is expected or a contributing factor.\r\n\r\nIt's expected. We've kept the AssemblyVersion constant at `15.1.0.0` to minimize the need to update binding redirects when MSBuild updates, but the file version reports the \"true\" version.\r\n\r\n\r\n> I'll also note that if I GAC these assemblies, then they are found. Should they be GAC'd? I see other lower versioned Microsoft.Build.* assemblies in the GAC.\r\n\r\nThey should **not** be GACed. If you GAC them you'll run into problems on VS upgrades/updates and potentially break side-by-side installations of Visual Studio (for instance having Preview and release installed simultaneously).",
        "createdAt": "2022-11-22T15:50:41Z",
        "updatedAt": "2022-11-22T15:50:41Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald Thank you! This did the trick.\r\n\r\n``` C#\r\n        var parameters = new BuildParameters(pc)\r\n        {\r\n            Loggers = ...\r\n            DisableInProcNode = true\r\n        };\r\n```\r\n",
        "createdAt": "2022-11-22T16:09:31Z",
        "updatedAt": "2022-11-22T16:09:31Z",
        "author": {
          "login": "mattaquinn"
        }
      },
      {
        "body": "It appears the above work-around creates a different problem, whenever a solution has a build dependency the build fails with \r\n\r\n error MSB4025: The project file could not be loaded. Could not find file 'Path\\to\\Some.csproj.metaproj'.\r\n\r\nThis seems to explain the problem best: https://github.com/dotnet/msbuild/issues/3517 \r\n\r\nIf set MSBuildEmitSolution=1 it will work, but (as intended) will leave .metaproj files hanging around afterwards.   \r\n\r\n@rainersigwald is there any other option I can try?  \r\n\r\n",
        "createdAt": "2022-12-06T16:22:40Z",
        "updatedAt": "2022-12-06T16:22:40Z",
        "author": {
          "login": "mattaquinn"
        }
      },
      {
        "body": "I have the same problem. And, to me it seems to be a general problem (or misunderstanding) about how MSBuild finds something (e.g. the assemblies that it loads). Whenever I run MSBuild from my solution, it doesn't work or load the wrong MSBuild version. I had to pack it into its own AppDomain and register assembly paths in order to solve this. I guess, Visual Studio does something similar, but I didn't find out what it does. ... now, this seems to be a solution, but it causes problems, whenever something happens, that runs in its own domain (again, I have no idea how Visual Studio handles this so that all the settings is makes are still set when something runs in its own domain)... but here, with XAML compilation, we do have such a problem. My temporary solution was to set \"AlwaysCompileMarkupFilesInSeparateDomain\" to \"false\". ... but I have still other problems like e.g. I cannot build solutions with project dependencies, because all the \"using\" paths are wrong then.\r\n\r\nso... would be nice to hear about how to prepare the \"world\" in order to be able to call MSBuild so that it then runs as if from within Visual Studio",
        "createdAt": "2022-12-20T14:59:11Z",
        "updatedAt": "2022-12-20T14:59:11Z",
        "author": {
          "login": "meirumeiru"
        }
      }
    ]
  }
}