{
  "number": 6913,
  "title": "How to evaluate a `Project` object created from memory rather than from a project file path?",
  "body": "I typically use the `Project(string projectFile)` constructor. However, in an attempt to better manage my IO workload vs CPU workload (as needed for improved performance processing thousands of C# files across hundreds of C# projects) I wanted to call the `Project(XmlReader xmlReader)` constructor. More details on what I am trying to achieve can be found here - https://stackoverflow.com/questions/69443155/how-to-optimize-performance-in-a-simple-tpl-dataflow-pipeline\r\n\r\nHowever, the `Project(XmlReader xmlReader)` constructor does not work and I think I know why. The `Project(string projectFile)` constructor initializes the Project's `FullPath` and `DirectoryPath` properties right away from the given `projectFile` argument. The `xmlReader` constructor does not do it and this yields wrong `Project` object.\r\n\r\nI have also found this comment in the [source code](https://github.com/dotnet/msbuild/blob/f9e7e8ed423930c0cb9753d949bdd0d161e3158a/src/Build/Definition/Project.cs#L716):\r\n```\r\npublic class Project : ILinkableObject\r\n{\r\n...\r\n    /// <summary>\r\n    /// The root directory for this project.\r\n    /// Is never null: in-memory projects use the current directory from the time of load.\r\n    /// </summary>\r\n    public string DirectoryPath => Xml.DirectoryPath;\r\n...\r\n}\r\n```\r\nSo one would think that setting the current directory to the project folder and then calling the `Project(XmlReader xmlReader)` constructor should work. No, it does not, the problem is that `MSBuildProjectFullPath` is `null` at a point where it is expected not to be. And setting it explicitly in the global properties is not allowed.\r\n\r\nAn important note - my code is .NET 5, but the projects I am trying to evaluate are .NET Framework. The Microsoft.Build NuGet package does not work here, at least I failed to make it work. So instead I am using the Microsoft.Build dll distributed with the VS like this:\r\n```\r\n  <PropertyGroup>\r\n    <VSINSTALLDIR Condition=\"'$(VSINSTALLDIR)' == '' AND '$(VSAPPIDDIR)' != ''\">$(VSAPPIDDIR)\\..\\..\\</VSINSTALLDIR>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <Reference Include=\"Microsoft.Build\">\r\n      <HintPath>$(VSINSTALLDIR)MSBuild\\Current\\Bin\\Microsoft.Build.dll</HintPath>\r\n    </Reference>\r\n    <Reference Include=\"Microsoft.Build.Framework\">\r\n      <HintPath>$(VSINSTALLDIR)MSBuild\\Current\\Bin\\Microsoft.Build.Framework.dll</HintPath>\r\n    </Reference>\r\n    <Reference Include=\"Microsoft.Build.Utilities.Core\">\r\n      <HintPath>$(VSINSTALLDIR)MSBuild\\Current\\Bin\\Microsoft.Build.Utilities.Core.dll</HintPath>\r\n    </Reference>\r\n  </ItemGroup>\r\n```\r\n\r\nSo, how can we evaluate a `Project` object created from memory?\r\n\r\n(I also posted this question on Stack Overflow - https://stackoverflow.com/questions/69454500/how-to-evaluate-a-microsoft-build-evaluation-project-object-created-from-memor)",
  "state": "CLOSED",
  "createdAt": "2021-10-06T04:10:44Z",
  "updatedAt": "2024-02-21T17:01:00Z",
  "closedAt": "2023-05-09T13:57:04Z",
  "author": {
    "login": "MarkKharitonov"
  },
  "labels": [
    "question",
    "Area: API",
    "author-responded",
    "Area: Tests",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "Have you tried the factory method `ProjectRootElement.Create` ? You can then couple this with `Project.FromProjectRootElement` if needed.\r\n\r\nI had a hard time using the Project API due to expectations on the project being backed by an on disk file, as well as performance issues when scanning 1000s of projects due to the Import elements being evaluated. ",
        "createdAt": "2021-10-06T10:39:10Z",
        "updatedAt": "2021-10-07T11:10:09Z",
        "author": {
          "login": "michael-baker"
        }
      },
      {
        "body": "@michael-baker - do you have a working example?",
        "createdAt": "2021-10-07T13:58:49Z",
        "updatedAt": "2021-10-07T13:58:49Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "@MarkKharitonov could you please post a self-contained C# console app example of how exactly you're calling MSBuild? You probably need a ProjectCollection to cache the XML.\r\n\r\nAlso you probably want to use MSBuildLocator:\r\nhttps://github.com/Microsoft/MSBuildLocator\r\ninstead of directly referencing the MSBuild dlls from the VS install path.\r\n\r\nAlso strictly speaking just evaluating to get the list of `Compile` items is not enough, since build targets can run in the project (and often do) that add generated .cs files to Compile item before they are passed to Csc. A lot of generated stuff like AssemblyVersionInfo.cs work this way. If you're OK with this, then evaluation is OK, just know that you'll be missing some generated files for some projects.\r\n\r\nIf you want the absolute full fidelity, there are several approaches you can take:\r\n * read the list of .cs files for each project from a .binlog: https://github.com/KirillOsenkov/SourceBrowser/wiki/Indexing-.binlogs\r\n * use Buildalyzer (https://github.com/daveaglick/Buildalyzer) which is a tool that runs proper design-time build (not just evaluation) so it will have .cs files added as part of target execution\r\n * read the resulting .dll file and if it has a portable .pdb (`DebugType` MSBuild property is either `portable` or `embedded`) then you can read the list of the .cs files from the .pdb (ILSpy shows debug directory entries for .pdb files):\r\n \r\n![image](https://user-images.githubusercontent.com/679326/136452242-19a15a4a-a695-43e8-a463-bd4796bad2d9.png)\r\n\r\nHere's an example of reading .pdb debug directory entries:\r\nhttps://github.com/KirillOsenkov/MetadataTools/blob/ee6bbe6b6aae78190eea6a7f4d740fbf8b190b80/src/Pdb/Program.cs#L138-L152",
        "createdAt": "2021-10-07T19:47:22Z",
        "updatedAt": "2021-10-07T19:49:47Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I've made a sample for evaluation here, but it evaluates files on disk. Let's see if we can change it to evaluate files in memory:\r\nhttps://github.com/KirillOsenkov/MSBuildTools/tree/main/src/Evaluation",
        "createdAt": "2021-10-07T20:23:52Z",
        "updatedAt": "2021-10-07T20:23:52Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov - I made an important note in the post - the code targets .NET Core, but the parsed projects target .NET Framework and many of them are **not** SDK style. I think it was you who has mentioned in the past that MSBuildLocator does not work in these circumstances.",
        "createdAt": "2021-10-07T21:23:06Z",
        "updatedAt": "2021-10-07T21:23:06Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "> \r\n> \r\n> @michael-baker - do you have a working example?\r\n\r\nToy example, just give the XML to the APIs mentioned\r\n\r\n```\r\nvar element1 = ProjectRootElement.Create();\r\nProjectPropertyGroupElement propertyGroup1 = element1.AddPropertyGroup();\r\npropertyGroup1.AddProperty(\"ProjectTypeGuids\", \"{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\");\r\npropertyGroup1.AddProperty(\"OutputType\", \"WinExe\");\r\npropertyGroup1.AddProperty(\"AssemblyName\", \"Blah\");\r\n\r\n\r\nvar fromProjectRootElement = Project.FromProjectRootElement(element1, new ProjectOptions() { });\r\n```\r\n\r\nfromProjectRootElement.FullPath won't throw it will return null.\r\n\r\n\r\nor\r\n\r\n```\r\nstring projectXml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n<Project ToolsVersion=\\\"14.0\\\" DefaultTargets=\\\"Build\\\" xmlns=\\\"http://schemas.microsoft.com/developer/msbuild/2003\\\"></Project>\";\r\n\r\nusing (var reader = new StringReader(projectXml)) {\r\n    ProjectRootElement element1;\r\n    using (var xmlReader = XmlReader.Create(reader)) {\r\n        element1 = ProjectRootElement.Create(xmlReader);\r\n    }\r\n\r\n    var fromProjectRootElement = Project.FromProjectRootElement(element1, new ProjectOptions() { });\r\n}\r\n```",
        "createdAt": "2021-10-07T21:52:45Z",
        "updatedAt": "2021-10-07T21:55:35Z",
        "author": {
          "login": "michael-baker"
        }
      },
      {
        "body": "**Use Cases**\r\n\r\nIn all the use cases I am going to parse legacy non SDK projects from .NET 5 code.\r\n\r\nThe repo https://github.com/MarkKharitonov/InMemoryMSBuild has 3 versions:\r\n\r\n 1. msbuild_from_nuget branch - using Microsoft.Build from NuGet\r\n 1. msbuild_from_vs branch:   - using Microsoft.Build from VS\r\n    1. from_disk tag            - reading from disk\r\n    1. from_memory tag          - reading from memory\r\n\r\n**Use case 1: using Microsoft.Build from nuget**\r\n\r\nSource code - https://github.com/MarkKharitonov/InMemoryMSBuild/tree/msbuild_from_nuget\r\n\r\n**InMemoryMSBuild.csproj**\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net5.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.Build\" Version=\"16.11.0\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n**Program.cs**\r\n\r\n```\r\nusing Microsoft.Build.Evaluation;\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Reflection;\r\n\r\nnamespace InMemoryMSBuild\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var sut = Path.GetFullPath(Path.Combine(Assembly.GetExecutingAssembly().Location, @\"..\\..\\..\\..\\..\\LegacyDotNetSUT\\LegacyDotNetSUT.csproj\"));\r\n            Debug.Assert(File.Exists(sut));\r\n            var project = new Project(sut);\r\n            foreach (var filePath in project.GetItems(\"Compile\").Select(o => o.GetMetadataValue(\"FullPath\")))\r\n            {\r\n                Console.WriteLine(filePath);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Output**\r\n```\r\nC:\\work\\InMemoryMSBuild [msbuild_from_nuget \u2261]> dotnet build /restore\r\nMicrosoft (R) Build Engine version 16.11.0+0538acc04 for .NET\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Determining projects to restore...\r\n  Restored C:\\work\\InMemoryMSBuild\\InMemoryMSBuild\\InMemoryMSBuild.csproj (in 328 ms).\r\n  LegacyDotNetSUT -> C:\\work\\InMemoryMSBuild\\LegacyDotNetSUT\\Bin\\Debug\\LegacyDotNetSUT.dll\r\n  InMemoryMSBuild -> C:\\work\\InMemoryMSBuild\\InMemoryMSBuild\\bin\\Debug\\net5.0\\InMemoryMSBuild.dll\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:02.91\r\nC:\\work\\InMemoryMSBuild [msbuild_from_nuget \u2261]> .\\InMemoryMSBuild\\bin\\Debug\\net5.0\\InMemoryMSBuild.exe\r\nUnhandled exception. Microsoft.Build.Exceptions.InvalidProjectFileException: The imported project \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\amd64\\Current\\Microsoft.Common.props\" was not found. Confirm that the expression in the Import declaration \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\amd64\\Current\\Microsoft.Common.props\" is correct, and that the file exists on disk.  C:\\work\\InMemoryMSBuild\\LegacyDotNetSUT\\LegacyDotNetSUT.csproj\r\n   at Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject(String errorSubCategoryResourceName, IElementLocation elementLocation, String resourceName, Object[] args)\r\n   at Microsoft.Build.Shared.ProjectErrorUtilities.VerifyThrowInvalidProject[T1,T2](Boolean condition, String errorSubCategoryResourceName, IElementLocation elementLocation, String resourceName, T1 arg0, T2 arg1)\r\n   at Microsoft.Build.Shared.ProjectErrorUtilities.ThrowInvalidProject[T1,T2](IElementLocation elementLocation, String resourceName, T1 arg0, T2 arg1)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImportsFromUnescapedImportExpression(String directoryOfImportingFile, ProjectImportElement importElement, String unescapedExpression, Boolean throwOnFileNotExistsError, List`1& imports)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(String directoryOfImportingFile, ProjectImportElement importElement, List`1& projects, SdkResult& sdkResult, Boolean throwOnFileNotExistsError)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImports(String directoryOfImportingFile, ProjectImportElement importElement, SdkResult& sdkResult)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.EvaluateImportElement(String directoryOfImportingFile, ProjectImportElement importElement)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.Evaluate()\r\n   at Microsoft.Build.Evaluation.Evaluator`4.Evaluate(IEvaluatorData`4 data, ProjectRootElement root, ProjectLoadSettings loadSettings, Int32 maxNodeCount, PropertyDictionary`1 environmentProperties, ILoggingService loggingService, IItemFactory`2 itemFactory, IToolsetProvider toolsetProvider, ProjectRootElementCacheBase projectRootElementCache, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, Int32 submissionId, EvaluationContext evaluationContext, Boolean interactive)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.Reevaluate(ILoggingService loggingServiceForEvaluation, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(ILoggingService loggingServiceForEvaluation, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(ILoggingService loggingServiceForEvaluation, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.Initialize(IDictionary`2 globalProperties, String toolsVersion, String subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion, String subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion, String subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)\r\n   at Microsoft.Build.Evaluation.Project..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)\r\n   at Microsoft.Build.Evaluation.Project..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion, ProjectCollection projectCollection)\r\n   at Microsoft.Build.Evaluation.Project..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion)\r\n   at Microsoft.Build.Evaluation.Project..ctor(String projectFile)\r\n   at InMemoryMSBuild.Program.Main(String[] args) in C:\\work\\InMemoryMSBuild\\InMemoryMSBuild\\Program.cs:line 16\r\nC:\\work\\InMemoryMSBuild [msbuild_from_nuget \u2261]>\r\n```\r\nSince parsing from disk does not work, no sense to proceed to in memory.\r\n\r\n**Use case 2: using Microsoft.Build from VS**\r\n\r\nSource code - https://github.com/MarkKharitonov/InMemoryMSBuild/tree/from_disk\r\n\r\n**InMemoryMSBuild.csproj**\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net5.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <PropertyGroup>\r\n    <VSINSTALLDIR Condition=\"'$(VSINSTALLDIR)' == '' AND '$(VSAPPIDDIR)' != ''\">$(VSAPPIDDIR)\\..\\..\\</VSINSTALLDIR>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Configuration.ConfigurationManager\" Version=\"5.0.0\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <Reference Include=\"Microsoft.Build\">\r\n      <HintPath>$(VSINSTALLDIR)MSBuild\\Current\\Bin\\Microsoft.Build.dll</HintPath>\r\n    </Reference>\r\n    <Reference Include=\"Microsoft.Build.Framework\">\r\n      <HintPath>$(VSINSTALLDIR)MSBuild\\Current\\Bin\\Microsoft.Build.Framework.dll</HintPath>\r\n    </Reference>\r\n    <Reference Include=\"Microsoft.Build.Utilities.Core\">\r\n      <HintPath>$(VSINSTALLDIR)MSBuild\\Current\\Bin\\Microsoft.Build.Utilities.Core.dll</HintPath>\r\n    </Reference>\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\n**Program.cs**\r\n\r\n*Same implementation*\r\n\r\n**Output**\r\n```\r\nC:\\work\\InMemoryMSBuild [(from_disk)]> dotnet build /restore\r\nMicrosoft (R) Build Engine version 16.11.0+0538acc04 for .NET\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Determining projects to restore...\r\n  Restored C:\\work\\InMemoryMSBuild\\InMemoryMSBuild\\InMemoryMSBuild.csproj (in 177 ms).\r\n  LegacyDotNetSUT -> C:\\work\\InMemoryMSBuild\\LegacyDotNetSUT\\Bin\\Debug\\LegacyDotNetSUT.dll\r\n  InMemoryMSBuild -> C:\\work\\InMemoryMSBuild\\InMemoryMSBuild\\bin\\Debug\\net5.0\\InMemoryMSBuild.dll\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:01.31\r\nC:\\work\\InMemoryMSBuild [(from_disk)]> .\\InMemoryMSBuild\\bin\\Debug\\net5.0\\InMemoryMSBuild.exe\r\nC:\\work\\InMemoryMSBuild\\LegacyDotNetSUT\\Class1.cs\r\nC:\\work\\InMemoryMSBuild [(from_disk)]>\r\n```\r\nWorks fine\r\n\r\n**Use case 3: using Microsoft.Build from VS to parse byte array**\r\n\r\nSource code - https://github.com/MarkKharitonov/InMemoryMSBuild/tree/from_memory\r\n\r\n**InMemoryMSBuild.csproj**\r\n\r\n*Same implementation*\r\n\r\n**Program.cs**\r\n```\r\nusing Microsoft.Build.Evaluation;\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing System.Xml;\r\n\r\nnamespace InMemoryMSBuild\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var sut = Path.GetFullPath(Path.Combine(Assembly.GetExecutingAssembly().Location, @\"..\\..\\..\\..\\..\\LegacyDotNetSUT\\LegacyDotNetSUT.csproj\"));\r\n            Debug.Assert(File.Exists(sut));\r\n\r\n            Console.WriteLine(\"Reading from disk\");\r\n            var project = new Project(sut);\r\n            foreach (var filePath in project.GetItems(\"Compile\").Select(o => o.GetMetadataValue(\"FullPath\")))\r\n            {\r\n                Console.WriteLine($\"File.Exists(\\\"{filePath}\\\") = {File.Exists(filePath)}\");\r\n            }\r\n            ProjectCollection.GlobalProjectCollection.UnloadAllProjects();\r\n\r\n            Console.WriteLine(\"Reading from memory\");\r\n            project = new Project(XmlReader.Create(new MemoryStream(File.ReadAllBytes(sut))));\r\n            foreach (var filePath in project.GetItems(\"Compile\").Select(o => o.GetMetadataValue(\"FullPath\")))\r\n            {\r\n                Console.WriteLine($\"File.Exists(\\\"{filePath}\\\") = {File.Exists(filePath)}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Output**\r\n```\r\nC:\\work\\InMemoryMSBuild [(from_memory)]> dotnet build /restore\r\nMicrosoft (R) Build Engine version 16.11.0+0538acc04 for .NET\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Determining projects to restore...\r\n  All projects are up-to-date for restore.\r\n  LegacyDotNetSUT -> C:\\work\\InMemoryMSBuild\\LegacyDotNetSUT\\Bin\\Debug\\LegacyDotNetSUT.dll\r\n  InMemoryMSBuild -> C:\\work\\InMemoryMSBuild\\InMemoryMSBuild\\bin\\Debug\\net5.0\\InMemoryMSBuild.dll\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:00.92\r\nC:\\work\\InMemoryMSBuild [(from_memory)]> .\\InMemoryMSBuild\\bin\\Debug\\net5.0\\InMemoryMSBuild.exe\r\nReading from disk\r\nFile.Exists(\"C:\\work\\InMemoryMSBuild\\LegacyDotNetSUT\\Class1.cs\") = True\r\nReading from memory\r\nFile.Exists(\"C:\\work\\InMemoryMSBuild\\Class1.cs\") = False\r\nC:\\work\\InMemoryMSBuild [(from_memory)]>\r\n```\r\nIn memory project is wrong, the file paths it produces are off.\r\n\r\n  [1]: https://github.com/dotnet/msbuild/blob/f9e7e8ed423930c0cb9753d949bdd0d161e3158a/src/Build/Definition/Project.cs#L716",
        "createdAt": "2021-10-08T03:38:09Z",
        "updatedAt": "2021-10-08T03:38:09Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "Bumpy bump. Knock knock.",
        "createdAt": "2021-11-04T03:30:51Z",
        "updatedAt": "2021-11-04T03:30:51Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "@MarkKharitonov I know my sample doesn't use in-memory evaluation, but still, have you tried it in your performance test? I'd be curious to see how it performs compared to other approaches.\r\n\r\nHere's the sample:\r\nhttps://github.com/KirillOsenkov/MSBuildTools/tree/main/src/Evaluation\r\n\r\nYou can try it out when you have time and let me know what the perf numbers are. Bonus points if you can profile and optimize to make it faster and send a PR ;)",
        "createdAt": "2021-11-04T16:28:51Z",
        "updatedAt": "2021-11-04T16:28:51Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov - thank you for providing this example.\r\n\r\nThere are several problems.\r\n\r\n**First problem**\r\nMy application uses MSBuild API to manipulate the project files on disk, but it also invokes msbuild.exe to actually build the manipulated code. And here hides a catch. Indeed, `MSBuildLocator.RegisterDefaults()` modifies the environment of the running process by adding 3 more variables:\r\n\r\n Name | Value \r\n -- | -- \r\n MSBUILD_EXE_PATH | \"C:\\\\Program Files\\\\dotnet\\\\sdk\\\\5.0.402\\\\MSBuild.dll\" \r\n MSBuildSDKsPath | \"C:\\\\Program Files\\\\dotnet\\\\sdk\\\\5.0.402\\\\Sdks\" \r\n MSBuildExtensionsPath | \"C:\\\\Program Files\\\\dotnet\\\\sdk\\\\5.0.402\\\\\" \r\n\r\nFor me this is important, because some of the projects are legacy Asp.Net projects, which cannot be built using the dotnet build tools. At least I do not know a way to do it. Therefore, I cannot use the build tools enforced by the presence of these environment variables - I need to remove them from the environment of the child process. Which is not a problem, although I do not like the idea of hard coding them.\r\n\r\nHowever, it still does not work. I have the following code in my tool:\r\n```\r\nm_project = new Lazy<Project>(() =>\r\n{\r\n    var found = ProjectCollection.GlobalProjectCollection.LoadedProjects.FirstOrDefault(p => p.FullPath.Equals(ProjectPath, C.IGNORE_CASE));\r\n    return found ?? new Project(ProjectPath, new Dictionary<string, string>\r\n    {\r\n        [\"SolutionDir\"] = Path.GetDirectoryName(SolutionPath) + \"\\\\\"\r\n    }, null);\r\n});\r\n```\r\nAnd this code throws an exception when evaluating a legacy Asp.Net project:\r\n![image](https://user-images.githubusercontent.com/489792/142709665-5c8ddab1-49bb-4eb2-9221-a4a2cf3ddc10.png)\r\n```\r\nSystem.IO.DirectoryNotFoundException\r\n  HResult=0x80070003\r\n  Message=Could not find a part of the path 'C:\\Program Files\\dotnet\\sdk\\5.0.402\\Microsoft\\VisualStudio\\v16.0\\WebApplications\\Microsoft.WebApplication.targets'.\r\n  Source=System.Private.CoreLib\r\n  StackTrace:\r\n   at System.IO.FileStream.ValidateFileHandle(SafeFileHandle fileHandle)\r\n```\r\nWhat is strange is that your little sample is able to evaluate it just fine. But there is a second problem here too.\r\n\r\n**Second problem**\r\nUnable to run your sample from VS 2019 IDE. I opened the relevant issue here - https://github.com/KirillOsenkov/MSBuildTools/issues/1\r\n\r\n**Third Problem**\r\nThis one is a minor nuisance - when compiling my unit tests with the NuGet packages as your sample suggests I get the following warnings:\r\n```\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277: Found conflicts between different versions of \"Microsoft.Win32.Registry\" that could not be resolved.\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277: There was a conflict between \"Microsoft.Win32.Registry, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" and \"Microsoft.Win32.Registry, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:     \"Microsoft.Win32.Registry, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" was chosen because it was primary and \"Microsoft.Win32.Registry, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" was not.\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:     References which depend on \"Microsoft.Win32.Registry, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" [C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.win32.registry\\4.3.0\\ref\\netstandard1.3\\Microsoft.Win32.Registry.dll].\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:         C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.win32.registry\\4.3.0\\ref\\netstandard1.3\\Microsoft.Win32.Registry.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:           Project file item includes which caused reference \"C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.win32.registry\\4.3.0\\ref\\netstandard1.3\\Microsoft.Win32.Registry.dll\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.win32.registry\\4.3.0\\ref\\netstandard1.3\\Microsoft.Win32.Registry.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:     References which depend on \"Microsoft.Win32.Registry, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" [].\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:         C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build\\16.11.0\\lib\\net5.0\\Microsoft.Build.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:           Project file item includes which caused reference \"C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build\\16.11.0\\lib\\net5.0\\Microsoft.Build.dll\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build\\16.11.0\\lib\\net5.0\\Microsoft.Build.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\dayforce\\CSTool\\CSTool\\bin\\Debug\\net5\\CSTool.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\dayforce\\CSTool\\CSTool.Infra\\bin\\Debug\\net5.0\\CSTool.Infra.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:         C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.tasks.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Tasks.Core.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:           Project file item includes which caused reference \"C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.tasks.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Tasks.Core.dll\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.tasks.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Tasks.Core.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:         C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.utilities.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Utilities.Core.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:           Project file item includes which caused reference \"C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.utilities.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Utilities.Core.dll\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.utilities.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Utilities.Core.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.build.tasks.core\\16.11.0\\lib\\netstandard2.0\\Microsoft.Build.Tasks.Core.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:         C:\\Users\\p11f70f\\.nuget\\packages\\nunit\\3.13.2\\lib\\netstandard2.0\\nunit.framework.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:           Project file item includes which caused reference \"C:\\Users\\p11f70f\\.nuget\\packages\\nunit\\3.13.2\\lib\\netstandard2.0\\nunit.framework.dll\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\nunit\\3.13.2\\lib\\netstandard2.0\\nunit.framework.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:         C:\\Program Files\\dotnet\\packs\\Microsoft.NETCore.App.Ref\\5.0.0\\ref\\net5.0\\mscorlib.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:           Project file item includes which caused reference \"C:\\Program Files\\dotnet\\packs\\Microsoft.NETCore.App.Ref\\5.0.0\\ref\\net5.0\\mscorlib.dll\".\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Program Files\\dotnet\\packs\\Microsoft.NETCore.App.Ref\\5.0.0\\ref\\net5.0\\mscorlib.dll\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets(2203,5): warning MSB3277:             C:\\Users\\p11f70f\\.nuget\\packages\\microsoft.codecoverage\\17.0.0\\lib\\netcoreapp1.0\\Microsoft.VisualStudio.CodeCoverage.Shim.dll\r\n```\r\nI managed to suppress them by adding `<MSBuildWarningsAsMessages>MSB3277</MSBuildWarningsAsMessages>` to the project file, but I do not like it at all.\r\n\r\n---\r\n\r\nEven though I do not understand how does it help me with my desire to evaluate a project in memory, I am still very much interested to make the NuGet package work, but this is another topic, isn't it? Or am I missing something? \r\n\r\n",
        "createdAt": "2021-11-20T03:00:56Z",
        "updatedAt": "2021-11-20T03:00:56Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "Instead of suppressing the MSB3277, you should use the binlog and understand where the conflicting references are coming from. Search for `$rar`, then look at the parameters of the task, and track down the origins of conflicting .dlls. I can't do this for you because I don't have access to your solution.\r\n\r\nCould you please remind us why do you need to evaluate in-memory? The sample I have provided should be high-performance and have sufficient throughput. If not, let's optimize the on-disk case. \r\n\r\nI'm not saying in-memory shouldn't work, but while we're waiting for someone else to respond to understand why in-memory doesn't work, I want to make sure that there are valid reasons why you want in-memory vs. on-disk. You may be going down the wrong path with the in-memory approach (or not, I don't know!)",
        "createdAt": "2021-11-20T04:00:53Z",
        "updatedAt": "2021-11-20T04:00:53Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "To your first problem, the only solution that comes to mind is to manually unset the environment variables before shelling out to an external MSBuild process. However I think this solution is perfectly acceptable.\r\n\r\nThe reason you're seeing failures with sdk 5.0.402 and Microsoft.WebApplication.targets is that your evaluation is in-proc, where the three environment variables are set. If you want to evaluate the legacy web projects, again, you need to unset the environment variables manually.\r\n\r\nThere are two different worlds: the legacy (with Microsoft.WebApplication.targets) and modern (.NET SDK, etc). You can't mix the two. You need to be fully aware of which world you're living in at any given point. Pay attention to where the MSBuild assemblies are loaded from in any process that hosts MSBuild, and which environment variables are set. All these details matter.\r\n\r\nThe legacy world is what it is. We can't go back in time and change it. This is why we are where we are, so we work with what we have.\r\n\r\n",
        "createdAt": "2021-11-20T04:06:36Z",
        "updatedAt": "2021-11-20T04:06:36Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov - I have unset the environment variables in my testing before invoking msbuild.exe and I did invoke it from the VS installation path because I need to build the legacy Asp.Net projects.\r\nThe error I see is when using MSBuild API to evaluate the projects. And it is a mystery why your sample is able to evaluate even the legacy Asp.Net projects (when ran on the console), whereas my code fails while using the same NuGet packages.",
        "createdAt": "2021-11-20T04:52:31Z",
        "updatedAt": "2021-11-20T04:52:31Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "@KirillOsenkov - I wanted in-memory for two reasons:\r\n\r\n1. I thought it would speed up parsing of about 400 projects if I read them all in memory first in 2 parallel streams (since I have SSD) and then evaluate them in memory using 12 (I have 12 logical processors) parallel streams. Sort of separating I/O from CPU load. This is now less relevant, because in addition to evaluating the projects I need to build the syntax trees for the source files in order to extract the names of the types and the cost of processing all the source files shadows the cost of reading the project files.\r\n2. Unit tests. I want to create dummy projects on the fly without polluting the disk. Right now I am doing it like this:\r\n```\r\npublic static Mock<IProjectEx> CreateProjectObjectMock(this string projectPath)\r\n{\r\n    var workDir = GetWorkDir();\r\n    var allProjects = GetProjectsToBuildInOrder(workDir);\r\n    var dependencies = YieldDependencies(projectPath, allProjects).Select(Path.GetFileNameWithoutExtension).ToList();\r\n\r\n    var projectMock = new Mock<IProjectEx>();\r\n    projectMock.Setup(o => o.AssemblyName).Returns(Path.GetFileNameWithoutExtension(projectPath));\r\n    projectMock.Setup(o => o.TargetPath).Returns(projectPath.Replace(\"csproj\", \"dll\"));\r\n    projectMock.Setup(o => o.ProjectPath).Returns(projectPath);\r\n    projectMock.Setup(o => o.DirectoryPath).Returns(workDir);\r\n    projectMock.Setup(o => o.DefineConstants).Returns(\"DEBUG\");\r\n    projectMock.Setup(o => o.ImmediateCompileTimeDependencies).Returns(dependencies);\r\n    var p = new Project(XmlReader.Create(FS.OpenRead(projectPath)), null, null, new ProjectCollection());\r\n    projectMock.Setup(o => o.GetItems(\"Compile\")).Returns(p.GetItems(\"Compile\"));\r\n    return projectMock;\r\n}\r\n```\r\nWhere `IProjectEx` is my wrapper interface around `Project`. I can easily mock some properties, but not functions like `GetItems(string itemType)` - for that I need to evaluate a real, albeit dummy project. The code `FS.OpenRead(projectPath)` actually returns a `MemoryStream` to a byte array in a dictionary. This byte array is the binary representation of a simple csproj file.\r\n\r\nSo I actually managed. At this point it is pure curiosity.",
        "createdAt": "2021-11-20T05:41:17Z",
        "updatedAt": "2021-11-20T05:41:17Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "1. Your hunch that in-memory should be faster is reasonable, but it's no more than a hunch. It can only be validated by actual performance measurements. My hunch (again, unvalidated) is that you won't see a perf difference at all, since the bulk of evaluation cost is not reading from disk or parsing XML, but instead it is expression evaluation, import lookup and item and metadata manipulation. We can wait until someone on the team has time to tell us why the in-memory approach doesn't work (and it should). If you'd like to pursue this further yourself, my advice is to look at MSBuild unit-tests in the repo as I'm guessing they must have lots of examples of in-memory evaluation.\r\n\r\n2. Again, it is a reasonable expectation, but from experience, to be close in behavior to actual MSBuild you need to work with disk. This is why the majority of the unit-tests in MSBuild do write temp files to disk to build and evaluate. Maybe this is why the in-memory path is not as well tested, because I doubt anyone relies on the in-memory path.",
        "createdAt": "2021-11-20T21:30:33Z",
        "updatedAt": "2021-11-20T21:30:33Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "BTW if you want to profile evaluations, MSBuild has this flag:\r\n\r\n```\r\n  -profileEvaluation:<file>\r\n                     Profiles MSBuild evaluation and writes the result\r\n                     to the specified file. If the extension of the specified\r\n                     file is '.md', the result is generated in markdown\r\n                     format. Otherwise, a tab separated file is produced.\r\n```\r\n\r\nIf you pass this flag you will see where really the majority of time is being spent during evaluation:\r\n![image](https://user-images.githubusercontent.com/679326/142741481-3d0aafb4-e0b0-4789-a8d7-f73ff640c9f6.png)\r\n",
        "createdAt": "2021-11-20T21:32:32Z",
        "updatedAt": "2021-11-20T21:32:32Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Yes, after I left my comment I realized that reading the project file into memory would not really separate IO from CPU, because the project file is just a tip of the iceberg and most of the build code is still read from the disk.\r\nAnd like I said, evaluating all the project files is shadowed by the parsing of all the source files and so it is insignificant really.\r\nBut I will keep in mind the `-profileEvaluation` flag - thanks for the tip.",
        "createdAt": "2021-11-20T23:35:14Z",
        "updatedAt": "2021-11-20T23:35:14Z",
        "author": {
          "login": "MarkKharitonov"
        }
      },
      {
        "body": "Team Triage: Given low interest of the community of this issue we decided to close it as \"Won't fix\"",
        "createdAt": "2023-05-09T13:57:04Z",
        "updatedAt": "2023-05-09T13:57:04Z",
        "author": {
          "login": "AR-May"
        }
      }
    ]
  }
}