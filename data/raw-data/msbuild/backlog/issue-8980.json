{
  "number": 8980,
  "title": "COM misregistration when building for a specific architecture",
  "body": "Ported from https://developercommunity.visualstudio.com/t/msbuild-attempts-to-register-typelibs-in/10396913\r\n\r\n> when a csproj using `<ComFileReference Include=\"...\">` is compiled for MSIL specific architecture, the ResolveComReference task uses `REGKIND_NONE`\r\n> \r\n> https://github.com/dotnet/msbuild/blob/363f522dc356a789976878e132d908779c01e3f1/src/Tasks/ComReferenceInfo.cs#L162-L166\r\n> \r\n> \r\n> But when building specifically for X86, X64, or IA64, it uses `REGKIND_LOAD_TLB_AS_64BIT`, or `REGKIND_LOAD_TLB_AS_32BIT`, which are really\r\n> \r\n> ```c#\r\n> REGKIND_DEFAULT | REGKIND_LOAD_TLB_AS_...BIT.\r\n> ```\r\n> \r\n> https://github.com/dotnet/msbuild/blob/363f522dc356a789976878e132d908779c01e3f1/src/Tasks/ComReferenceInfo.cs#L154-L160\r\n> \r\n> \r\n> `REGKIND_DEFAULT` means this falls into the usual weird trap of the non-Ex LoadTypeLibrary\r\n> \r\n> \r\n> \r\n> For backward compatibility, LoadTypeLib will register the type library if the path is not specified in the szFile parameter. LoadTypeLib will not register the type library if the path of the type library is specified.\r\n> \r\n> \r\n> \r\n> And LoadTypeLib has kind of a weird idea of whether or not you specified the path: things like using forward slashes don\u2019t count (in my case, there was a .props file being generated by an outside tool that didn\u2019t flip the path to backslashes).\r\n> \r\n> \r\n> I\u2019ve worked around my immediate problem by imporiving our .props generator to ensure an absolute path canonicalized to backslashes, but presumably these architecture-specific cases didn\u2019t intend to do registration differently from the MSIL/AnyCPU case. It was probably just an oversight where nobody noticed 0 was `REGKIND_DEFAULT` rather than `REGKIND_NONE`.\r\n> \r\n> \r\n> So to match, these should have been `REGKIND_NONE | REGKIND_LOAD_TLB_AS_64BIT` and `REGKIND_NONE | REGKIND_LOAD_TLB_AS_32BIT`.\r\n\r\n@AaronRobinsonMSFT reviewed this and said\r\n\r\n> The OP is absolutely correct and this has likely been causing confusion for years.\r\n> \r\n> The following link to some TlbImp code demonstrates the correct behavior - https://github.com/clrinterop/TypeLibraryImporter/blob/b76f55e11cca50c647ebf444e4d884fa85d0cbfb/TlbImp/tlbimpcode.cs#L77-L89\r\n> \r\n> The gist here is as they suggested update the following uses these higher order flags at https://github.com/dotnet/msbuild/blob/363f522dc356a789976878e132d908779c01e3f1/src/Tasks/ComReferenceInfo.cs#L154-L160 to include `REGKIND.REGKIND_NONE`.",
  "state": "CLOSED",
  "createdAt": "2023-06-29T21:30:10Z",
  "updatedAt": "2024-02-21T14:04:26Z",
  "closedAt": "2023-07-31T17:08:03Z",
  "author": {
    "login": "rainersigwald"
  },
  "labels": [
    "Area: Tasks",
    "Priority:1",
    "triaged"
  ],
  "assignees": {
    "nodes": [
      {
        "login": "rokonec"
      }
    ]
  },
  "milestone": {
    "title": "VS 17.8"
  },
  "comments": {
    "nodes": [
      {
        "body": "> The OP is absolutely correct and this has likely been causing confusion for years.\r\n\r\nBig yeah on that one. It manifested as random intermittent failures that only ever happened on CI.\r\n\r\nDepending on whether the agent had been handed x86 or x64 builds recently either or both keys might have gotten inadvertently registered. Depending on how long ago, the build workspace paths the registration referrs to might still exist or might have been garbage-collected. And we were testing a DllHost surrogate activation (cross-architecture). So it would fail only if a `win64` registration exists, but points to a nonexisent path. If it didn't exist, the proxy construction would fall through to the `win32` typelib registered by the x86 server (the intended outcome). If if a `win64` registration exists and pointed to leftover .tlb that was still around, that would *probably* work (since interfaces tend to keep binary compatibility) but every once in a while it would just go wonky (if the x64 and x86 builds that agent had done were different branches and with a relevant .idl difference).\r\n\r\nSo hooray, pinned down one flaky test...\r\n\r\nAll hail https://learn.microsoft.com/en-us/sysinternals/downloads/procmon (and the fact dotnet publishes to symbol server and source link) for making it practical to track down this kind of thing.",
        "createdAt": "2023-06-29T22:44:57Z",
        "updatedAt": "2023-06-29T22:44:57Z",
        "author": {
          "login": "puetzk"
        }
      }
    ]
  }
}