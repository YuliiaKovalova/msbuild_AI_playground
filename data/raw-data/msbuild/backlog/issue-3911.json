{
  "number": 3911,
  "title": "Evaluate a project from the command line",
  "body": "This is a feature request: Add a command line switch which would make MSBuild evaluate a project and output the value of a property or a list of items. No target would be called. This would be useful for scripting purposes.\r\n\r\nSome examples of what I mean:\r\n\r\n```\r\nC:\\Project> msbuild SomeProject.csproj -evaluate:'$(TargetPath)'\r\nC:\\Project\\SomeProject\\bin\\Debug\\SomeProject.exe\r\n```\r\n\r\n```\r\nC:\\Project> msbuild SomeProject.csproj -evaluate:'@(Compile)'\r\nProgram.cs\r\nFoo.cs\r\nBar.cs\r\n```\r\n\r\n```\r\nC:\\Project> msbuild SomeProject.csproj -evaluate:'@(Compile->%(FileName))'\r\nProgram\r\nFoo\r\nBar\r\n```\r\n\r\nOr a simpler version:\r\n\r\n```\r\nC:\\Project> msbuild SomeProject.csproj -evaluateProperty:TargetPath\r\nC:\\Project\\SomeProject\\bin\\Debug\\SomeProject.exe\r\n```\r\n\r\n```\r\nC:\\Project> msbuild SomeProject.csproj -evaluateItems:Compile\r\nProgram.cs\r\nFoo.cs\r\nBar.cs\r\n```\r\n",
  "state": "CLOSED",
  "createdAt": "2018-11-07T11:13:18Z",
  "updatedAt": "2024-03-01T23:11:28Z",
  "closedAt": "2023-08-15T08:03:59Z",
  "author": {
    "login": "ltrzesniewski"
  },
  "labels": [
    "help wanted",
    "Area: Debuggability",
    "Priority:2",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": {
    "title": "VS 17.8"
  },
  "comments": {
    "nodes": [
      {
        "body": "Take a look at MSBuildDumper and see if it fits your needs: https://github.com/KirillOsenkov/MSBuildTools\r\n\r\nhttps://github.com/KirillOsenkov/MSBuildTools/blob/master/src/MSBuildDumper/MSBuildDumper.cs",
        "createdAt": "2018-11-17T19:57:07Z",
        "updatedAt": "2018-11-17T19:57:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov thanks, but I know that getting the evaluated values is pretty easy with the MSBuild NuGet package.\r\n\r\nTo clarify, I simply thought that having this possibility from MSBuild itself (without requiring additional tools) would be a useful feature, and I think it would make sense to support that. I wished several times that MSBuild offered that.\r\n\r\nI could contribute that feature if the MSBuild team thinks it would be valuable. \r\n",
        "createdAt": "2018-11-17T23:53:40Z",
        "updatedAt": "2018-11-17T23:53:40Z",
        "author": {
          "login": "ltrzesniewski"
        }
      },
      {
        "body": "Can you elaborate on \"This would be useful for scripting purposes.\"? What specifically?\r\n\r\nI would have sworn that we already had a work item for this but I don't see one. I think it's a fine idea and would help with various debugging scenarios. I would lean toward the simpler only-dump-values interface; I'm not sure how difficult plumbing the transform mechanism in would be and I think you could get most of the value from just items/properties. I'd suggest that the output should match the text logger, so combining requests would be more clear:\r\n\r\n```sh-session\r\n$ msbuild SomeProject.csproj -evaluateItems:Compile -evaluateProperty:TargetPath\r\nTargetPath = s:\\msbuild\\artifacts\\Debug\\bin\\Microsoft.Build.Framework\\net472\\Microsoft.Build.Framework.dll\r\nCompile\r\n    ..\\Shared\\BinaryWriterExtensions.cs\r\n        Link = Shared\\BinaryWriterExtensions.cs\r\n    ..\\Shared\\Constants.cs\r\n        Link = Shared\\Constants.cs\r\n    BuildEngineResult.cs\r\n    BuildErrorEventArgs.cs\r\n    BuildEventArgs.cs\r\n    BuildEventContext.cs\r\n```",
        "createdAt": "2018-11-19T15:54:23Z",
        "updatedAt": "2018-11-19T15:54:23Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> Can you elaborate on \"This would be useful for scripting purposes.\"? What specifically?\r\n\r\nI originally needed to get the `OutDir` property value in a script in order to zip the build output.\r\n\r\nI couldn't just set my own `OutDir` because some referenced projects use multi-targeting and all targets would end up in the same output directory, thus overwriting each other. I ended up solving this issue differently, but I wished I had that feature nevertheless.\r\n\r\n> I'd suggest that the output should match the text logger, so combining requests would be more clear\r\n\r\nThe problem I see with this approach is that it's well suited for human inspection, but less useful for scripting. My idea was to make MSBuild behave like a Unix utility in this case: only output the desired value so it can be easily consumed by a script or by another tool which could be piped to the MSBuild output.\r\n\r\nWith this approach, a script would additionally have to strip the `TargetPath = ` prefix, and there would probably be issues if the value is multi-line.\r\n\r\nAlso, given that the debugging experience is very good using the binary log viewer, I don't think a text output aimed at debuggability would provide a compelling benefit over that.\r\n",
        "createdAt": "2018-11-19T17:01:20Z",
        "updatedAt": "2018-11-19T17:01:20Z",
        "author": {
          "login": "ltrzesniewski"
        }
      },
      {
        "body": "That's interesting. What would you do about item metadata?",
        "createdAt": "2018-11-19T17:07:05Z",
        "updatedAt": "2018-11-19T17:07:05Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Well, actually item metadata is the reason I suggested the \"full\" syntax (`-evaluate`) in the first place. I supposed it shouldn't be too hard to evaluate MSBuild expressions since they're also evaluated in the execution phase, and that this mode could be an alternate \"execution phase\" where you basically evaluate a single expression.\r\n\r\nSo suppose I want a list of linked files from your example, here's how I could get it:\r\n\r\n```shellsession\r\n$ msbuild SomeProject.csproj -evaluate:\"@(Compile->'%(Identity):%(Link)')\"\r\n..\\Shared\\BinaryWriterExtensions.cs:Shared\\BinaryWriterExtensions.cs\r\n..\\Shared\\Constants.cs:Shared\\Constants.cs\r\nBuildEngineResult.cs:\r\nBuildErrorEventArgs.cs:\r\nBuildEventArgs.cs:\r\nBuildEventContext.cs:\r\n```\r\n\r\nLine breaks could still be an issue though, but a unique delimiter could be inserted at the end of each line to handle these if needed.\r\n",
        "createdAt": "2018-11-19T19:32:37Z",
        "updatedAt": "2018-11-19T20:17:00Z",
        "author": {
          "login": "ltrzesniewski"
        }
      },
      {
        "body": "This would be super useful for us. We worked around that currently but our workaround broke and we now have lots of work backporting script-changes :-(",
        "createdAt": "2020-09-09T13:33:42Z",
        "updatedAt": "2020-09-09T13:33:42Z",
        "author": {
          "login": "Scordo"
        }
      },
      {
        "body": "There's a related consideration here - properties and items are not static, they can be modified during the evaluation of a particular target. That implies to me that the request might look something like to specify a target to run (and maybe just evaluate the project if none is specified):\r\n\r\n```\r\ndotnet msbuild -t:TARGET_TO_RUN --evaluate \"EVAL_EXPRESSION\"\r\n```\r\nor\r\n```\r\ndotnet msbuild -t:TARGET_TO_RUN --evaluateProperty \"PROP_NAME\"\r\n```\r\nor\r\n```\r\ndotnet msbuild -t:TARGET_TO_RUN --evaluateItems \"ITEMS_NAME\"\r\n```\r\n\r\n(though labeling of the returned values might be interesting)",
        "createdAt": "2022-01-25T19:19:03Z",
        "updatedAt": "2022-01-25T19:19:03Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "@baronfel Great point. We do this in the Docker extension for VSCode to determine the path of the Blazor static web assets manifest, in order to \"containerize\" it by adjusting the paths. The target \"ResolveStaticWebAssetsConfiguration\" has to be run before the necessary information is available.\r\n\r\nMore on that here: https://github.com/microsoft/vscode-docker/blob/main/resources/netCore/GetBlazorManifestLocations.targets",
        "createdAt": "2022-01-25T20:29:13Z",
        "updatedAt": "2022-01-25T20:29:13Z",
        "author": {
          "login": "bwateratmsft"
        }
      },
      {
        "body": "I just want to show our usecase. We do have a msbuild file thats integrated in most of our projects. It contains version info which is used to set assembly metadata like FileVersion, AssemblyVersion and so on. There are properties which are static and calculated using values of other properties. We do have Powershell scripts that have to read this values to do deployments and calculate paths and so on. We've used the msbuild api in the past to evaluate the properties in powershell but this broke with a new version of msbuild/powershell. So we now have a proxy msbuild-script which gets a path to another msbuild-script and a list of properties to evaluate and then does the evaluation and pretty prints the evaluated properties and so on. So we now use msbuild to run the proxy-msbuild script which then prints everything to console and we parse it in powershell.\r\n\r\nHere is the script we want to have values of:\r\n\r\n```\r\n<Project xmlns=\"http://XXXs.microsoft.com/developer/msbuild/2003\">\r\n  <Import Project=\"$(USERPROFILE)\\Pre-XXX-VersionInfo.msb.xml\" Condition=\"exists('$(USERPROFILE)\\Pre-XXX-VersionInfo.msb.xml')\" />\r\n  <PropertyGroup>\r\n    <!-- The XXX Release-Year -->\r\n     <XXXProductYear Condition=\"'$(XXXProductYear)' == ''\">2022</XXXProductYear>\r\n    <!-- The XXX Service-Pack or empty for a major release -->\r\n     <XXXProductServicePack Condition=\"'$(XXXProductServicePack)' == ''\">0</XXXProductServicePack>\r\n    <!-- The suffix appended to the product name, for example \"SP1\" -->\r\n    <XXXProductSuffix Condition=\"'$(XXXProductSuffix)' == '' and '$(XXXProductServicePack)' != '0'\"> SP$(XXXProductServicePack)</XXXProductSuffix>\r\n    <!-- The full product name used in AssemblyInformationalVersion -->\r\n    <XXXProductName Condition=\"'$(XXXProductName)' == ''\">XXX $(XXXProductYear)$(XXXProductSuffix)</XXXProductName>\r\n    <XXXCompanyName>XXX Company</XXXCompanyName>\r\n    <XXXCopyright>Copyright \u00a9 XXX</XXXCopyright>\r\n    <!-- START: Release Version -->\r\n    <!-- This group of versions will be used as the release version and for help documentation -->\r\n    <!-- $(XXXVersionMajor).$(XXXVersionMinor).$(XXXVersionBuild).$(XXXVersionRevision) -->\r\n    <!-- Major version position -->\r\n     <XXXVersionMajor Condition=\"'$(XXXVersionMajor)' == ''\">12</XXXVersionMajor>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionMinor Condition=\"'$(XXXVersionMinor)' == ''\">0</XXXVersionMinor>\r\n    <!-- Service-Pack position -->\r\n    <XXXVersionBuild Condition=\"'$(XXXVersionBuild)' == ''\">$(XXXProductServicePack)</XXXVersionBuild>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionRevision Condition=\"'$(XXXVersionRevision)' == ''\">0</XXXVersionRevision>\r\n    <!-- END: Release Version -->\r\n    <!-- START: Assembly Version -->\r\n    <!-- This group of versions will be used in future to automatically manipulate assembly version of assemblyinfo.cs files -->\r\n    <!-- $(XXXVersionAssemblyMajor).$(XXXVersionAssemblyMinor).$(XXXVersionAssemblyBuild).$(XXXVersionAssemblyRevision) -->\r\n    <!-- Major verison used for references between assemblies -->\r\n    <XXXVersionAssemblyMajor Condition=\"'$(XXXVersionAssemblyMajor)' == ''\">$(XXXVersionMajor)</XXXVersionAssemblyMajor>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionAssemblyMinor Condition=\"'$(XXXVersionAssemblyMinor)' == ''\">0</XXXVersionAssemblyMinor>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionAssemblyBuild Condition=\"'$(XXXVersionAssemblyBuild)' == ''\">$(XXXProductServicePack)</XXXVersionAssemblyBuild>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionAssemblyRevision Condition=\"'$(XXXVersionAssemblyRevision)' == ''\">0</XXXVersionAssemblyRevision>\r\n    <!-- END: Assembly Version -->\r\n    <!-- START: File Version -->\r\n    <!-- This group of versions will be used in future to automatically manipulate file version of assemblyinfo.cs files -->\r\n    <!-- $(XXXVersionFileMajor).$(XXXVersionFileMinor).$(XXXVersionFileBuild).$(XXXVersionFileRevision) -->\r\n    <!-- Major version used for file details in windows explorer -->\r\n    <XXXVersionFileMajor Condition=\"'$(XXXVersionFileMajor)' == ''\">$(XXXVersionMajor)</XXXVersionFileMajor>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionFileMinor Condition=\"'$(XXXVersionFileMinor)' == ''\">0</XXXVersionFileMinor>\r\n    <!-- Is never changed currently. Defaults to zero -->\r\n    <XXXVersionFileBuild Condition=\"'$(XXXVersionFileBuild)' == ''\">$(XXXProductServicePack)</XXXVersionFileBuild>\r\n    <!-- can be changed for each modified assembly manually. -->\r\n    <XXXVersionFileRevision Condition=\"'$(XXXVersionFileRevision)' == ''\">0</XXXVersionFileRevision>\r\n    <!-- END: File Version -->\r\n    <!-- Make sure our target file changes will take effect when a new build is done -->\r\n    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>\r\n    <GenerateXXXAssemblyInfo Condition=\"'$(GenerateXXXAssemblyInfo)' == ''\">true</GenerateXXXAssemblyInfo>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(GenerateXXXAssemblyInfo)' == 'true'\">\r\n    <GenerateXXXAssemblyVersionAttribute Condition=\"'$(GenerateXXXAssemblyVersionAttribute)' == ''\">true</GenerateXXXAssemblyVersionAttribute>\r\n    <GenerateXXXAssemblyFileVersionAttribute Condition=\"'$(GenerateXXXAssemblyFileVersionAttribute)' == ''\">true</GenerateXXXAssemblyFileVersionAttribute>\r\n    <GenerateXXXAssemblyInformationalVersionAttribute Condition=\"'$(GenerateXXXAssemblyInformationalVersionAttribute)' == ''\">true</GenerateXXXAssemblyInformationalVersionAttribute>\r\n    <GenerateXXXAssemblyCompanyAttribute Condition=\"'$(GenerateXXXAssemblyCompanyAttribute)' == ''\">true</GenerateXXXAssemblyCompanyAttribute>\r\n    <GenerateXXXAssemblyCopyrightAttribute Condition=\"'$(GenerateXXXAssemblyCopyrightAttribute)' == ''\">true</GenerateXXXAssemblyCopyrightAttribute>\r\n  </PropertyGroup>\r\n  <Target Name=\"GenerateXXXAssemblyInfoFile\" BeforeTargets=\"CoreCompile\" DependsOnTargets=\"PrepareForBuild;BeforeCoreGenerateXXXAssemblyInfoFile;CoreGenerateXXXAssemblyInfoFile\" Condition=\"'$(GenerateXXXAssemblyInfo)' == 'true'\" />\r\n  <!-- We have to create the property here, otherwise $(IntermediateOutputPath) would be empty -->\r\n  <Target Name=\"BeforeCoreGenerateXXXAssemblyInfoFile\">\r\n    <PropertyGroup>\r\n      <XXXAssemblyInfoFilePath Condition=\"'$(XXXAssemblyVersionInfoFilePath)' == ''\">$(IntermediateOutputPath)$(MSBuildProjectName).XXXAssemblyInfo$(DefaultLanguageSourceExtension)</XXXAssemblyInfoFilePath>\r\n    </PropertyGroup>\r\n  </Target>\r\n  <Target Name=\"CoreGenerateXXXAssemblyInfoFile\" Condition=\"'$(Language)'=='VB' or '$(Language)'=='C#'\" Inputs=\"$(MSBuildAllProjects)\" Outputs=\"$(XXXAssemblyInfoFilePath)\">\r\n    <PropertyGroup>\r\n      <GitShortSHA Condition=\"'$(CI_COMMIT_SHORT_SHA)' != ''\">$(CI_COMMIT_SHORT_SHA)</GitShortSHA>\r\n    </PropertyGroup>\r\n    <Exec Command=\"git rev-parse --short=8 HEAD\" ConsoleToMSBuild=\"true\" EchoOff=\"true\" WorkingDirectory=\"$(SourceCodePath)\" ContinueOnError=\"true\" Condition=\"'$(GitShortSHA)' == ''\">\r\n      <Output TaskParameter=\"ConsoleOutput\" PropertyName=\"GitShortSHA\" />\r\n    </Exec>\r\n    <ItemGroup>\r\n      <XXXAssemblyAttribute Include=\"System.Reflection.AssemblyVersionAttribute\" Condition=\"'$(GenerateXXXAssemblyVersionAttribute)' == 'true'\">\r\n        <_Parameter1>$(XXXVersionAssemblyMajor).$(XXXVersionAssemblyMinor).$(XXXVersionAssemblyBuild).$(XXXVersionAssemblyRevision)</_Parameter1>\r\n      </XXXAssemblyAttribute>\r\n      <XXXAssemblyAttribute Include=\"System.Reflection.AssemblyFileVersionAttribute\" Condition=\"'$(GenerateXXXAssemblyFileVersionAttribute)' == 'true'\">\r\n        <_Parameter1>$(XXXVersionFileMajor).$(XXXVersionFileMinor).$(XXXVersionFileBuild).$(XXXVersionFileRevision)</_Parameter1>\r\n      </XXXAssemblyAttribute>\r\n      <XXXAssemblyAttribute Include=\"System.Reflection.AssemblyInformationalVersionAttribute\" Condition=\"'$(GenerateXXXAssemblyInformationalVersionAttribute)' == 'true'\">\r\n        <_Parameter1>$(XXXVersionAssemblyMajor).$(XXXVersionAssemblyMinor).$(XXXVersionAssemblyBuild).$(XXXVersionAssemblyRevision) $(XXXProductName) ($(GitShortSHA))</_Parameter1>\r\n      </XXXAssemblyAttribute>\r\n      <XXXAssemblyAttribute Include=\"System.Reflection.AssemblyCompanyAttribute\" Condition=\"'$(GenerateXXXAssemblyCompanyAttribute)' == 'true'\">\r\n        <_Parameter1>$(XXXCompanyName)</_Parameter1>\r\n      </XXXAssemblyAttribute>\r\n      <XXXAssemblyAttribute Include=\"System.Reflection.AssemblyCopyrightAttribute\" Condition=\"'$(GenerateXXXAssemblyCopyrightAttribute)' == 'true'\">\r\n        <_Parameter1>$(XXXCopyright)</_Parameter1>\r\n      </XXXAssemblyAttribute>\r\n    </ItemGroup>\r\n    <ItemGroup>\r\n      <!-- Ensure the generated assemblyinfo file is not already part of the Compile sources -->\r\n      <Compile Remove=\"$(XXXAssemblyInfoFilePath)\" />\r\n    </ItemGroup>\r\n    <Error Text=\"Variable XXXVersionAssemblyMajor with value '$(XXXVersionAssemblyMajor)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionAssemblyMajor), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionAssemblyMinor with value '$(XXXVersionAssemblyMinor)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionAssemblyMinor), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionAssemblyBuild with value '$(XXXVersionAssemblyBuild)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionAssemblyBuild), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionAssemblyRevision with value '$(XXXVersionAssemblyRevision)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionAssemblyRevision), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionFileMajor with value '$(XXXVersionFileMajor)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionFileMajor), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionFileMinor with value '$(XXXVersionFileMinor)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionFileMinor), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionFileBuild with value '$(XXXVersionFileBuild)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionFileBuild), '^\\d+$'))\" />\r\n    <Error Text=\"Variable XXXVersionFileRevision with value '$(XXXVersionFileRevision)' is not a number.'\" Condition=\"!$([System.Text.RegularExpressions.Regex]::IsMatch($(XXXVersionFileRevision), '^\\d+$'))\" />\r\n    <WriteCodeFragment AssemblyAttributes=\"@(XXXAssemblyAttribute)\" Language=\"$(Language)\" OutputFile=\"$(XXXAssemblyInfoFilePath)\">\r\n      <Output TaskParameter=\"OutputFile\" ItemName=\"Compile\" />\r\n      <Output TaskParameter=\"OutputFile\" ItemName=\"FileWrites\" />\r\n    </WriteCodeFragment>\r\n  </Target>\r\n  <Import Project=\"$(USERPROFILE)\\Post-XXX-VersionInfo.msb.xml\" Condition=\"exists('$(USERPROFILE)\\Post-XXX-VersionInfo.msb.xml')\" />\r\n</Project>\r\n```\r\n\r\nAnd thats the proxy-script:\r\n\r\n```\r\n<Project DefaultTargets=\"PrintPropertiesToEvaluate\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectFilePath></ProjectFilePath>\r\n\t\t<PropertiesToEvaluate></PropertiesToEvaluate>\r\n\t\t<PropertiesToInitialize></PropertiesToInitialize>\r\n\t\t<IncludePropertyNames>false</IncludePropertyNames>\r\n\t\t<PropertyValueSeparator>=</PropertyValueSeparator>\r\n\t</PropertyGroup>\r\n\r\n\t<Target Name=\"PrintPropertiesToEvaluate\">\r\n\t\t<Error Text=\"The property 'ProjectFilePath' is empty, but is required.\" Condition=\"'$(ProjectFilePath)' == ''\" />\r\n\t\t<Error Text=\"Project '$(ProjectFilePath)' does not exist.\" Condition=\"!Exists('$(ProjectFilePath)')\" />\r\n\t\t<Error Text=\"The property 'PropertiesToEvaluate' is empty, but is required.\" Condition=\"'$(PropertiesToEvaluate)' == ''\" />\r\n\r\n\t\t<EvaluateMSBuildProperties ProjectFilePath=\"$(ProjectFilePath)\" PropertiesToEvaluate=\"$(PropertiesToEvaluate)\" PropertiesToInitialize=\"$(PropertiesToInitialize)\">\r\n\t\t\t<Output TaskParameter=\"Result\" ItemName=\"EvaluatedProperties\"/>\r\n\t\t</EvaluateMSBuildProperties>\r\n\r\n\t\t<ConsoleWriteLine Text=\"%(EvaluatedProperties.Identity)$(PropertyValueSeparator)%(EvaluatedProperties.Value)\" Condition=\"$(IncludePropertyNames)\"/>\r\n\t\t<ConsoleWriteLine Text=\"%(EvaluatedProperties.Value)\" Condition=\"!$(IncludePropertyNames)\"/>\r\n\t</Target>\r\n\r\n\t<UsingTask TaskName=\"EvaluateMSBuildProperties\" TaskFactory=\"CodeTaskFactory\" AssemblyFile=\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\">\r\n\t\t<ParameterGroup>\r\n\t\t\t<ProjectFilePath ParameterType=\"System.String\" Required=\"true\" />\r\n\t\t\t<PropertiesToEvaluate ParameterType=\"System.String\" Required=\"true\" />\r\n\t\t\t<PropertiesToInitialize ParameterType=\"System.String\" Required=\"false\" />\r\n\t\t\t<Result ParameterType=\"Microsoft.Build.Framework.ITaskItem[]\" Output=\"true\" />\r\n\t\t</ParameterGroup>\r\n\t\t<Task>\r\n\t\t\t<Reference Include=\"System.Xml\" />\r\n\t\t\t<Reference Include=\"Microsoft.Build\" />\r\n\t\t\t<Using Namespace=\"System.Collections.Generic\" />\r\n\t\t\t<Using Namespace=\"Microsoft.Build.Evaluation\" />\r\n\r\n\t\t\t<Code Type=\"Fragment\" Language=\"cs\"><![CDATA[\r\n\t\t\t\tDictionary<string, string> initProperties = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);\r\n\r\n\t\t\t\tif (PropertiesToInitialize != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (string initProperty in PropertiesToInitialize.Split(';'))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint equalSignIndex = initProperty.IndexOf('=');\r\n\t\t\t\t\t\tif (equalSignIndex == -1)\r\n\t\t\t\t\t\t\tthrow new InvalidDataException(string.Format(\"Property definition '{0}' is invalid. It's missing a value (no equal sign).\", initProperty));\r\n\r\n\t\t\t\t\t\tinitProperties[initProperty.Substring(0, equalSignIndex)] = initProperty.Substring(equalSignIndex + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tProjectCollection projectCollection = new ProjectCollection(initProperties);\r\n\t\t\t\tProject project = projectCollection.LoadProject(ProjectFilePath);\r\n\r\n\t\t\t\tstring[] propertyNamesToValuate = PropertiesToEvaluate.Split(';');\r\n\t\t\t\tResult = new ITaskItem[propertyNamesToValuate.Length];\r\n\r\n\t\t\t\tfor (int i = 0; i < propertyNamesToValuate.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring propertyName = propertyNamesToValuate[i];\r\n\t\t\t\t\tstring propertyValue = project.GetPropertyValue(propertyName);\r\n\t\t\t\t\tResult[i] = new TaskItem(propertyName, new Dictionary<string, string> { { \"Value\", propertyValue } });\r\n\t\t\t\t}\r\n\t\t\t]]>\r\n\t\t\t</Code>\r\n\t\t</Task>\r\n\t</UsingTask>\r\n\r\n\t<UsingTask TaskName=\"ConsoleWriteLine\" TaskFactory=\"CodeTaskFactory\" AssemblyFile=\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\">\r\n\t\t<ParameterGroup>\r\n\t\t\t<Text Required=\"false\" ParameterType=\"System.String\"/>\r\n\t\t</ParameterGroup>\r\n\t\t<Task>\r\n\t\t\t<Code Type=\"Fragment\" Language=\"cs\"><![CDATA[ Console.WriteLine(Text); ]]></Code>\r\n\t\t</Task>\r\n\t</UsingTask>\r\n</Project>\r\n```\r\n\r\nIt would be nice to be able to skip this proxy script and just use msbuild with parameters. We dont use the msbuild api in powershell anymore because it broke suddenly and we had to do lots of backporting.\r\nHope this helps in evaluating usecases.\r\n\r\nRegards,\r\nScordo",
        "createdAt": "2022-01-26T08:51:40Z",
        "updatedAt": "2022-01-26T08:51:40Z",
        "author": {
          "login": "Scordo"
        }
      },
      {
        "body": "@Scordo for advanced scenarios like this I think a C# console app that uses MSBuild APIs would be a good approach.\r\n\r\nI doubt we can ever put enough flexibility into MSBuild.exe to get what you want, and arguably, at this point just doing what you\u2019re already doing with a proxy project is that kind of extensibility already.",
        "createdAt": "2022-01-26T17:49:50Z",
        "updatedAt": "2022-01-26T17:49:50Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I like the idea of rendering just one interesting property (as mentioned in the OP), but I also like the idea of rendering the entire xml (as in my closed dupe [issue](https://github.com/dotnet/msbuild/issues/7848)). The fact that some variables cannot be evaluated is true, but many can be, so it's still useful.\r\n\r\nQuick elaboration:\r\n\r\nWhen everything is done by msbuild, this feature request adds no value and seems unimportant.\r\n\r\nBut not everyone uses msbuild as the primary build mechanism. We use bash for everything, and call the msbuild/dotnet CLI to perform work for c# projects. But that means we are outside msbuild's \"domain\", and so lack data that msbuild doesn't naturally provide - so it would be helpful to have a feature where we can get msbuild to rendering the csproj.\r\n\r\nIn a multi-platform build environment, with many containers, different technologies (not just c#), etc., shell scripting is the lowest common denominator, but acquiring the info required to perform a build is quite hard.\r\n\r\n",
        "createdAt": "2022-07-28T00:55:32Z",
        "updatedAt": "2022-07-28T00:55:32Z",
        "author": {
          "login": "lonix1"
        }
      },
      {
        "body": "Here's a proposal for this to see if we can get it moving forward.  What do people think?\r\n\r\n# Command line evaluation of MSBuild properties\r\n\r\nWe will add command-line options to MSBuild to support getting the value of properties, items, or target return values.\r\n\r\n- `-getProperty:<propertyName>` - Get the value of the specified property\r\n- `-getItem:<itemName>` - Get the value(s) of the specified item\r\n- `-getTargetResult` - Get the return values of the targets that were specified via the `-target` option.\r\n\r\nIf no targets are specified on the command line via the `-target` option, then the `-getProperty` and `-getItem` options will get the values from MSBuild evaluation, and no targets will be built.  If the `-target` option is specified, then the property or item values returned will be the values after the build is finished (all targets have run).\r\n\r\nBy default, the requested values will be printed to the console output in text format, and any other MSBuild output will be suppressed, unless there is an error.  The text format for the values will simply put each value on a separate line, and won't include any item metadata.  It will be possible to get the values for multiple properties, for example `-getProperty:OutputPath;TargetPath`.  In that case each property would be on a separate line in the text format output.  It will also be possible to get values for multiple items this way, however this won't be very useful with the text format as there won't be a way to know when the values for one item stop and the next one begin.\r\n\r\nThe format for the values can be switched to json by specifying `-resultsFormat:json`.  This format will include item metadata values, as well as supporting multiple properties, items, and target results.\r\n\r\nThe values can be saved to a file instead of printed to the console with the `-resultsFile:<fileName>` option.  In this case the normal console log output will not be suppressed.  If saving the results to a file, and the results format is not specified, it will default to using json unless the file extension of the results file is `.txt`.\r\n\r\nA possible format for the json output could be as follows:\r\n\r\n```json\r\n{\r\n  \"properties\":\r\n  {\r\n    \"PropertyName\": \"PropertyValue\",\r\n    \"PropertyName2\": \"PropertyValue2\"\r\n  },\r\n  \"items\":\r\n  {\r\n    \"Sources\":\r\n    [\r\n        {\r\n            \"ItemSpec\": \"Program.cs\"\r\n        },\r\n        {\r\n            \"ItemSpec\": \"obj\\\\Debug\\\\net6.0-windows10.0.19041.0\\\\ConsoleTest.AssemblyInfo.cs\"\r\n        }\r\n    ],\r\n    \"References\":\r\n    [\r\n        {\r\n            \"ItemSpec\": \"C:\\\\Program Files\\\\dotnet\\\\packs\\\\Microsoft.WindowsDesktop.App.Ref\\\\6.0.14\\\\ref\\\\net6.0\\\\Accessibility.dll\",\r\n            \"FileVersion\": \"6.0.1423.7402\",\r\n            \"ReferenceSourceTarget\": \"ResolveAssemblyReference\"\r\n        }\r\n    ]\r\n  },\r\n  \"targets\":\r\n  {\r\n    \"GetTargetPath\":\r\n    {\r\n      {\r\n        \"ItemSpec\": \"c:\\\\git\\\\repro\\\\ConsoleTest\\\\bin\\\\Debug\\\\net6.0-windows10.0.19041.0\\\\ConsoleTest.dll\",\r\n        \"TargetFrameworkIdentifier\": \".NETCoreApp\",\r\n        \"ReferenceAssembly\": \"c:\\\\git\\\\repro\\\\ConsoleTest\\\\obj\\\\Debug\\\\net6.0-windows10.0.19041.0\\\\ref\\\\ConsoleTest.dll\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Comments\r\n\r\nThis doesn't support evaluating arbitrary expressions from the command line, so something like `-evaluate:'@(Compile->%(FileName))'` isn't possible.  However, the command line syntax is simpler, and you can still get more complex values by using the json format or calling a target.\r\n\r\nThe `-getTargetResult` option may not be necessary as it is a bit redundant with just getting property or item values after running targets.  However, it would allow for command-line builds to do the same thing as design-time builds do in Visual Studio, where a bunch of targets are run and the return values of each target are returned.\r\n",
        "createdAt": "2023-03-21T19:30:48Z",
        "updatedAt": "2023-03-21T19:30:48Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "Thanks, I like it! \ud83d\ude42\r\n\r\nA few comments:\r\n\r\n> any other MSBuild output will be suppressed, unless there is an error\r\n\r\nJust to clarify: will the error message go to stderr? I think it would be better for stdout to remain empty in that case.\r\n\r\n> The format for the values can be switched to json\r\n\r\nExcellent idea. It becomes necessary when dealing with multi-line values.\r\n\r\n> The values can be saved to a file instead of printed to the console\r\n\r\nIs there a real use case for this? When used in a script, the command output can be redirected to a file.\r\n\r\n> ```json\r\n> \"ItemSpec\": \"Program.cs\"\r\n> ```\r\n\r\n- Shouldn't it be `Identity` instead of `ItemSpec`?\r\n- Should other well-known item metadata be included? Stuff like `FullPath` could be useful.\r\n- Since everything in MSBuild uses PascalCase, I'd also name the top-level JSON items that way: `Properties`, `Items`, `Targets`.\r\n",
        "createdAt": "2023-03-21T19:53:16Z",
        "updatedAt": "2023-03-21T19:53:16Z",
        "author": {
          "login": "ltrzesniewski"
        }
      },
      {
        "body": "How would these options interact with the `InitialTargets` and `DefaultTargets` attributes of the [Project element](https://learn.microsoft.com/visualstudio/msbuild/project-element-msbuild?view=vs-2022)? I'd expect:\r\n\r\n- `-getProperty` or `-getItem`, without `-target`, ignores both `InitialTargets` and `DefaultTargets`.\r\n- `-getProperty` or `-getItem`, with `-target`, runs both `InitialTargets` and the `-target` targets, but not `DefaultTargets`.\r\n- `-getTargetResult`, without `-target`, is an error and ignores both `InitialTargets` and `DefaultTargets`.\r\n- `-getTargetResult`, with `-target`, runs both `InitialTargets` and the `-target` targets, but not `DefaultTargets`. It outputs only the results of the `-target` targets, not the results of `InitialTargets`.\r\n",
        "createdAt": "2023-03-21T20:05:36Z",
        "updatedAt": "2023-03-21T20:05:56Z",
        "author": {
          "login": "KalleOlaviNiemitalo"
        }
      },
      {
        "body": "> Just to clarify: will the error message go to stderr? I think it would be better for stdout to remain empty in that case.\r\n\r\nI'm not sure.  I don't know if the error messages currently go to stdout or stderr, and if they don't go to stderr it might be tricky to change that.\r\n\r\n> > The values can be saved to a file instead of printed to the console\r\n> \r\n> Is there a real use case for this? When used in a script, the command output can be redirected to a file.\r\n\r\nI think the normal MSBuild output can be useful to have in logs in case something goes wrong.  This is more likely to matter if targets are being run instead of just evaluating the project.\r\n\r\n> * Shouldn't it be `Identity` instead of `ItemSpec`?\r\n\r\nWe use both.  `ItemSpec` is what we use in the [MSBuild .NET APIs](https://github.com/dotnet/msbuild/blob/b84faa7d0dfb42daedca5c244f73f0b07e1135d7/src/Framework/ITaskItem.cs#L26), while `Identity` is what we use as the metadata name.  Probably `Identity` would be better here.\r\n\r\n> * Should other well-known item metadata be included? Stuff like `FullPath` could be useful.\r\n\r\nYes, this is probably a good idea.\r\n\r\n> * Since everything in MSBuild uses PascalCase, I'd also name the top-level JSON items that way: `Properties`, `Items`, `Targets`.\r\n\r\nI'm not sure about this, JSON typically uses camelCase.\r\n",
        "createdAt": "2023-03-22T20:31:11Z",
        "updatedAt": "2023-03-22T20:31:11Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "> How would these options interact with the `InitialTargets` and `DefaultTargets` attributes of the [Project element](https://learn.microsoft.com/visualstudio/msbuild/project-element-msbuild?view=vs-2022)? I'd expect:\r\n> \r\n> * `-getProperty` or `-getItem`, without `-target`, ignores both `InitialTargets` and `DefaultTargets`.\r\n> * `-getProperty` or `-getItem`, with `-target`, runs both `InitialTargets` and the `-target` targets, but not `DefaultTargets`.\r\n> * `-getTargetResult`, without `-target`, is an error and ignores both `InitialTargets` and `DefaultTargets`.\r\n> * `-getTargetResult`, with `-target`, runs both `InitialTargets` and the `-target` targets, but not `DefaultTargets`. It outputs only the results of the `-target` targets, not the results of `InitialTargets`.\r\n\r\nYes, all of this matches what I was thinking.",
        "createdAt": "2023-03-22T20:32:16Z",
        "updatedAt": "2023-03-22T20:32:16Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "An explicit use case for this comes from our friends at the VSCode Docker tooling - they currently do evaluations looking for specific properties and items. They'd love to have a way to get that same information that doesn't require building and shipping an entire .NET application.",
        "createdAt": "2023-04-11T21:54:02Z",
        "updatedAt": "2023-04-12T01:49:23Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "Using stdout in MSBuild for structured data output is something we have not done in past, all structured build artifacts are in form of files. Although convenient, there is lot of corner cases like errors during MSBuild execution which might make it less useful. \r\nI recommend to support just json file output. That should be sufficient for almost everybody.",
        "createdAt": "2023-04-13T13:30:45Z",
        "updatedAt": "2023-04-13T13:30:45Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "> I recommend to support just json file output. That should be sufficient for almost everybody.\r\n\r\nThat would be *very* inconvenient to use in scripts (you'd need to install and use something like `jq`, then get rid of the output json file).\r\n\r\nRetrieving info in scripts in the main goal behind this feature request.",
        "createdAt": "2023-04-13T20:35:07Z",
        "updatedAt": "2023-04-13T20:35:07Z",
        "author": {
          "login": "ltrzesniewski"
        }
      },
      {
        "body": "> That would be _very_ inconvenient to use in scripts (you'd need to install and use something like `jq`, then get rid of the output json file).\r\n\r\nNot an expert here, but I believed that it is quite simple for javascript to read json files.\r\nAnyway, I am just expecting whole kind of issues with it, and would rather not to implement it unless it is necessary. I would rather propose stable solution which is harder to use than easy but buggy solution.\r\n\r\nHere are incomplete list of possible problems I fear (please take it with grain of salt):\r\n- custom tasks using Console.WriteLine as oppose to ILogger\r\n- error in execution will cause partial output while failure exit code will be not be handled\r\n- cancellation will cause partial output while failure exit code will be not be handled\r\n- stderr vs stdout confusion\r\n- console out encoding mismatch (ansi vs utf-8 for example)\r\n- console buffer width truncating lines\r\n\r\nEspecially the 1st point is very concerning as I am sure quite a few people do it. I even know few internal tasks which do so.",
        "createdAt": "2023-04-14T00:02:09Z",
        "updatedAt": "2023-04-14T00:05:07Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "Please dont discuss if the output should be json or stdout. Just let the user decide when invoking msbuild. Just provide parameters  like --std-out or --json-out xxx.json or --xml-out. The user knows his scenario and knows what can go wrong. For me using a json-file would be bad. Our scenario is to evaluate properties. We know that nothing additionally would be written to stdout in this case. Creating and deleting a json file is a pain in the ass for certain scenarios when you can just use stdout. So just implement both and use parameters. :-) ",
        "createdAt": "2023-04-14T07:00:06Z",
        "updatedAt": "2023-04-14T07:00:06Z",
        "author": {
          "login": "Scordo"
        }
      },
      {
        "body": "> it is quite simple for javascript to read json files\r\n\r\nIt's easy in JavaScript, but not so much in shell scripts. Does anyone even call MSBuild from JS? \ud83d\ude05 \r\n\r\n> * custom tasks using Console.WriteLine as oppose to ILogger\r\n\r\nThis can be mitigated with:\r\n\r\n```csharp\r\nConsole.Out = TextWriter.Null;\r\nConsole.Error = TextWriter.Null;\r\n```\r\n\r\nCustom tasks would then need to use `Console.OpenStandardOutput` to write to stdout, and I wouldn't expect any task to do so.\r\n\r\nRedirecting `Console.Out`/`Error` to an `ILogger` instead of `TextWriter.Null` by writing an adapter would be nice to have, but potentially unreliable due to missing line feeds for instance.\r\n\r\nAlso, as @Scordo stated above, this is not a problem if all you need is the evaluation phase.\r\n\r\n> * failure exit code will be not be handled\r\n\r\nThat would be a bug in the script which calls MSBuild, not in MSBuild itself.\r\n\r\n> * stderr vs stdout confusion\r\n> * console out encoding mismatch (ansi vs utf-8 for example)\r\n\r\nThose points are valid for any command-line executable.\r\n\r\n> * console buffer width truncating lines\r\n\r\nThis shouldn't be an issue when redirecting MSBuild output.\r\n\r\n",
        "createdAt": "2023-04-14T08:34:34Z",
        "updatedAt": "2023-04-14T08:34:34Z",
        "author": {
          "login": "ltrzesniewski"
        }
      },
      {
        "body": "There is already an open PR and there has been lots of discussion both here in the issue and in the PR.\r\n\r\nEvery target available on an MSBuild project is a potential 'endpoint' or 'sub-command'. You don't need to use the `build` target for everything.\r\n\r\nI have routinely implemented 'diagnostic' targets whose purpose is to report specific information (from properties and/or items). These targets can require other targets to execute, or not. A common set of 'diagnostic' targets can be applied to a set of projects with a `Directory.Build.targets` file. For each project in the set the shared target can then be called. Creating a shared `PrintTargetPath` target, as an example, is straightforward.\r\n\r\nFor a one-off ad-hoc circumstance, simple evaluations at the command line have value.\r\n\r\nFor some of the scripting use cases described, expanding the API surface (or the command surface if you prefer) by adding specialized targets is a better approach because it can be tailored to the specific requirements (including the returned data format) and can use the full capabilities of MSBuild.\r\n\r\nThere is a way in which the more complete and the more sophisticated the command line evaluation support is, the more redundant it will be with just executing a project.",
        "createdAt": "2023-07-05T00:02:40Z",
        "updatedAt": "2023-07-05T00:25:13Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "Hi there, is this available in RC1?\r\nIf so, are there any more examples of how to use this?\r\nI would be very interested to get the parameters of the `FscTask` in `CoreCompile` for F# projects;\r\n![image](https://github.com/dotnet/msbuild/assets/2621499/8a4bf535-6a85-4259-b1dc-2280b5bd01a3)\r\n\r\nWould this be possible to extract with these new flags?",
        "createdAt": "2023-09-13T08:44:03Z",
        "updatedAt": "2023-09-13T08:44:03Z",
        "author": {
          "login": "nojaf"
        }
      },
      {
        "body": "This will be in RC 2, and we'll have proper documentation on learn.microsoft.com at that time.",
        "createdAt": "2023-09-13T11:43:07Z",
        "updatedAt": "2023-09-13T11:43:07Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "I've been playing with it in the nightlys, it's very cool \ud83d\ude0e",
        "createdAt": "2023-09-13T13:07:00Z",
        "updatedAt": "2023-09-13T13:07:00Z",
        "author": {
          "login": "slang25"
        }
      },
      {
        "body": "@slang25 got anything you want to share with the class? \ud83e\udd79",
        "createdAt": "2023-09-13T13:19:08Z",
        "updatedAt": "2023-09-13T13:19:08Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "`-help` doesn't provide usage information for the new command line switches.",
        "createdAt": "2023-09-14T20:23:37Z",
        "updatedAt": "2023-09-14T20:23:37Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "The meta project created from a solution file has properties, items, and targets. What is the rationale for the MSB1063 error?\r\n\r\n```\r\nMSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.\r\n```\r\n\r\nI didn't find anything in the discussion here or in the PR.",
        "createdAt": "2023-09-17T02:18:44Z",
        "updatedAt": "2023-09-17T02:18:44Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "`-getTargetResult` will run a target that otherwise would not run.\r\n\r\nE.g. Given a project with targets `one` and `two` and the targets have no dependency between them:\r\n\r\n```xml\r\n<Project>\r\n  <Target Name=\"One\">\r\n    <PropertyGroup>\r\n      <First Condition=\"$(First) == ''\">One</First>\r\n    </PropertyGroup>\r\n    <Message Text=\"One\" />\r\n    <Message Text=\"First = $(First)\" />\r\n  </Target>\r\n\r\n  <Target Name=\"Two\">\r\n    <PropertyGroup>\r\n      <First Condition=\"$(First) == ''\">Two</First>\r\n    </PropertyGroup>\r\n    <Message Text=\"Two\" />\r\n    <Message Text=\"First = $(First)\" />\r\n  </Target>\r\n</Project>\r\n```\r\n\r\nand given a command line with `-target:one -getTargetResult:two`, both targets will be executed.\r\n\r\nThe current behavior executes the targets provided to `-getTargetResult` that didn't already execute, after the 'standard' target build order. Essentially there is a secondary chain of targets.\r\n\r\nIt seems from the discussion that this is not the intended behavior.\r\n\r\nMy own quick take is that `-getTargetResult` should not itself cause a target to be executed and if a target provided to `-getTargetResult` didn't execute then there is no result to report.",
        "createdAt": "2023-09-17T03:15:12Z",
        "updatedAt": "2023-09-17T03:15:12Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "> What is the rationale for the MSB1063 error?\r\n\r\nImplementation annoyances, not anything principled. Because the solution metaproject isn't _actually_ the project that was specified, it's nontrivial to reach \"through\" the `.sln` to the metaproj to get the results.\r\n\r\nI'd be happy to see this restriction removed, but not enough to block the feature on it.",
        "createdAt": "2023-09-18T13:34:40Z",
        "updatedAt": "2023-09-18T13:34:40Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> `-getTargetResult` will run a target that otherwise would not run.\r\n\r\nExcellent catch, thanks. Let's discuss on https://github.com/dotnet/msbuild/issues/9225.",
        "createdAt": "2023-09-18T13:39:56Z",
        "updatedAt": "2023-09-18T13:39:56Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> > What is the rationale for the MSB1063 error?\r\n> \r\n> Implementation annoyances, not anything principled. Because the solution metaproject isn't _actually_ the project that was specified, it's nontrivial to reach \"through\" the `.sln` to the metaproj to get the results.\r\n> \r\n> I'd be happy to see this restriction removed, but not enough to block the feature on it.\r\n\r\nMakes sense. Thanks",
        "createdAt": "2023-09-18T14:47:58Z",
        "updatedAt": "2023-09-18T14:47:58Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "The lack of `-resultsFile:...` makes this rather unreliable for scripting :/ https://github.com/dotnet/sdk/issues/36694",
        "createdAt": "2023-11-07T12:31:35Z",
        "updatedAt": "2023-11-07T12:31:35Z",
        "author": {
          "login": "rolfbjarne"
        }
      },
      {
        "body": "> This will be in RC 2, and we'll have proper documentation on learn.microsoft.com at that time.\r\n\r\nFriendly reminder that as of today there's still no trace of the `--getProperty` feature on https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build. I knew I had read about it somewhere some time ago but it was difficult to find information about it.",
        "createdAt": "2024-03-01T23:03:59Z",
        "updatedAt": "2024-03-01T23:03:59Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "@0xced it's in the linked [MSBuild command-line docs](https://learn.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference).",
        "createdAt": "2024-03-01T23:11:27Z",
        "updatedAt": "2024-03-01T23:11:27Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  }
}