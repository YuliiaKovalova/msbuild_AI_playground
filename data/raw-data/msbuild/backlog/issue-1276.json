{
  "number": 1276,
  "title": "Avoid double evaluation of all ProjectReferences",
  "body": "As of #1018, the `ResolveProjectReferences` flow (which is executed during solution load in VS and is therefore very perf-sensitive) is two-phase:\n1. Run [`_GetProjectReferenceTargetFrameworkProperties`](https://github.com/Microsoft/msbuild/blob/2db4d4b6821ff65987b2843d29cc5f02c4db59f5/src/XMakeTasks/Microsoft.Common.CurrentVersion.targets#L1494-L1528) to ask the reference \"What TFM of yours should I build to match my current TFM?\"\n2. Run [`ResolveProjectReferences`](https://github.com/Microsoft/msbuild/blob/2db4d4b6821ff65987b2843d29cc5f02c4db59f5/src/XMakeTasks/Microsoft.Common.CurrentVersion.targets#L1569-L1697) to ask the reference \"What is your primary output for this TFM?\"\n\nThose evaluations have different sets of global properties (the first sets `ReferringTargetFramework` and the latter sets `SetTargetFramework`), so they must be evaluated separately. Neither called target takes very long, but the evaluation is not cheap. This means that time to `ResolveProjectReferences` has roughly doubled in cost for all projects.\n\nCost of crosstargeting should be on a pay-for-play basis as much as possible. Existing csproj -> existing csproj (ditto vcxproj) shouldn't be slowed down by this.\n\n/cc @nguerrera\n",
  "state": "CLOSED",
  "createdAt": "2016-10-27T22:58:52Z",
  "updatedAt": "2024-02-21T17:24:48Z",
  "closedAt": "2017-10-11T21:23:33Z",
  "author": {
    "login": "rainersigwald"
  },
  "labels": [
    ".NET Core",
    "needs-design",
    "Area: Performance",
    "regression",
    "triaged"
  ],
  "assignees": {
    "nodes": [
      {
        "login": "nguerrera"
      },
      {
        "login": "rainersigwald"
      }
    ]
  },
  "milestone": {
    "title": "MSBuild 15.5"
  },
  "comments": {
    "nodes": [
      {
        "body": "@nguerrera Any progress on this? Thanks!\n",
        "createdAt": "2016-11-11T22:37:13Z",
        "updatedAt": "2016-11-11T22:37:13Z",
        "author": {
          "login": "Sarabeth-Jaffe-Microsoft"
        }
      },
      {
        "body": "Update on this: I worked hard on the approach we white boarded and it's doable, but too risky of a change for RTW, I've gotten far enough to determine that it can be done without breaking changes (unless you consider not calling GetTargetFrameworkProperties when we don't have to breaking. I don't.) So we can fix this in an update.\r\n\r\nMeanwhile https://github.com/Microsoft/msbuild/pull/1621 includes some escape hatches to turn it off or just force a selection, so that can be used as a workaround for anyone hitting the perf issue until we arrive with the improved protocol in an update.\r\n\r\n",
        "createdAt": "2017-01-27T20:27:19Z",
        "updatedAt": "2017-01-27T20:27:19Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "Sounds great. I agree that that wouldn't be a breaking change.",
        "createdAt": "2017-01-27T20:49:33Z",
        "updatedAt": "2017-01-27T20:49:33Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Just to add some additional data here, looking at trying to reduce build times over on project system, and this one is floating to the top as our slowest targets:\r\n\r\n```\r\n    18445 ms  _GetProjectReferenceTargetFrameworkProperties 278 calls\r\n    28138 ms  ResolveProjectReferences                  32 calls\r\n    40642 ms  RebuildSolution                            1 calls\r\n    40644 ms  Rebuild                                   36 calls\r\n    300481 ms  CleanReferencedProjects                   32 calls\r\n```",
        "createdAt": "2017-02-27T11:38:11Z",
        "updatedAt": "2017-02-27T11:38:11Z",
        "author": {
          "login": "davkean"
        }
      },
      {
        "body": "Nick gave me his prototype branch; I'm planning to pick this up this week.",
        "createdAt": "2017-02-27T15:24:57Z",
        "updatedAt": "2017-02-27T15:24:57Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Update: I've been playing with the basic approach Nick and I were talking about. He was working on https://github.com/nguerrera/msbuild/tree/wip-double-eval.\r\n\r\nI wound up starting from scratch since the changes span multiple repos, so it was easier to just make myself a fresh copy of the CLI and start hacking at it.\r\n\r\nThe basic idea so far is: do not specify a TF when building a reference. Instead, change the return value of a multitargeting project's outer build to include a marker that more details are required. On the referencing side, look for that marker and do the existing \"I am TFM X what TFM of yours should I build?\" dance to get the right output.\r\n\r\nI've got this mostly working for command-line builds as a prototype. It has some interesting properties:\r\n* The initial \"just build\" request with no special TFM requests has the side-effect of running all inner builds.\r\n  * That means that when we come back to request a specific output, it's already built.\r\n  * But it also means that more than what we want/need/will request is built. You'd see build errors from a .NET Core version of a library even when the entry point was a full framework executable.\r\n* If the project in `@(_MSBuildProjectReferenceExistent)` doesn't get a TF specified, other parts of the build will try to build it and be surprised. I had to add a stub `GetNativeManifest` target and it's currently complaining about `GetCopyToOutputDirectoryItems`.\r\n\r\n<details>\r\n<summary>Work in progress overall diff</summary>\r\n\r\n```diff\r\n\r\ndiff --git \"a/S:\\\\work\\\\single-eval\\\\cli_1.0.0\\\\sdk\\\\1.0.0/Microsoft.Common.CrossTargeting.targets\" \"b/S:\\\\work\\\\single-eval\\\\cli_modified\\\\sdk\\\\1.0.0/Microsoft.Common.CrossTargeting.targets\"\r\nindex d4ede1a..2cd44c0 100644\r\n--- \"a/S:\\\\work\\\\single-eval\\\\cli_1.0.0\\\\sdk\\\\1.0.0/Microsoft.Common.CrossTargeting.targets\"\r\n+++ \"b/S:\\\\work\\\\single-eval\\\\cli_modified\\\\sdk\\\\1.0.0/Microsoft.Common.CrossTargeting.targets\"\r\n@@ -38,6 +38,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n   <Target Name=\"DispatchToInnerBuilds\" Returns=\"@(InnerOutput)\">\r\n     <ItemGroup>\r\n       <_TargetFramework Include=\"$(TargetFrameworks)\" />\r\n+\r\n+      <_VirtualOutput Include=\"Project $(MSBuildProjectFile) has multiple TargetFrameworks. To consume its output, specify a TargetFramework before building it.\">\r\n+        <TargetFrameworks>$(TargetFrameworks)</TargetFrameworks>\r\n+        <HasMultitargeting>true</HasMultitargeting>\r\n+      </_VirtualOutput>\r\n     </ItemGroup>\r\n     <MSBuild Projects=\"$(MSBuildProjectFile)\"\r\n              Condition=\"'$(TargetFrameworks)' != '' \"\r\n@@ -66,7 +71,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n                     all builds.\r\n   ============================================================\r\n   -->\r\n-  <Target Name=\"Build\" DependsOnTargets=\"_SetBuildInnerTarget;DispatchToInnerBuilds\" />\r\n+  <Target Name=\"Build\"\r\n+          DependsOnTargets=\"_SetBuildInnerTarget;DispatchToInnerBuilds\"\r\n+          Returns=\"@(_VirtualOutput)\" />\r\n+\r\n \r\n   <Target Name=\"_SetBuildInnerTarget\" Returns=\"@(InnerOutput)\">\r\n     <PropertyGroup  Condition=\"'$(InnerTargets)' == ''\">\r\n@@ -103,6 +111,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n     </PropertyGroup>\r\n   </Target>\r\n \r\n+  <!-- Stub to make calling project happy. -->\r\n+  <Target Name=\"GetNativeManifest\" />\r\n+\r\n   <!--\r\n     This will import NuGet restore targets, which is a special case separate from the package -> project extension \r\n     mechanism below. For obvious reasons,  we need restore to work before any package assets are available.\r\ndiff --git \"a/S:\\\\work\\\\single-eval\\\\cli_1.0.0\\\\sdk\\\\1.0.0/Microsoft.Common.CurrentVersion.targets\" \"b/S:\\\\work\\\\single-eval\\\\cli_modified\\\\sdk\\\\1.0.0/Microsoft.Common.CurrentVersion.targets\"\r\nindex 80fbf5a..ee7dbcf 100644\r\n--- \"a/S:\\\\work\\\\single-eval\\\\cli_1.0.0\\\\sdk\\\\1.0.0/Microsoft.Common.CurrentVersion.targets\"\r\n+++ \"b/S:\\\\work\\\\single-eval\\\\cli_modified\\\\sdk\\\\1.0.0/Microsoft.Common.CurrentVersion.targets\"\r\n@@ -1498,112 +1498,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n   </Target>\r\n \r\n   <!--\r\n-    ====================================================================================\r\n-                                        _GetProjectReferenceTargetFrameworkProperties\r\n-\r\n-    Builds the GetTargetFrameworkProperties target of all existent project references,\r\n-    passing $(TargetFrameworkMoniker) as $(ReferringTargetFramework) and sets the\r\n-    SetTargetFramework metadata of the project reference to the value that is returned.\r\n-\r\n-    This allows a cross-targeting project to select how it should be configured to\r\n-    build against the most appropriate target for the referring target framework.\r\n-\r\n-    ======================================================================================\r\n-  -->\r\n-  <Target Name=\"_GetProjectReferenceTargetFrameworkProperties\"\r\n-          Outputs=\"%(_MSBuildProjectReferenceExistent.Identity)\">\r\n-    <!--\r\n-      Honor SkipGetTargetFrameworkProperties=true metadata on project references\r\n-      to mean that the project reference is known not to target multiple frameworks\r\n-      and the mechanism here for selecting the best one can be skipped as an optimization.\r\n-\r\n-      We give this treatment to .vcxproj by default since no .vcxproj can target more\r\n-      than one framework.\r\n-   -->\r\n-   <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and '%(Extension)' == '.vcxproj'\">\r\n-        <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>\r\n-      </_MSBuildProjectReferenceExistent>\r\n-   </ItemGroup>\r\n-\r\n-    <!--\r\n-       Allow project references to specify which target framework properties to set and their values\r\n-       without consulting the referenced project. This has two use cases:\r\n-\r\n-       1. A caller may wish to pick a compatible but sub-optimal target framework. For example,\r\n-          to unit test the .NETStandard implementation using a .NETFramework caller even though\r\n-          there is also a .NETFramework implementation.\r\n-\r\n-       2. As an escape hatch for cases where the compatibility check performed by \r\n-          GetTargetFrameworkProperties is faulty.\r\n-    -->\r\n-    <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetTargetFramework)' != ''\">\r\n-        <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>\r\n-      </_MSBuildProjectReferenceExistent>\r\n-    </ItemGroup>\r\n-\r\n-    <!--\r\n-      Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over \r\n-      TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and \r\n-      has floating NTM=UAP,Version=vX.Y.Z. However, in other cases (classic PCLs), NTM contains multiple values and that will cause the MSBuild\r\n-      invocation below to fail by passing invalid properties. Therefore we do not use the NTM if it contains a semicolon.\r\n-    -->\r\n-    <PropertyGroup Condition=\"'$(ReferringTargetFrameworkForProjectReferences)' == ''\">\r\n-      <ReferringTargetFrameworkForProjectReferences Condition=\"'$(NugetTargetMoniker)' != '' and !$(NuGetTargetMoniker.Contains(';'))\">$(NugetTargetMoniker)</ReferringTargetFrameworkForProjectReferences>\r\n-      <ReferringTargetFrameworkForProjectReferences Condition=\"'$(NugetTargetMoniker)' == ''\">$(TargetFrameworkMoniker)</ReferringTargetFrameworkForProjectReferences>\r\n-    </PropertyGroup>\r\n-\r\n-    <MSBuild\r\n-        Projects=\"%(_MSBuildProjectReferenceExistent.Identity)\"\r\n-        Targets=\"GetTargetFrameworkProperties\"\r\n-        BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); ReferringTargetFramework=$(ReferringTargetFrameworkForProjectReferences)\"\r\n-        ContinueOnError=\"!$(BuildingProject)\"\r\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier\"\r\n-        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'\">\r\n-\r\n-      <Output TaskParameter=\"TargetOutputs\" PropertyName=\"_ProjectReferenceTargetFrameworkProperties\" />\r\n-    </MSBuild>\r\n-\r\n-    <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n-        <SetTargetFramework>$(_ProjectReferenceTargetFrameworkProperties)</SetTargetFramework>\r\n-\r\n-        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectHasSingleTargetFramework=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework;ProjectHasSingleTargetFramework</UndefineProperties>\r\n-        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove TargetFramework -->\r\n-        <UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectHasSingleTargetFramework=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectHasSingleTargetFramework</UndefineProperties>\r\n-      </_MSBuildProjectReferenceExistent>\r\n-    </ItemGroup>\r\n-\r\n-    <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n-        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);RuntimeIdentifier;ProjectIsRidAgnostic</UndefineProperties>\r\n-        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove RuntimeIdentifier -->\r\n-        <UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectIsRidAgnostic</UndefineProperties>\r\n-      </_MSBuildProjectReferenceExistent>\r\n-    </ItemGroup>\r\n-\r\n-    <PropertyGroup>\r\n-      <_ProjectReferenceTargetFrameworkProperties />\r\n-    </PropertyGroup>\r\n-  </Target>\r\n-\r\n-  <!--\r\n-    ============================================================\r\n-                                    GetTargetFrameworkProperties\r\n-\r\n-    Overrridden by cross-targeting projects to return the set of\r\n-    properties (in the form \"key1=value1;...keyN=valueN\") needed\r\n-    to build it with the best target for the referring project's\r\n-    target framework.\r\n-\r\n-    The referring project's $(TargetFrameworkMoniker) is passed \r\n-    in as $(ReferringTargetFramework)\r\n-  -->\r\n-  <Target Name=\"GetTargetFrameworkProperties\" />\r\n-\r\n-  <!--\r\n     ============================================================\r\n                                         PrepareProjectReferences\r\n \r\n@@ -1622,8 +1516,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n   <PropertyGroup>\r\n     <PrepareProjectReferencesDependsOn>\r\n       AssignProjectConfiguration;\r\n-      _SplitProjectReferencesByFileExistence;\r\n-      _GetProjectReferenceTargetFrameworkProperties\r\n+      _SplitProjectReferencesByFileExistence\r\n     </PrepareProjectReferencesDependsOn>\r\n   </PropertyGroup>\r\n   <Target Name=\"PrepareProjectReferences\" DependsOnTargets=\"$(PrepareProjectReferencesDependsOn)\" />\r\n@@ -1724,6 +1617,80 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n \r\n     </MSBuild>\r\n \r\n+    <!-- Ask the multitargeting projects what they should be called with. -->\r\n+\r\n+    <!--\r\n+      Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over\r\n+      TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and\r\n+      has floating NTM=UAP,Version=vX.Y.Z. However, in other cases (classic PCLs), NTM contains multiple values and that will cause the MSBuild\r\n+      invocation below to fail by passing invalid properties. Therefore we do not use the NTM if it contains a semicolon.\r\n+    -->\r\n+    <PropertyGroup Condition=\"'$(ReferringTargetFrameworkForProjectReferences)' == ''\">\r\n+      <ReferringTargetFrameworkForProjectReferences Condition=\"'$(NugetTargetMoniker)' != '' and !$(NuGetTargetMoniker.Contains(';'))\">$(NugetTargetMoniker)</ReferringTargetFrameworkForProjectReferences>\r\n+      <ReferringTargetFrameworkForProjectReferences Condition=\"'$(NugetTargetMoniker)' == ''\">$(TargetFrameworkMoniker)</ReferringTargetFrameworkForProjectReferences>\r\n+    </PropertyGroup>\r\n+\r\n+    <Warning Text=\"@(_ResolvedProjectReferencePaths) - @(_ResolvedProjectReferencePaths->'%(OriginalItemSpec)')\" Condition=\"'%(_ResolvedProjectReferencePaths.HasMultitargeting)' == 'true'\" />\r\n+    <ItemGroup>\r\n+      <_MSBuildProjectReferenceWithMultitargeting Include=\"@(_ResolvedProjectReferencePaths->'%(OriginalItemSpec)')\"\r\n+                                                  Condition=\"'%(_ResolvedProjectReferencePaths.HasMultitargeting)' == 'true'\">\r\n+      </_MSBuildProjectReferenceWithMultitargeting>\r\n+\r\n+      <_ResolvedProjectReferencePaths Remove=\"@(_ResolvedProjectReferencePaths)\"\r\n+                                      Condition=\"'%(_ResolvedProjectReferencePaths.HasMultitargeting)' == 'true'\" />\r\n+\r\n+    </ItemGroup>\r\n+\r\n+\r\n+    <MSBuild\r\n+        Projects=\"@(_MSBuildProjectReferenceWithMultitargeting)\"\r\n+        Targets=\"GetTargetFrameworkProperties\"\r\n+        BuildInParallel=\"$(BuildInParallel)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); ReferringTargetFramework=$(ReferringTargetFrameworkForProjectReferences)\"\r\n+        ContinueOnError=\"!$(BuildingProject)\"\r\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier\"\r\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'\">\r\n+\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferenceTargetFrameworkProperties\" />\r\n+    </MSBuild>\r\n+\r\n+    <PropertyGroup>\r\n+      <MUSTFIX_TFProps>%(_ProjectReferenceTargetFrameworkProperties.Identity)</MUSTFIX_TFProps>\r\n+    </PropertyGroup>\r\n+\r\n+    <ItemGroup>\r\n+      <_MSBuildProjectReferenceWithMultitargeting>\r\n+        <SetTargetFramework>$(MUSTFIX_TFProps)</SetTargetFramework>\r\n+      </_MSBuildProjectReferenceWithMultitargeting>\r\n+\r\n+      <RainerDebug Include=\"@(_MSBuildProjectReferenceWithMultitargeting)\" />\r\n+    </ItemGroup>\r\n+\r\n+    <!--<ItemGroup>\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n+        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);RuntimeIdentifier;ProjectIsRidAgnostic</UndefineProperties>-->\r\n+        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove RuntimeIdentifier -->\r\n+        <!--<UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectIsRidAgnostic</UndefineProperties>\r\n+      </_MSBuildProjectReferenceExistent>\r\n+    </ItemGroup>-->\r\n+\r\n+    <!--\r\n+        Build multitargeting referenced projects when building from the command line.\r\n+        -->\r\n+    <MSBuild\r\n+        Projects=\"@(_MSBuildProjectReferenceWithMultitargeting)\"\r\n+        Targets=\"%(_MSBuildProjectReferenceWithMultitargeting.Targets)\"\r\n+        BuildInParallel=\"$(BuildInParallel)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceWithMultitargeting.SetConfiguration); %(_MSBuildProjectReferenceWithMultitargeting.SetPlatform);  %(_MSBuildProjectReferenceWithMultitargeting.SetTargetFramework)\"\r\n+        Condition=\"'%(_MSBuildProjectReferenceWithMultitargeting.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''\"\r\n+        ContinueOnError=\"$(ContinueOnError)\"\r\n+        RemoveProperties=\"%(_MSBuildProjectReferenceWithMultitargeting.GlobalPropertiesToRemove)\">\r\n+\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ResolvedProjectReferencePaths\" Condition=\"'%(_MSBuildProjectReferenceWithMultitargeting.ReferenceOutputAssembly)'=='true' or '$(DesignTimeBuild)' == 'true'\"/>\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"%(_MSBuildProjectReferenceWithMultitargeting.OutputItemType)\" Condition=\"'%(_MSBuildProjectReferenceWithMultitargeting.OutputItemType)' != ''\"/>\r\n+\r\n+    </MSBuild>\r\n+\r\n     <!--\r\n         Get manifest items from the (non-exe) built project references (to feed them into ResolveNativeReference).\r\n         -->\r\n@@ -4191,8 +4158,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n   <PropertyGroup>\r\n     <GetCopyToOutputDirectoryItemsDependsOn>\r\n       AssignTargetPaths;\r\n-      _SplitProjectReferencesByFileExistence;\r\n-      _GetProjectReferenceTargetFrameworkProperties\r\n+      _SplitProjectReferencesByFileExistence\r\n     </GetCopyToOutputDirectoryItemsDependsOn>\r\n   </PropertyGroup>\r\n   <Target\r\ndiff --git \"a/S:\\\\work\\\\single-eval\\\\cli_1.0.0\\\\sdk\\\\1.0.0/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\" \"b/S:\\\\work\\\\single-eval\\\\cli_modified\\\\sdk\\\\1.0.0/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\"\r\nindex 1cdc34e..5bc1bc1 100644\r\n--- \"a/S:\\\\work\\\\single-eval\\\\cli_1.0.0\\\\sdk\\\\1.0.0/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\"\r\n+++ \"b/S:\\\\work\\\\single-eval\\\\cli_modified\\\\sdk\\\\1.0.0/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\"\r\n@@ -51,7 +51,7 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n     with the referencing project's target framework.\r\n   ============================================================\r\n    -->\r\n-  <Target Name=\"GetTargetFrameworkProperties\" Returns=\"TargetFramework=$(NearestTargetFramework);ProjectHasSingleTargetFramework=$(_HasSingleTargetFramework);ProjectIsRidAgnostic=$(_IsRidAgnostic)\">\r\n+  <Target Name=\"GetTargetFrameworkProperties\" Returns=\"@(_ReturnItem)\">\r\n \r\n     <PropertyGroup>\r\n       <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\r\n@@ -62,10 +62,6 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n       <_SkipNearestTargetFrameworkResolution Condition=\"'$(TargetFramework)' != '' and '$(ReferringTargetFramework)' == ''\">true</_SkipNearestTargetFrameworkResolution>\r\n       <NearestTargetFramework Condition=\"'$(_SkipNearestTargetFrameworkResolution)' == 'true'\">$(TargetFramework)</NearestTargetFramework>\r\n \r\n-      <!-- A project can only have more than one output if the current global properties are such that the current build is a cross-targeting one. -->\r\n-      <_HasSingleTargetFramework Condition=\"'$(IsCrossTargetingBuild)' != 'true'\">true</_HasSingleTargetFramework>\r\n-      <_HasSingleTargetFramework Condition=\"'$(_HasSingleTargetFramework)' == ''\">false</_HasSingleTargetFramework>\r\n-\r\n       <_PossibleTargetFrameworks Condition=\"'$(TargetFramework)' != ''\">$(TargetFramework)</_PossibleTargetFrameworks>\r\n       <_PossibleTargetFrameworks Condition=\"'$(TargetFramework)' == ''\">$(TargetFrameworks)</_PossibleTargetFrameworks>\r\n     </PropertyGroup>\r\n@@ -76,6 +72,11 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n                                Condition=\"'$(_SkipNearestTargetFrameworkResolution)' != 'true'\">\r\n       <Output PropertyName=\"NearestTargetFramework\" TaskParameter=\"NearestTargetFramework\" />\r\n     </GetNearestTargetFramework>\r\n+\r\n+    <ItemGroup>\r\n+      <!-- TODO: return rid-agnostic -->\r\n+      <_ReturnItem Include=\"$([MSBuild]::Escape('TargetFramework=$(NearestTargetFramework)'))\" />\r\n+    </ItemGroup>\r\n   </Target>\r\n   \r\n </Project>\r\n```\r\n</details>\r\n\r\nI'm pausing this for now to investigate another avenue.",
        "createdAt": "2017-03-01T23:04:49Z",
        "updatedAt": "2017-03-01T23:04:49Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "While overhauling, we should consider https://github.com/dotnet/sdk/issues/939--that's a result of the new MSBuild invocation for the query.",
        "createdAt": "2017-03-06T21:22:21Z",
        "updatedAt": "2017-03-06T21:22:21Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "The \"another avenue\" I mentioned above is this flow:\r\n\r\n* Run `ShouldEvaluateWithTargetFramework` in all refs with no TF or RID specified.\r\n  * Non-Sdk projects get a default \"false\" from a definition of this target in Common.targets.\r\n  * Sdk projects override the default with the value of `$(IsCrossTargetingBuild)`\r\n* For only the projects that say they're cross-targeting, build `GetTargetFrameworkProperties` with a `ReferringTargetFramework`, and update the ref with the desired TF.\r\n* Proceed with `ResolveProjectReferences` as usual.\r\n\r\nThis means that a referenced cross-targeting project will have evaluations:\r\n* With no TF (asking if it's cross-targeting)\r\n* With a TF (getting its outputs)\r\n\r\nA referenced non-cross-targeting or legacy project will have only one evaluation, with no TF (asking if it's cross-targeting), which will be reused at build time. There is an additional MSBuild-task invocation compared to the all-legacy case, but the evaluation cost isn't paid again.\r\n\r\nThis avoids the \"built more TFs than was necessary\" problem of the just-call-the-outer-build approach, but I'm not sure it's better overall. I'm going to try to get semi-productized versions of both so we can compare them, probably on Roslyn Project System since that's a mid-size project that's feeling this.\r\n\r\nOne consideration: design-time builds won't necessarily have the \"build all TFs\" problem because we can intercept `GetTargetPath` to return \"I cross-target, tell me what you want\" quickly. But we can't do that for the default/`Build` target, so I don't see a way to avoid that for command line builds. If we thought that \"most\" command-line builds would be solution builds (and thus eventually build all TFs anyway) then the extra builds could be less important.",
        "createdAt": "2017-03-07T23:55:10Z",
        "updatedAt": "2017-03-07T23:55:10Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I've been beating my head against this for a while trying to figure out why my changes don't show an apparent improvement on the Roslyn Project System solution--total elapsed time barely budged, no matter what I did: the current strategy, hardcode `SkipGetTargetFrameworkProperties=true` (as an \"optimal\" approach), or either of the two approaches I've been thinking of here.\r\n\r\nThen eventually it dawned on me: in the detailed summary, time is attributed to a target while it's blocked on MSBuilding another project, even if the reason it's blocked isn't that _that build request_ is taking time--it could just be that another build request is taking up the node.\r\n\r\nIn the case of a solution build of RPS, the solution points to all of the projects directly, and they each do the \"main\" build, up until they get blocked--either resolving project references (i.e. waiting for other projects to finish), or querying project references about their TF (i.e. waiting for the \"main\" build request on each project to get blocked so that a supplemental build request can run an additional target). If eval time isn't super significant (which it is not for .csproj), you'd expect about the same amount of time blocked--the time it takes for the \"main\" build to get blocked + evaluation time (\u2248 0) + target execution time (\u22480, either because it's already done or because it doesn't take very long to run the \"build me for this TF\" target). In the query cases, all of that waiting is attributed to the query operation, while in the optimal case it's all attributed to ResolveProjectReferences.\r\n\r\nAnd that's what I see:\r\n\r\nRTW: total blocked time = 227506 ms (ResolveProjectReferences + GetProjectReferenceTargetFrameworkProperties)\r\n```\r\n    11930 ms  CoreCompile                               18 calls\r\n    15522 ms  _GetProjectReferenceTargetFrameworkProperties  58 calls\r\n    29514 ms  Build                                     18 calls\r\n    211984 ms  ResolveProjectReferences                  17 calls\r\n```\r\n\r\n`SkipGetTargetFrameworkProperties=true` total blocked time = 222181 ms (ResolveProjectReferences only)\r\n```\r\n    17678 ms  CoreCompile                               18 calls\r\n    28394 ms  Build                                     18 calls\r\n    222181 ms  ResolveProjectReferences                  17 calls\r\n```\r\n\r\nMy approach 2 (explicit query for cross-targeting before querying for TF): total blocked time = 216631 ms (ResolveProjectReferences + _GetCrossTargetingProjectReferences)\r\n```\r\n    11679 ms  CoreCompile                               18 calls\r\n    28187 ms  Build                                     18 calls\r\n    76436 ms  _GetCrossTargetingProjectReferences       17 calls\r\n    140195 ms  ResolveProjectReferences                  17 calls\r\n```\r\n\r\nThose are all in spitting distance of each other.\r\n\r\nWhere the approaches will see more differences is for .vcxproj, where eval time is much more significant. I'll try the different approaches out on some projects there in the morning.",
        "createdAt": "2017-03-10T00:36:42Z",
        "updatedAt": "2017-03-10T00:36:42Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Interesting!",
        "createdAt": "2017-03-10T00:40:07Z",
        "updatedAt": "2017-03-10T00:40:07Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "PLEASE IGNORE\r\n\r\nPlease add an override property to turn it off. I have a compilation task that runs my custom compiler in-proc which does not support parallel executions in the same process. It would be nice to be able to force a serial compilation if needed.",
        "createdAt": "2017-03-10T19:45:37Z",
        "updatedAt": "2017-03-10T19:59:28Z",
        "author": {
          "login": "borgdylan"
        }
      },
      {
        "body": "@borgdylan I don't understand. What is \"it\" that you want to be able to be turned off? How does your compilation task play into this issue, which is about how ProjectReferences are resolved?",
        "createdAt": "2017-03-10T19:56:41Z",
        "updatedAt": "2017-03-10T19:56:41Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Oh, I posted into thr wrong issue. I wanted to post in the issue with regards to the parallel building for all TFMs.",
        "createdAt": "2017-03-10T19:59:11Z",
        "updatedAt": "2017-03-10T20:06:13Z",
        "author": {
          "login": "borgdylan"
        }
      },
      {
        "body": "Lost my working implementation of option 2 due to a tragic incident involving reinstalling Windows and not backing up BitLocker keys.\r\n\r\nThis is my attempt at reconstructing it:\r\n\r\n```diff\r\ndiff --git a/15.0/Bin/Microsoft.Common.CurrentVersion.targets b/15.0/Bin/Microsoft.Common.CurrentVersion.targets\r\nindex 80fbf5a..1a0e760 100644\r\n--- a/15.0/Bin/Microsoft.Common.CurrentVersion.targets\r\n+++ b/15.0/Bin/Microsoft.Common.CurrentVersion.targets\r\n@@ -1499,7 +1499,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n \r\n   <!--\r\n     ====================================================================================\r\n-                                        _GetProjectReferenceTargetFrameworkProperties\r\n+                                        _GetProjectReferenceCrossTargetingStatus\r\n \r\n     Builds the GetTargetFrameworkProperties target of all existent project references,\r\n     passing $(TargetFrameworkMoniker) as $(ReferringTargetFramework) and sets the\r\n@@ -1510,21 +1510,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n \r\n     ======================================================================================\r\n   -->\r\n-  <Target Name=\"_GetProjectReferenceTargetFrameworkProperties\"\r\n-          Outputs=\"%(_MSBuildProjectReferenceExistent.Identity)\">\r\n+  <Target Name=\"_GetProjectReferenceCrossTargetingStatus\">\r\n     <!--\r\n       Honor SkipGetTargetFrameworkProperties=true metadata on project references\r\n       to mean that the project reference is known not to target multiple frameworks\r\n       and the mechanism here for selecting the best one can be skipped as an optimization.\r\n-\r\n-      We give this treatment to .vcxproj by default since no .vcxproj can target more\r\n-      than one framework.\r\n-   -->\r\n-   <ItemGroup>\r\n+    -->\r\n+    <!--<ItemGroup>\r\n       <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and '%(Extension)' == '.vcxproj'\">\r\n         <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>\r\n       </_MSBuildProjectReferenceExistent>\r\n-   </ItemGroup>\r\n+    </ItemGroup>-->\r\n \r\n     <!--\r\n        Allow project references to specify which target framework properties to set and their values\r\n@@ -1543,6 +1539,41 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n       </_MSBuildProjectReferenceExistent>\r\n     </ItemGroup>\r\n \r\n+    <MSBuild\r\n+        Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n+        Targets=\"IsCrossTargetingProject\"\r\n+        BuildInParallel=\"$(BuildInParallel)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)\"\r\n+        ContinueOnError=\"!$(BuildingProject)\"\r\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier\"\r\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'\">\r\n+\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_MSBuildProjectReferenceCrossTargetingResults\" />\r\n+    </MSBuild>\r\n+\r\n+    <ItemGroup>\r\n+      <_MSBuildProjectReferenceCrossTargeting Include=\"@(_MSBuildProjectReferenceCrossTargetingResults->'%(OriginalItemSpec)')\"\r\n+                                              Condition=\"'%(_MSBuildProjectReferenceCrossTargetingResults.Identity)' == 'true'\" />\r\n+      <_MSBuildProjectReferenceNoCrossTargeting Include=\"@(_MSBuildProjectReferenceCrossTargetingResults->'%(OriginalItemSpec)')\"\r\n+                                                Condition=\"'%(_MSBuildProjectReferenceCrossTargetingResults.Identity)' == 'false'\" />\r\n+    </ItemGroup>\r\n+  </Target>\r\n+\r\n+  <!--\r\n+    ====================================================================================\r\n+                                        _GetProjectReferenceTargetFrameworkProperties\r\n+\r\n+    Builds the GetTargetFrameworkProperties target of all existent project references,\r\n+    passing $(TargetFrameworkMoniker) as $(ReferringTargetFramework) and sets the\r\n+    SetTargetFramework metadata of the project reference to the value that is returned.\r\n+\r\n+    This allows a cross-targeting project to select how it should be configured to\r\n+    build against the most appropriate target for the referring target framework.\r\n+\r\n+    ======================================================================================\r\n+  -->\r\n+  <Target Name=\"_GetProjectReferenceTargetFrameworkProperties\"\r\n+          DependsOnTargets=\"_GetProjectReferenceCrossTargetingStatus\">\r\n     <!--\r\n       Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over \r\n       TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and \r\n@@ -1555,7 +1586,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n     </PropertyGroup>\r\n \r\n     <MSBuild\r\n-        Projects=\"%(_MSBuildProjectReferenceExistent.Identity)\"\r\n+        Projects=\"@(_MSBuildProjectReferenceCrossTargeting)\"\r\n         Targets=\"GetTargetFrameworkProperties\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n         Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); ReferringTargetFramework=$(ReferringTargetFrameworkForProjectReferences)\"\r\n@@ -1563,30 +1594,32 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier\"\r\n         Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'\">\r\n \r\n-      <Output TaskParameter=\"TargetOutputs\" PropertyName=\"_ProjectReferenceTargetFrameworkProperties\" />\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferenceTargetFrameworkProperties\" />\r\n     </MSBuild>\r\n \r\n     <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n-        <SetTargetFramework>$(_ProjectReferenceTargetFrameworkProperties)</SetTargetFramework>\r\n+      <!-- Build an item that has Identity matching _MSBuildProjectReferenceExistent and metadata for properties to set. -->\r\n+      <_ProjectReferencesWithTargetFrameworkProperties Include=\"@(_ProjectReferenceTargetFrameworkProperties->'%(OriginalItemSpec)')\" />\r\n+      <_ProjectReferencesWithTargetFrameworkProperties Include=\"@(_MSBuildProjectReferenceNoCrossTargeting)\">\r\n+        <HasSingleTargetFramework>true</HasSingleTargetFramework>\r\n+        <IsRidAgnostic>true</IsRidAgnostic>\r\n+      </_ProjectReferencesWithTargetFrameworkProperties>\r\n+\r\n+      <!-- Set the project's returned TargetFramework -->\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'@(_ProjectReferencesWithTargetFrameworkProperties)' == '%(Identity)' and '@(_ProjectReferencesWithTargetFrameworkProperties->'%(HasSingleTargetFramework)')' != 'true'\">\r\n+        <SetTargetFramework>@(_ProjectReferencesWithTargetFrameworkProperties->'%(DesiredTargetFrameworkProperties)')</SetTargetFramework>\r\n+      </_MSBuildProjectReferenceExistent>\r\n \r\n-        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectHasSingleTargetFramework=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework;ProjectHasSingleTargetFramework</UndefineProperties>\r\n-        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove TargetFramework -->\r\n-        <UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectHasSingleTargetFramework=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectHasSingleTargetFramework</UndefineProperties>\r\n+      <!-- If the project has only one TF, don't specify it. It will go directly to the inner build anyway and we don't want to redundantly specify a global property, which can cause a race. -->\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'@(_ProjectReferencesWithTargetFrameworkProperties)' == '%(Identity)' and '@(_ProjectReferencesWithTargetFrameworkProperties->'%(HasSingleTargetFramework)')' == 'true'\">\r\n+        <UndefineProperties>@(_MSBuildProjectReferenceExistent->'%(UndefineProperties)');TargetFramework</UndefineProperties>\r\n       </_MSBuildProjectReferenceExistent>\r\n-    </ItemGroup>\r\n \r\n-    <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n-        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);RuntimeIdentifier;ProjectIsRidAgnostic</UndefineProperties>\r\n-        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove RuntimeIdentifier -->\r\n-        <UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectIsRidAgnostic</UndefineProperties>\r\n+      <!-- If the project has only one RID, assume it's compatible with the current project and don't pass this one along. -->\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'@(_ProjectReferencesWithTargetFrameworkProperties)' == '%(Identity)' and '@(_ProjectReferencesWithTargetFrameworkProperties->'%(IsRidAgnostic)')' == 'true'\">\r\n+        <UndefineProperties>@(_MSBuildProjectReferenceExistent->'%(UndefineProperties)');RuntimeIdentifier</UndefineProperties>\r\n       </_MSBuildProjectReferenceExistent>\r\n     </ItemGroup>\r\n-\r\n-    <PropertyGroup>\r\n-      <_ProjectReferenceTargetFrameworkProperties />\r\n-    </PropertyGroup>\r\n   </Target>\r\n \r\n   <!--\r\n@@ -1605,6 +1638,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n \r\n   <!--\r\n     ============================================================\r\n+                                         IsCrossTargetingProject\r\n+\r\n+    Overrridden by cross-targeting projects to return \"true\" if\r\n+    the project should have its GetTargetFrameworkProperties\r\n+    target called with a ReferringTargetFramework. If \"false\",\r\n+    the single output of the project is used.\r\n+  -->\r\n+  <Target Name=\"IsCrossTargetingProject\" Returns=\"false\" />\r\n+\r\n+  <!--\r\n+    ============================================================\r\n                                         PrepareProjectReferences\r\n \r\n     Prepares project references for consumption by other targets.\r\ndiff --git a/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets b/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\r\nindex 1cdc34e..ba32ce6 100644\r\n--- a/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\r\n+++ b/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\r\n@@ -51,7 +51,7 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n     with the referencing project's target framework.\r\n   ============================================================\r\n    -->\r\n-  <Target Name=\"GetTargetFrameworkProperties\" Returns=\"TargetFramework=$(NearestTargetFramework);ProjectHasSingleTargetFramework=$(_HasSingleTargetFramework);ProjectIsRidAgnostic=$(_IsRidAgnostic)\">\r\n+  <Target Name=\"GetTargetFrameworkProperties\" Returns=\"@(ProjectBuildInstructions)\">\r\n \r\n     <PropertyGroup>\r\n       <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\r\n@@ -76,6 +76,14 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n                                Condition=\"'$(_SkipNearestTargetFrameworkResolution)' != 'true'\">\r\n       <Output PropertyName=\"NearestTargetFramework\" TaskParameter=\"NearestTargetFramework\" />\r\n     </GetNearestTargetFramework>\r\n+\r\n+    <ItemGroup>\r\n+      <ProjectBuildInstructions Include=\"$(MSBuildProjectFullPath)\">\r\n+        <DesiredTargetFrameworkProperties>TargetFramework=$(NearestTargetFramework)</DesiredTargetFrameworkProperties>\r\n+        <HasSingleTargetFramework>$(_HasSingleTargetFramework)</HasSingleTargetFramework>\r\n+        <IsRidAgnostic>$(_IsRidAgnostic)</IsRidAgnostic>\r\n+      </ProjectBuildInstructions>\r\n+    </ItemGroup>\r\n   </Target>\r\n   \r\n </Project>\r\ndiff --git a/Sdks/Microsoft.NET.Sdk/buildCrossTargeting/Microsoft.NET.Sdk.targets b/Sdks/Microsoft.NET.Sdk/buildCrossTargeting/Microsoft.NET.Sdk.targets\r\nindex 75112db..932d340 100644\r\n--- a/Sdks/Microsoft.NET.Sdk/buildCrossTargeting/Microsoft.NET.Sdk.targets\r\n+++ b/Sdks/Microsoft.NET.Sdk/buildCrossTargeting/Microsoft.NET.Sdk.targets\r\n@@ -73,4 +73,14 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n     </PropertyGroup>\r\n   </Target>\r\n \r\n+  <!--\r\n+    ============================================================\r\n+                                         IsCrossTargetingProject\r\n+\r\n+    Indicate that this project cross-targets, so before building\r\n+    it, a referring project must call GetTargetFrameworkProperties\r\n+    to get the matching TargetFramework to specify.\r\n+  -->\r\n+  <Target Name=\"IsCrossTargetingProject\" Returns=\"true\" />\r\n+\r\n </Project>\r\n```",
        "createdAt": "2017-03-14T23:23:11Z",
        "updatedAt": "2017-03-14T23:23:11Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Where are we with this? Investigating ASP.NET up-to-date build logs, and _GetProjectReferenceTargetFrameworkProperties is showing heavily on the radar as the slowest thing.",
        "createdAt": "2017-04-12T01:17:58Z",
        "updatedAt": "2017-04-12T01:17:58Z",
        "author": {
          "login": "davkean"
        }
      },
      {
        "body": "I'm back from leave and actively working on this, but again I'd be very surprised if this is actually causing you a problem, per my analysis above. Do you have evidence to contradict that, @davkean?",
        "createdAt": "2017-04-12T15:34:53Z",
        "updatedAt": "2017-04-12T15:34:53Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Not sure what you mean? On some up-to-date builds, _GetProjectReferenceTargetFrameworkProperties  is 63% of the build time - is that expected?",
        "createdAt": "2017-04-13T00:58:02Z",
        "updatedAt": "2017-04-13T00:58:19Z",
        "author": {
          "login": "davkean"
        }
      },
      {
        "body": "Re-reading above, maybe i need a little more guidance I'm not really understanding your conclusion - or what we can do get build time down.",
        "createdAt": "2017-04-13T01:00:47Z",
        "updatedAt": "2017-04-13T01:00:47Z",
        "author": {
          "login": "davkean"
        }
      },
      {
        "body": "@davkean can you point me toward a repro of that extreme percentage? I can walk through that specific case and make sure my reasoning still holds.\r\n\r\nIn general, my theory is that: evaluation is fast and `GetTargetFrameworkProperties` is also fast. Therefore, any time spent in `_GetProjectReferenceTargetFrameworkProperties` is time spent waiting for the node to be available to do the work, and not time spent doing the work itself. I expect that wait time to be similar to the wait time for the node that did the compilation work, so it comes out in the wash.",
        "createdAt": "2017-04-20T20:42:10Z",
        "updatedAt": "2017-04-20T20:42:10Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Picking this up again. I'm setting a testbed up:\r\n\r\nBuilding [this Roslyn project](https://github.com/dotnet/roslyn/blob/20d3d7a2b91f6804fecd87997e756450df761619/src/VisualStudio/IntegrationTest/IntegrationTests/VisualStudioIntegrationTests.csproj) (at that version), after having built the whole repo (to restore packages).\r\n\r\nIn a \"design-time-like\" way, meaning\r\n```\r\nmsbuild /m:1 /v:m /clp:Summary /flp:v=m;PerformanceSummary /t:CollectResolvedSDKReferencesDesignTime;DebugSymbolsProjectOutputGroup;ResolveComReferencesDesignTime;ContentFilesProjectOutputGroup;DocumentationProjectOutputGroupDependencies;SGenFilesOutputGroup;ResolveProjectReferencesDesignTime;SourceFilesProjectOutputGroup;DebugSymbolsProjectOutputGroupDependencies;SatelliteDllsProjectOutputGroup;BuiltProjectOutputGroup;SGenFilesOutputGroupDependencies;ResolveAssemblyReferencesDesignTime;CollectSDKReferencesDesignTime;DocumentationProjectOutputGroup;PriFilesOutputGroup;BuiltProjectOutputGroupDependencies;SatelliteDllsProjectOutputGroupDependencies;SDKRedistOutputGroup \"/p:SolutionFileName=Roslyn.sln;LangName=en-US;Configuration=Debug;LangID=1033;DesignTimeBuild=true;SolutionDir=S:\\\\roslyn\\\\;SolutionExt=.sln;BuildingInsideVisualStudio=true;DefineExplicitDefaults=true;Platform=AnyCPU;SolutionPath=S:\\\\roslyn\\\\Roslyn.sln;SolutionName=Roslyn;DevEnvDir=C:\\\\Program Files %28x86%29\\\\Microsoft Visual Studio\\\\Preview\\\\EntInt\\\\Common7\\\\IDE\\\\\"\r\n```\r\n\r\nOn my machine with VS 26730.0.d15rel, that takes `Time Elapsed 00:00:08.69`, of which\r\n\r\n```\r\n      516 ms  ResolveAssemblyReferences                  1 calls\r\n     3449 ms  ResolveProjectReferences                   1 calls\r\n     3732 ms  _GetProjectReferenceTargetFrameworkProperties  36 calls\r\n```\r\n\r\nThe 36 references are each evaluated twice, with [some projects](https://github.com/dotnet/roslyn/blob/20d3d7a2b91f6804fecd87997e756450df761619/src/Features/Core/Portable/) with lots of globbed includes taking more than 500 ms total evaluation time.",
        "createdAt": "2017-08-04T20:59:16Z",
        "updatedAt": "2017-08-04T20:59:16Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Resurrecting https://github.com/dotnet/sdk/pull/993 and Microsoft/msbuild#1866 cuts the time dramatically, as hoped (`Time Elapsed 00:00:05.21`):\r\n\r\n```\r\n      164 ms  ReportAssetsLogMessages                    1 calls\r\n      186 ms  ResolveProjectReferences                   1 calls\r\n      206 ms  _GetProjectReferenceTargetFrameworkProperties   1 calls\r\n      504 ms  ResolveAssemblyReferences                  1 calls\r\n     3422 ms  _GetProjectReferencesThatNeedProperties    1 calls\r\n```\r\n\r\n<details>\r\n<summary>target diffs in the private MSBuild folder</summary>\r\n\r\n```diff\r\ndiff --git a/MSBuild/15.0/Bin/Microsoft.Common.CurrentVersion.targets b/MSBuild/15.0/Bin/Microsoft.Common.CurrentVersion.targets\r\nindex 531d63f..36fcd53 100644\r\n--- a/MSBuild/15.0/Bin/Microsoft.Common.CurrentVersion.targets\r\n+++ b/MSBuild/15.0/Bin/Microsoft.Common.CurrentVersion.targets\r\n@@ -910,7 +910,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"BuildGenerateSources\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework);\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties);\"\r\n         Condition=\"'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'\"\r\n         ContinueOnError=\"!$(BuildingProject)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -935,7 +935,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"BuildCompile\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'\"\r\n         ContinueOnError=\"!$(BuildingProject)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -960,7 +960,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"BuildLink\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'\"\r\n         ContinueOnError=\"!$(BuildingProject)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -1511,33 +1511,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n \r\n   <!--\r\n     ====================================================================================\r\n-                                        _GetProjectReferenceTargetFrameworkProperties\r\n+                                        _GetProjectReferencesThatNeedProperties\r\n \r\n-    Builds the GetTargetFrameworkProperties target of all existent project references,\r\n-    passing $(TargetFrameworkMoniker) as $(ReferringTargetFramework) and sets the\r\n-    SetTargetFramework metadata of the project reference to the value that is returned.\r\n+    Builds the ShouldQueryForProperties target of all existent project references,\r\n+    removing any TargetFramework and RuntimeIdentifier properties that are set as\r\n+    global properties in this project.\r\n \r\n-    This allows a cross-targeting project to select how it should be configured to\r\n-    build against the most appropriate target for the referring target framework.\r\n+    This allows a cross-targeting project to indicate that it should be asked\r\n+    for a compatible TargetFramework before building.\r\n \r\n     ======================================================================================\r\n   -->\r\n-  <Target Name=\"_GetProjectReferenceTargetFrameworkProperties\"\r\n-          Outputs=\"%(_MSBuildProjectReferenceExistent.Identity)\">\r\n-    <!--\r\n-      Honor SkipGetTargetFrameworkProperties=true metadata on project references\r\n-      to mean that the project reference is known not to target multiple frameworks\r\n-      and the mechanism here for selecting the best one can be skipped as an optimization.\r\n-\r\n-      We give this treatment to .vcxproj by default since no .vcxproj can target more\r\n-      than one framework.\r\n-   -->\r\n-   <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and '%(Extension)' == '.vcxproj'\">\r\n-        <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>\r\n-      </_MSBuildProjectReferenceExistent>\r\n-   </ItemGroup>\r\n-\r\n+  <Target Name=\"_GetProjectReferencesThatNeedProperties\">\r\n     <!--\r\n        Allow project references to specify which target framework properties to set and their values\r\n        without consulting the referenced project. This has two use cases:\r\n@@ -1547,15 +1532,58 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n           there is also a .NETFramework implementation.\r\n \r\n        2. As an escape hatch for cases where the compatibility check performed by \r\n-          GetTargetFrameworkProperties is faulty.\r\n+          GetDesiredProperties is faulty.\r\n     -->\r\n     <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetTargetFramework)' != ''\">\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.SetDesiredProperties)' != ''\">\r\n         <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>\r\n       </_MSBuildProjectReferenceExistent>\r\n     </ItemGroup>\r\n \r\n     <!--\r\n+      Honor SkipGetTargetFrameworkProperties=true metadata on project references\r\n+      to mean that the project reference is known not to target multiple frameworks\r\n+      and the mechanism here for selecting the best one can be skipped as an optimization.\r\n+    -->\r\n+    <MSBuild\r\n+        Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n+        Targets=\"ShouldQueryForProperties\"\r\n+        BuildInParallel=\"$(BuildInParallel)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)\"\r\n+        ContinueOnError=\"!$(BuildingProject)\"\r\n+        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);$(PropertiesToRemoveWhenQueryingForDesiredProperties)\"\r\n+        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'\">\r\n+\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_MSBuildProjectReferenceWithDesiredPropertiesResults\" />\r\n+    </MSBuild>\r\n+\r\n+    <ItemGroup>\r\n+      <!-- Transform the list so that its Identity correlates with that of _MSBuildProjectReferenceExistent. -->\r\n+      <_MSBuildProjectReferenceWithDesiredProperties Include=\"@(_MSBuildProjectReferenceWithDesiredPropertiesResults->'%(OriginalItemSpec)')\" />\r\n+\r\n+      <!-- Update refs to remove any properties that the reference knows (without the referring TF) it doesn't want. -->\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'@(_MSBuildProjectReferenceWithDesiredProperties)' == '%(Identity)' and '@(_MSBuildProjectReferenceWithDesiredProperties->'%(QueryForProperties)')' == 'false'\">\r\n+        <UndefineProperties>@(_MSBuildProjectReferenceExistent->'%(UndefineProperties)');@(_MSBuildProjectReferenceWithDesiredProperties->'%(UndefineProperties)')</UndefineProperties>\r\n+      </_MSBuildProjectReferenceExistent>\r\n+    </ItemGroup>\r\n+  </Target>\r\n+\r\n+  <!--\r\n+    ====================================================================================\r\n+                                        _GetProjectReferenceTargetFrameworkProperties\r\n+\r\n+    Builds the GetDesiredProperties target of all existent project references,\r\n+    passing $(TargetFrameworkMoniker) as $(ReferringTargetFramework) and sets the\r\n+    SetDesiredProperties metadata of the project reference to the value that is returned.\r\n+\r\n+    This allows a cross-targeting project to select how it should be configured to\r\n+    build against the most appropriate target for the referring target framework.\r\n+\r\n+    ======================================================================================\r\n+  -->\r\n+  <Target Name=\"_GetProjectReferenceTargetFrameworkProperties\"\r\n+          DependsOnTargets=\"_GetProjectReferencesThatNeedProperties\">\r\n+    <!--\r\n       Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over \r\n       TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and \r\n       has floating NTM=UAP,Version=vX.Y.Z. However, in other cases (classic PCLs), NTM contains multiple values and that will cause the MSBuild\r\n@@ -1567,53 +1595,62 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n     </PropertyGroup>\r\n \r\n     <MSBuild\r\n-        Projects=\"%(_MSBuildProjectReferenceExistent.Identity)\"\r\n-        Targets=\"GetTargetFrameworkProperties\"\r\n+        Projects=\"@(_MSBuildProjectReferenceWithDesiredProperties)\"\r\n+        Targets=\"GetDesiredProperties\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); ReferringTargetFramework=$(ReferringTargetFrameworkForProjectReferences)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceWithDesiredProperties.SetConfiguration); %(_MSBuildProjectReferenceWithDesiredProperties.SetPlatform); ReferringTargetFramework=$(ReferringTargetFrameworkForProjectReferences)\"\r\n         ContinueOnError=\"!$(BuildingProject)\"\r\n-        RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier\"\r\n-        Condition=\"'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'\">\r\n+        RemoveProperties=\"%(_MSBuildProjectReferenceWithDesiredProperties.GlobalPropertiesToRemove);$(PropertiesToRemoveWhenQueryingForDesiredProperties)\"\r\n+        Condition=\"'%(_MSBuildProjectReferenceWithDesiredProperties.SkipGetTargetFrameworkProperties)' != 'true' and '%(_MSBuildProjectReferenceWithDesiredProperties.QueryForProperties)' == 'true'\">\r\n \r\n-      <Output TaskParameter=\"TargetOutputs\" PropertyName=\"_ProjectReferenceTargetFrameworkProperties\" />\r\n+      <Output TaskParameter=\"TargetOutputs\" ItemName=\"_ProjectReferenceTargetFrameworkProperties\" />\r\n     </MSBuild>\r\n \r\n     <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n-        <SetTargetFramework>$(_ProjectReferenceTargetFrameworkProperties)</SetTargetFramework>\r\n+      <!-- Build an item that has Identity matching _MSBuildProjectReferenceExistent and metadata for properties to set. -->\r\n+      <_ProjectReferencesWithTargetFrameworkProperties Include=\"@(_ProjectReferenceTargetFrameworkProperties->'%(OriginalItemSpec)')\" />\r\n \r\n-        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectHasSingleTargetFramework=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework;ProjectHasSingleTargetFramework</UndefineProperties>\r\n-        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove TargetFramework -->\r\n-        <UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectHasSingleTargetFramework=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectHasSingleTargetFramework</UndefineProperties>\r\n+      <!-- Set the project's returned TargetFramework -->\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'@(_ProjectReferencesWithTargetFrameworkProperties)' == '%(Identity)' and '@(_ProjectReferencesWithTargetFrameworkProperties->'%(SetDesiredProperties)')' != ''\">\r\n+        <SetDesiredProperties>@(_ProjectReferencesWithTargetFrameworkProperties->'%(SetDesiredProperties)')</SetDesiredProperties>\r\n       </_MSBuildProjectReferenceExistent>\r\n-    </ItemGroup>\r\n \r\n-    <ItemGroup>\r\n-      <_MSBuildProjectReferenceExistent Condition=\"'%(_MSBuildProjectReferenceExistent.Identity)' == '%(Identity)' and '$(_ProjectReferenceTargetFrameworkProperties)' != ''\">\r\n-        <UndefineProperties Condition=\"$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);RuntimeIdentifier;ProjectIsRidAgnostic</UndefineProperties>\r\n-        <!-- Unconditionally remove the property that was set as a marker to indicate that for this call we should remove RuntimeIdentifier -->\r\n-        <UndefineProperties Condition=\"!$(_ProjectReferenceTargetFrameworkProperties.Contains(`ProjectIsRidAgnostic=true`))\">%(_MSBuildProjectReferenceExistent.UndefineProperties);ProjectIsRidAgnostic</UndefineProperties>\r\n+      <!-- Remove any properties that the reference didn't want. -->\r\n+      <_MSBuildProjectReferenceExistent Condition=\"'@(_ProjectReferencesWithTargetFrameworkProperties)' == '%(Identity)' and '@(_ProjectReferencesWithTargetFrameworkProperties->'%(UndefineProperties)')' != ''\">\r\n+        <UndefineProperties>@(_MSBuildProjectReferenceExistent->'%(UndefineProperties)');@(_ProjectReferencesWithTargetFrameworkProperties->'%(UndefineProperties)')</UndefineProperties>\r\n       </_MSBuildProjectReferenceExistent>\r\n     </ItemGroup>\r\n-\r\n-    <PropertyGroup>\r\n-      <_ProjectReferenceTargetFrameworkProperties />\r\n-    </PropertyGroup>\r\n   </Target>\r\n \r\n   <!--\r\n     ============================================================\r\n-                                    GetTargetFrameworkProperties\r\n+                                    GetDesiredProperties\r\n \r\n     Overrridden by cross-targeting projects to return the set of\r\n-    properties (in the form \"key1=value1;...keyN=valueN\") needed\r\n-    to build it with the best target for the referring project's\r\n-    target framework.\r\n+    properties (in the metadatum SetDesiredProperties` in the\r\n+    form \"key1=value1;...keyN=valueN\") needed to build against\r\n+    the target framework that best matches the referring\r\n+    project's target framework.\r\n+\r\n+    The referring project's $(TargetFrameworkMoniker) is passed\r\n+    in as $(ReferringTargetFramework).\r\n+  -->\r\n+  <Target Name=\"GetDesiredProperties\" />\r\n+\r\n+  <!--\r\n+    ============================================================\r\n+                                        ShouldQueryForProperties\r\n+\r\n+    Overrridden by cross-targeting projects to return an item\r\n+    with QueryForProperties metadata that is a boolean set to\r\n+    \"true\" if the project should have its GetDesiredProperties\r\n+    target called with a ReferringTargetFramework.\r\n \r\n-    The referring project's $(TargetFrameworkMoniker) is passed \r\n-    in as $(ReferringTargetFramework)\r\n+    If the returned QueryForProperties is false, the project\r\n+    will be built with the returned UndefineProperties metadata\r\n+    removed from its global properties.\r\n   -->\r\n-  <Target Name=\"GetTargetFrameworkProperties\" />\r\n+  <Target Name=\"ShouldQueryForProperties\" />\r\n \r\n   <!--\r\n     ============================================================\r\n@@ -1626,8 +1663,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n \r\n         [OUT]\r\n         @(ProjectReferenceWithConfiguration)   - Project references with apporpriate metadata\r\n-        @(_MSBuildProjectReferenceExistent)    - Subset of @(ProjectReferenceWithConfiguration) that exist \r\n-                                                 with added SetTargetFramework metadata for cross-targeting\r\n+        @(_MSBuildProjectReferenceExistent)    - Subset of @(ProjectReferenceWithConfiguration) that exist\r\n+                                                 with added SetDesiredProperties metadata for cross-targeting\r\n         @(_MSBuildProjectReferenceNonExistent) - Subset of  @(ProjectReferenceWithConfiguration) that do not exist\r\n     ============================================================\r\n   -->\r\n@@ -1682,7 +1719,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"GetTargetPath\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' != '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''\"\r\n         ContinueOnError=\"!$(BuildingProject)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -1709,7 +1746,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"%(_MSBuildProjectReferenceExistent.Targets);GetTargetPath\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' == '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''\"\r\n         ContinueOnError=\"!$(BuildingProject)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -1726,7 +1763,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"%(_MSBuildProjectReferenceExistent.Targets)\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform);  %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform);  %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''\"\r\n         ContinueOnError=\"$(ContinueOnError)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -1743,7 +1780,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"GetNativeManifest\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingProject)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''\"\r\n         ContinueOnError=\"$(ContinueOnError)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -2318,7 +2355,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n   <Target Name=\"GetReferenceTargetPlatformMonikers\" DependsOnTargets=\"PrepareProjectReferences\">\r\n     <MSBuild\r\n       Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n-      Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+      Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n       Targets=\"GetTargetPathWithTargetPlatformMoniker\"\r\n       BuildInParallel=\"$(BuildInParallel)\"\r\n       ContinueOnError=\"!$(BuildingProject)\"\r\n@@ -4301,7 +4338,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"GetCopyToOutputDirectoryItems\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         Condition=\"'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false' and '$(UseCommonOutputDirectory)' != 'true'\"\r\n         ContinueOnError=\"$(ContinueOnError)\"\r\n         RemoveProperties=\"%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)\">\r\n@@ -4864,7 +4901,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n     <MSBuild\r\n         Projects=\"@(_MSBuildProjectReferenceExistent)\"\r\n         Targets=\"Clean\"\r\n-        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)\"\r\n+        Properties=\"%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetDesiredProperties)\"\r\n         BuildInParallel=\"$(BuildInParallel)\"\r\n         Condition=\"'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''\"\r\n         ContinueOnError=\"$(ContinueOnError)\"\r\ndiff --git a/MSBuild/15.0/Microsoft.Common.props b/MSBuild/15.0/Microsoft.Common.props\r\nindex b04ff5b..defd522 100644\r\n--- a/MSBuild/15.0/Microsoft.Common.props\r\n+++ b/MSBuild/15.0/Microsoft.Common.props\r\n@@ -147,6 +147,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\r\n     <WMSJSProjectDirectory Condition=\"'$(WMSJSProjectDirectory)' == ''\">JavaScript</WMSJSProjectDirectory>\r\n   </PropertyGroup>\r\n \r\n+  <PropertyGroup>\r\n+    <PropertiesToRemoveWhenQueryingForDesiredProperties Condition=\"'$(PropertiesToRemoveWhenQueryingForDesiredProperties)' == ''\">TargetFramework;RuntimeIdentifier</PropertiesToRemoveWhenQueryingForDesiredProperties>\r\n+  </PropertyGroup>\r\n+\r\n   <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.VisualStudioVersion.v*.Common.props\" Condition=\"'$(VisualStudioVersion)' == ''\" />\r\n \r\n   <!-- \r\ndiff --git a/MSBuild/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets b/MSBuild/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\r\nindex 1cdc34e..fad922e 100644\r\n--- a/MSBuild/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\r\n+++ b/MSBuild/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.Common.targets\r\n@@ -28,54 +28,127 @@ Copyright (c) .NET Foundation. All rights reserved.\r\n     <DefaultImplicitPackages>Microsoft.NETCore.App;NETStandard.Library</DefaultImplicitPackages>\r\n   </PropertyGroup>\r\n \r\n+  <!--\r\n+     Some versions of Microsoft.NET.Test.Sdk.targets change the OutputType after we've set _IsExecutable and\r\n+     HasRuntimeOutput default in Microsfot.NET.Sdk.BeforeCommon.targets. Refresh these value here for backwards\r\n+     compatibilty with that.\r\n+   -->\r\n+  <PropertyGroup>\r\n+    <_IsExecutable Condition=\"'$(OutputType)' == 'Exe' or '$(OutputType)'=='WinExe'\">true</_IsExecutable>\r\n+    <HasRuntimeOutput Condition=\"'$(_UsingDefaultForHasRuntimeOutput)' == 'true'\">$(_IsExecutable)</HasRuntimeOutput>\r\n+  </PropertyGroup>\r\n+\r\n+  <PropertyGroup Condition=\"'$(DotnetCliToolTargetFramework)' == '' And '$(BundledNETCoreAppTargetFrameworkVersion)' != ''\">\r\n+    <!-- Set the TFM used to restore .NET CLI tools to match the version of .NET Core bundled in the CLI -->\r\n+    <DotnetCliToolTargetFramework>netcoreapp$(BundledNETCoreAppTargetFrameworkVersion)</DotnetCliToolTargetFramework>\r\n+  </PropertyGroup>\r\n \r\n   <UsingTask TaskName=\"GetNearestTargetFramework\" AssemblyFile=\"$(MicrosoftNETBuildTasksAssembly)\" />\r\n   <UsingTask TaskName=\"NETSdkError\" AssemblyFile=\"$(MicrosoftNETBuildTasksAssembly)\" />\r\n-  \r\n+\r\n+  <!--\r\n+    ============================================================\r\n+                                        ShouldQueryForProperties\r\n+\r\n+    Indicate whether this project cross-targets, so before\r\n+    building it, a referring project must call\r\n+    GetDesiredProperties to get the matching TargetFramework to\r\n+    specify.\r\n+\r\n+    If this project only has a single TF and a single RID,\r\n+    return UndefineProperties to allow the referring project\r\n+    to build it directly without a subsequent query.\r\n+  -->\r\n+  <Target Name=\"ShouldQueryForProperties\"\r\n+          Returns=\"@(_ShouldQueryForPropertiesResult)\">\r\n+    <PropertyGroup>\r\n+      <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\r\n+      <_IsRidAgnostic>false</_IsRidAgnostic>\r\n+      <_IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</_IsRidAgnostic>\r\n+\r\n+      <_DesiredRemovedProperties Condition=\"'$(_IsRidAgnostic)' == 'true'\">$(_DesiredRemovedProperties);RuntimeIdentifier</_DesiredRemovedProperties>\r\n+\r\n+      <!-- A project can only have more than one output if the current global properties are such that the current build is a cross-targeting one. -->\r\n+      <_HasSingleTargetFramework Condition=\"'$(IsCrossTargetingBuild)' != 'true'\">true</_HasSingleTargetFramework>\r\n+      <_HasSingleTargetFramework Condition=\"'$(_HasSingleTargetFramework)' == ''\">false</_HasSingleTargetFramework>\r\n+\r\n+      <_DesiredRemovedProperties Condition=\"'$(_HasSingleTargetFramework)' == 'true'\">$(_DesiredRemovedProperties);TargetFramework</_DesiredRemovedProperties>\r\n+\r\n+      <_ReferringProjectShouldCallGetDesiredProperties>true</_ReferringProjectShouldCallGetDesiredProperties>\r\n+      <_ReferringProjectShouldCallGetDesiredProperties Condition=\"$(_HasSingleTargetFramework) and $(_IsRidAgnostic)\">false</_ReferringProjectShouldCallGetDesiredProperties>\r\n+    </PropertyGroup>\r\n+\r\n+    <ItemGroup>\r\n+      <_ShouldQueryForPropertiesResult Include=\"$(MSBuildProjectFullPath)\">\r\n+        <QueryForProperties>$(_ReferringProjectShouldCallGetDesiredProperties)</QueryForProperties>\r\n+        <UndefineProperties Condition=\"'$(_ReferringProjectShouldCallGetDesiredProperties)' == 'false'\">$(_DesiredRemovedProperties)</UndefineProperties>\r\n+      </_ShouldQueryForPropertiesResult>\r\n+    </ItemGroup>\r\n+  </Target>\r\n+\r\n   <!--\r\n   ============================================================\r\n-                              GetTargetFrameworkProperties\r\n+                              GetDesiredProperties\r\n \r\n-    Invoked by common targets to return the set of properties \r\n-    (in the form  \"key1=value1;...keyN=valueN\") needed to build \r\n-    against the target framework that best matches the referring\r\n-    project's target framework.\r\n+    Invoked by common targets to return the set of properties\r\n+    (in the metadatum SetDesiredProperties` in the form\r\n+    \"key1=value1;...keyN=valueN\") needed to build against the\r\n+    target framework that best matches the referring project's\r\n+    target framework.\r\n \r\n-    The referring project's $(TargetFrameworkMoniker) is passed \r\n+    The referring project's $(TargetFrameworkMoniker) is passed\r\n     in as $(ReferringTargetFramework).\r\n-\r\n-    This is in the common targets so that it will apply to both\r\n-    cross-targeted and single-targeted projects.  It is run\r\n-    for single-targeted projects so that an error will be\r\n-    generated if the referenced project is not compatible\r\n-    with the referencing project's target framework.\r\n   ============================================================\r\n    -->\r\n-  <Target Name=\"GetTargetFrameworkProperties\" Returns=\"TargetFramework=$(NearestTargetFramework);ProjectHasSingleTargetFramework=$(_HasSingleTargetFramework);ProjectIsRidAgnostic=$(_IsRidAgnostic)\">\r\n+  <Target Name=\"GetDesiredProperties\"\r\n+          DependsOnTargets=\"ShouldQueryForProperties\"\r\n+          Returns=\"@(_ProjectBuildInstructions)\">\r\n \r\n     <PropertyGroup>\r\n-      <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->\r\n-      <_IsRidAgnostic>false</_IsRidAgnostic>\r\n-      <_IsRidAgnostic Condition=\" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' \">true</_IsRidAgnostic>\r\n-\r\n       <!-- If a ReferringTargetFramework was not specified, and we only have one TargetFramework, then don't try to check compatibility -->\r\n       <_SkipNearestTargetFrameworkResolution Condition=\"'$(TargetFramework)' != '' and '$(ReferringTargetFramework)' == ''\">true</_SkipNearestTargetFrameworkResolution>\r\n       <NearestTargetFramework Condition=\"'$(_SkipNearestTargetFrameworkResolution)' == 'true'\">$(TargetFramework)</NearestTargetFramework>\r\n \r\n-      <!-- A project can only have more than one output if the current global properties are such that the current build is a cross-targeting one. -->\r\n-      <_HasSingleTargetFramework Condition=\"'$(IsCrossTargetingBuild)' != 'true'\">true</_HasSingleTargetFramework>\r\n-      <_HasSingleTargetFramework Condition=\"'$(_HasSingleTargetFramework)' == ''\">false</_HasSingleTargetFramework>\r\n+      <_PossibleTargetFrameworks Condition=\"'$(TargetFramework)' != ''\">$(TargetFramework)</_PossibleTargetFrameworks>\r\n+      <_PossibleTargetFrameworks Condition=\"'$(TargetFramework)' == ''\">$(TargetFrameworks)</_PossibleTargetFrameworks>\r\n+    </PropertyGroup>\r\n+\r\n+    <GetNearestTargetFramework ReferringTargetFramework=\"$(ReferringTargetFramework)\"\r\n+                               PossibleTargetFrameworks=\"$(_PossibleTargetFrameworks)\"\r\n+                               ProjectFilePath=\"$(MSBuildProjectFullPath)\"\r\n+                               Condition=\"'$(_SkipNearestTargetFrameworkResolution)' != 'true'\">\r\n+      <Output PropertyName=\"NearestTargetFramework\" TaskParameter=\"NearestTargetFramework\" />\r\n+    </GetNearestTargetFramework>\r\n+\r\n+    <ItemGroup>\r\n+      <_ProjectBuildInstructions Include=\"$(MSBuildProjectFullPath)\">\r\n+        <SetDesiredProperties>TargetFramework=$(NearestTargetFramework)</SetDesiredProperties>\r\n+        <UndefineProperties>$(_DesiredRemovedProperties)</UndefineProperties>\r\n+      </_ProjectBuildInstructions>\r\n+    </ItemGroup>\r\n+  </Target>\r\n+\r\n+  <!-- This target is a compat shim, allowing the SDK to continue to function with older common targets that haven't switched to GetDesiredProperties.\r\n+\r\n+       TODO: After the SDK has picked up an MSBuild with https://github.com/Microsoft/msbuild/pull/1866, it should be deleted. -->\r\n+  <Target Name=\"GetTargetFrameworkProperties\" Returns=\"TargetFramework=$(NearestTargetFramework);ProjectHasSingleTargetFramework=$(_HasSingleTargetFramework);ProjectIsRidAgnostic=$(_IsRidAgnostic)\"\r\n+          DependsOnTargets=\"ShouldQueryForProperties\">\r\n+\r\n+    <PropertyGroup>\r\n+      <!-- If a ReferringTargetFramework was not specified, and we only have one TargetFramework, then don't try to check compatibility -->\r\n+      <_SkipNearestTargetFrameworkResolution Condition=\"'$(TargetFramework)' != '' and '$(ReferringTargetFramework)' == ''\">true</_SkipNearestTargetFrameworkResolution>\r\n+      <NearestTargetFramework Condition=\"'$(_SkipNearestTargetFrameworkResolution)' == 'true'\">$(TargetFramework)</NearestTargetFramework>\r\n \r\n       <_PossibleTargetFrameworks Condition=\"'$(TargetFramework)' != ''\">$(TargetFramework)</_PossibleTargetFrameworks>\r\n       <_PossibleTargetFrameworks Condition=\"'$(TargetFramework)' == ''\">$(TargetFrameworks)</_PossibleTargetFrameworks>\r\n     </PropertyGroup>\r\n \r\n-    <GetNearestTargetFramework ReferringTargetFramework=\"$(ReferringTargetFramework)\" \r\n+    <GetNearestTargetFramework ReferringTargetFramework=\"$(ReferringTargetFramework)\"\r\n                                PossibleTargetFrameworks=\"$(_PossibleTargetFrameworks)\"\r\n                                ProjectFilePath=\"$(MSBuildProjectFullPath)\"\r\n                                Condition=\"'$(_SkipNearestTargetFrameworkResolution)' != 'true'\">\r\n       <Output PropertyName=\"NearestTargetFramework\" TaskParameter=\"NearestTargetFramework\" />\r\n     </GetNearestTargetFramework>\r\n   </Target>\r\n-  \r\n+\r\n </Project>\r\n```\r\n\r\n</summary>",
        "createdAt": "2017-08-04T21:13:42Z",
        "updatedAt": "2017-08-04T21:13:42Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I wrote up some detailed notes about the problem and options for solving it: https://gist.github.com/rainersigwald/fdf2be017223bf90850abf06ffa32169.\r\n\r\nI talked to @nguerrera @davkean and @terrajobst about it a while ago and settled on the \u201cQuery for TFs; Choose in Consumer\u201d approach as the option that looked the best. In particular, the improved error messages available from consumption-side TF selection are a big win.\r\n\r\nGoing down that road requires\r\n* Formalizing the multitargeted build into core MSBuild (it already is since crosstargeting.targets is in our repo and the existing ask-project-what-TF-to-build code is in common.targets).\r\n* Elevating the concept of TF compatibility to core MSBuild.\r\n* Changing the ProjectReference protocol to support the get-TFs target.\r\n\r\n### Formalizing multitargeting\r\n\r\nRight now multitargeting is defined in MSBuild (crosstargeting.targets and the existing ask-project-what-TF-to-build code is in common.targets), and in the SDK.\r\n\r\nSince any project type can reference a multitargeted project, we should just admit that it's a core MSBuild concept now. That means taking ownership of the definitions of  multitargetable dimensions (currently that's just `TargetFrameworks`).\r\n\r\nI don't think anything really has to change for this, just mindset.\r\n\r\n### Elevating TargetFramework compatibility\r\n\r\nDeciding what TF from a list is most compatible with the a given TF is currently handled by [NuGet.Frameworks](https://www.nuget.org/packages/NuGet.Frameworks/), which is an optional add-in to MSBuild. It\u2019s delivered in the SDK (that's how the current give-me-your-TF-properties code works) but isn\u2019t available in some MSBuild scenarios.\r\n\r\nIdeally, the compat matrix would be represented as data, and we could query it with a Framework method. At the moment, that doesn't appear likely to happen.\r\n\r\nI propose that we add a reference to NuGet.Frameworks from Microsoft.Build.Tasks.Core.dll, and add a new target to perform the select-best-match-for-reference-or-error functionality. This is conceptually similar to the existing [`AssignProjectConfiguration`](https://github.com/Microsoft/msbuild/blob/master/src/Tasks/AssignProjectConfiguration.cs), which considers solution configurations.\r\n\r\nI've prototyped that in https://github.com/Microsoft/msbuild/pull/2472. It does not include nice error messages yet.\r\n\r\n### Changing the ProjectReference protocol\r\n\r\nThis is tricky because it is necessarily a breaking change . . . but only for projects that manually implement the ProjectReference protocol and don't include common.targets.\r\n\r\nIf that\u2019s too breaking for a minor release of VS, we could add an an engine feature (https://github.com/Microsoft/msbuild/issues/2471) to avoid failing on ProjectReferences to projects that don't have a `GetTargetFrameworks`.\r\n\r\nI have prototyped the change to the protocol in a way that's backward-compatible (as long as you import common.targets/crosstargeting.targets) in https://github.com/Microsoft/msbuild/pull/2472.\r\n\r\n## Getting rid of double evaluation for multitargeted projects\r\n\r\nThis isn't possible in general, because with no knowlege of a project we can't know whether it multitargets or what TF to request, so we have to evaluate it in some context to figure out the right context to evaluate it in for real.\r\n\r\nBUT! The list of supported `TargetFrameworks` shouldn\u2019t change between the inner and outer builds. That means that we could\r\n\r\n1. Query the supported `TargetFrameworks` for each reference.\r\n2. Select the right one.\r\n3. Persist that information in the current project's `obj` directory.\r\n4. Resolve the reference with the right TF properties.\r\n\r\nWhen resolving P's references with a cache:\r\n1. Ask M and S what TFs they support, using the cached properties. [Evaluates `M(TF=x)` and `S()`]\r\n1. Determine the best match TF for M, and that S's only TF is fine.\r\n1. Annotate the reference for M in P with the desired target metadata.\r\n1. Get the output for the given TF from M and S. [no new evaluations]\r\n\r\nThis allows us to maintain correctness if the TFs supported by a reference change (we still ask what it supports) but save an evaluation in the (common) case that the best-match TF is the same as it was last build.",
        "createdAt": "2017-08-24T20:24:03Z",
        "updatedAt": "2017-08-24T20:24:03Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "This was merged in: https://github.com/Microsoft/msbuild/pull/2595.",
        "createdAt": "2017-10-11T21:23:32Z",
        "updatedAt": "2017-10-11T21:23:32Z",
        "author": {
          "login": "davkean"
        }
      }
    ]
  }
}