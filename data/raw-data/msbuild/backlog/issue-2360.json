{
  "number": 2360,
  "title": "UsingTask Architecture not working for custom task",
  "body": "Hello, \r\nI'm writing a custom task that needs to run as x64 (because it uses another x64 library) but if I compile it as x64 I get an error when building: \r\n\r\n     ..Sample\\Application1\\packages\\ServiceFabricSdkContrib.Service.0.0.2-beta\\build\\ServiceFabricSdkContrib.Service.targets(4,5): error MSB4062: The \"ServiceFabricSdkContrib.MsBuild.GenerateVersionHashTask\" task could not be loaded from the assembly D:\\Documents\\GitHub\\ServiceFabricSdkContrib\\Sample\\Application1\\packages\\ServiceFabricSdkContrib.Service.0.0.2-beta\\build\\ServiceFabricSdkContrib.MsBuild2.dll. Could not load file or assembly 'file:///D:\\Documents\\GitHub\\ServiceFabricSdkContrib\\Sample\\Application1\\packages\\ServiceFabricSdkContrib.Service.0.0.2-beta\\build\\ServiceFabricSdkContrib.MsBuild2.dll' or one of its dependencies. An attempt was made to load a program with an incorrect format. Confirm that the <UsingTask> declaration is correct, that the assembly and all its dependencies are available, and that the task contains a public class that implements Microsoft.Build.Framework.ITask.\r\n\r\nIf I build the task as AnyCpu it does work.\r\n\r\nI've set the Architecture and MSBuildArchitecture in the target file but that seems to have no effect, it never works if the task is built as x64 and it always works if its built as AnyCpu\r\n\r\nSpecifically this fails when using the latest vs preview witch seems to run msbuild version: 15.3.409.57025 for .NET Framework\r\n\r\nIt does work as expected using dotnet build (15.3.388.41745 for .NET Core) however there it works regardless if specify the architecture or not\r\n\r\nI've not tried with the release branch of vs but i'll do that\r\n\r\nam I doing something wrong in my target file or is this a bug?",
  "state": "CLOSED",
  "createdAt": "2017-07-28T10:29:21Z",
  "updatedAt": "2024-02-21T17:17:40Z",
  "closedAt": "2023-06-16T15:02:00Z",
  "author": {
    "login": "aL3891"
  },
  "labels": [
    "Area: Engine",
    "Area: TaskHost",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": {
    "title": "VS 17.7"
  },
  "comments": {
    "nodes": [
      {
        "body": "targetfile\r\n\r\n```\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <UsingTask TaskName=\"ServiceFabricSdkContrib.MsBuild.GenerateVersionHashTask\"  Architecture=\"x64\" AssemblyFile=\"ServiceFabricSdkContrib.MsBuild2.dll\"/>\r\n  <Target Name=\"GenerateVersionHash\" AfterTargets=\"CoreCompile\">\r\n    <GenerateVersionHashTask MSBuildArchitecture=\"x64\">\r\n    </GenerateVersionHashTask>\r\n  </Target>\r\n</Project>\r\n```\r\n\r\nThe task itself is just empty",
        "createdAt": "2017-07-28T10:37:28Z",
        "updatedAt": "2017-07-28T10:37:28Z",
        "author": {
          "login": "aL3891"
        }
      },
      {
        "body": "Investigating further, it seems like setting the Archtecture does indeed cause the task to be run in a 64bit process, however it only seems to work if the task itself is compiled as AnyCpu, if the task is compiled as x64 I get the error above.. \r\n\r\nSince it does actually run a 64bit process I can work around the issue by just compiling my main task as AnyCpu, but I do get warnings that I've got references that are x64, slightly annoying but no biggie\r\n\r\nIt does seem like this should work even if the task is also x64 though :) \r\n",
        "createdAt": "2017-07-28T11:07:40Z",
        "updatedAt": "2017-07-28T11:07:40Z",
        "author": {
          "login": "aL3891"
        }
      },
      {
        "body": "How very odd! I confirm your results, even on old MSBuild:\r\n\r\n```\r\nS:\\work\\x64task [master +1 ~2 -0 !]> C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\MSBuild.exe .\\test.proj\r\nMicrosoft (R) Build Engine version 4.7.2046.0\r\n[Microsoft .NET Framework, version 4.0.30319.42000]\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nBuild started 7/28/2017 9:34:29 AM.\r\nProject \"S:\\work\\x64task\\test.proj\" on node 1 (default targets).\r\nS:\\work\\x64task\\test.proj(6,5): error MSB4062: The \"Class1\" task could not be loaded from the assembly s:\\work\\x64task\\x64task\\bin\\Debug\\x64task.dll. Could not load fil\r\ne or assembly 'file:///s:\\work\\x64task\\x64task\\bin\\Debug\\x64task.dll' or one of its dependencies. An attempt was made to load a program with an incorrect format. Confir\r\nm that the <UsingTask> declaration is correct, that the assembly and all its dependencies are available, and that the task contains a public class that implements Micro\r\nsoft.Build.Framework.ITask.\r\nDone Building Project \"S:\\work\\x64task\\test.proj\" (default targets) -- FAILED.\r\n\r\n\r\nBuild FAILED.\r\n\r\n\"S:\\work\\x64task\\test.proj\" (default target) (1) ->\r\n(Go target) ->\r\n  S:\\work\\x64task\\test.proj(6,5): error MSB4062: The \"Class1\" task could not be loaded from the assembly s:\\work\\x64task\\x64task\\bin\\Debug\\x64task.dll. Could not load f\r\nile or assembly 'file:///s:\\work\\x64task\\x64task\\bin\\Debug\\x64task.dll' or one of its dependencies. An attempt was made to load a program with an incorrect format. Conf\r\nirm that the <UsingTask> declaration is correct, that the assembly and all its dependencies are available, and that the task contains a public class that implements Mic\r\nrosoft.Build.Framework.ITask.\r\n\r\n    0 Warning(s)\r\n    1 Error(s)\r\n\r\nTime Elapsed 00:00:00.12\r\n```\r\n\r\nIt looks like the engine always attempts to load the task assembly in the primary host process, even if it will never be executed there.\r\n\r\n<details>\r\n<summary>Callstack of the failure</summary>\r\n\r\n```\r\n 1      Microsoft.Build.dll!Microsoft.Build.BackEnd.AssemblyTaskFactory.InitializeFactory(Microsoft.Build.Shared.AssemblyLoadInfo loadInfo, string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, System.Collections.Generic.IDictionary<string, string> taskFactoryIdentityParameters, bool taskHostFactoryExplicitlyRequested, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation, string taskProjectFile)\r\n 2      Microsoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.GetTaskFactory(Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation, string taskProjectFile)\r\n*3      Microsoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation)\r\n 4      Microsoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.GetMatchingRegistration(string taskName, System.Collections.Generic.List<Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord> taskRecords, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation)\r\n 5      Microsoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.GetTaskRegistrationRecord(string taskName, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, bool exactMatchRequired, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation, out bool retrievedFromCache)\r\n 6      Microsoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.GetRegisteredTask(string taskName, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, bool exactMatchRequired, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation)\r\n 7      Microsoft.Build.dll!Microsoft.Build.BackEnd.TaskExecutionHost.FindTaskInRegistry(System.Collections.Generic.IDictionary<string, string> taskIdentityParameters)\r\n 8      Microsoft.Build.dll!Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.FindTask(System.Collections.Generic.IDictionary<string, string> taskIdentityParameters)\r\n 9      Microsoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteBucket(Microsoft.Build.BackEnd.TaskHost taskHost, Microsoft.Build.BackEnd.ItemBucket bucket, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask, System.Collections.Generic.Dictionary<string, string> lookupHash)\r\n 10     Microsoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup lookup)\r\n 11     Microsoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.Logging.TargetLoggingContext loggingContext, Microsoft.Build.BackEnd.BuildRequestEntry requestEntry, Microsoft.Build.BackEnd.ITargetBuilderCallback targetBuilderCallback, Microsoft.Build.Execution.ProjectTargetInstanceChild taskInstance, Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup inferLookup, Microsoft.Build.BackEnd.Lookup executeLookup, System.Threading.CancellationToken cancellationToken)\r\n 12     Microsoft.Build.dll!Microsoft.Build.BackEnd.TargetEntry.ProcessBucket(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup lookupForInference, Microsoft.Build.BackEnd.Lookup lookupForExecution)\r\n 13     Microsoft.Build.dll!Microsoft.Build.BackEnd.TargetEntry.ExecuteTarget(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder, Microsoft.Build.BackEnd.BuildRequestEntry requestEntry, Microsoft.Build.BackEnd.Logging.ProjectLoggingContext projectLoggingContext, System.Threading.CancellationToken cancellationToken)\r\n 14     Microsoft.Build.dll!Microsoft.Build.BackEnd.TargetBuilder.ProcessTargetStack(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder)\r\n 15     Microsoft.Build.dll!Microsoft.Build.BackEnd.TargetBuilder.BuildTargets(Microsoft.Build.BackEnd.Logging.ProjectLoggingContext loggingContext, Microsoft.Build.BackEnd.BuildRequestEntry entry, Microsoft.Build.BackEnd.IRequestBuilderCallback callback, string[] targetNames, Microsoft.Build.BackEnd.Lookup baseLookup, System.Threading.CancellationToken cancellationToken)\r\n 16     Microsoft.Build.dll!Microsoft.Build.BackEnd.RequestBuilder.BuildProject()\r\n 17     Microsoft.Build.dll!Microsoft.Build.BackEnd.RequestBuilder.BuildAndReport()\r\n 18     Microsoft.Build.dll!Microsoft.Build.BackEnd.RequestBuilder.RequestThreadProc(bool setThreadParameters)\r\n 19     Microsoft.Build.dll!Microsoft.Build.BackEnd.RequestBuilder.StartBuilderThread.AnonymousMethod__44_2()\r\n 20     mscorlib.dll!System.Threading.Tasks.Task<System.Threading.Tasks.Task>.InnerInvoke()\r\n 21     mscorlib.dll!System.Threading.Tasks.Task.Execute()\r\n 22     mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj)\r\n 23     mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\r\n 24     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\r\n 25     mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot)\r\n 26     mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution)\r\n 27     mscorlib.dll!System.Threading.Tasks.ThreadPoolTaskScheduler.LongRunningThreadWork(object obj)\r\n 28     mscorlib.dll!System.Threading.ThreadHelper.ThreadStart_Context(object state)\r\n 29     mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\r\n 30     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\r\n 31     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n 32     mscorlib.dll!System.Threading.ThreadHelper.ThreadStart(object obj)\r\n```\r\n\r\n</details>\r\n\r\n## Workaround\r\n\r\nAs you noted, you can build AnyCPU and rely on MSBuild to use the right runtime.\r\n\r\nOr you could split your task in two:\r\n\r\n* An AnyCPU `ITask` implementation that does nothing except call code from\r\n* An arch-specific implementation assembly.",
        "createdAt": "2017-07-28T15:09:46Z",
        "updatedAt": "2017-07-28T15:09:46Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I just hit this, and I think I know what's going on. MSBuild isn't truly honoring the `Architecture` attribute, in that it's *first* loading the task assembly in whatever the native msbuild.exe process is, and _then_ it decides to spawn a task host to load the assembly *again* before executing it. So if the task assembly is arch-specific, being loaded in the wrong process causes msbuild to fail. This is why AnyCPU task dlls execute in the process you requested, but still oddly fail if they are arch-specific.\r\n\r\nHere is the callstack I'm seeing with MSBuild 17.3 that's failing. It's in a 64-bit process, preparing to execute a task with `Architecture=x86` on it:\r\n\r\n```\r\n \tmscorlib.dll!System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity, System.Reflection.RuntimeAssembly reqAssembly, ref System.Threading.StackCrawlMark stackMark, System.IntPtr pPrivHostBinder, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks)\tUnknown\r\n \tmscorlib.dll!System.Reflection.RuntimeAssembly.InternalLoadFrom(string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm, bool forIntrospection, bool suppressSecurityChecks, ref System.Threading.StackCrawlMark stackMark)\tUnknown\r\n \tmscorlib.dll!System.Reflection.Assembly.UnsafeLoadFrom(string assemblyFile)\tUnknown\r\n \tMicrosoft.Build.dll!Microsoft.Build.Shared.TypeLoader.LoadAssembly(Microsoft.Build.Shared.AssemblyLoadInfo assemblyLoadInfo) Line 157\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes.ScanAssemblyForPublicTypes() Line 350\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes.GetLoadedTypeByTypeName.AnonymousMethod__0(string key) Line 322\tC#\r\n \tmscorlib.dll!System.Collections.Concurrent.ConcurrentDictionary<string, System.Type>.GetOrAdd(string key, System.Func<string, System.Type> valueFactory)\tUnknown\r\n \tMicrosoft.Build.dll!Microsoft.Build.Shared.TypeLoader.AssemblyInfoToLoadedTypes.GetLoadedTypeByTypeName(string typeName) Line 294\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.AssemblyTaskFactory.InitializeFactory(Microsoft.Build.Shared.AssemblyLoadInfo loadInfo, string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, System.Collections.Generic.IDictionary<string, string> taskFactoryIdentityParameters, bool taskHostFactoryExplicitlyRequested, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation, string taskProjectFile) Line 282\tC#\r\n>\tMicrosoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.GetTaskFactory(Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation, string taskProjectFile) Line 1531\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord.CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation) Line 1255\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.GetMatchingRegistration(string taskName, System.Collections.Generic.List<Microsoft.Build.Execution.TaskRegistry.RegisteredTaskRecord> taskRecords, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation) Line 755\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.GetTaskRegistrationRecord(string taskName, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, bool exactMatchRequired, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation, out bool retrievedFromCache) Line 555\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Execution.TaskRegistry.GetRegisteredTask(string taskName, string taskProjectFile, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters, bool exactMatchRequired, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.Construction.ElementLocation elementLocation) Line 419\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskExecutionHost.FindTaskInRegistry(System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) Line 845\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.FindTask(System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) Line 249\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteBucket(Microsoft.Build.BackEnd.TaskHost taskHost, Microsoft.Build.BackEnd.ItemBucket bucket, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask, System.Collections.Generic.Dictionary<string, string> lookupHash) Line 431\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup lookup) Line 331\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TaskBuilder.ExecuteTask(Microsoft.Build.BackEnd.Logging.TargetLoggingContext loggingContext, Microsoft.Build.BackEnd.BuildRequestEntry requestEntry, Microsoft.Build.BackEnd.ITargetBuilderCallback targetBuilderCallback, Microsoft.Build.Execution.ProjectTargetInstanceChild taskInstance, Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup inferLookup, Microsoft.Build.BackEnd.Lookup executeLookup, System.Threading.CancellationToken cancellationToken) Line 183\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TargetEntry.ProcessBucket(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder, Microsoft.Build.BackEnd.Logging.TargetLoggingContext targetLoggingContext, Microsoft.Build.BackEnd.TaskExecutionMode mode, Microsoft.Build.BackEnd.Lookup lookupForInference, Microsoft.Build.BackEnd.Lookup lookupForExecution) Line 807\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TargetEntry.ExecuteTarget(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder, Microsoft.Build.BackEnd.BuildRequestEntry requestEntry, Microsoft.Build.BackEnd.Logging.ProjectLoggingContext projectLoggingContext, System.Threading.CancellationToken cancellationToken) Line 501\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.BackEnd.TargetBuilder.ProcessTargetStack(Microsoft.Build.BackEnd.ITaskBuilder taskBuilder) Line 488\tC#\r\n```",
        "createdAt": "2022-04-29T23:37:11Z",
        "updatedAt": "2022-04-29T23:37:11Z",
        "author": {
          "login": "AArnott"
        }
      },
      {
        "body": "That's correct; we're fixing this now via its other symptom https://github.com/dotnet/msbuild/issues/6461.",
        "createdAt": "2022-04-30T02:23:46Z",
        "updatedAt": "2022-04-30T02:23:46Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "The merged PR <https://github.com/dotnet/msbuild/pull/7387> was said to fix <https://github.com/dotnet/msbuild/issues/6461>; did it fix this one too?",
        "createdAt": "2022-12-31T01:03:05Z",
        "updatedAt": "2022-12-31T01:03:05Z",
        "author": {
          "login": "KalleOlaviNiemitalo"
        }
      },
      {
        "body": "I'm sorry, I can't speak to that.  We resolved our issue at Rubberduck in another way.",
        "createdAt": "2022-12-31T02:25:54Z",
        "updatedAt": "2022-12-31T02:25:54Z",
        "author": {
          "login": "pflugs30"
        }
      },
      {
        "body": "AFAIK this is done via https://github.com/dotnet/msbuild/pull/7387",
        "createdAt": "2023-06-16T15:02:00Z",
        "updatedAt": "2023-06-16T15:02:00Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  }
}