{
  "number": 4217,
  "title": "GeneratedInternalTypeHelper.g.cs Causes Rebuild Of Solution When Opening Visual Studio But Not in MSBuild",
  "body": "Hi,\r\n\r\nI am currently investigating why we get full builds on some of our larger solution files (500+ CSPROJ).\r\n\r\nWe are currently using Visual Studio 2017 15.9.6\r\n\r\n# Goals\r\nHere is what we are trying to do:\r\n\r\n1. We want to be able to invoke MSBuild from the Command Line to build our solutions (this way we can script this to happen in the morning before a developer comes in).\r\n2. With NO changes we expect to be able to open the Solution File in Visual Studio and hit Build and have nothing build (since everything should be up to date).\r\n\r\nIn this way our Developers can be productive right when they get in instead of waiting on a build.\r\n\r\nUnfortunately as it stands today Visual Studio feels like it needs to rebuild a significant amount of the code base.\r\n\r\n# Background\r\nWe have already encountered and corrected the following issues:\r\n\r\n1. The State Files attempt to write to paths that were too long. We would constantly get `MSB3101: Could not write state file` errors. We had these as relative paths but unbeknown to us apparently MSBuild does not \"expand\" this path prior to passing it off; this actually resulted in paths that were even LONGER than we expected. We worked around that by setting our IntermediateOutputPath to be explicitly expanded by MSBuild prior to passing it off. Like so:\r\n\r\n```xml\r\n<IntermediateOutputPath>$([System.IO.Path]::GetFullPath('$(MSBuildProjectDirectory)\\..\\..\\..\\..\\..\\..\\bin\\obj\\$(ProjectGuid)'))</IntermediateOutputPath>\r\n```\r\n\r\nThis seems to have resolved that issue and we no longer encounter the warnings and incremental builds seem to work. I have not seen any issues reported for this; but I did find this StackOverflow post which led me in the right direction: https://stackoverflow.com/questions/139964/msbuild-directory-structure-limit-workarounds/9635709#9635709 Its unclear if this is a known issue, an issue that will go away once we get Long Path Support, or an issue that should be reported as a new bug.\r\n\r\n2. We then encountered Issue #1648 wherein when Visual Studio would launch it would then create the 3 Temporary generated files in the \\bin\\obj\\ folder even when we were not utilizing Workflow; this of course triggered a rebuild. We have worked around that by inserting into every single project a no-op like so:\r\n```xml\r\n  <Target Name=\"GenerateCompiledExpressionsTempFile\">\r\n    <!--This is a no-op to overwrite the existing target that ships with MSBuild. When we upgrade to Visual Studio 2019 (MSBuild 16.0) we can remove this. See https://github.com/Microsoft/msbuild/issues/1648-->\r\n  </Target>\r\n```\r\n\r\n3. We identified several locations in our code base where we had `<CopyToOutputDirectory>Always</CopyToOutputDirectory>` this seemed to trigger builds; we have converted all of these to `<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>` which again seems to have reduced the copying. This seems to have been documented in several places on the internet; one such place is https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/.\r\n\r\n\r\n# Current Roadblock (This Report)\r\nWith these changes we have been able to drive down our solution rebuilds from 900 projects down to 140 Projects; all of which are Xaml Projects or have an N-Order Dependency on a shared library which contains Xaml code.\r\n\r\nUsing the diagnostic verbosity level we can see the following from within Visual Studio:\r\n\r\n```text\r\nProject 'CU.TestClient.Core' is not up to date. Input file 's:\\timssvn\\6x\\trunk\\bin\\obj\\{5b44a2e5-81f9-4d9d-9857-006b76d62f8c}\\generatedinternaltypehelper.g.cs' is modified after output file ''.\r\n```\r\n\r\nWhen we build via the Command Line in MSBuild in MSBuild we see that the file is indeed created; however the file is empty. When we run this build in diagnostic verbosity we see the following:\r\n\r\n```\r\nInternalTypeHelper class is not required for this project, make file 'S:\\TimsSVN\\6x\\Trunk\\bin\\obj\\{5B44A2E5-81F9-4D9D-9857-006B76D62F8C}\\GeneratedInternalTypeHelper.g.cs' empty.\r\n```\r\n\r\nThis traces back to this section of logic in MarkupCompilePass2.cs: https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass2.cs,684\r\n\r\n```csharp\r\n//\r\n// If no any xaml file with local-types wants to reference an internal type from\r\n// current assembly and friend assembly, and InternalTypeHelperFile is set in the\r\n// cache file, now it is the time to remove the content of InternalTypeHelper File.\r\n//\r\n// We still keep the empty file to make other parts of the build system happy.\r\n//\r\nif (!String.IsNullOrEmpty(_internalTypeHelperFile) && !compilerWrapper.HasInternals)\r\n{\r\n    if (TaskFileService.Exists(_internalTypeHelperFile))\r\n    {\r\n        // Make empty content for this file.\r\n\r\n        MemoryStream memStream = new MemoryStream();\r\n\r\n        using (StreamWriter writer = new StreamWriter(memStream, new UTF8Encoding(false)))\r\n        {\r\n            writer.WriteLine(String.Empty);\r\n            writer.Flush();\r\n            TaskFileService.WriteFile(memStream.ToArray(), _internalTypeHelperFile);\r\n        }\r\n\r\n        Log.LogMessageFromResources(MessageImportance.Low, SRID.InternalTypeHelperNotRequired, _internalTypeHelperFile);\r\n    }\r\n}\r\n```\r\n\r\nTherefore the file is indeed empty. HOWEVER when the solution is loaded up in Visual Studio (**on launch; not even hitting Build or in any way interacting with the IDE beyond opening**) we see:\r\n\r\n* generatedinternaltypehelper.g.cs get deleted\r\n* generatedinternaltypehelper.g.i.cs get created with content\r\n* generatedinternaltypehelper.g.cs get recreated with the same content as the i.cs\r\n\r\nThe Code within these files is:\r\n\r\n```csharp\r\n//------------------------------------------------------------------------------\r\n// <auto-generated>\r\n//     This code was generated by a tool.\r\n//     Runtime Version:4.0.30319.42000\r\n//\r\n//     Changes to this file may cause incorrect behavior and will be lost if\r\n//     the code is regenerated.\r\n// </auto-generated>\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace XamlGeneratedNamespace {\r\n    \r\n    \r\n    /// <summary>\r\n    /// GeneratedInternalTypeHelper\r\n    /// </summary>\r\n    [System.Diagnostics.DebuggerNonUserCodeAttribute()]\r\n    [System.CodeDom.Compiler.GeneratedCodeAttribute(\"PresentationBuildTasks\", \"4.0.0.0\")]\r\n    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]\r\n    public sealed class GeneratedInternalTypeHelper : System.Windows.Markup.InternalTypeHelper {\r\n        \r\n        /// <summary>\r\n        /// CreateInstance\r\n        /// </summary>\r\n        protected override object CreateInstance(System.Type type, System.Globalization.CultureInfo culture) {\r\n            return System.Activator.CreateInstance(type, ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic) \r\n                            | (System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.CreateInstance)), null, null, culture);\r\n        }\r\n        \r\n        /// <summary>\r\n        /// GetPropertyValue\r\n        /// </summary>\r\n        protected override object GetPropertyValue(System.Reflection.PropertyInfo propertyInfo, object target, System.Globalization.CultureInfo culture) {\r\n            return propertyInfo.GetValue(target, System.Reflection.BindingFlags.Default, null, null, culture);\r\n        }\r\n        \r\n        /// <summary>\r\n        /// SetPropertyValue\r\n        /// </summary>\r\n        protected override void SetPropertyValue(System.Reflection.PropertyInfo propertyInfo, object target, object value, System.Globalization.CultureInfo culture) {\r\n            propertyInfo.SetValue(target, value, System.Reflection.BindingFlags.Default, null, null, culture);\r\n        }\r\n        \r\n        /// <summary>\r\n        /// CreateDelegate\r\n        /// </summary>\r\n        protected override System.Delegate CreateDelegate(System.Type delegateType, object target, string handler) {\r\n            return ((System.Delegate)(target.GetType().InvokeMember(\"_CreateDelegate\", (System.Reflection.BindingFlags.InvokeMethod \r\n                            | (System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)), null, target, new object[] {\r\n                        delegateType,\r\n                        handler}, null)));\r\n        }\r\n        \r\n        /// <summary>\r\n        /// AddEventHandler\r\n        /// </summary>\r\n        protected override void AddEventHandler(System.Reflection.EventInfo eventInfo, object target, System.Delegate handler) {\r\n            eventInfo.AddEventHandler(target, handler);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nReading the source to MarkupCompilePass2 it appears that the g.i.cs file is generated for use by Intellisense and is not put into play with the build (as is expected) but for some reason Visual Studio felt that it needed to regenerate the g.cs file.\r\n\r\nThis is where I am stuck; I am not smart enough to understand the scenarios in which the MarkupCompilePass2 will require itself to build the g.cs file. I have tried to narrow down if it is a project or solution file causing the issue (to try and get a smaller repo) but I have been unsuccessful.\r\n\r\nWhen I have attempted to reduce it down to just this project I am unable to get the same behavior; with smaller solutions I will often get this behavior:\r\n\r\n* generatedinternaltypehelper.g.cs is left alone (still blank)\r\n* generatedinternaltypehelper.g.i.cs is created **with the content listed above**\r\n\r\nIn this cases the incremental build obviously works because g.cs was not touched.\r\n\r\nCan anyone provide pointers as to where I can go to continue to debug this? I am currently stuck and unsure how to debug further.\r\n\r\n# Questions\r\n* What in the Visual Studio Startup Process is muxing the generatedinternaltypehelper files?\r\n* How can I debug that above process?\r\n\r\n\r\nI am dedicated to identifying this issue and am pretty resourceful if pointed in the right direction.\r\n\r\nThank you",
  "state": "OPEN",
  "createdAt": "2019-03-07T17:25:20Z",
  "updatedAt": "2025-06-02T08:26:42Z",
  "closedAt": null,
  "author": {
    "login": "aolszowka"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Tasks",
    "triaged"
  ],
  "comments": {
    "nodes": [
      {
        "body": "I've forwarded this internally to a couple of folks I hope can help.\r\n\r\n> * What in the Visual Studio Startup Process is muxing the generatedinternaltypehelper files?\r\n\r\nThat's a Design-Time build, which uses MSBuild but can set various properties, call different targets, and set \"host objects\" that cause tasks to behave differently.\r\n\r\n> * How can I debug that above process?\r\n\r\nThere's a document on [debugging design-time builds](https://github.com/dotnet/project-system/blob/master/docs/design-time-builds.md#diagnosing-design-time-builds) in the dotnet/project-system repo. For these projects, I think you'll want to use the TRACEDESIGNTIME option, rather than the newer options.",
        "createdAt": "2019-03-07T22:19:25Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald this log is very useful (using the TRACEDESIGNTIME option); however it appears that it is being invoked in Parallel; is it possible to have this invoked in sequence? Also is there a way to control the verbosity? I see it mentioned for the other options that it is respected from that dialog (and honestly it looks like it might be? but at very least the number of processors is not). I do not see the `Project '{EXT}' is not up to date` messages in this log; but searching though I do see CoreCompile get called several times with and output directory that would modify the remaining projects I believe.\r\n\r\nIs there something I am missing?",
        "createdAt": "2019-03-08T18:39:04Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "I expected it to follow the `Tools -> Options -> Build and Run -> maximum number of parallel builds` setting, but it sounds like you've tried that and it's not working. Maybe try running VS under `start /AFFINITY` restricted to one processor?\r\n\r\n> I do not see the `Project '{EXT}' is not up to date` messages in this log\r\n\r\nYes, this hooks up an MSBuild logger to the MSBuild invocations, but those messages are generated by the project system's \"Fast up-to-date check\" which is outside MSBuild and thus doesn't get logged to the same place (it should still be in the build output window).",
        "createdAt": "2019-03-08T18:58:49Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald that did not seem to work either (neither the AFFINITY nor Maximum number of parallel builds).\r\n\r\nI have been able to make progress though; I am able to get it to reproduce using a smaller project (but still ~400 projects). Using the MSBuild Structured Log Viewer I can tell that DesignTimeMarkupCompilation is getting ran on launch:\r\n\r\n![image](https://user-images.githubusercontent.com/2592881/54061375-c7e7ea80-41bd-11e9-8395-a02358473cf4.png)\r\n\r\nI think there is something slightly wrong in the logic for MarkupCompilePass1.cs; it would be extremely helpful if I could debug into this code and evalute its Execute Method (https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs,108)\r\n\r\nIs there a way I can hook into this and step through?\r\n",
        "createdAt": "2019-03-08T23:20:26Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "I have made further progress for anyone following along at home.\r\n\r\n- I have setup dotPeek's Symbol Server (https://www.jetbrains.com/help/decompiler/Using_product_as_a_Symbol_Server.html) to allow me to debug the reflected code\r\n- I have installed the Microsoft Child Process Debugging Power Tool (https://marketplace.visualstudio.com/items?itemName=vsdbgplat.MicrosoftChildProcessDebuggingPowerTool) this is required because this is actually being ran in the MSBuild child processes outside of DevEnv\r\n\r\nI feel there has to be an easier way to debug this because this is extremely complex; however I am starting to dig into this.\r\n\r\nI am getting burned by devenv throwing a \"Stack cookie instrumentation code detected a stack-based buffer overrun.\" we usually see these when bad things are about to happen. However due to the fact that I am debugging I am leery to waste engineering effort chasing ghosts. I do have a dump I am willing to share (we're setup to capture dumps via ProcDump) if someone cares enough to have me track on this. Here's a Gist with the stack trace: https://gist.github.com/aolszowka/5331073234dc13fe4374272a74b4f54b",
        "createdAt": "2019-03-11T13:55:42Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "## Progress\r\nIn Visual Studio on launch in the Design Time Build MarkupCompilePass1 is called. Within it AnalyzeInputsAndSettings() is invoked (https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs,1103) in this method _referencesCache is recalculated using CompilerState.GenerateCacheForFileList(ITaskItem[]) (https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/MS/Internal/Tasks/CompilerState.cs,211) this is where the first divergence occurs.\r\n\r\nThis is important because this information is calculated and compared to the cache file within the same AnalyzeInputsAndSettings() method by calling the IncrementialCompilerAnalyzer.AnalyzerInputFiles() https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/MS/Internal/Tasks/IncrementalCompileAnalyzer.cs,102\r\n\r\nHere is the code in question:\r\n\r\n```csharp\r\n        //\r\n        // Generate cache string for item lists such as PageMarkup, References, \r\n        // ContentFiles and CodeFiles etc.\r\n        //\r\n        internal static string GenerateCacheForFileList(ITaskItem[] fileItemList)\r\n        {\r\n            string cacheString = String.Empty;\r\n \r\n            if (fileItemList != null && fileItemList.Length > 0)\r\n            {\r\n                int iHashCode = 0;\r\n \r\n                int iCount = fileItemList.Length;\r\n \r\n                for (int i = 0; i < iCount; i++)\r\n                {\r\n                    iHashCode += fileItemList[i].ItemSpec.GetHashCode();\r\n                }\r\n \r\n                StringBuilder sb = new StringBuilder();\r\n \r\n                sb.Append(iCount);\r\n                sb.Append(iHashCode);\r\n \r\n                cacheString = sb.ToString();\r\n            }\r\n \r\n \r\n            return cacheString;\r\n \r\n        }\r\n```\r\n\r\nA quick reading of the code shows that you will overflow that int very quickly when suming the HashCodes; however because we are in an unchecked context this will simply truncate.\r\n\r\nIn MSBuild the result of this call (for our project inputs) is: `18275237762`\r\nIn Visual Studio the result of this call (for our project inputs) is: `181871276592`\r\n\r\nSo we know that at least MSBuild and Visual Studio are getting the same number of files (18; as this is the first part of the cache string) however they are generating different HashCodes for the Input Items.\r\n\r\nUnfortunately I am unable to see what ItemSpec is as this is optimized:\r\n\r\n![image](https://user-images.githubusercontent.com/2592881/54230017-24534e80-44cb-11e9-82c5-e77d2fce2656.png)\r\n\r\nI am at least able to see what the FIRST hash is reliably (since it is assigned to iHashCode which is available to me). It appears that the Visual Studio version is simply taking the Hash of the file path; however MSBuild gets a completely different Hash.\r\n\r\n| File                                                                         | VS ItemSpec.GetHashCode() | MSB ItemSpec.GetHashCode() |\r\n|------------------------------------------------------------------------------|---------------------------|----------------------------|\r\n| S:\\TimsSVN\\6x\\Trunk\\Bin\\Client\\ComputersUnlimited.Fusion.PlatformProxies.dll | 450276713                 | -1712272455                |\r\n\r\n## Question\r\nIs there any other way to get the HashCode of this ItemSpec item from within MSBuild? It will help point out why Visual Studio's DesignTime Compile and MSBuild's compile differ.",
        "createdAt": "2019-03-12T19:49:07Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "So the Hashcode Mismatches are a BUST.\r\n\r\nItemSpec is indeed a string; the difference in GetHashCode() was because in running from the command line we use MSBuild64 in order to address more than 4gb of RAM per MSBuild Process. While the result is consistent from run to run on the same platform; changing platforms has no such guarantee https://stackoverflow.com/questions/4466132/string-gethashcode-returns-different-values this is a good lesson to remember when implementing a hashing mechanism to remember not to rely on implementation details for your own caching logic.\r\n\r\nGetting past that we still end up building but for a different reason; this time it is a difference in the source code files https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs,1109\r\n\r\nWhen ran via MSBuild this list (for our inputs) produces 75 items; however when ran via Visual Studio this list produces 76 items.\r\n\r\nThe difference in Visual Studio is that this item is getting added:\r\n\r\n```C:\\Users\\aceo\\AppData\\Local\\Temp\\2\\.NETFramework,Version=v4.7.2.AssemblyAttributes.cs```\r\n\r\nI am continuing to track.\r\n",
        "createdAt": "2019-03-13T13:21:07Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "The AssemblyAttributes.cs is being generated here https://github.com/Microsoft/msbuild/blob/a972ec96c3920705e4e8d03d7ac8b6c3328450bd/src/Tasks/Microsoft.Common.CurrentVersion.targets#L3321-L3326\r\n\r\nWhen this project is built via MSBuild the call to MarkupCompilePass1 happens long before `GenerateTargetFrameworkMonikerAttribute` is called:\r\n\r\n![image](https://user-images.githubusercontent.com/2592881/54286649-d3defe00-4569-11e9-84d5-6eb41635f080.png)\r\n\r\nWhen this project is invoked in Visual Studio the GenerateTargetFrameworkMonikerAttribute is invoked which adds this file to the list of items to compile. Because this list no longer matches with the cache created by MarkupCompilePass1 within MSBuild a rebuild occurs.\r\n\r\n![image](https://user-images.githubusercontent.com/2592881/54287035-8d3dd380-456a-11e9-8e48-a5295c70488e.png)\r\n\r\n@rainersigwald Who should own this? Is this MSBuild or is this Roslyn?\r\n\r\nI am trying to find a way around this short of modifying the Microsoft.Common.CurrentVersion.targets for all our developers.",
        "createdAt": "2019-03-13T14:32:04Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "For anyone following along at home; this work around works; but is required to be inserted into all WPF Projects:\r\n\r\n```xml\r\n  <PropertyGroup>\r\n    <!--This is a hack to try and fix https://github.com/Microsoft/msbuild/issues/4217-->\r\n    <MarkupCompilePass1DependsOn>$(MarkupCompilePass1DependsOn);GenerateTargetFrameworkMonikerAttribute</MarkupCompilePass1DependsOn>\r\n  </PropertyGroup>\r\n```",
        "createdAt": "2019-03-14T13:41:40Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "Kudos for that investigation @aolszowka!",
        "createdAt": "2019-03-27T04:42:40Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "I am investigating incremental builds of WPF projects and hitting this issue too. In my case the `GeneratedInternalTypeHelper.g.cs` is sometimes cleared by MarkupCompilePass2:\r\n`InternalTypeHelper class is not required for this project, make file 'C:\\XXX\\obj\\Debug\\YYY\\net472\\GeneratedInternalTypeHelper.g.cs' empty.`\r\n\r\nAnd sometimes it isn't cleared and has contents (when coming from MarkupCompilePass1).\r\n\r\nTo me the logic that clears the file is a bug - we should be always generating the type even if it isn't used, to avoid flip-flopping and breaking incrementality. I still don't understand why it decides that the file is not needed sometimes, but not always.\r\n\r\n@aolszowka amazing and deep investigation, great job! To debug tasks in the MSBuild Structured Log Viewer, right-click a task (such as MarkupCompilePass1) and click Debug. It will start a TaskRunner.exe process and run the task inside that process with the same arguments from the binlog. It will display the JIT Debugger dialog to give you a chance to attach before the task runs.\r\n\r\n@vatsan-madhavan as people are tuning their builds and WPF is resurging in popularity, it would be nice to get to the bottom of this at some point. Who would be the best person most knowledgeable about MarkupCompilePass1 and 2?",
        "createdAt": "2019-12-05T15:25:54Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@aolszowka also set the `COMPLUS_ZapDisable=1` environment variable before you debug, to disable optimizations. Note that you need to start the debuggee under debugger and with this variable set, attaching to a running process that wasn't started under debugger won't disable the optimizations.",
        "createdAt": "2019-12-05T15:28:40Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov Thank you for the tips, and thank you for MSBuild Structured Log Viewer, that tool is invaluable to us. We've noticed that on our larger builds (~3500 projects) the tooling seems to choke (launching is difficult, filtering just about impossible), but I have not taken the time to get a good bug report written up yet. Keep up the good work!\r\n\r\nMake sure you're not getting burned by the other WPF bugs I reported as well; this is our current work arounds:\r\n\r\n```xml\r\n  <Target Name=\"GenerateCompiledExpressionsTempFile\">\r\n    <!--This is a no-op to overwrite the existing target that ships with MSBuild. When we upgrade to Visual Studio 2019 (MSBuild 16.0) we can remove this. See https://github.com/Microsoft/msbuild/issues/1648-->\r\n  </Target>\r\n  <PropertyGroup>\r\n    <!--This is a hack to try and fix https://github.com/Microsoft/msbuild/issues/4217-->\r\n    <MarkupCompilePass1DependsOn>$(MarkupCompilePass1DependsOn);GenerateTargetFrameworkMonikerAttribute</MarkupCompilePass1DependsOn>\r\n  </PropertyGroup>\r\n```\r\n\r\nI believe I have the minimal test case here https://github.com/microsoft/msbuild/issues/4228 that was closed in lieu of a VS Feedback issue that has received zero visible traction; we are still willing to assist as required.",
        "createdAt": "2019-12-05T15:44:02Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "Cool, I've filed https://github.com/dotnet/wpf/issues/2281 and also asked Livar to reactivate the other bug where you have the repro.\r\n\r\nAlso for incrementality, have you played with `ProduceReferenceAssembly` property? Setting it to true will generate a reference assembly into `bin\\Debug\\ref` for each project, and other projects would reference the binary from the ref folder. This is super useful when you just change a method body or fix whitespace or make any other edit that doesn't change the public API of the assembly. For such non-invasive edits the dependent projects will not rebuild.\r\n\r\nThe bug we're having here breaks that, since it keeps adding and removing the `GeneratedInternalTypeHelper` type to the compilation, thus invalidating the ref assemblies.\r\n\r\nBinlog viewer does unfortunately have scaling issues and they are not easy to address. MSBuild just logs too much. There are bugs that we could fix to alleviate the problem, such as https://github.com/microsoft/msbuild/issues/4956. Or I could invest in some sophisticated indexing algorithms to speed up search and filtering. Unfortunately I doubt we can do anything about the initial speed of reading a large binlog - there's just too much data there, and I can't see a way to make some of it lazy/on-demand/deferred.",
        "createdAt": "2019-12-05T16:06:00Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  }
}