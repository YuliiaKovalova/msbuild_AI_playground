{
  "number": 5169,
  "title": "Unzip Task: Enable filtering",
  "body": "### Desired functionality\r\n\r\nProject file\r\n```xml\r\n<Project>\r\n  <Target Name=\"Build\">\r\n    <Unzip SourceFiles=\"MyZipFile.zip\" DestinationFolder=\"path\\to\\unzip\\to\" IncludeEntries=\"regex/for/path/inside/zip/.*$\" ExcludeEntries=\"regex/for/path/inside/zip/exclusion/.*$\"/>\r\n  </Target>\r\n</Project>\r\n```\r\n\r\nDirectory contents:\r\n```\r\n/\r\n- MyZipFile.zip\r\n```\r\n\r\nMyZipFile.zip contents:\r\n```\r\n/\r\n- root.txt\r\n/regex/for/path/inside/zip\r\n- included.txt\r\n/regex/for/path/inside/zip/exclusion\r\n- excluded.txt\r\n```\r\n\r\n### Expected behavior\r\nThe MyZipFile.zip is unzipped to the desired location, unzipping only entries that match up with inclusion (if present) and are not excluded.\r\n\r\nIn the example root.txt is not unzipped because it's not included and excluded.txt is not unzipped because it's excluded.\r\n\r\nResulting Directory contents:\r\n```\r\n/\r\n- MyZipFile.zip\r\n/path/to/unzip/to/regex/for/path/inside/zip\r\n- included.txt\r\n```\r\n\r\n### Actual behavior\r\nNo filtering of Unzip is possible at this time.\r\n\r\n### Environment data\r\n`msbuild /version` output:\r\n16.4.0.56107\r\nOS info:\r\nWindows 10 Enterprise\r\nIf applicable, version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc):\r\n/",
  "state": "CLOSED",
  "createdAt": "2020-03-10T16:38:49Z",
  "updatedAt": "2024-02-21T17:04:44Z",
  "closedAt": "2021-02-06T21:02:43Z",
  "author": {
    "login": "IvanLieckens"
  },
  "labels": [
    "help wanted",
    "needs-design",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "Team triage: this is an interesting idea. We would potentially accept a PR that did this, but we'd like to first see a rough design about the filter mechanism, including whether it's easy to implement with the zip APIs we use, or if there's an easier one to implement.",
        "createdAt": "2020-03-16T20:56:06Z",
        "updatedAt": "2020-03-16T20:56:06Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald I'm sorry it's not a PR but what I did for now to quickly have this working for my own build is the following custom task, it only adds a few small modifications to the existing one (and some because I couldn't access the internal classes being used in some places):\r\n\r\n```c#\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Resources;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\n\r\nusing Microsoft.Build.Framework;\r\nusing Microsoft.Build.Utilities;\r\n\r\nusing Tasks.Properties;\r\n\r\nnamespace Tasks\r\n{\r\n    public class FilteredUnzip : Task, ICancelableTask\r\n    {\r\n        // We pick a value that is the largest multiple of 4096 that is still smaller than the large object heap threshold (85K).\r\n        // The CopyTo/CopyToAsync buffer is short-lived and is likely to be collected at Gen0, and it offers a significant\r\n        // improvement in Copy performance.\r\n        private const int _DefaultCopyBufferSize = 81920;\r\n\r\n        /// <summary>\r\n        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\r\n        /// </summary>\r\n        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\r\n\r\n        public FilteredUnzip()\r\n        {\r\n            Log.TaskResources = Resources.ResourceManager;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\r\n        /// </summary>\r\n        [Required]\r\n        public ITaskItem DestinationFolder { get; set; }\r\n\r\n        /// <summary>\r\n        /// Gets or sets a value indicating whether read-only files should be overwritten.\r\n        /// </summary>\r\n        public bool OverwriteReadOnlyFiles { get; set; }\r\n\r\n        /// <summary>\r\n        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\r\n        /// </summary>\r\n        public bool SkipUnchangedFiles { get; set; } = true;\r\n\r\n        /// <summary>\r\n        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\r\n        /// </summary>\r\n        [Required]\r\n        public ITaskItem[] SourceFiles { get; set; }\r\n\r\n        /// <summary>\r\n        /// Gets or sets a regular expression that will be used to include files to be unzipped.\r\n        /// </summary>\r\n        public string Include { get; set; }\r\n\r\n        /// <summary>\r\n        /// Gets or sets a regular expression that will be used to exclude files to be unzipped.\r\n        /// </summary>\r\n        public string Exclude { get; set; }\r\n\r\n        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\r\n        public void Cancel()\r\n        {\r\n            _cancellationToken.Cancel();\r\n        }\r\n\r\n        /// <inheritdoc cref=\"Task.Execute\"/>\r\n        public override bool Execute()\r\n        {\r\n            DirectoryInfo destinationDirectory;\r\n            try\r\n            {\r\n                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\r\n\r\n                return false;\r\n            }\r\n\r\n            BuildEngine3.Yield();\r\n\r\n            try\r\n            {\r\n                foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\r\n                {\r\n                    if (!File.Exists(sourceFile.ItemSpec))\r\n                    {\r\n                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\r\n                        continue;\r\n                    }\r\n\r\n                    try\r\n                    {\r\n                        using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, 0x1000, false))\r\n                        {\r\n                            using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, false))\r\n                            {\r\n                                try\r\n                                {\r\n                                    Extract(zipArchive, destinationDirectory);\r\n                                }\r\n                                catch (Exception e)\r\n                                {\r\n                                    // Unhandled exception in Extract() is a bug!\r\n                                    Log.LogErrorFromException(e, true);\r\n                                    return false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    catch (OperationCanceledException)\r\n                    {\r\n                        break;\r\n                    }\r\n                    catch (Exception e)\r\n                    {\r\n                        // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\r\n                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\r\n                    }\r\n                }\r\n            }\r\n            finally\r\n            {\r\n                BuildEngine3.Reacquire();\r\n            }\r\n\r\n            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Extracts all files to the specified directory.\r\n        /// </summary>\r\n        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\r\n        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\r\n        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\r\n        {\r\n            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\r\n            {\r\n                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\r\n\r\n                // Zip archives can have directory entries listed explicitly.\r\n                // If this entry is a directory we should create it and move to the next entry.\r\n                if (Path.GetFileName(destinationPath.FullName).Length == 0)\r\n                {\r\n                    // The entry is a directory\r\n                    Directory.CreateDirectory(destinationPath.FullName);\r\n                    continue;\r\n                }\r\n\r\n                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\r\n                {\r\n                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\r\n                    // for logging and cancellation, we need to check for it ourselves.\r\n                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\r\n                    continue;\r\n                }\r\n\r\n                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\r\n                {\r\n                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\r\n                    continue;\r\n                }\r\n\r\n                try\r\n                {\r\n                    destinationPath.Directory?.Create();\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\r\n                    continue;\r\n                }\r\n\r\n                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\r\n                {\r\n                    try\r\n                    {\r\n                        destinationPath.IsReadOnly = false;\r\n                    }\r\n                    catch (Exception e)\r\n                    {\r\n                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotMakeFileWriteable\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                try\r\n                {\r\n                    Log.LogMessageFromResources(MessageImportance.Normal, \"Unzip.FileComment\", zipArchiveEntry.FullName, destinationPath.FullName);\r\n\r\n                    using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))\r\n                    using (Stream stream = zipArchiveEntry.Open())\r\n                    {\r\n                        stream.CopyToAsync(destination, _DefaultCopyBufferSize, _cancellationToken.Token)\r\n                            .ConfigureAwait(false)\r\n                            .GetAwaiter()\r\n                            .GetResult();\r\n                    }\r\n\r\n                    destinationPath.LastWriteTimeUtc = zipArchiveEntry.LastWriteTime.UtcDateTime;\r\n                }\r\n                catch (IOException e)\r\n                {\r\n                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotExtractFile\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\r\n                }\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Determines whether or not a file should be skipped when unzipping.\r\n        /// </summary>\r\n        /// <param name=\"zipArchiveEntry\">The <see cref=\"ZipArchiveEntry\"/> object containing information about the file in the zip archive.</param>\r\n        /// <param name=\"fileInfo\">A <see cref=\"FileInfo\"/> object containing information about the destination file.</param>\r\n        /// <returns><code>true</code> if the file should be skipped, otherwise <code>false</code>.</returns>\r\n        private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)\r\n        {\r\n            bool result = SkipUnchangedFiles && fileInfo.Exists\r\n                                             && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc\r\n                                             && zipArchiveEntry.Length == fileInfo.Length;\r\n\r\n            if (!string.IsNullOrWhiteSpace(Include))\r\n            {\r\n                result |= !Regex.IsMatch(zipArchiveEntry.FullName, Include);\r\n            }\r\n\r\n            if (!string.IsNullOrWhiteSpace(Exclude))\r\n            {\r\n                result |= Regex.IsMatch(zipArchiveEntry.FullName, Exclude);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}\r\n```",
        "createdAt": "2020-03-23T20:32:56Z",
        "updatedAt": "2020-03-24T11:39:30Z",
        "author": {
          "login": "IvanLieckens"
        }
      },
      {
        "body": "There's some difference between the PR code and the code I originally posted here. By using that custom task I found some flaws in the original code found here which have been resolved in the PR. For 1 it doesn't fail with \"PathTooLong\" in case you exclude the archive entry that would cause this by moving the validation to the first position. Secondly it adds its own message making logs clearer as to why a certain file wasn't unzipped. Any and all feedback is very welcome.",
        "createdAt": "2021-01-12T09:20:03Z",
        "updatedAt": "2021-01-12T09:20:03Z",
        "author": {
          "login": "IvanLieckens"
        }
      }
    ]
  }
}