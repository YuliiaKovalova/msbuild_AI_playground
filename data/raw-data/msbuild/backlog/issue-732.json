{
  "number": 732,
  "title": "Enhance OM: Project.GetItemProvenance",
  "body": "Parent issue: #700 \n\nGoal: Track down the history of what happened to an item (did it come from a glob, where was it updated, where was it excluded, etc)\n\nDesign so far: \n- Inputs:\n  - string itemValue\n    - String that represents an item\n    - [?] Should there be any normalization done on the name (e.g. relative vs full path)\n  - string itemType\n    - Scope down the search by only looking at item tags of a certain type\n  - item\n    - The ProjectItem to get the value and type from. Also, start the search from this item's tag upwards\n- Return\n  - Project evaluation order sorted list of item tags that did something to that item (included, excluded, updated, removed)\n- Remarks\n  - GetItemProvenance(string) and GetItemProvenance(string, string) are flow insensitive, they scan the entire item list of a Project. GetItemProvenance(ProjecItem) is flow sensitive, it starts the search from the underlying ProjectItemElement upwards\n  - Globs are not exploded, but rather pattern matching is used to see if the item fits a glob. This enables calling this method for a newly added file without having to re-evaluate the project\n  - Indirect item references are ignored\n    <Compile Include=\"@(Sources);$(ItemLiteralsInsideAProperty)\">. If this contains the item \"Program.cs\", then calling GetItemProvenance(\"Program.cs\") won't return anything for this tag\n    - [?] how to deal with a ProjectItem that may come from multiple include fragments? The OM does not link ProjectItem to what portion of the include string generated it.\n  - Since an item can come from multiple sources inside an include (e.g., from glob AND literals) the Provenance enums can be aggregated (Provenance.FromGlob | Provenance.FromLiteral)\n\n```\nList<ProvenanceResult> Project.GetItemProvenance(string itemValue)\nList<ProvenanceResult> Project.GetItemProvenance(ProjectItem item)\nList<ProvenanceResult> Project.GetItemProvenance(string itemValue, string itemType)\n\nstruct ProvenanceResult\n{\n    ProjectItemElement\n    Operation\n    Provenance\n}\n\nenum Operation\n{\n    Include\n    Exclude\n    Update\n    Remove\n}\n\n[Flags]\nProvenance\n{\n    FromGlob //\"*.cs\"\n    FromLiteral //\"Program.cs\"\n    FromParametirizedLiteral //\"Program$(Extension)\"\n    //FromItem\n    //FromProperty\n    //Inconclusive\n}\n```\n\nThe indirect reference problem:\n\n```\n1.   <PropertyGroup>\n2.     <ItemsInString>*.a</ItemsInString>\n3.     <ItemsInString>1.a;2.a;3.a;$(ItemsInString)</ItemsInString>\n4.   </PropertyGroup>\n\n5.   <ItemGroup>\n6.     <Foo Include=\"*.a\" Exclude=\"3.a\"/>\n7.     <Foo Include=\"3.a\"/>\n8.     <Foo Include=\"*.a\" Exclude=\"1.a;2.a\"/>\n\n9.     <Bar Include=\"@(Foo);3.a\"/>\n\n10.     <Zar Include=\"*.a;@(Bar);3.a\"/>\n\n11.     <Tar Include=\"@(Zar)\"/>\n\n12.     <Gar Include=\"$(ItemsInString)\"/>\n    <>\n13.   </ItemGroup>\n\n\nProjectItems\n[11]    \"Foo\"=\"1.a\" [\"*.a\"] \n[12]    \"Foo\"=\"2.a\" [\"*.a\"] \n[13]    \"Foo\"=\"3.a\" [\"3.a\"] (FromLiteral)\n[14]    \"Foo\"=\"3.a\" [\"*.a\"] (FromGlob)\n[15]    \"Bar\"=\"1.a\" [\"@(Foo);3.a\"] \n[16]    \"Bar\"=\"2.a\" [\"@(Foo);3.a\"] \n[17]    \"Bar\"=\"3.a\" [\"@(Foo);3.a\"]  \n[18]    \"Bar\"=\"3.a\" [\"@(Foo);3.a\"] \n[19]    \"Bar\"=\"3.a\" [\"@(Foo);3.a\"] (Inconclusive| FromLiteral)\n[20]    \"Zar\"=\"1.a\" [\"*.a;@(Bar);3.a\"] \n[21]    \"Zar\"=\"2.a\" [\"*.a;@(Bar);3.a\"] \n[22]    \"Zar\"=\"3.a\" [\"*.a;@(Bar);3.a\"] \n[23]    \"Zar\"=\"1.a\" [\"*.a;@(Bar);3.a\"] \n[24]    \"Zar\"=\"2.a\" [\"*.a;@(Bar);3.a\"] \n[25]    \"Zar\"=\"3.a\" [\"*.a;@(Bar);3.a\"] \n[26]    \"Zar\"=\"3.a\" [\"*.a;@(Bar);3.a\"] \n[27]    \"Zar\"=\"3.a\" [\"*.a;@(Bar);3.a\"] \n[28]    \"Zar\"=\"3.a\" [\"*.a;@(Bar);3.a\"] (Inconclusive | FromLiteral)\n[29]    \"Tar\"=\"1.a\" [\"@(Zar)\"] \n[30]    \"Tar\"=\"2.a\" [\"@(Zar)\"] \n[31]    \"Tar\"=\"3.a\" [\"@(Zar)\"] \n[32]    \"Tar\"=\"1.a\" [\"@(Zar)\"] \n[33]    \"Tar\"=\"2.a\" [\"@(Zar)\"] \n[34]    \"Tar\"=\"3.a\" [\"@(Zar)\"] \n[35]    \"Tar\"=\"3.a\" [\"@(Zar)\"] \n[36]    \"Tar\"=\"3.a\" [\"@(Zar)\"] \n[37]    \"Tar\"=\"3.a\" [\"@(Zar)\"] (FromList)\n[38]    \"Gar\"=\"1.a\" [\"$(ItemsInString)\"] \n[39]    \"Gar\"=\"2.a\" [\"$(ItemsInString)\"] \n[40]    \"Gar\"=\"3.a\" [\"$(ItemsInString)\"] (FromProperty / Inconclusive?)\n[41]    \"Gar\"=\"1.a\" [\"$(ItemsInString)\"] \n[42]    \"Gar\"=\"2.a\" [\"$(ItemsInString)\"] \n[43]    \"Gar\"=\"3.a\" [\"$(ItemsInString)\"] (FromProperty / Inconclusive?)\n\n```\n\nQuestions:\n- which item tags to look at? Current project only, or all imports?\n",
  "state": "CLOSED",
  "createdAt": "2016-06-27T21:15:18Z",
  "updatedAt": "2024-02-21T17:27:30Z",
  "closedAt": "2016-08-03T01:38:42Z",
  "author": {
    "login": "cdmihai"
  },
  "labels": [
    "Feature - Globbing",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "After looking through the code, it seems like there are 2 main ways of implementing this:\n1. Inside Project, after evaluation has finished\n   - Iterate over the inorder ProjectItemElement list of the import closure and for each element peek into the raw include / exclude strings and compute provenance\n   - Changes to the Evaluator:\n     - expose the xml element lists collected during the depth first pass. The evaluator is the only place where the inorder traversal of item groups is computed. Instead of duplicating that logic and re-computing the same information inside the provenance code, it would be nice to reuse the one computed by the Evaluator\n     - extract condition evaluation code in a separate class so it could be called outside the evaluator. The provenance code will need this to filter out elements with false conditions.\n2. Inside the Evaluator, during evaluation\n   - Change ProjectItem to store information about its provenance, and compute that provenance during evaluation, as ProjectItem objects are produced from include strings\n\nDiscussed with @rainersigwald and I'll go for option 1 because:\n- GetItemProvenance is a partial implementation (only considers items coming from literals and globs directly referenced inside an include string, and ignores items coming from properties and lists) whereas the current Evaluator has the \"correct\" complete implementation (it brings indirect items). Mixing an incomplete provenance with the existing code will result in some messy, confusing code. As long as the two code paths do not overlap in intent, it's better for maintenance purposes to keep them separated.\n  - Having a partial provenance over the full item production gets even messier when we add Update and Remove.\n- Empty include strings (e.g., globs that expand to empty lists) produce no ProjectItem objects. We'd need to inject some special ProjectItems that represent an empty expansion\n",
        "createdAt": "2016-07-06T21:09:43Z",
        "updatedAt": "2016-07-06T21:13:37Z",
        "author": {
          "login": "cdmihai"
        }
      }
    ]
  }
}