{
  "number": 6911,
  "title": "Question: Shared state file to improve RAR task performance",
  "body": "This is not a performance issue rather it is a question on how to use the MS Build API to solve a performance issue I have.\r\n\r\n### Issue Description\r\nMy build has 7000~ directories in a packages folder. The total time for RAR across the projects in the build is 30 minutes.\r\nI currently inject many search paths via SearchPaths into the RAR task for compatibility reasons within my build.\r\n\r\nI desire to have a faster build so optimizing RAR felt like a good place to start. \r\nA solution I've thought about for a long time is to have a single state file for all of the projects as there is so much duplicated information that each RAR task discovers as it is a bit of a gold fish on a clean CI build.\r\n\r\nI noticed in a recent drop of MSBuild that some new RAR properties had shown up with the words \"precompute\" and \"statefile\" which sounds very exciting. \r\n\r\nA sample was constructed to have a single RAR instance walk the packages directory and hopefully crack open every single DLL in the folder and write that info the cache file which I can then provide to each project.\r\n\r\nI've _assumed_ I am able to use **AssemblyInformationCacheOutputPath** and then feed that back into **AssemblyInformationCachePaths**. \r\n\r\n```\r\npublic class PrecomputeReferenceCache : Task {\r\n\r\n        public string[] ReferencePath { get; set; }\r\n\r\n        public override bool Execute() {\r\n            System.Diagnostics.Debugger.Launch();\r\n\r\n            // 7000 items\r\n            var directories = Directory.GetDirectories(ReferencePath[0], \"*\", SearchOption.AllDirectories);\r\n\r\n            var sw = Stopwatch.StartNew();\r\n            ResolveAssemblyReference rar = new ResolveAssemblyReference() {\r\n                BuildEngine = this.BuildEngine,\r\n                SearchPaths = directories,\r\n                Assemblies = new ITaskItem[] {\r\n                    new TaskItem(\"WebGrease, Version=1.6.5135.21930, Culture=neutral, PublicKeyToken=31bf3856ad364e35\")\r\n                },\r\n                AssemblyInformationCacheOutputPath = @\"C:\\temp\\rar.cache2\",\r\n               StateFile = @\"C:\\temp\\rar.cache\",\r\n            };\r\n\r\n            rar.Execute();\r\n            sw.Stop();\r\n            var elapsed1 = sw.ElapsedMilliseconds;\r\n\r\n            sw = Stopwatch.StartNew();\r\n            ResolveAssemblyReference rar2 = new ResolveAssemblyReference()\r\n            {\r\n                BuildEngine = this.BuildEngine,\r\n                SearchPaths = directories,\r\n                Assemblies = new ITaskItem[] {\r\n                    new TaskItem(\"WebGrease, Version=1.6.5135.21930, Culture=neutral, PublicKeyToken=31bf3856ad364e35\")\r\n                },\r\n                AssemblyInformationCachePaths = new ITaskItem[]\r\n                {\r\n                    new TaskItem(@\"C:\\temp\\rar.cache2\")\r\n                },\r\n                StateFile = @\"C:\\temp\\rar.cache\"\r\n\r\n            };\r\n            rar2.Execute();\r\n            sw.Stop();\r\n            var elapsed2 = sw.ElapsedMilliseconds;\r\n\r\n            return !Log.HasLoggedErrors;\r\n        }\r\n```\r\n\r\n\r\nelapsed1: 4528 \r\nelapsed2: 5773\r\n\r\nThe second RAR instance takes longer than the first instance and still grovels into each folder in SearchPaths.\r\n\r\n![image](https://user-images.githubusercontent.com/1083622/136095202-f70f8068-4944-4bc4-9c9d-0608e71db67c.png)\r\n\r\nThe output files from the first RAR instance have some size to them\r\n![image](https://user-images.githubusercontent.com/1083622/136095018-7f1c60d7-3fb0-43ee-968b-f4cf4548e3a2.png)\r\n\r\nI was hoping that upToDateLocalFileStateCache would contain all of the metadata for each assembly so I can reuse this information for each project and avoid the repeated analysis cost.\r\n\r\n![image](https://user-images.githubusercontent.com/1083622/136095757-1523ae23-663e-4eb3-adec-62b356fdd8ad.png)\r\n\r\n\r\n**What I've learned**\r\nIt appears RAR will only store metadata for a DLL if it is present in the Assemblies list.\r\nIn my example I'm looking for WebGrease which only appears in a single folder of the 7000. \r\n\r\nIf I add 7000 unique entries to the Assemblies list will I get the behaviour I desire? \r\n\r\nIf I cannot get the precomputed state file to work I could look at removing as many SearchPaths as possible to speed up RAR.\r\n\r\n\r\n### Versions & Configurations\r\n```\r\nMicrosoft (R) Build Engine version 16.11.0+0538acc04 for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n16.11.0.36601\r\n```\r\n\r\n### Regression?\r\nNo",
  "state": "OPEN",
  "createdAt": "2021-10-05T20:22:15Z",
  "updatedAt": "2024-01-31T08:20:22Z",
  "closedAt": null,
  "author": {
    "login": "michael-baker"
  },
  "labels": [
    "Area: Performance",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": {
    "title": "Discussion"
  },
  "comments": {
    "nodes": [
      {
        "body": "Hi @michael-baker,\r\n\r\nThanks for trying this out! The precomputed cache isn't intended to fill upToDateLocalFileStateCache, as we don't actually have evidence it is up-to-date. In fact, when building your own projects, it may end up invalidating a large fraction of your cache if you create the precomputed cache then modify all your other assemblies and rebuild them.\r\n\r\nThe precomputed cache should provide an initial value for instanceLocalFileStateCache instead. I noticed from your screenshot that its count was 0, which suggests the cache isn't actually being read in at all. Since rar.cache exists, the most likely explanation is that you had created an empty rar.cache at some point with assembly information for 0 files but correctly formatted\u2014unless this is happening with the second RAR execution, in which case this isn't right. That cache takes precedence over the precomputed cache, so it would completely ignore it when the second RAR iteration came around. As a second (long shot) option, if you happened to use a different version of MSBuild to make the cache then use it, that might have prevented it from being read in properly. We changed the serialization format recently, which would have meant doing work then giving up and defaulting to an empty cache. 35kb also sounds really small; making a cache for a very simple app (what comes out of `dotnet new console`) is > 1800kb. Does WebGrease depend (directly or independently) on all of your other assemblies? It looks like it took 4.5 seconds to make the cache, whereas to do all the work before took 30 minutes; I expect that you'd have a much larger (and hopefully more useful) cache if you did add all of the assemblies to the list.\r\n\r\nWhen I was testing this while first implementing the feature, I got great numbers like improving RAR execution time by a third, but I've gotten worse results more recently with our new serialization method and format; I'm still looking into that, so I can't 100% promise this cache will be a panacea, just FYI.\r\n\r\nLast thought\u2014how many processors do you have? In addition to caching certain information by file, we cache information in processes, and that takes priority, so if most of the assemblies are duplicated between projects, that might mean that using any kind of a file cache means more time reading files and deserializing their contents but no time saved because of the process cache. We also have a longer-term initiative to make a separate RAR-as-a-Service node that would hold all this cached information without having to either deserialize anything more than once or calculate the same assembly information more than once. Even so, initially calculating the paths will still benefit from having fewer search paths, so that isn't a bad direction to go.",
        "createdAt": "2021-10-06T23:35:41Z",
        "updatedAt": "2021-10-06T23:35:41Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Thanks for the help. I'll clarify my goal and approach. \r\nI have a full build that takes hours and hours - of which 30 minutes is RAR. \r\n\r\nThe code is my playground to find a way to reduce cost of RAR by asking it to precompute a humongous state file at the start of the build that contains data for 10,000+ dependencies. \r\nI realize that there will be a deserialization cost of such a humongous state file but I'm hoping that the aggressive caching of RAR will mitigate this. \r\n\r\nMy plan is this\r\n\r\n- clone repo\r\n- get dependencies, packages etc\r\n- precompute humongous state file\r\n- pass location of  humongous state file as global property to each project\r\n- build project 1....n\r\n\r\nAll my my testing is based on the code above - just a a simple MSBuild project that calls a custom C# task with two RAR tasks inside of it. I realize this is a not the intended way that tasks should be composed but I'm trying just experimenting at the moment. \r\n\r\nThe number of processors doesn't matter as I am controlling the RAR task invocation in my custom task.\r\n\r\nThe 4.5 seconds is the cost of a single RAR instance to traverse 7000~ directories in the SearchPaths set. \r\nIf my build contains 10,000+ projects I do not need 10,000 RAR instances all discovering the same information project-by-project. \r\n\r\nThe state files in in the screenshot are from the playground code.\r\n\r\nThe first RAR instance creates the two files, which I then just feed into the second instance. I don't do any reflection or anything left field - just using the 'public' API of the RAR task as coded above. Any serialization issues, versioning etc isn't occurring as it all occurs within the same MSBuild process, instance and version.\r\n\r\nOnly a handful of my actual projects depend on WebGrease. In practice I don't care what inputs I have to feed the precompute task, my goal was to have RAR to traverse all 7000 directories and crack each DLL open it comes across and cache the metadata. It appears RAR seems to ignore caching data for _misses_. If it goes into a directory that cotnains 50 DLLs and cracks each one but one of them was not WebGrease then it will not populate the cache. At least this is what I've observed by poking around in the debugger.",
        "createdAt": "2021-10-07T01:10:28Z",
        "updatedAt": "2021-10-07T01:10:28Z",
        "author": {
          "login": "michael-baker"
        }
      },
      {
        "body": "> I'm hoping that the aggressive caching of RAR will mitigate this.\r\n\r\nWhat part of RAR's caching strategy mitigates serialization costs? The caches I'm familiar with are for assembly information, but I think we always read in a state file if it exists for every RAR execution.\r\n \r\n> All my my testing is based on the code above - just a a simple MSBuild project that calls a custom C# task with two RAR tasks inside of it. I realize this is a not the intended way that tasks should be composed but I'm trying just experimenting at the moment.\r\n\r\nI noticed something that confirmed my earlier hunch: the timestamp on rar.cache. It was made earlier, which means it was present both with the first RAR execution in your task and the second. RAR ignores a precomputed cache if there's a not precomputed cache already present. That explains why the precomputed cache had no effect but doesn't explain why it took longer to build the second time than the first. If you forced RAR out of process somehow, maybe it landed on a process with an empty cache the second time? Maybe it was just noise? The presence of the precomputed cache should not have affected the second execution at all, and it should have overwritten rar.cache, so that's two mysteries I might want to dig into.\r\n \r\n> The number of processors doesn't matter as I am controlling the RAR task invocation in my custom task.\r\n\r\nRight; I was thinking for your actual build.\r\n\r\n> The first RAR instance creates the two files, which I then just feed into the second instance.\r\n\r\nRAR should only create one file per execution, and given the timestamp different I noted above, I suspect rar.cache already existed.\r\n \r\n> It appears RAR seems to ignore caching data for _misses_. If it goes into a directory that cotnains 50 DLLs and cracks each one but one of them was not WebGrease then it will not populate the cache. At least this is what I've observed by poking around in the debugger.\r\n\r\nThis is what I would expect. Our caches are basically Dictionary<path, information>, which is great if we know where a file is already. It would be nice if we could have a Dictionary<assemblyName, information including path>, but that would start to have trouble if we ever want to use multiple assemblies. What might be interesting is a fast track for if your search paths (including the order in which you search them) is identical between two times when you're looking for a single assembly. Unless it's right next to referencing projects, you should find the same assembly, so we might be able to speed that up. I'm a little worried we'd break something, but it's certainly an interesting idea.",
        "createdAt": "2021-10-07T20:58:10Z",
        "updatedAt": "2021-10-07T20:58:10Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  }
}