{
  "number": 2221,
  "title": "GenerateResource task does not support non-string resources on .NET core",
  "body": "_From @tarekgh on June 14, 2017 15:54_\n\n@Spongman commented on [Tue Jun 13 2017](https://github.com/dotnet/coreclr/issues/12262)\r\n\r\na (.csproj) project a with an embedded text file, added using the VS2017.2 project properties UI.\r\n\r\n[ConsoleApp2.zip](https://github.com/dotnet/coreclr/files/1073187/ConsoleApp2.zip)\r\n\r\non windows, it works fine.\r\n\r\non linux, it just shows:\r\n````\r\n$ dotnet --version\r\n1.0.4\r\n$ uname -a\r\nLinux mybox 3.16.0-4-amd64 #1 SMP Debian 3.16.43-2 (2017-04-30) x86_64 GNU/Linux\r\n$ dotnet run\r\n..\\Resources\\New Text Document.txt;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;Windows-1252\r\n````\r\n\r\n\r\n---\r\n\r\n@danmosemsft commented on [Tue Jun 13 2017](https://github.com/dotnet/coreclr/issues/12262#issuecomment-308318082)\r\n\r\n@tarekgh are there any known issues here?\r\n\r\n---\r\n\r\n@tarekgh commented on [Wed Jun 14 2017](https://github.com/dotnet/coreclr/issues/12262#issuecomment-308475890)\r\n\r\nPlease take a look at the issue https://github.com/dotnet/cli/issues/3695 this was CLI issue and I believe it is already fixed but I am not sure which release include the fix. I'll move this issue to CLI repo.\r\n\r\n\n\n_Copied from original issue: dotnet/cli#6866_",
  "state": "CLOSED",
  "createdAt": "2017-06-15T13:30:35Z",
  "updatedAt": "2024-02-21T17:18:27Z",
  "closedAt": "2019-07-23T15:53:54Z",
  "author": {
    "login": "nguerrera"
  },
  "labels": [
    "bug",
    ".NET Core",
    "triaged"
  ],
  "assignees": {
    "nodes": [
      {
        "login": "rainersigwald"
      }
    ]
  },
  "milestone": {
    "title": "MSBuild 16.3"
  },
  "comments": {
    "nodes": [
      {
        "body": "MSBuild does not support currently support non-string resources on .NET Core. However, it is not checking the resx data's type attribute, but instead blindly using the value as a string. This should either work or have a clear \"not supported\" error at build time.\r\n\r\nRelevant snippet from repro project resx:\r\n``` xml\r\n  <data name=\"New Text Document\" type=\"System.Resources.ResXFileRef, System.Windows.Forms\">\r\n    <value>..\\Resources\\New Text Document.txt;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;Windows-1252</value>\r\n  </data>\r\n```\r\n\r\nCode that is not checking the `type` attribute:\r\nhttps://github.com/Microsoft/msbuild/blob/cc727f715651f305639ad8635fefc40165299f86/src/Tasks/GenerateResource.cs#L2909-L2920\r\n\r\nIt might be easy enough to actually handle this ResxFileRef-to-string case correctly. If we do that, we still need a clear error in other non-string data cases.\r\n",
        "createdAt": "2017-06-15T13:37:09Z",
        "updatedAt": "2018-05-15T00:00:02Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "I am eagerly awaiting the embedding of all resources via the commandline as it will make my life easier with the `watch` command. ",
        "createdAt": "2017-09-03T18:33:04Z",
        "updatedAt": "2017-09-03T18:33:04Z",
        "author": {
          "login": "eltiare"
        }
      },
      {
        "body": "As a stop-gap solution while we wait for resource embedding to become a properly-supported, cross-platform, I created a `dotnet` tool which does something vaguely similar: https://github.com/RendleLabs/Embedder/blob/master/README.md\r\n\r\n(I forgot to `git push`, will do that soon)",
        "createdAt": "2017-09-04T16:30:42Z",
        "updatedAt": "2017-09-04T16:30:42Z",
        "author": {
          "login": "ThatRendle"
        }
      },
      {
        "body": "This also applies to images even on Windows using dotnet build, msbuild \ud83d\ude2d \r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```",
        "createdAt": "2017-11-08T19:22:25Z",
        "updatedAt": "2017-11-08T19:24:12Z",
        "author": {
          "login": "jetersen"
        }
      },
      {
        "body": "Any ETA on fixing this?",
        "createdAt": "2017-12-06T08:55:22Z",
        "updatedAt": "2017-12-06T08:55:22Z",
        "author": {
          "login": "viktors-telle"
        }
      },
      {
        "body": "I'm also getting with issue with `dotnet build` / `dotnet msbuild`, but *not* with the msbuild.exe packaged with VS2017, which seems to correctly embed string resources.",
        "createdAt": "2017-12-11T20:34:58Z",
        "updatedAt": "2017-12-11T20:34:58Z",
        "author": {
          "login": "auxym"
        }
      },
      {
        "body": "This explains a lot. I had a WinForms application that would fail to launch at runtime with `dotnet build` but worked fine in VS2017. I was getting an InvalidCastException when loading an image resource.\r\n\r\nEDIT \r\nAs auxym says, `dotnet msbuild` does not work as of cli version 2.1.2. You need to call the msbuild visual studio installs. For me this is located at:\r\n```\r\n\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\15.0\\Bin\\MSBuild.exe\"\r\n```\r\n\r\nFor some reason this still does not work in release configuration. I have to use debug to get the resources embedded correctly. Hope this helps until a proper fix is available.",
        "createdAt": "2018-01-17T15:36:37Z",
        "updatedAt": "2018-01-17T16:10:43Z",
        "author": {
          "login": "AlgorithmsAreCool"
        }
      },
      {
        "body": "I have a `ResourceManager.GetObject` call on an embedded resource which succeeds on windows but fails with the following error on using dotnetcore 2.0.3 (from the dotnet-sdk-2.0.3 docker image) on Linux:\r\n\r\n    System.InvalidCastException : Unable to cast object of type 'System.String' to type 'System.Byte[]'.\r\n\r\nIs this a related issue?\r\n\r\nI have an embedded text file \"grades.json\" which is accessed via the autogenerated `Resources.Designer.cs` file.  That error message occurs here:\r\n\r\n```csharp\r\ninternal static byte[] grades {\r\n    get {\r\n        object obj = ResourceManager.GetObject(\"grades\", resourceCulture);\r\n        return ((byte[])(obj));\r\n    }\r\n}\r\n```\r\n\r\n",
        "createdAt": "2018-02-01T19:13:13Z",
        "updatedAt": "2018-02-01T19:34:07Z",
        "author": {
          "login": "mikebridge"
        }
      },
      {
        "body": "ResourceManager will support binary blobs in resources with https://github.com/dotnet/corefx/issues/26745. I am guessing this is also \"Unable to cast object of type 'System.String' to type 'System.Byte[]'\" .. @viktorhofer can verify.\r\n\r\n> I had a WinForms application that would fail to launch at runtime with dotnet build\r\n\r\nBear in mind that Winforms is not supported on .NET Core so if it's actually a Winforms app you will hit more errors after this when you try to load a Winforms type.\r\n\r\nOne other Winforms caveat: the set of binary-serializable types is smaller in .NET Core than in .NET Framework ([list](https://docs.microsoft.com/en-us/dotnet/standard/serialization/binary-serialization)) and it does not include for example Image, Icon and Font - types that the Winforms designer likes to binary serialize into resources. ",
        "createdAt": "2018-02-01T19:22:02Z",
        "updatedAt": "2018-02-01T19:22:02Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@danmosemsft this particular instance is a c# library called from a webapp.",
        "createdAt": "2018-02-01T19:27:27Z",
        "updatedAt": "2018-02-01T19:27:27Z",
        "author": {
          "login": "mikebridge"
        }
      },
      {
        "body": "@mikebridge what are the `type` / `mimetype` you see in the resx? \r\neg \r\n```\r\n  <data name=\"pictureBox1.Image\" type=\"System.Drawing.Bitmap, System.Drawing\" mimetype=\"application/x-microsoft.net.object.bytearray.base64\">\r\n```",
        "createdAt": "2018-02-01T19:34:04Z",
        "updatedAt": "2018-02-01T19:34:04Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@danmosemsft The resx file shows this:\r\n\r\n```\r\n<data name=\"grades\" type=\"System.Resources.ResXFileRef, System.Windows.Forms\">\r\n  <value>..\\grades.json;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>\r\n</data>\r\n```\r\nI didn't realize it was specific to winforms---I can embed this file another way if necessary....",
        "createdAt": "2018-02-01T19:38:28Z",
        "updatedAt": "2018-02-01T19:38:43Z",
        "author": {
          "login": "mikebridge"
        }
      },
      {
        "body": "Yeah, `ResxFileRef` is a Winforms type for whatever reason (although presumably it doesn't need Winforms proper so it could be ported.) You'll want to embed as a string or a binary formatted string directly into the resx.",
        "createdAt": "2018-02-01T19:46:00Z",
        "updatedAt": "2018-02-01T19:46:00Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "you can just embed the file directly to the resources and read it with Assembly.GetManifestResourceStream. no need to miss with the resx at all. ",
        "createdAt": "2018-02-01T20:09:12Z",
        "updatedAt": "2018-02-01T20:09:12Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "@danmosemfst @tarekgh, Thanks, I managed to work around it like this:\r\n\r\n```csharp\r\n\r\nvar assembly = Assembly.GetExecutingAssembly();\r\nString resourceName = @\"GradeTranslator.grades.json\";\r\nusing (var stream = assembly.GetManifestResourceStream(resourceName))\r\n{\r\n    if (stream == null)\r\n    {\r\n        throw new Exception($\"Resource {resourceName} not found in {assembly.FullName}.  Valid resources are: {String.Join(\", \", assembly.GetManifestResourceNames())}.\");\r\n    }\r\n    using (var reader = new StreamReader(stream))\r\n    {\r\n        return reader.ReadToEnd();\r\n    }\r\n}\r\n```\r\n\r\nThis appears to work under both dotnet cli and msbuild\r\n\r\n\r\n",
        "createdAt": "2018-02-01T20:11:43Z",
        "updatedAt": "2018-02-01T20:11:43Z",
        "author": {
          "login": "mikebridge"
        }
      },
      {
        "body": "When is this planned to be fixed ?",
        "createdAt": "2018-05-15T00:04:38Z",
        "updatedAt": "2018-05-15T00:04:38Z",
        "author": {
          "login": "amrmahdi"
        }
      },
      {
        "body": "I'm pretty sure this is now a must-fix for the announced .NET Core 3.0 support for Windows Forms: https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications/ :)\r\n\r\nAnd we can't just error out and say only strings are supported. We have to actually make non-strings work.\r\n\r\n",
        "createdAt": "2018-05-15T00:06:11Z",
        "updatedAt": "2018-05-15T00:06:11Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "fyi @ericstj",
        "createdAt": "2018-05-15T00:07:04Z",
        "updatedAt": "2018-05-15T00:07:04Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@tarekgh wrote:\r\n\r\n> you can just embed the file directly to the resources and read it with Assembly.GetManifestResourceStream. no need to miss with the resx at all.\r\n\r\nNote that this doesn't work very well if your resources are localized. You also need the logic to get the right resource for the current UI culture. ResourceManager is supposed to be the thing that handles that.\r\n\r\n",
        "createdAt": "2018-05-15T00:11:39Z",
        "updatedAt": "2018-05-15T00:11:39Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "> Note that this doesn't work very well if your resources are localized. You also need the logic to get the right resource for the current UI culture. ResourceManager is supposed to be the thing that handles that.\r\n\r\nThat is right. who want language-specific resources will need this functionality fixed otherwise it will not be easy to workaround this except if you do a lot of manual workaround work.\r\n\r\n@nguerrera I was looking at some other offline internal reported issue, and it end-up it is the same issue here but using binary files and calling ResourceManager.GetStream. \r\n\r\n```Xml\r\n  <data name=\"LanguageDetection\" type=\"System.Resources.ResXFileRef, System.Windows.Forms\">\r\n    <value>AudioFiles\\pt-br\\LanguageDetection.wav;System.IO.MemoryStream, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>\r\n  </data>\r\n```\r\n\r\nof course, using ```mscorlib``` need to change anyway by our tools. \r\n\r\nI have a couple of questions here: \r\n\r\n- does currently msbuild differ if building for Windows than building on Linux? I am asking because the claim from the user is what they are doing work on Windows but not on Linux. I'll try to take a deeper look to know how they are building anyway.\r\n- Is there any possibility the fix of this embedded files issues be serviced to 2.1? the user is trying to ship with 2.1 and wants this functionality.\r\n",
        "createdAt": "2018-05-22T17:27:59Z",
        "updatedAt": "2018-05-22T17:29:20Z",
        "author": {
          "login": "tarekgh"
        }
      },
      {
        "body": "> does currently msbuild differ if building for Windows than building on Linux? \r\n\r\nThe distinction is whether the MSBuild that is building the project is the full-framework `MSBuild.exe` that is distributed with VS and runs only on Windows, or the .NET Core version that comes with the `dotnet` SDK and runs cross-platform. The latter does not support some paths through resource generation.",
        "createdAt": "2018-05-22T17:30:45Z",
        "updatedAt": "2018-05-22T17:30:45Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "For a real world example of where this can come up: this bug is currently blocking the VB compiler tests from running on CoreClr. The `dotnet build` command embeds our resources used in tests incorrectly and as a result the tests end up failing. \r\n\r\nhttps://github.com/dotnet/roslyn/pull/28063",
        "createdAt": "2018-06-25T22:12:58Z",
        "updatedAt": "2018-06-25T22:12:58Z",
        "author": {
          "login": "jaredpar"
        }
      },
      {
        "body": "@nguerrera gave me a work around here. Going to move to this declaration to work around it.\r\n\r\n``` xml\r\n<EmbeddedResource Include=\"results\\uncheckedctypeandimplicitconversionseven.txt\" />\r\n```",
        "createdAt": "2018-06-25T22:13:30Z",
        "updatedAt": "2018-06-25T22:13:30Z",
        "author": {
          "login": "jaredpar"
        }
      },
      {
        "body": "Commenting for visibility. This is not purely an issue on Linux.",
        "createdAt": "2018-06-27T18:31:19Z",
        "updatedAt": "2018-06-27T18:31:19Z",
        "author": {
          "login": "maxrandolph"
        }
      },
      {
        "body": "@maxrandolph definitely. If you look at all the commits I've been linking in here they are fixing problems on Windows. It's a `dotnet build` issue. \r\n\r\n@nguerrera okay to change the title?",
        "createdAt": "2018-06-27T18:58:33Z",
        "updatedAt": "2018-06-27T18:58:33Z",
        "author": {
          "login": "jaredpar"
        }
      },
      {
        "body": "I changed the title. It was just carried over from the original user report on dotnet/sdk that got moved here.",
        "createdAt": "2018-06-27T20:06:34Z",
        "updatedAt": "2018-06-27T20:06:34Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "> It's a dotnet build issue.\r\n\r\nCorrect. (More pedantically, it's an issue with MSBuild running on .NET Core.)",
        "createdAt": "2018-06-27T20:07:24Z",
        "updatedAt": "2018-06-27T20:07:24Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "Just bumping this comment: https://github.com/Microsoft/msbuild/issues/2221#issuecomment-389000840\r\n\r\nThis is a must-fix for .NET Core 3. @AndyGerlicher, do we have a milestone or tag we can use for that?\r\n\r\n@dsplaisted Can you put this on the agenda for next sync up with msbuild?\r\n\r\ncc @dasMulli \r\n",
        "createdAt": "2018-09-24T21:41:38Z",
        "updatedAt": "2018-09-24T21:41:38Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "We're not currently distinguishing between 16.0 and .NET Core 3 even though the timelines may not match in practice, so pulled this in for 16.0.",
        "createdAt": "2018-09-24T21:54:13Z",
        "updatedAt": "2018-09-24T21:54:13Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "cc @dreddy-work who is on the winforms side.",
        "createdAt": "2018-09-24T22:28:59Z",
        "updatedAt": "2018-09-24T22:28:59Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "I spent some time looking into what MSBuild's dependencies are here.\r\n\r\nGenerateResource has a few categories of thing gated behind feature flags:\r\n\r\n- [ ] The ability to just pass its arguments to an invocation of `resgen.exe`.\r\n  * No resgen equivalent on Core.\r\n- [x] References to `IResourceWriter` and `IResourceReader`.\r\n  * Available now, but weren't at initial port.\r\n  * PR to unify this codepath: https://github.com/Microsoft/msbuild/pull/3816\r\n- [ ] References to `System.Resources.ResXResourceReader` (from `System.Windows.Forms.dll`).\r\n  * Not available in Core at the moment.\r\n  * Is this tracked in a winforms effort somewhere?\r\n- [ ] AppDomain and other assembly-loading-manipulation code.\r\n  * There's code to run `ProcessResourceFiles` in a separate appdomain if the resx file has types that cannot be loaded from the GAC.\r\n  * That appdomain is unloaded after processing, so MSBuild doesn't lock the (probably built in the same solution) assemblies it needed to load to process the resources.\r\n  * In Core there are no appdomains nor assembly unloading.\r\n  * This could just be elided for Core, but that would probably result in background MSBuild.exe processes locking user code semi-randomly.\r\n  * Or maybe there's some future in \"don't allow loading types during resource processing\"? I don't know how feasible that would be.\r\n\r\n",
        "createdAt": "2018-10-01T19:14:35Z",
        "updatedAt": "2018-11-13T18:19:04Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "`System.Resources.ResXResourceReader` looks like it's available in the Microsoft.DesktopUI shared framework.  Probably we don't want to add a dependency in MSBuild to that, so we'll have to discuss further.",
        "createdAt": "2018-10-01T19:27:55Z",
        "updatedAt": "2018-10-01T19:27:55Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "> no resgen equivalent on core\r\n\r\nI would imagine it would be possible to build resgen on core now if we need it.\r\n\r\n> References to System.Resources.ResXResourceReader (from System.Windows.Forms.dll).\r\n\r\nI see this type in System.Windows.Forms.dll of 3.0 builds now. I think we still have a layering issue, though. I'm not sure if we can make msbuild depend on the winforms shared runtime component.\r\n\r\n> In Core there are no appdomains nor assembly unloading.\r\n\r\nAFAIK, collectible assemblies are planned for 3.0. https://github.com/dotnet/coreclr/issues/552#issuecomment-410238253\r\n\r\n\r\n",
        "createdAt": "2018-10-01T19:29:36Z",
        "updatedAt": "2018-10-01T19:29:36Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "> System.Windows.Forms\r\n\r\nWe produce a NuGet package for that assembly as well.  Again, not sure if that is the final form of this (perhaps we want to push the type(s) down) but it could work for now.",
        "createdAt": "2018-10-01T19:30:21Z",
        "updatedAt": "2018-10-01T19:30:21Z",
        "author": {
          "login": "ericstj"
        }
      },
      {
        "body": "> I would imagine it would be possible to build resgen on core now if we need it.\r\n\r\nI don't think it's necessary. It is not normally used for builds anymore unless someone explicitly forces it. The only reason to bring it back in is perhaps to replace the AppDomain isolation.",
        "createdAt": "2018-10-01T19:35:17Z",
        "updatedAt": "2018-10-01T19:35:17Z",
        "author": {
          "login": "filipnavara"
        }
      },
      {
        "body": "@vitek-karas @jeffschwMSFT Note @rainersigwald's comment https://github.com/Microsoft/msbuild/issues/2221#issuecomment-426028467 above regarding AppDomain dependency.  Also .Net Core resgen dependency.",
        "createdAt": "2018-10-30T21:42:27Z",
        "updatedAt": "2018-10-30T21:42:27Z",
        "author": {
          "login": "sdmaclea"
        }
      },
      {
        "body": "> AppDomain dependency\r\n\r\nAnother angle to take on that is: why does ResGen need to load user code for execution/relfection?  ResGen should be able to get everything it needs by just reading assembly metadata and never loading types.  That likely means larger changes in either this task or in the WinForms implementation of ResXResourceReader but that's the direction we've been heading with other build tools.  ",
        "createdAt": "2018-10-31T17:54:41Z",
        "updatedAt": "2018-10-31T17:54:41Z",
        "author": {
          "login": "ericstj"
        }
      },
      {
        "body": "I've asked this before, but I'll ask it again here. Why do we need reflection at all to go from one serialized format (resx) to another (resources)?\r\n\r\nIgnoring format details, it seems theoretically possible to defer all instantiation until runtime and just encode the resx without loss of information into the resource.\r\n\r\nIs there a limitation of the .resources format itself at play, or is it just the API we've been using to write it?\r\n",
        "createdAt": "2018-11-13T18:12:16Z",
        "updatedAt": "2018-11-13T18:12:16Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "The design of .resx for non-string resources is questionable already.\r\nCurrently it states \"use this class for serialisation with this input parameter\", the parameter being file references and the classes being inside the windows forms namespaces or system.drawing..\r\nA \"new\" first-class format would be great (with xliff support), but for portability we'd need some sort of compatibility..",
        "createdAt": "2018-11-14T07:33:05Z",
        "updatedAt": "2018-11-14T07:33:05Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "Bootstrapping a net472 deployment tool via `dotnet run` causes this subtle issue. You don't find out until you've already executed the SQL command `path\\to\\file.sql;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;Windows-1252` against your SQL Server. \ud83d\ude02\r\n\r\nWe're working around it by assuming there will be a Visual Studio installation on the machine.  `dotnet run deploy\\Foo.Deploy` becomes:\r\n\r\n```ps1\r\n$visualStudioInstallation = & \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath\r\n$configuration = 'Release'\r\n$targetFramework = 'net472'\r\n\r\n$msbuild = Join-Path $visualStudioInstallation 'MSBuild\\15.0\\Bin\\MSBuild.exe'\r\n& $msbuild deploy\\Foo.Deploy /restore /p:Configuration=$configuration /v:quiet /nologo\r\n$fooDeploy= \"deploy\\Foo.Deploy\\bin\\$configuration\\$targetFramework\\Foo.Deploy.exe\"\r\n\r\n& $fooDeploy $args\r\n```\r\n\r\nLooking forward to the .NET Core 3.0 SDK! \ud83c\udf89",
        "createdAt": "2018-11-20T23:29:33Z",
        "updatedAt": "2018-11-20T23:29:59Z",
        "author": {
          "login": "jnm2"
        }
      },
      {
        "body": "We are currently working around this issue in our projects with the following helper function:\r\n\r\n```csharp\r\npublic static class ResourceHelper\r\n{\r\n    public static byte[] GetBytes<T>(string name)\r\n    {\r\n        var assembly = typeof(T).Assembly;\r\n        using (var stream = assembly.GetManifestResourceStream(name))\r\n        {\r\n            if (stream == null)\r\n            {\r\n                throw new Exception(\r\n                    $\"Resource {name} not found in {assembly.FullName}.  Valid resources are: {string.Join(\", \", assembly.GetManifestResourceNames())}.\");\r\n            }\r\n            using (var ms = new MemoryStream())\r\n            {\r\n                stream.CopyTo(ms);\r\n                return ms.ToArray();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThen we add the files as `<EmbeddedResource Include=\"Resources\\some_file\" />` and replace the old `Resources`with this:\r\n\r\n```csharp\r\nnamespace Some.Namespace.Resources\r\n{\r\n    public class Resources\r\n    {\r\n        public static byte[] SomeFile => ResourceHelper.GetBytes<Resources>(\"Some.Namespace.Resources.some_file\");\r\n    }\r\n} \r\n```",
        "createdAt": "2018-12-01T16:45:47Z",
        "updatedAt": "2018-12-01T16:45:47Z",
        "author": {
          "login": "wheerd"
        }
      },
      {
        "body": "Extremely sloppy notes to myself from things I've figured out recently:\r\n\r\n* ResourceWriter.Precanned resource exists: https://github.com/dotnet/corefx/blob/eb068ffb575e7fc561bac65b236dbbb739e4e0c7/src/System.Resources.Writer/src/System/Resources/ResourceWriter.cs#L205-L218\r\n* call via [AddResourceData](https://docs.microsoft.com/en-us/dotnet/api/system.resources.resourcewriter.addresourcedata?view=netframework-4.7.2#System_Resources_ResourceWriter_AddResourceData_System_String_System_String_System_Byte___)\r\n* But getting the correct fully-qualified type from the resx xml might be a hassle, see\r\n```xml\r\n  <assembly alias=\"System.Drawing\" name=\"System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\r\n  <data name=\"logoPictureBox.Image\" type=\"System.Drawing.Bitmap, System.Drawing\" mimetype=\"application/x-microsoft.net.object.bytearray.base64\">\r\n```\r\n* So the task will probably need a custom resx parser that understands that, or get a ResXResourceReader that does type-name resolution but never loads a type (somehow?)\r\n",
        "createdAt": "2018-12-13T18:58:27Z",
        "updatedAt": "2018-12-13T18:58:27Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> does type-name resolution but never loads a type (somehow?)\r\n\r\nWill https://github.com/dotnet/corefx/pull/33201 possibly help?",
        "createdAt": "2018-12-13T19:28:08Z",
        "updatedAt": "2018-12-13T19:28:08Z",
        "author": {
          "login": "jnm2"
        }
      },
      {
        "body": "> Will [dotnet/corefx#33201](https://github.com/dotnet/corefx/pull/33201) possibly help?\r\n\r\nI don't think so, because the problem is that in the normal current flow, the type is deserialized into a live object in memory, so the assembly that contains the type definition must be really loaded, not reflection-only loaded or metadata loaded.",
        "createdAt": "2018-12-17T16:56:04Z",
        "updatedAt": "2018-12-17T16:56:04Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I did a sloppy prototype to learn about the feasibility of using `AddResourceData`: https://github.com/rainersigwald/msbuild/commit/9ee5773739eb743dba4bea22cb4ad348dd5ab0da.\r\n\r\nIt's super close, but doesn't quite work.\r\n\r\n```\r\nUnhandled Exception: System.Runtime.Serialization.SerializationException: The input stream is not a valid binary format. The starting contents (in bytes) are: FF-D8-FF-E0-00-10-4A-46-49-46-00-01-01-01-00-60-00 ...\r\n   at System.Runtime.Serialization.Formatters.Binary.SerializationHeaderRecord.Read(BinaryParser input)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryParser.ReadSerializationHeaderRecord()\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryParser.Run()   at System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(BinaryParser serParser, Boolean fCheck)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, Boolean check)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream)   at System.Resources.ResourceReader.DeserializeObject(Int32 typeIndex)\r\n   at System.Resources.ResourceReader.LoadObjectV2(Int32 pos, ResourceTypeCode& typeCode)   at System.Resources.RuntimeResourceSet.GetObject(String key, Boolean ignoreCase, Boolean isString)\r\n   at System.Resources.ResourceManager.GetObject(String name, CultureInfo culture, Boolean wrapUnmanagedMemStream)   at netcore.Form1.InitializeComponent() in S:\\work\\netcore_resources\\netcore\\Form1.Designer.cs:line 38\r\n   at netcore.Form1..ctor() in S:\\work\\netcore_resources\\netcore\\Form1.cs:line 17\r\n   at netcore.Program.Main() in S:\\work\\netcore_resources\\netcore\\Program.cs:line 19\r\n```\r\n\r\nDiffing the `.resources` file, left=full-framework MSBuild, right=hardcoded `AddResourceData`\r\n\r\n```\r\nMode:  Differences\r\nLeft file: S:\\work\\netcore_resources\\examples\\full\\netcore.Form1.resources\r\nRight file: S:\\work\\netcore_resources\\netcore\\obj\\Debug\\netcoreapp3.0\\netcore.Form1.resources\r\n0000013C 00 49 00 6D 00 61 00 67  00 65 00 00 00 00 00 40  00 01 00 00 00 FF FF FF  .I.m.a.g.e.....@.....\u00ff\u00ff\u00ff <> 0000013C 00 49 00 6D 00 61 00 67  00 65 00 00 00 00 00 40                           .I.m.a.g.e.....@\r\n00000154 FF 01 00 00 00 00 00 00  00 0C 02 00 00 00 51 53  79 73 74 65 6D 2E 44 72  \u00ff.............QSystem.Dr\r\n0000016C 61 77 69 6E 67 2C 20 56  65 72 73 69 6F 6E 3D 34  2E 30 2E 30 2E 30 2C 20  awing, Version=4.0.0.0,\r\n00000184 43 75 6C 74 75 72 65 3D  6E 65 75 74 72 61 6C 2C  20 50 75 62 6C 69 63 4B  Culture=neutral, PublicK\r\n0000019C 65 79 54 6F 6B 65 6E 3D  62 30 33 66 35 66 37 66  31 31 64 35 30 61 33 61  eyToken=b03f5f7f11d50a3a\r\n000001B4 05 01 00 00 00 15 53 79  73 74 65 6D 2E 44 72 61  77 69 6E 67 2E 42 69 74  ......System.Drawing.Bit\r\n000001CC 6D 61 70 01 00 00 00 04  44 61 74 61 07 02 02 00  00 00 09 03 00 00 00 0F  map.....Data............\r\n000001E4 03 00 00 00 05 4B 00 00  02 FF D8 FF E0 00 10 4A  46 49 46 00 01 01 01 00  .....K...\u00ff\u00d8\u00ff\u00e0..JFIF.....    0000014C                             FF D8 FF E0 00 10 4A  46 49 46 00 01 01 01 00           \u00ff\u00d8\u00ff\u00e0..JFIF.....\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n000001FC 60                                                                         `                        =  0000015B 60                                                                         `\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n00004CE2 40 05 14 51 40 05 14 51  40 05 14 51 40 1F FF D9  0B                       @..Q@..Q@..Q@.\u00ff\u00d9.        <> 00004C41 40 05 14 51 40 05 14 51  40 05 14 51 40 1F FF D9                           @..Q@..Q@..Q@.\u00ff\u00d9\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n```\r\n\r\nLooks like a missing type header, which I bet is a result of binary serializing the object. I think the resx contains only the payload data, since it also has type information elsewhere in the XML.\r\n\r\nIt's probably possible to reconstruct the payload header from the resx information directly (looks like a few length-delimited fields), but that might be more coupling with implementation details of `BinaryFormatter` than we care for.\r\n\r\nWe could of course do what we do on full framework: use `ResXResourceReader` to deserialize the type and `ResourceWriter` to serialize it again. **Edit:** But note that right now `ResourceWriter` on core doesn't support `BinaryFormatter`--that was lit up for reading in https://github.com/dotnet/coreclr/pull/20907 but not writing (https://github.com/dotnet/corefx/issues/26745#issuecomment-438342828).",
        "createdAt": "2018-12-17T17:49:17Z",
        "updatedAt": "2018-12-17T18:14:36Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I think we should avoid the deserialize, reseralize route because it's basically incompatible with cross-compilation.\r\n\r\nThe lengths involved in handling different classic runtime versions for generate resource today demonstrate this. \r\n\r\nIf we're really just a few header bytes away, let's ask corefx for an api that adds this envelope. I think that would address the coupling concern.",
        "createdAt": "2018-12-17T18:15:57Z",
        "updatedAt": "2018-12-17T18:15:57Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "@nguerrera I haven't (re)read the entire thread - but is the only reason we're not following .NET Framework verbatim, that dotnet/corefx#26745 is not done? \r\n\r\n@ericstj ",
        "createdAt": "2018-12-17T18:31:35Z",
        "updatedAt": "2018-12-17T18:31:35Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@danmosemsft I don't think so. Using the exact same code as full framework msbuild (is that what you mean by following .NET Framework verbatim?), actively deserializes objects in the build only to reserialize them. I *really* think we should *not* do that. At some point, I suspect that even the full framework msbuild should avoid this. With the current approach, we cannot ever have data in a .resx that could only be used at runtime on .NET Core. \r\n\r\nAnother issue with using the exact same code is that it would introduce a dependency from MSBuild -> Windows Forms, which we shouldn't have anywhere IMHO, and can't have x-plat. We would have to move the RexXResourceReader down and make it portable.\r\n\r\n\r\n\r\n",
        "createdAt": "2018-12-17T19:14:23Z",
        "updatedAt": "2018-12-17T19:14:43Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "@nguerrera that makes sense. I am on the lookout for BCL work necessary for this. It sounds like we haven't identified any remaining BCL requirements here, right now. ",
        "createdAt": "2018-12-17T19:51:23Z",
        "updatedAt": "2018-12-17T19:51:23Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@rainersigwald was going to set something up to discuss the next steps. \r\n\r\nI don't think we can say that we don't need bcl changes for this. We just don't know *exactly* what we'll need yet. Even if avoiding deserialization works out, we may need API to write the blobs with appropriate header, etc.\r\n\r\nAnd if we don't avoid it, then we do need at least the above work item for ResourceWriter and maybe moving ResxResourceReader out of winforms.\r\n\r\n",
        "createdAt": "2018-12-17T20:12:03Z",
        "updatedAt": "2018-12-17T20:12:03Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "OK, let me know.",
        "createdAt": "2018-12-17T21:04:56Z",
        "updatedAt": "2018-12-17T21:04:56Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "any ETA on this?",
        "createdAt": "2019-03-04T11:26:20Z",
        "updatedAt": "2019-03-04T11:26:20Z",
        "author": {
          "login": "vanbukin"
        }
      },
      {
        "body": "Aslo would like to know when this will be fixed ?",
        "createdAt": "2019-03-12T12:24:18Z",
        "updatedAt": "2019-03-12T12:24:18Z",
        "author": {
          "login": "michalss"
        }
      },
      {
        "body": "This issue is seriously keeping me porting my existing wpf application to dotnet core 3!\r\n\r\nMy proposal here: in a .resx file, support only i) strings (is already working) and ii) binary data.\r\nThus everything else but string will be treated as binary data (images, other files etc.). ResourceMananager.GetObject can then deliver the data as byte array, and GetStream() as stream.\r\n\r\nDelivering as GetObject() also works already, but I have to rename my image files from e.g. image.png to image.xyz, in order to get them embedded as binary.\r\n\r\nBut make it work now!",
        "createdAt": "2019-03-21T21:22:55Z",
        "updatedAt": "2019-03-21T21:22:55Z",
        "author": {
          "login": "lellid"
        }
      },
      {
        "body": "Update: by chance I found, that the behavior that I proposed above is already implemented, but only if you have the .resx file in a net core console app (I tested it with netcoreapp2.2).\r\nOn the other hand, if I try to embed an .png image in a .resx file that is inside a netcore3.0app wpf application, the resx editor try to embed the .png file not as binary, but at System.Drawing.Bitmap. ",
        "createdAt": "2019-03-21T22:29:53Z",
        "updatedAt": "2019-03-21T22:29:53Z",
        "author": {
          "login": "lellid"
        }
      },
      {
        "body": "@lellid Have you build your app from VS or from dotnet sdk cli? VS use full msbuild and can build resx, but msbuild that ships with dotnet core sdk is not.",
        "createdAt": "2019-03-21T22:45:07Z",
        "updatedAt": "2019-03-21T22:45:07Z",
        "author": {
          "login": "vanbukin"
        }
      },
      {
        "body": "In both cases (console app and wpf app) I built it with  VS2019RC3.",
        "createdAt": "2019-03-21T22:47:43Z",
        "updatedAt": "2019-03-21T22:47:43Z",
        "author": {
          "login": "lellid"
        }
      },
      {
        "body": "But what I think is this: it is not an issue with the build process. It is an issue with the resx editor of VS2019. In the case of the console netcore app, if a add a .png file in the .resx editor  (Add resource -> Add existing file), the resx file afterwards looks like this:\r\n```\r\n  <data name=\"Icons.16x16.ArrangeBottom\" type=\"System.Resources.ResXFileRef, System.Windows.Forms\">\r\n    <value>Icons.16x16.ArrangeBottom.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>\r\n  </data>\r\n```\r\n\r\nIf I add the same file in the resx editor (Add resource -> Add existing file) in a Wpf netcoreapp3.0, the .resx file looks like this:\r\n\r\n```\r\n  <data name=\"Icons.16x16.ArrangeBottom\" type=\"System.Resources.ResXFileRef, System.Windows.Forms\">\r\n    <value>Icons.16x16.ArrangeBottom.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>\r\n  </data>\r\n```\r\n\r\nSee the difference? While in the first case the file is embedded as byte[], in the latter case it is embedded as System.Drawing.Bitmap.",
        "createdAt": "2019-03-21T23:03:43Z",
        "updatedAt": "2019-03-21T23:03:43Z",
        "author": {
          "login": "lellid"
        }
      },
      {
        "body": "As all roads lead here, I found no better place to add a quick set of workaround steps for those attempting to log a TRX file and find resource related tests failing in the CLI.  This is not a solution to the issue though.\r\n\r\nOpen the Solution in Visual Studio\r\nSet the Project to the desired configuration \"Debug|Release\"\r\nClean the Solution\r\nBuild the Solution\r\nEnsure all Unit Tests Pass in Visual Studio\r\nExecute the CLI command on the appropriate config but do not allow the project to build(e.g dotnet test --no-build --logger \"trx;logfilename=filename.trx\")\r\n\r\nThis ensures the resource files have been copied, and will leave them there for the CLI execution.\r\n\r\nHope this helps someone.",
        "createdAt": "2019-04-24T16:38:23Z",
        "updatedAt": "2019-04-24T16:38:23Z",
        "author": {
          "login": "fraher"
        }
      },
      {
        "body": "I get this when the project is of the new sdk style *.csproj format and when it only targets net472for some reason when I do ``(Icon)resourceMan.GetObject(\"icon name\", localization);``. It always happens even after a little while after building within Visual Studio. I am not sure but it seems GetObject sometimes returns a string when the respurce is in fact a icon.",
        "createdAt": "2019-05-12T19:47:08Z",
        "updatedAt": "2019-05-12T19:47:08Z",
        "author": {
          "login": "AraHaan"
        }
      },
      {
        "body": "> It always happens even after a little while after building within Visual Studio.\r\n\r\nCan you expand on that a little? Do you _ever_ build with `dotnet` CLI? That behavior should not happen in Visual Studio or msbuild.exe-built bits (but they might not overwrite things if the last build was from `dotnet build` and things appear incrementally up to date.\r\n\r\n(I'm working on the real fix here)",
        "createdAt": "2019-05-14T00:00:32Z",
        "updatedAt": "2019-05-14T00:00:32Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Yes, I from time to time use ``dotnet build --configuration Release --ignore-failed-sources`` when I feel too lazy to open up Visual Studio.",
        "createdAt": "2019-05-14T12:10:42Z",
        "updatedAt": "2019-05-14T12:11:06Z",
        "author": {
          "login": "AraHaan"
        }
      },
      {
        "body": "@AraHaan if you can arrange to have MSBuild on your path (for example by using the Developer Command Prompt for Visual Studio 2019), you should be able to use `msbuild -restore -p:Configuration=Release` instead, without hitting this problem.\r\n\r\n(Again, fixing this, just trying to help now)",
        "createdAt": "2019-05-14T12:47:27Z",
        "updatedAt": "2019-05-14T12:47:27Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Alright cool, is there also a way for me to compile or test these fixes locally for me and verify that it works? As long as it is resolved I have no issue. Also if only the installer could list the vs developer prompts like how the ps and cmd are listed on clean os installs for a given folder. Basically so I can click on the top corner of the folder and -> Open vs2019 developer command prompt.",
        "createdAt": "2019-05-14T17:53:38Z",
        "updatedAt": "2019-05-14T17:53:38Z",
        "author": {
          "login": "AraHaan"
        }
      },
      {
        "body": "Is there an ETA for this?",
        "createdAt": "2019-07-23T09:11:38Z",
        "updatedAt": "2019-07-23T09:11:38Z",
        "author": {
          "login": "mark-raymond"
        }
      },
      {
        "body": "@mark-raymond I think it's known that it's essential for Windows Forms on .NET Core, so I'm expecting the ETA to be the same as the ETA for .NET Core 3.0. (@rainersigwald Is this right?)",
        "createdAt": "2019-07-23T11:24:13Z",
        "updatedAt": "2019-07-23T11:24:13Z",
        "author": {
          "login": "jnm2"
        }
      },
      {
        "body": "Let's hope it won't be windows only then (as WinForms will be.)",
        "createdAt": "2019-07-23T11:42:26Z",
        "updatedAt": "2019-07-23T11:42:41Z",
        "author": {
          "login": "markusschaber"
        }
      },
      {
        "body": "See related https://github.com/dotnet/corefx/issues/37041 and https://github.com/microsoft/msbuild/pull/4420\r\n> initial deploy in 16.3p1/SDK 3.0.100-p7\r\n\r\nThere was live streamed discussion available at https://www.youtube.com/watch?v=5heMq4U2ek8\r\n",
        "createdAt": "2019-07-23T13:34:06Z",
        "updatedAt": "2019-07-23T13:34:14Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "That's correct, but with one wrinkle: we didn't make it into 16.3p1, so there will be a difference in your assemblies between code compiled with `MSBuild.exe`/Visual Studio, and that compiled with `dotnet {ms}build` for 16.3p1/3.0.100-p7. Both should work, but only the `dotnet build`-produced binaries will fully adopt the new mechanisms. This will be fixed for p2/p8.\r\n\r\nI'm going to close this since the initial implementation is complete. After trying your scenarios with `dotnet build` in p7, please file new issues about any problems you encounter with non-string resources!",
        "createdAt": "2019-07-23T15:53:54Z",
        "updatedAt": "2019-07-23T15:53:54Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "This fix should be backported to MSBuild 15 at least and .NET Core 2.1/2.2, resource files are a very old feature, lack of support for them prevents people on .NET FX from migrating onto .NET Core. ",
        "createdAt": "2019-07-30T15:08:40Z",
        "updatedAt": "2019-07-30T15:08:40Z",
        "author": {
          "login": "voltcode"
        }
      },
      {
        "body": "@voltcode I'm afraid adding support for something that never worked in that combination would not be allowed for a servicing change. We keep a very high bar for that. Taking big features like this backwards adds too much risk. This was a very large change across three repositories. We have fixed this for .NET Core 3.0+ and MSBuild 16.3+, and that is all we can do without a time machine.",
        "createdAt": "2019-07-30T15:15:50Z",
        "updatedAt": "2019-07-30T15:15:50Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "What do you mean it never worked? It worked in Visual Studio. This is a big inconsistency, resource files are from year 2003 and you're forcing people to move to VS 2019 (paid upgrade) to fix it.\r\nUnless NET Core 3.0 will be supported in VS 2017?",
        "createdAt": "2019-07-30T15:18:29Z",
        "updatedAt": "2019-07-30T15:18:29Z",
        "author": {
          "login": "voltcode"
        }
      },
      {
        "body": "It is not supported in VS 2017. There has been a lot of work in msbuild, NuGet, the project system, and other VS components for .NET Core 3.",
        "createdAt": "2019-07-30T15:28:19Z",
        "updatedAt": "2019-07-30T15:54:01Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "@voltcode What I've been doing is using Visual Studio's .NET Framework msbuild which has always supported non-string resources rather than .NET Core's msbuild which had never supported them. I used this starting with VS2017:\r\n\r\n```ps1\r\n$visualStudioInstallation = & \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath\r\n$msbuild = Join-Path $visualStudioInstallation 'MSBuild\\15.0\\Bin\\MSBuild.exe'\r\n& $msbuild path\\to\\project\\folder /restore /p:Configuration=Release /v:minimal /nologo\r\n```",
        "createdAt": "2019-07-30T15:32:34Z",
        "updatedAt": "2019-07-30T15:32:34Z",
        "author": {
          "login": "jnm2"
        }
      },
      {
        "body": "> What do you mean it never worked?\r\n\r\nI mean .NET Core 2.x projects with .NET Core SDK 2.x behave as they always have. It is regrettable that they did not have the result of this work, but it is simply too late to change that.\r\n\r\n.NET Core 2.x filled many gaps with .NET Framework vs. .NET Core 1.x, but not this one. We didn't backport all of those gap closings to 1.x either. We literally cannot do that. We have to defend every backport rigorously, and the change will be rejected if it is closing a gap that was always there. \r\n\r\nWe will get tenfold more passionate feedback when we break something in a servicing update. We are holding this bar with the best of intentions. The risk is simply too high. ",
        "createdAt": "2019-07-30T15:32:35Z",
        "updatedAt": "2019-07-30T15:32:35Z",
        "author": {
          "login": "nguerrera"
        }
      },
      {
        "body": "thanks @jnm2 . Just to clarify by .NET FX you mean the real, old school MSBuild.exe, and by .NET Core msbuild you mean dotnet build command? \r\n\r\nWhen writing build scripts, I would like exactly the same behavior between script and VS. To achieve this goal - what is better to use for scripts - MSBuild.exe or dotnet build ?\r\n\r\nWe hit the resources problem when using dotnet test in build scripts - as far as I understand - if we use MSBuild.exe to build entire solution and dotnet test with --no-build flag - we should be fine? We're using .NET Core 2.2.\r\n",
        "createdAt": "2019-07-30T17:11:36Z",
        "updatedAt": "2019-07-30T17:11:36Z",
        "author": {
          "login": "voltcode"
        }
      },
      {
        "body": "Visual Studio uses MSBuild.exe to build. Using that will be closer to the VS build.\r\n\r\nYes, using MSBuild.exe followed by `dotnet test --no-build` sounds reasonable in your use case.",
        "createdAt": "2019-07-30T17:19:23Z",
        "updatedAt": "2019-07-30T17:19:23Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Thanks @rainersigwald, we've tested your suggestion and it we're definitely going to stay on MSBuild.exe and avoid dotnet * tools as much as possible to replicate VS behavior.",
        "createdAt": "2019-07-31T13:01:47Z",
        "updatedAt": "2019-07-31T13:01:47Z",
        "author": {
          "login": "voltcode"
        }
      },
      {
        "body": "EDIT: *** IF YOU ARE RUNNING INTO THIS ERROR WHEN THEN READ THIS - YOUR BUILD SERVER'S \"BUILD TOOLS FOR VISUAL STUDIO 2019\" MAY NOT BE UP TO DATE ***\r\n\r\nI am able to successfully run my app from my command line on my local dev machine, but cannot run it after it's being built in TeamCity.\r\n\r\n#### Local Dev Machine\r\n```powershell\r\n & \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\M\r\nsBuild.exe\" --version\r\nMicrosoft (R) Build Engine version 16.2.37902+b5aaefc9f for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nMSBUILD : error MSB1001: Unknown switch.\r\nSwitch: --version\r\n\r\nFor switch syntax, type \"MSBuild -help\"\r\n```\r\n\r\n#### TeamCity Build Server\r\nVisual Studio Build Tools 16.1.9\r\n![image](https://user-images.githubusercontent.com/447485/69379546-aa40af80-0c7e-11ea-9544-a7318dd58e2b.png)\r\n\r\nWhen I click \"Launch\", I get:\r\n\r\n```cmd\r\n**********************************************************************\r\n** Visual Studio 2019 Developer Command Prompt v16.0\r\n** Copyright (c) 2019 Microsoft Corporation\r\n**********************************************************************\r\n```\r\n\r\n# Attempt to fix\r\n\r\n1. Go to https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019\r\n2. Download \"Build Tools for Visual Studio 2019\" (`vs_buildtools__1704816089.1574373004.exe`)\r\n3. Get file SHA256 hash with PowerShell: `7DA4388648C92544C97407C6F052FD6BC0317DB407CADAB9FDCB328A34D3E317`\r\n```powershell\r\nPS C:\\Users\\john.zabroski> Get-FileHash \"C:\\Users\\john.zabroski\\Downloads\\vs_buildtools__1704816089.1574373004.exe\"\r\n\r\nAlgorithm       Hash                                                                   Path\r\n---------       ----                                                                   ----\r\nSHA256          7DA4388648C92544C97407C6F052FD6BC0317DB407CADAB9FDCB328A34D3E317       C:\\Users\\john.zabroski\\Downlo...\r\n```\r\n4. Install the exe\r\n5. Running the installer indicates it is 16.3.10\r\n\r\n",
        "createdAt": "2019-11-21T21:53:19Z",
        "updatedAt": "2019-11-21T21:54:39Z",
        "author": {
          "login": "jzabroski"
        }
      }
    ]
  }
}