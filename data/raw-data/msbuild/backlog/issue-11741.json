{
  "number": 11741,
  "title": "RAR-as-a-service implementation spec",
  "body": "# RAR-as-a-service implementation spec\n\n*See [documentation/specs/archive/rar-as-service.md](https://github.com/dotnet/msbuild/blob/main/documentation/specs/archive/rar-as-service.md) for a brief background of goals and overall architecture. Although that doc was written for a previous prototype of this project, it mostly still applies outside of implementation details.*\n\nThis is a detailed implementation overview of **RAR-as-a-service**. intended to give a big picture view of currently completed work, design choices, ect., and lay out the critical path / blockers for PRs.\n\n***Out for review:***\n- [x] [1: Node lifecycle](#node-lifecycle)\n    - [Pull 11383: Implement out-of-proc RAR node lifecycle](https://github.com/dotnet/msbuild/pull/11383)\n\n***Completed, but blocked on PR:***\n- [ ] [2: Serialization](#serialization) (blocked on 1)\n- [ ] [3: Task Execution](#task-execution) (blocked on 2)\n- [ ] [4: Caching](#caching) (blocked on 2)\n\n***Needs design:***\n- [ ] [5: Environment snapshots (needs feedback)](#environment-snapshots) (blocked on 2)\n[6: Miscellaneous Notes](#misc-notes)\n\n***Additional related perf work:***\n(These aren't *blccking* but still important for perf, will be breaking into a separate issue):\n[Pull 11640: Support string interning / deduplication within packets](https://github.com/dotnet/msbuild/pull/11640)\n[Pull 11638: Fix TaskParameterTaskItem serialization perf](https://github.com/dotnet/msbuild/pull/11638)\n[Pull 11635: Optimize TaskItem cloning between Engine and Tasks](https://github.com/dotnet/msbuild/pull/11635/)\n\n# 1: Node lifecycle<a id='node-lifecycle'></a>\n\n[Pull 11383: Implement out-of-proc RAR node lifecycle](https://github.com/dotnet/msbuild/pull/11383)\n\n## Control Flags\n\n`BuildParameters.EnableRarNode` enables both launching the out-of-proc RAR node, and configuring all RAR tasks in the build to forward execution to the node. This flag will also be set via the **command line switch** *(naming open for discussion)*:\n\n```bat\nmsbuild.exe -enableRarNode\n```\n*Note: To avoid publicly exposing the feature until complete, `-enableRarNode` is currently replaced by the environment variable `MSBuildRarNode`.*\n\nA new **node mode** is added to configure MSBuild to start as the RAR node, displaying as just another `msbuild.exe` process:\n\n```bat\nmsbuild.exe /nodemode:3\n```\n\nTasks unfortunately don't have access to `BuildParameters`, so we'd still need some method to signal RAR to connect to the out-of-proc node, tied to the *build* and not the *environment*.\n\nThere's already precedence for using `EngineServices` for this purpose (see `IsTaskInputLoggingEnabled`, only used by RAR), so it seems like the obvious choice to plumb this through to the task:\n\n```.cs\n// Framework/EngineServices.cs\nabstract class EngineServices\n{\n    public const int Version2 = 2;\n    virtual bool IsOutOfProcRarNodeEnabled => /* true when EnableRarNode is set + we successfully launched or found the node */;\n}\n```\n\nFinally, any project can explicitly opt out of running RAR out-of-proc, even if set via the `BuildParameters` flag:\n\n```Microsoft.Common.CurrentVersion.targets\n<!-- Microsoft.Common.CurrentVersion.targets -->\n<PropertyGroup>\n      <!-- Defaults to true, but actual execution is still dependent on the BuildParameters flag -->\n      <ResolveAssemblyReferencesOutOfProcess Condition=\"'$(ResolveAssemblyReferencesOutOfProcess)' == ''\">true</ResolveAssemblyReferencesOutOfProcess>\n</PropertyGroup>\n```\n\n## Node launch / existence check\n\nWith `BuildParameters.EnableRarNode` set, MSBuild checks for an existing named pipe instance matching the name `MSBuildRarNode-{handshake}`. To avoid blocking the build, we avoid going through the sequence of creating a pipe client and performing a handshake, or relying on interprocess synchronization methods such as shared mutexes.\n\nInstead, we can just perform a quick file probe to see if the handle exists, and continue on with the build, assuming the server will handle any potential race conditions. This looks slightly different depending on the platform:\n\n- **Windows** - All named pipes are prefixed with the pipe root `\\\\.\\pipe\\`, and are partially treated as file system objects compatible with read/write APIs. However, attempting to directly probe the path will crash the pipe server due to undefined behavior. Instead, we need to enumerate `\\\\.\\pipe\\` as a directory and match on the name.\n- **MacOS / Linux** - Sockets are represented as files and don't have an OS-defined location. We always place them under `/tmp`, so we can just directly call `File.Exists()`.\n\nIf this fails to find a match, we kick off a new MSBuild process in `/nodemode:3`. `NodeLauncher` automatically handles locating the appropriate MSBuild executable / host + assembly for .NET Framework / .NET Core.\n\n## Node (RAR Service)\n\nWhen `/nodemode:3` is read from command line arguments, MSBuild will set itself up as the RAR node. The RAR node uses two sets of pipe servers, connected via separate handles:\n\n1. `MSBuildRarNode-{handshake.ComputeHash()}` - *Single-instance pipe server*\n    - Receives messages from MSBuild execution\n    - Manages the setup/teardown of the node and its workers\n    - Initializes any shared caching and global settings\n    - Starts up the multi-instance pipe workers to await RAR requests\n2. `MSBuildRarNodeEndpoint-{handshake.ComputeHash()}` - *Multi-instance pipe server*\n    - Receives commands from the RAR task and executes requests\n    - Connection lives\n    - Does not manage its own lifetime, apart from observing cancellation\n    - Maintain an active connection with a single MSBuild node for the duration of a build\n\nThis structure is important for enforcing that only a single RAR node process can exist. Ideally we'd only need the multi-instance server, and let `maxNumberOfServerInstances` *(parameter for `NamedPipeServerStream`)* automatically handle this for us. But because multi-instance pipes can live across multiple processes on Windows, this could create a race condition where pipe server instances are split across nodes.\n\nBy setting up `MSBuildRarNode-{*}` before the worker pipes, the single instance acts as implicit mutex. In the event of a race, the other node will fail to create the server and shut down.\n\n```pwsh\n# RAR node launches as first server instance.\n\u276f <path-to-msbuild>\\MSBuild.exe /nodemode:3\nMSBuild version <version> for .NET Framework\n\n# Second RAR node launches, errors out.\n# Should not get here in normal conditions.\n\u276f <path-to-msbuild>\\MSBuild.exe /nologo /nodemode:3\nMSBuild version <version> for .NET Framework\nMSBUILD : error MSB1025: An internal failure occurred while running MSBuild.\nSystem.InvalidOperationException: RAR node is already running.\n```\n\n*Note: These node implementations currently live separate from the rest of MSBuild's IPC Node infrastructure, over in `Microsoft.Build.Tasks`, due to RAR type dependencies for both the client and server. As such, some logic is duplicated (e.g. pipe setup, handshakes), although there's work-in-progress to share code where possible. E.g. [Pull 11546: Consolidate common IPC / named pipe code](https://github.com/dotnet/msbuild/pull/11546)*\n\n## Handshake\n\nOur `Handshake` implementation needs to be independent of the build session, so the standard implementation used for out-of-proc nodes would not work.\n\nFor now, we can reuse the existing `ServerNodeHandshake`, designed for the `MSBuildServer` feature.\n\n```.cs\n// Shared/CommunicationsUtilities.cs\n// Handshake layout. Salt == hash(MSBuild tools directory)\n$\"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate}\".ToString(CultureInfo.InvariantCulture);\n```\n\nOne current gap is that the `salt` is a just hash of the MSBuild tools directory, which would prevent a .NET Framework RAR task from communicating with a .NET Core RAR node. *(see perf section for more details)*.\n\n## Node Client (RAR Task)\n\nIf `EngineServices.IsOutOfProcRarNodeEnabled` is set *and* property `/p:ResolveAssemblyReferencesOutOfProcess` is not overridden, the RAR task will create the client and forward execution to the server. If the connection fails for any reason (aka not a Task failure), or exceeds the short timeout period, it will always fall back to executing in-proc.\n\nFor performance purposes, each MSBuild node maintains it's own global `OutOfProcRarClient` which is registered via `IBuildEngine4`. This is created when RAR runs for the first time on a given node, and reused on all subsequent runs.\n\n```cs\n// First run...\nrarClient = new OutOfProcRarClient();\nbuildEngine.RegisterTaskObject(OutOfProcRarClientKey, rarClient, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);\n\n// Skip connection overhead + buffer allocations!\nOutOfProcRarClient rarClient = (OutOfProcRarClient)buildEngine.GetRegisteredTaskObject(OutOfProcRarClientKey, RegisteredTaskObjectLifetime.Build);\n```\n\nThis allows us to skip the handshake check for the duration of the build, and reuse buffers across every RAR task. We intentionally allow the client to be disposed between builds (e.g. when `/nodereuse` is enabled) so we don't lock each pipe instance to a specific node for its lifetime.\n\n*Example 1: A multi-proc build. Each MSBuild node holds the connection until the overall build completes.*\n\n![Image](https://github.com/user-attachments/assets/6cd9e20e-279c-4f94-9244-f1d04cda5bab)\n\n*Example 2: Multiple single-proc MSBuild instances (as orchestrated by a higher-level build engine).*\n\n![Image](https://github.com/user-attachments/assets/3afc80bd-90eb-4a13-a6ee-4f129251bb46)\n\n# 2: Serialization<a id='serialization'></a>\n\n## Task parameters\n\n**RAR input / output parameters are dynamically discovered and accessed via reflection.**\n\nFor context, the first idea here was to simply redeclare all of RAR's parameters and set up minimal shims for `ITaskItem` inputs/outputs. While this is *probably* the most performant thing to do, it added a *ton* of boilerplate and looked like an easy point for regressions. For instance, what happens when RAR adds another input or output?\n\n```cs\ninternal class RarNodeExecuteRequest : RarSerializableMessageBase\n{\n    private bool _autoUnify;\n    private RarTaskItemInput[] _assemblies = [];\n    private string[] _candidateAssemblyFiles = [];\n    // ...\n    // 40+ lines of fields...\n    // ...\n    internal bool AutoUnify { get => _autoUnify; set => _autoUnify = value; }\n    internal RarTaskItemInput[] Assemblies { get => _assemblies; set => _assemblies = value; }\n    internal string[] CandidateAssemblyFiles { get => _candidateAssemblyFiles; set => _candidateAssemblyFiles = value; }\n    // ...\n    // Another 40+ lines of properties...\n    // ...\n    public override void Translate(ITranslator translator)\n    {\n        translator.Translate(ref _autoUnify);\n        translator.TranslateArray(ref _assemblies);\n        translator.Translate(ref _candidateAssemblyFiles);\n        // ...\n        // Not shown: Another 40+ lines, The response side, TaskItem wrappers, many more conversion utils...\n        // ...\n    }\n}\n```\n\n...so I dug around MSBuild to see what could be reused. Luckily, `TaskParameter` (currently used by the out-of-proc task host) already does the work of wrapping arbitrary types into an `ITranslatable` object, and even provides a `ITaskItem` shim via `TaskParameterTaskItem`.\n\n```cs\n// Shared/TaskParameter.cs\ninternal class TaskParameter\n{\n    private TaskParameterType _parameterType;\n    private TypeCode _parameterTypeCode;\n    private object _wrappedParameter;\n    // ...\n    private class TaskParameterTaskItem\n    {\n        // Handles cloning from arbitrary ITaskItem implementations\n    }\n}\n```\n\n*Note: This currently has some (fixable) perf gaps related to TaskItem cloning, but otherwise has minimal reflection overhead since it relies on optimized functions like GetType(). See: [Pull 11638: Fix TaskParameterTaskItem serialization perf](https://github.com/dotnet/msbuild/pull/11638)*\n\nThis means we only need a scaled down version of the work `TaskExecutionHost` does to dynamically discover RAR's input and output parameters. This involves reflection, but as long as the expensive `Type.GetProperties()` is globally cached, this doesn't appear to cause a performance issue.\n\n*Implementation snippet:*\n\n```cs\nclass RarTaskParameters\n{\n    private static readonly Lazy<PropertyInfo[]> s_outputProperties = new(() =>\n        [.. typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n            .Where(property => property.GetCustomAttribute<OutputAttribute>() != null && !property.Name.Equals(CopyLocalPropertyName, StringComparison.Ordinal))]);\n\n    private static readonly Lazy<PropertyInfo[]> s_inputProperties = new(() =>\n        [.. typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n            .Where(property => property.GetGetMethod() != null && property.GetSetMethod() != null)]);\n\n    // ...\n    {\n        // ...\n        // PropertyInfo.SetValue(ResolveAssemblyReference, TaskParameter)\n        property.SetValue(rarTask, parameter.WrappedParameter);\n    }\n}\n```\n\n*Note: Supposedly `PropertyInfo.SetValue` can also be a perf slow point, but so far I haven't picked it up in profiling traces. If necessary, `Delegate.CreateDelegate` is a commonly used alternative to cache the setters.*\n\nThis eliminates the need for almost all custom serialization logic, outside of the main request / response wrappers and a couple special cases...\n\n## Parameter-specific handling\n\n### CopyLocalFiles\n\nSo one \"special\" RAR output is the `CopyLocalFiles` property. This is an `ITaskItem[]` constructed by *reference* to other outputs produced by RAR.\n\nAlthough the reference equality isn't important (`TaskExecutionHost` will eventually duplicate these into separate `ProjectItemInstance.TaskItem` instances when collecting outputs), serializing these duplicate outputs back to the client can add *significantly* to the payload size.\n\nLuckily, `CopyLocalFiles` is simply produced by looking for the key `ItemMetadataNames.CopyLocal`:\n\n```cs\n// Tasks/AssemblyDependency/ReferenceTable.cs\nbool copyLocal = MetadataConversionUtilities.TryConvertItemMetadataToBool(\n        i,\n        ItemMetadataNames.copyLocal,\n        out bool found);\n\n```\n\n...so as an optimization, we can just rely on the metadata key and reconstruct the output on the client.\n\n### Path normalization\n\nAny relative paths also need to be resolved to the full path of the project it is relative to - otherwise RAR will blow up at runtime.\n\nCurrently this only applies to `AppConfigFile` and `StateFile`, and this is easily done ahead of time from the client.\n\n# 3: Full Execution<a id='full-execution'></a>\n\nBy this point, all the plumbing exists for the task to execute end-to-end, so this PR is mostly just connecting the last dots.\n\n## Replaying log event messages\n\nOne challenge here is that log events need to be replayed on the client as if they occurred in-proc. So instead of passing a real `IBuildEngine` implementation, the node passes a dummy which queues messages to send back to the client.\n\nHowever, log events can explode the size of the final payload, and of course aren't well suited for string deduplication.\n\nTo solve this, the dummy build engine queues events into a `Channel` to be processed asynchronously by the node. Once the capacity exceeds a set threshold, the current batch of messages is sent back to the client. \n\nBy buffering in chunks, log events add minimal overhead to the final payload, as the client will have already processed most messages by the time RAR completes.\n\n*Implementation snippets:*\n\n```cs\ninternal class RarNodeBuildEngine : IBuildEngine10\n{\n\tprivate readonly Channel<RarBuildEventArgs> _channel = new(/* unbounded, single reader/writer */);\n\t\n\tpublic void LogMessageEvent(BuildMessageEventArgs e)\n\t{\n\t\t// Wraps event to support ITranslatable.\n\t\t_channel.Writer.TryWrite(new RarBuildEventArgs(e));\n\t}\n\t\n\tinternal ChannelReader<RarBuildEventArgs> BuildEventQueue => _channel.Reader;\n}\n```\n\n```cs\nclass OutOFProcRarNodeEndpoint\n{\n\t// Synchronous buffer.\n\tprivate readonly Queue<RarBuildEventArgs> _buildEventQueue;\n\t\n\t// ...\n\t// Runs in a task concurrent to the RAR task until the task completes.\n\t{\n\t\tRarBuildEventArgs buildEventArgs = await buildEngine.BuildEventQueue.ReadAsync(cancellationToken);\n\t\t_buildEventQueue.Enqueue(buildEventArgs);\n\t\t\n\t\tif (_buildEventQueue.Count == MaxBuildEventsBeforeFlush)\n\t\t{\n\t\t\tawait _pipeServer.WritePacketAsync(new RarNodeBuildEvents(_buildEventQueue), cancellationToken);\n\t\t\t_buildEventQueue.Clear();\n\t\t}\n\t}\n}\n```\n\n# 4: Caching<a id='caching'></a>\n\n## File metadata caching\n\nFor a refresher, RAR currently has two levels of **file metadata caching**:\n1. **Process-wide cache** - shared across all executions.\n2. **Task-local cache** - serialized to disk.\n\n```cs\nclass SystemState\n{\n    // Process-wide\n    static readonly ConcurrentDictionary<string, FileState> s_processWideFileStateCache;\n\n    // Task-local\n    Dictionary<string, FileState> instanceLocalOutgoingFileStateCache;\n\n    // ...more local caches exist, but aren't accessed as frequently.\n}\n```\n\nHowever, as MSBuild's parallelism increases, the less effective this cache becomes:\n\n- Scheduling is non-deterministic, so there's a high change of a project building on a node which has not deserialized this project's cache file yet.\n- On rebuilds, every node then needs to incrementally invalidate its cache, and write the updates back to disk.\n- Any newly spun up processes always start with an empty cache.\n\nWe improve this scenario for free just by running RAR out-of-proc:\n\n- Every RAR worker is able to share the same global cache instance.\n- The cache lives across MSBuild invocations, even when running single-proc builds or with node reuse disabled.\n    - Important for higher level build engines like QuickBuild which can't use those features due to sandbox tracing + build caching.\n\nHowever, we take this even *futher* now that we have a persistent node...\n\n## Task-level incremental caching\n\n**Given a set of task inputs, file system state, and environment, RAR will access the same set of files and produce the same outputs.**\n\nNormally, RAR does not support the concept of an incremental task. This is because its outputs are a function of both the inputs *and* the file system state, which makes it impossible to know which files will be accessed without first running the task.\n\nHowever, if running RAR in a persistent node, we have the ability to track which files RAR accessed at execution time.\n\nSo when a RAR task completes, we store the request -> result pair into a cache which lives for the duration of the RAR node...\n\n```cs\nclass RarExecutionCache\n{\n\t// TODO: Should probably key this by some project identifier as a simple way to evict old entries.\n\tprivate ConcurrentDictionary<byte[], RarCachedExecution> _executionCache = new(/* custom byte[] comparer */);\n}\n```\n\n...*deferring deserialization* until we've performed the lookup.\n\nBut first, we need to know the full set of files accessed + have a cache invalidation mechanism...\n\n## File access tracking\n\nTracking changes purely via file watchers is not performant when monitoring a large number of files and directories, in addition to the potential chance of dropping accesses when the CPU is loaded.\n\nRAR has a fairly long list of potential IO calls:\n\n```cs\n// Tasks/AssemblyDependency/ResolveAssemblyReference.cs\nExecute(\n\tp => FileUtilities.FileExistsNoThrow(p),\n\tp => FileUtilities.DirectoryExistsNoThrow(p),\n\t(p, searchPattern) => [.. FileSystems.Default.EnumerateDirectories(p, searchPattern)],\n\tAssemblyNameExtension.GetAssemblyNameEx,\n\tAssemblyInformation.GetAssemblyMetadata,\n#if FEATURE_WIN32_REGISTRY\n\t(baseKey, subkey) => RegistryHelper.GetSubKeyNames(baseKey, subkey),\n\t(baseKey, subkey) => RegistryHelper.GetDefaultValue(baseKey, subkey),\n#endif\n\tNativeMethodsShared.GetLastWriteFileUtcTime,\n\tAssemblyInformation.GetRuntimeVersion,\n#if FEATURE_WIN32_REGISTRY\n\t(hive, view) => RegistryHelper.OpenBaseKey(hive, view),\n#endif\n\tGetAssemblyPathInGac,\n\tAssemblyInformation.IsWinMDFile,\n\tReferenceTable.ReadMachineTypeFromPEHeader);\n}\n```\n\n... but they nearly all pass through a `NativeMethodsShared.GetLastWriteFileUtcTime` in order to check for cache invalidation.\n\nThis reduces down to only two sets of accesses which need be checked for up-to-date:\n- **File modifications**\n    - Check if existence state or the timestamp has changed\n- **Directory enumerations**\n    - Check if existence state has changed\n    - Check if the *set* of files which were accessed has changed\n        - We do not need to check if their *contents* have changed since enumerations are only used to check for the existence of specific file extensions in neighboring files\n\nAnd once again, `SystemState` already tracks this for us:\n\n```cs\n// Tasks/AssemblyDependency/SystemState.cs\ninternal sealed class SystemState : StateFileBase, ITranslatable\n\t// Validate file timestamps\n\tinternal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);\n\t// Validate enumeration results\n\tinternal Dictionary<string, bool> instanceLocalDirectoryExists = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);\n\tinternal Dictionary<string, string[]> instanceLocalDirectories = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);\n```\n\n## Invalidation\n\n...which makes our up-to-date check as simple as just walking the caches:\n\n```cs\n// Up-to-date check\nforeach (KeyValuePair<string, SystemState.FileState> kvp in cachedExecution.SystemState.instanceLocalFileStateCache)\n{\n\tif (NativeMethodsShared.GetLastWriteFileUtcTime(kvp.Key) != kvp.Value.LastModified)\n\t{\n\t\treturn false;\n\t}\n}\n// Repeat for instanceLocalDirectoryExists + instanceLocalDirectories \n```\n\n*Note: A potential perf improvement here is to populate RAR's SystemState on cache miss with any IO that we've already done.\n\n# 5. Environment snapshots (needs feedback)<a id='environment-snapshots'></a>\n\nThe out-of-proc RAR task inherits the environment variables present at the time the RAR node launches. However, environment variables may change between builds.\n\nIsolating this per-task is not so straightforward - RAR itself only has a few environment variables which could be refactored to take internal overrides, but there are many other in shared dependencies that are not easy to modify or comprehensively track.\n\n*RAR-specific env vars from a grep of `AssemblyDependency/**` (`Traits.Instance.EscapeHatches` + `Environment.GetEnvironmentVariable(_)`)*\n```cs\n// Additional logging\n\"MSBUILDDUMPFRAMEWORKSUBSETLIST\"\n\"MSBUILDLOGVERBOSERARSEARCHRESULTS\"\n\n// Flags for legacy behavior\n\"MSBUILDDISABLEGACRARCACHE\"\n\"MSBUILDTARGETPATHFORRELATEDFILES\"\n\n// Opts out of a task-local metadata cache\n\"MSBUILDDONOTCACHERARASSEMBLYINFORMATION\"\n\n// Opts out of an additional process-wide cache\n\"MSBUILDDISABLEASSEMBLYFOLDERSEXCACHE\"\n```\n\nOther nodes use a global snapshot system to temporarily swap state on the execution of a command. However, this works on the assumption of a single build command running on a node at any given time, while the RAR node can run multiple concurrent tasks.\n\n```cs\n// A snapshot of the node startup state.\n_savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();\n\n// Potential franken-vars...\nforeach (KeyValuePair<string, string> kvp in _buildParameters.BuildProcessEnvironment)\n{\n    Environment.SetEnvironmentVariable(environmentPair.Key, environmentPair.Value);\n}\n\n// ... and another potential race in cached traits.\nTraits.UpdateFromEnvironment();\n```\n\nSo as a default, we can assume that environment variables will mostly only change in between builds, and use a fallback mechanism to run the request on the client if necessary:\n\n1. If no tasks are currently running:\n    - On the first request, set the new environment state of the process. \n2. If any task is running:\n    - On incoming requests, check if the current set of environment variables match\n    - If true, execute RAR on the node.\n    - Else, reject the request and allow the client to fall back to in-proc.\n\nNotice the word *default* - higher-level build engines (e.g. QuickBuild) often set environment variables per-target, such as a log directory or file unique for the command. In that case, this system would leave the node running a single RAR task at a time. The higher-level build engine may also launch the RAR node directly to force global flags.\n\nTo solve this, I either propose an additional environment variable to opt-out of env var snapshotting, or scoping the snapshot to a subset of known environment variables relevant for RAR.\n\n## Working directory snapshot\n\nFrom what I've found so far, this seems to be the only place in RAR (outside of handled task inputs) that might resolve a relative path based on the current directory:\n\n```cs\n// Tasks/AssemblyDependency/ReferenceTable.cs\nprivate AssemblyNameExtension NameAssemblyFileReference(/* reference + file name */)\n\t// ...\n\tif (!Path.IsPathRooted(assemblyFileName))\n\t{\n\t\treference.FullPath = Path.GetFullPath(assemblyFileName);\n\t}\n}\n```\n\nThough, even this can be traced back to the `_assemblyFiles` input, so it may be as simple as ensuring the `ItemSpec` is a full path:\n\n```cs\n// AssemblyDependency/ResolveAseemblyReference.cs\npublic ITaskItem[] AssemblyFiles\n{\n\tget { return _assemblyFiles; }\n\tset { _assemblyFiles = value; }\n}\n```\n\n# 6: Miscellaneous Notes<a id='misc-notes'></a>\n\nDump for additional ideas that don't make sense to put into an item yet:\n\n### First is run slower on .NET Framework\n\n**Only on .NET Framework** - the first run of a RAR task on a newly launched RAR node always appears to have an additional few 100ms of overhead due to JIT-ing (verified via profiling). This does not reproduce at all on .NET Core, so I expect it's just inherent to the runtime.\n\nI expect this may just auto-resolve with NGEN-ed MSBuild, and it only seems to be an issue on the first build - but it is something to watch out for. And it leads directly to my next point...\n\n### .NET Core RAR node is just faster\n\nBefore integrating the server handshake, I had mostly tested using .NET Framework MSBuild -> .NET Core RAR Node. After, I noticed that *a .NET Core instance of the RAR node noticeably outperforms the .NET Framework node*, in both overhead and E2E task execution time. So an area for perf improvement would be to *default to launching a .NET Core RAR node (when available)*.\n\nMain blockers I can think of:\n- Locating the dotnet host + MSBuild assembly. The shared `NodeLauncher` only knows how to find the `dotnet` if it exist in the parent tools directory, and of course it still needs to locate the target assembly. From what I can tell, `BuildEnvironmentHelper` also doesn't support this. Either way, this seems like the main problem that would need to be solved.\n- Some code paths in RAR are feature-flagged for each runtime, so I'm not sure of the potential for output differences. Specifically:\n    - **FEATURE_ASSEMBLYLOADCONTEXT**\n    - **FEATURE_WIN32_REGISTRY**\n    - **FEATURE_GAC**\n- As mentioned earlier, this would also need a change in the handshake definition specific to the RAR node, although that seems comparatively simple.\n",
  "state": "OPEN",
  "createdAt": "2025-04-17T17:35:35Z",
  "updatedAt": "2025-05-26T11:18:10Z",
  "closedAt": null,
  "author": {
    "login": "ccastanedaucf"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rainersigwald"
      },
      {
        "login": "SimaTian"
      }
    ]
  },
  "labels": [
    "triaged"
  ],
  "comments": {
    "nodes": []
  }
}