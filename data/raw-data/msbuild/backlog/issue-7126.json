{
  "number": 7126,
  "title": "Look into merging MSBuild's RAR caching and the SDK's assembly (?) caching",
  "body": "Look into what they have in common.\r\nMerge the caching to some extent.\r\nPossibly merge the code paths?\r\nPossibly only run it once and share the results?\r\n\r\nSpecifically ProcessFrameworkReferences and ResolvePackageAssets.",
  "state": "CLOSED",
  "createdAt": "2021-12-06T17:49:06Z",
  "updatedAt": "2024-02-21T17:00:50Z",
  "closedAt": "2022-08-23T16:21:49Z",
  "author": {
    "login": "Forgind"
  },
  "labels": [
    "Area: Performance",
    "Area: Task: Resolve Assembly References (RAR)",
    "triaged"
  ],
  "assignees": {
    "nodes": [
      {
        "login": "Forgind"
      }
    ]
  },
  "milestone": {
    "title": "VS 17.3"
  },
  "comments": {
    "nodes": [
      {
        "body": "> Possibly only run it once and share the results?\r\n\r\nThis one could have most potential.\r\n\r\nI'm experiencing a similar design in my prototype [BenchBuild](https://github.com/xoofx/BenchBuild) of a fast up-to-date build server with msbuild, and I'm for example generating cache files for all dependent assembly references (including analyzers):\r\n\r\n```\r\n   163 dll-Microsoft.CodeAnalysis.CSharp.NetAnalyzers.dll-43cd394337288a248c9bb1478bfa61aa.cache\r\n   156 dll-Microsoft.CodeAnalysis.NetAnalyzers.dll-964681bd507788578febb23a827afebf.cache       \r\n18,232 fwk-Microsoft.NETCore.App-6.0.0-e9432bea5bfe249209d36d6163b16e05.cache                   \r\n```\r\nAll these files are unique and shared by all projects in a solution and they represent all the input assembly dependencies of all projects (the benchmark projects I setup doesn't have any package yet, so they only depend on framework)\r\n\r\nThen I store the results in a file `$ProjectName.csproj.BuildResult.cache`. This file has dependencies on the files above (relying on my static-graph PR #7121)\r\n\r\n![image](https://user-images.githubusercontent.com/715038/145474341-04ec3e37-52ba-4f2a-b168-4dda96e11b9e.png)\r\n\r\nIn this solution, there are 100 projects. The state file generated by RAR for one project (the red part `LibChild1_0.csproj.AssemblyReference.cache` in the picture) takes  85KB. Multiply by 100 and msbuild is basically loading/saving 8.5MB just for assembly references, while all these references are the same in my projects. While with a shared approach, it could basically reduce this data to less than 100KB for all the projects.\r\n\r\nOne challenge is that regular msbuild projects don't have a place for a shared build folder (e.g like the top level folder `.vs` used by Visual Studio for caching).",
        "createdAt": "2021-12-09T21:04:25Z",
        "updatedAt": "2021-12-09T21:04:25Z",
        "author": {
          "login": "xoofx"
        }
      },
      {
        "body": "Consider a cheap in-proc optimization:\r\n\r\nonce we read the info of a .dll on disk, cache it using the full path + timestamp as the key (in a static dictionary). Next time we need to read .dll info, check the file path and timestamp and if we've read it before, just return the info.\r\n\r\nThis will only cache per node, and will invalidate if the timestamp changes, but seems like very easy to implement and gets us significant wins so we don't need to read metadata for the same .dll repeatedly.",
        "createdAt": "2022-05-13T21:06:46Z",
        "updatedAt": "2022-05-13T21:06:46Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Need this for RAR as well as `ResolvePackageFileConflicts` as well as others potentially. `ResolvePackageFileConflicts` is slow and not incremental.",
        "createdAt": "2022-05-13T21:07:25Z",
        "updatedAt": "2022-05-13T21:07:25Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "The SDK's assembly resolution is presumably done in dotnet.dll, whereas RAR is in msbuild.dll. Would they be able to communicate, or were you just thinking of speeding up dotnet.dll's tasks?",
        "createdAt": "2022-05-13T21:51:03Z",
        "updatedAt": "2022-05-13T21:51:03Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Each can have their own independent cache, but we'd want to speed up both.",
        "createdAt": "2022-05-14T00:12:25Z",
        "updatedAt": "2022-05-14T00:12:25Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "If there are concerns about the DLL changing over time, the MVID can be read quickly from the first bytes of the DLL.",
        "createdAt": "2022-05-14T02:00:51Z",
        "updatedAt": "2022-05-14T02:00:51Z",
        "author": {
          "login": "drewnoakes"
        }
      },
      {
        "body": "I think a timestamp is good enough and won't require reading the file at all. If the timestamp has changed we can just bypass the cache and do what we'd normally do.\r\n\r\nBut yeah, I benchmarked reading MVID a while back:\r\nhttps://github.com/KirillOsenkov/MetadataTools/blob/main/src/PEFile/MvidBenchmark.cs",
        "createdAt": "2022-05-14T03:48:02Z",
        "updatedAt": "2022-05-14T03:48:02Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "We looked at this with a few people on the team and decided it isn't an avenue worth pursuing. Only one SDK task actually resolves similar data to RAR, and that one task only does so for a few assemblies per build, so merging the cache infrastructure would likely be more work than it's worth.",
        "createdAt": "2022-08-23T16:21:49Z",
        "updatedAt": "2022-08-23T16:21:49Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  }
}