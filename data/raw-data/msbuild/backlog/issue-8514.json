{
  "number": 8514,
  "title": "[Bug]: Assembly Microsoft.Build.Framework loaded twice",
  "body": "### Issue Description\r\n\r\nHey there,\r\n\r\nI am currently trying to include MSBuild with my application. Unfortunately I deem that necessarry in favor of having users install the .NET SDK or Visual Studio. I've got that working in Visual Studio during debugging, here everything works fine.\r\n\r\nMy issue is, as the title says, tha Microsoft.Build.Framework gets loaded twice actually, into the same host context, that being the default one. I do not know if this issue is related to MSBuild directly or if it does have its root in the .NET runtime, but I'll try my luck here to see if there's any difference between my two environments in which this issue has its differences.\r\n\r\nThe reason I'm talking about two environments is that I am hosting the .NET application myself, I have a native host application that invokes the CoreCLR and runs my code, which in turn tries to invoke MSBuild. Running the code from that native host causes the issue to arise, and in my debugging environment which is started using Visual Studio I have no issues.\r\n\r\n### Steps to Reproduce\r\n\r\nUpdate: I have made a repository reproducing the issue. It is found [here](https://github.com/MansenC/TwiceLoadedAssemblyIssue). Note that this only works on Windows since I am using a Windows machine.\r\n\r\nI am not quite sure if it is easily reproducible or if that even does help. I have not tested this thusfar, but I expect it goes as follows: Create a native host for some C# code that is \"started\" using hostfxr_initialize_for_dotnet_command_line_fn. In one of the calls to said C# code, start a build using the `BuildManager.DefaultBuildManager` (this is where the first assembly load occurrs), create a new `MSBuild.Project` instance (this is where the assembly gets loaded a second time), and then try to restore the project.\r\n\r\nThe restore fails here, due to the error message `WarnForInvalidProjectsTask could not be instantiated from assembly`. Now, don't be too excited, this is an error message that has arised before when there had been version conflicts between Visual Studio, MSBuild and ReSharper all using a different version of the `NuGet.Build.Tasks.dll` file. This is unfortunately not the case. I really suspect that the duplicated assembly is the root cause of this issue here.\r\n\r\n### Expected Behavior\r\n\r\nThe restore task succeeds and no assembly is loaded twice\r\n\r\n### Actual Behavior\r\n\r\nThe assembly gets loaded twice, and thus, no NuGet task can be casted to MSBuild.Framework.ITask\r\n\r\n### Analysis\r\n\r\nAs stated above, I know where both assemblies get loaded. And it's quite odd. The first time the assembly gets loaded is implicitly through .Net - when the function gets called that starts my build, or in other words, the first time I use any class that in itself references the `Microsoft.Build.Framework` namespace and thus that DLL. The call is made through `System.Runtime.Loader.AssemblyLoadContext.Resolve` as expected, and this is the only time the DLL is loaded in Visual Studio, too. This is the correct call and the only call that should load this assembly.\r\n\r\nThe second time the assembly is loaded is from a call to `Microsoft.Build.Evaluation.Project..ctor`. When I construct the new instance of Project, the following stacktrace is produced when I listen on OnAssemblyLoad:\r\n```\r\n   at System.Reflection.RuntimeAssembly.GetExportedTypes()\r\n   at System.Reflection.Assembly.get_ExportedTypes()\r\n   at Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader.GetResolverTypes(Assembly assembly)\r\n   at Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader.LoadResolvers(String resolverPath, LoggingContext loggingContext, ElementLocation location, List`1 resolvers)\r\n   at Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader.LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)\r\n   at Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.GetResolvers(IList`1 resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\r\n   at Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.ResolveSdkUsingResolversWithPatternsFirst(Int32 submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, String solutionPath, String projectPath, Boolean interactive, Boolean isRunningInVisualStudio)\r\n   at Microsoft.Build.BackEnd.SdkResolution.SdkResolverService.ResolveSdk(Int32 submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, String solutionPath, String projectPath, Boolean interactive, Boolean isRunningInVisualStudio)\r\n   at Microsoft.Build.BackEnd.SdkResolution.CachingSdkResolverService.<>n__0(Int32 submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, String solutionPath, String projectPath, Boolean interactive, Boolean isRunningInVisualStudio)\r\n   at Microsoft.Build.BackEnd.SdkResolution.CachingSdkResolverService.<>c__DisplayClass3_0.<ResolveSdk>b__2()\r\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\r\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.get_Value()\r\n   at Microsoft.Build.BackEnd.SdkResolution.CachingSdkResolverService.ResolveSdk(Int32 submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, String solutionPath, String projectPath, Boolean interactive, Boolean isRunningInVisualStudio)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(String directoryOfImportingFile, ProjectImportElement importElement, List`1& projects, SdkResult& sdkResult, Boolean throwOnFileNotExistsError)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.ExpandAndLoadImports(String directoryOfImportingFile, ProjectImportElement importElement, SdkResult& sdkResult)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.EvaluateImportElement(String directoryOfImportingFile, ProjectImportElement importElement)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)\r\n   at Microsoft.Build.Evaluation.Evaluator`4.Evaluate()\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.Reevaluate(ILoggingService loggingServiceForEvaluation, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(ILoggingService loggingServiceForEvaluation, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(ILoggingService loggingServiceForEvaluation, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.ReevaluateIfNecessary(EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project.ProjectImpl.Initialize(IDictionary`2 globalProperties, String toolsVersion, String subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)\r\n   at Microsoft.Build.Evaluation.Project..ctor(ProjectRootElement xml, IDictionary`2 globalProperties, String toolsVersion, String subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)\r\n   at Microsoft.Build.Evaluation.Project..ctor(ProjectRootElement xml, IDictionary`2 globalProperties, String toolsVersion, String subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)\r\n   at Microsoft.Build.Evaluation.Project..ctor(ProjectRootElement xml, IDictionary`2 globalProperties, String toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)\r\n   at Microsoft.Build.Evaluation.Project..ctor(ProjectRootElement xml, IDictionary`2 globalProperties, String toolsVersion, ProjectCollection projectCollection)\r\n```\r\nUnfortunately, it seems like GetExportedTypes is implemented in non-C# code, which means it doesn't come up in the stacktrace retreived by `Environment.StackTrace`. The assembly is the exact same. It doesn't equal in code since it's a new instance, but it's the same path, same name, same version, same everything. And this is bad.\r\n\r\nI don't think there's any way to fix that per say in here, but since it doesn't happen when I use Visual Studio as the runtime environment, there has to be a difference somewhere that prevents this from happening, and maybe someone here has an idea what that difference may be\r\n\r\nUpdate: I have now found out some new things. First of all, a low hanging fruit to check was if any environment variabels differ. They don't, or at least don't matter. Additionally I have gone ahead and modified the `Microsoft.Build.dll` to print what is happening following the stacktrace of the second load. `GetExportedTypes` gets called on the dll `Microsoft.Build.NuGetSdkResolver`.\r\n\r\n### Versions & Configurations\r\n\r\nI am using .NET Core 6.0.201 with Visual Studio 22 and the following MSBuild (-related) NuGet packages:\r\n- Microsoft.Build.Locator 1.4.1\r\n- Microsoft.Build.NuGetSdkResolver 5.11.0-rc.10\r\n- Microsoft.Build.Runtime 17.3.2\r\n- NuGet.Build.Tasks 6.5.0\r\n\r\nAll this on Windows 11 x64.\r\n\r\nThank you in advance",
  "state": "CLOSED",
  "createdAt": "2023-03-01T19:34:26Z",
  "updatedAt": "2023-03-02T20:53:07Z",
  "closedAt": "2023-03-02T20:53:07Z",
  "author": {
    "login": "MansenC"
  },
  "labels": [
    "bug",
    "needs-triage"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "Closing this here since this is not an issue with MSBuild but with the CoreCLR/hostfxr",
        "createdAt": "2023-03-02T20:53:07Z",
        "updatedAt": "2023-03-02T20:53:07Z",
        "author": {
          "login": "MansenC"
        }
      }
    ]
  }
}