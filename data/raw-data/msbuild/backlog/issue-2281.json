{
  "number": 2281,
  "title": "Add support for non-string assembly attributes",
  "body": "_From @AmadeusW on July 11, 2017 16:44_\n\nThere should be a way to generate non-string assembly attributes.\r\nFor example,\r\n```xml\r\n  <ItemGroup>\r\n    <AssemblyAttribute Include=\"System.CLSCompliant\">\r\n      <_Parameter1>true</_Parameter1>\r\n    </AssemblyAttribute>\r\n  </ItemGroup>\r\n```\r\ngenerates\r\n```csharp\r\n[assembly: System.CLSCompliant(\"true\")]\r\n```\r\nwhich produces an error, because the parameter must be a boolean.\r\n\r\n* Are there any workarounds so that I can produce a correct attribute with msbuild today?\r\n* Would you take a PR to fix this?\r\n* If this is not the correct place to raise this issue, I'm sorry, but in the entirety of searchable internet, this repo is the closest to dealing with assembly attributes.\n\n_Copied from original issue: dotnet/sdk#1402_",
  "state": "CLOSED",
  "createdAt": "2017-07-11T20:34:53Z",
  "updatedAt": "2024-02-21T17:18:07Z",
  "closedAt": "2021-04-08T16:08:48Z",
  "author": {
    "login": "rainersigwald"
  },
  "labels": [
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "_From @dasMulli on July 11, 2017 20:26_\n\nOn Slack, a few ppl asked how to set `ComVisibleAttribute` using an `<AssemblyAttribute>` item for `net*` projects.",
        "createdAt": "2017-07-11T20:34:53Z",
        "updatedAt": "2017-07-11T20:34:53Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I'm searching for `AssemblyAttribute` in this repo and can't find any code with it. Where are the tasks that define this attribute?",
        "createdAt": "2017-07-11T20:45:40Z",
        "updatedAt": "2017-07-11T20:45:40Z",
        "author": {
          "login": "AmadeusW"
        }
      },
      {
        "body": "(sorry, got distracted while writing this explanation of why this is the right place for this)\r\n\r\nThis is the right home for this issue, because it's a feature request for the [`WriteCodeFragment`](https://github.com/Microsoft/msbuild/blob/7b9ebbae516f7a9b19e6b4de195a648073bf3ab9/src/Tasks/WriteCodeFragment.cs) task that [consumes the `AssemblyAttribute` items](https://github.com/Microsoft/msbuild/blob/7b9ebbae516f7a9b19e6b4de195a648073bf3ab9/src/Tasks/Microsoft.Common.CurrentVersion.targets#L3234-L3237) and emits code.\r\n\r\nThere's no way to do this currently. You can always add a standard `.cs` file that defines the attribute you want.\r\n\r\nWhy do you want to do this with MSBuild instead of C#? I'm not totally opposed to the idea but would rate it as pretty low-priority.",
        "createdAt": "2017-07-11T20:53:47Z",
        "updatedAt": "2017-07-11T20:53:47Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I'd like to do it with MSBuild for consistency with other attributes that we're defining. \r\n\r\nAlso, the snippet you pointed at refers to `@(AssemblyAttributes)` (plural) - is there some code that automatically maps singular and plural form of an XML tag to this code path?",
        "createdAt": "2017-07-11T20:56:51Z",
        "updatedAt": "2017-07-11T20:56:51Z",
        "author": {
          "login": "AmadeusW"
        }
      },
      {
        "body": "You're right, I was pointing to the wrong implementation. The one you care about is [in the Sdk](https://github.com/dotnet/sdk/blob/a4bceb67b160c72318a581d87d52796e4fa31794/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.GenerateAssemblyInfo.targets#L119-L122).\r\n\r\nI'd be interested in seeing proposals for how to carry the metadata needed to make this possible. It's already very ugly with `_Parameter1` -- having something like `_Parameter1_Type` that maps to a fixed list of known types in `WriteCodeFragment` seems bad.",
        "createdAt": "2017-07-11T21:57:44Z",
        "updatedAt": "2017-07-11T21:57:44Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Team Triage:\r\nClosing this as won't fix. This would be difficult to implement (map literal to type) and a fairly easy workaround (use a C# file). If this becomes a more frequent ask we could revisit this in the future.",
        "createdAt": "2017-07-11T22:34:50Z",
        "updatedAt": "2017-07-11T22:34:50Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "Sorry for being late to the party on this. I know it's closed, but I think it's worth considering reopening. In my opinion, this can be achieved very easily without breaking the existing behavior or requiring complex, brittle parameter _magic_.\r\n\r\n## Background\r\nMost of the attributes that used to be placed in code files (ex: AssemblyInfo) have been replaced with first-class equivalents in MSBuild 15.0, save a handful of outliers. To my knowledge the following attributes do not have built-in build properties in MSBuild 15.0:\r\n\r\n* System.CLSCompliantAttribute\r\n* System.Reflection.AssemblyTrademarkAttribute\r\n* System.Runtime.InteropServices.ComVisibleAttribute\r\n\r\nThe **AssemblyTrademarkAttribute** can use the existing **AssemblyAttribute** build items, but the others cannot because they are not of type `String`.\r\n\r\nWhile it's true that this limitation can be mitigated with a linked or dynamically generated code file, it would be far more preferable to have it supported as a first-class citizen. In large solutions, this information would typically be placed or imported into **directory.build.props**.\r\n\r\n## Proposed Solution\r\nTo enable this scenario, the existing implementation just needs to not wrap the provided value in double quotes. There currently is no validation on the input value matching the attributes because the compiler will handle that automatically; therefore, there is no need to include or otherwise formally support type semantics.\r\n\r\nTo achieve this behavior without breaking the existing behavior, I propose you simply add one new, optional metadata element - **IsLiteral** (Boolean). The default value will be `false` and continue to have the current behavior. Items which are marked as `IsLiteral=\"true\"` will forego wrapping the value with double quotes. In a scenario where there are multiple parameters where some must be literal and others require double quotes, the developer can explicitly provide the `&quot;` escape sequence as necessary\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"System.CLSCompliantAttribute\" IsLiteral=\"true\" _Parameter1=\"true\" />\r\n</ItemGroup>\r\n```\r\n```c#\r\n[assembly: System.CLSCompliant(true)]\r\n```\r\n_Figure 1: Using IsLiteral to omitted surrounding quotes_\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"System.Reflection.AssemblyTrademarkAttribute\"\r\n                     IsLiteral=\"true\"\r\n                     _Parameter1=\"&quot;My Company&quot;\" />\r\n</ItemGroup>\r\n```\r\n```c#\r\n[assembly: System.Reflection.AssemblyTrademarkAttribute(\"My Company\")]\r\n```\r\n_Figure 2: Using IsLiteral to with user-defined double quotes_\r\n\r\n## Benefits\r\nIn addition to these basic scenarios, this approach would enable more advanced scenarios without additional modification. Consider a scenario where a developer would specify the attribute for an OWIN startup class. Today, this is often in the assembly information file (*.cs, *.vb, etc) or it is placed in an arbitrary file (ex: Startup.cs). This new support would allow it to go into a *.props file or the *.*proj directly.\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"Microsoft.Owin.OwinStartup\"\r\n                     IsLiteral=\"true\"\r\n                     _Parameter1=\"typeof(Microsoft.Examples.Startup)\" />\r\n</ItemGroup>\r\n```\r\n```c#\r\n[assembly: Microsoft.Owin.OwinStartup(typeof(Microsoft.Examples.Startup))]\r\n```\r\n_Figure 3: Using IsLiteral to insert an arbitrarily supported value such as a type_",
        "createdAt": "2018-01-09T20:28:02Z",
        "updatedAt": "2018-01-09T20:28:02Z",
        "author": {
          "login": "commonsensesoftware"
        }
      },
      {
        "body": "I do like this suggestion. Doing it in msbuild may still be beneficial in situations where a Directory.Build.* file is easier to use than shared AssemblyInfo.cs files.\r\n\r\nI'd just argue that a name like `TreatParametersAsLiterals` is a bit more descriptive.",
        "createdAt": "2018-01-09T20:37:43Z",
        "updatedAt": "2018-01-09T20:37:43Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "There any number of possible names:\r\n\r\n* IsQuoted (reverse to default to true)\r\n* OmitQuotes\r\n* OmitDoubleQuotes\r\n* RemoveQuotes\r\n* ...\r\n\r\nI'm good with any name if it lands. While I can certainly appreciate schedule, this shouldn't require a large development effort at all to implement (IMHO). If the team approves the feature and can agree on a suitable metadata item name, I get the impression there are multiple folks in the community that would submit a PR for this.",
        "createdAt": "2018-01-09T21:37:40Z",
        "updatedAt": "2018-01-09T21:37:40Z",
        "author": {
          "login": "commonsensesoftware"
        }
      },
      {
        "body": "Actually, this came up with us today. We would like to mark all of our sdk-style projects as ComVisible false, and adding an AssemblyInfo.cs to every project (even implicitly) instead of adding a property into a shared `.props` file doesn't feel good.",
        "createdAt": "2018-01-17T09:50:05Z",
        "updatedAt": "2018-01-17T09:50:05Z",
        "author": {
          "login": "onyxmaster"
        }
      },
      {
        "body": "Proof-of-concept: https://github.com/Microsoft/msbuild/compare/master...dasMulli:feature/literal-code-fragment\r\n\r\nWill allow e.g.:\r\n```xml\r\n  <ItemGroup>\r\n    <AssemblyAttribute Include=\"System.Runtime.InteropServices.ComVisibleAttribute\">\r\n      <_Parameter1>false</_Parameter1>\r\n      <_Treat_Parameter1AsLiteral>true</_Treat_Parameter1AsLiteral>\r\n    </AssemblyAttribute>\r\n  </ItemGroup>\r\n```\r\n\r\n@rainersigwald does this seem reasonable?",
        "createdAt": "2018-01-18T18:01:08Z",
        "updatedAt": "2018-01-18T18:01:08Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "@dasMulli we'll see what @rainersigwald  says. I think you've proven that this can work and isn't terribly complex. However, IMHO having an additional metadata item for every parameter is overkill. My proposal and continued position is that you only need a single metadata item (called `[insert name]` = `true | false`). Either all of the parameters are literal or none of them are. In 90%+ of the cases, there is only a single parameter anyway. Of the remaining 10%, there are very few parameter combinations where they aren't all the same type (e.g. all strings, integers, etc). As I demonstrated above, it's possible to achieve a _mixed_ combination by providing your own quoting.\r\n\r\nNice work putting this together. Hopefully that will grab the attention of the team and get them to roll it in.",
        "createdAt": "2018-01-18T18:12:26Z",
        "updatedAt": "2018-01-18T18:12:26Z",
        "author": {
          "login": "commonsensesoftware"
        }
      },
      {
        "body": "Happy to turn it into a proper PR whatever the decision.\r\n\r\nfyi I can see myself porting stuff to SDK-based csproj that needs\r\n```c#\r\n[assembly: log4net.Config.XmlConfigurator(ConfigFileExtension=\"log4net\",Watch=true)]\r\n```\r\nfor all executables, so a `Directory.Build.targets` with an item group conditioned on `$(OutputType)` would be easiest her.",
        "createdAt": "2018-01-18T18:26:37Z",
        "updatedAt": "2018-01-18T18:29:17Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "@dasMulli this looks great. \r\n@commonsensesoftware raises a good point that user can mix literals and strings by using a single parameter `IsLiteral` (or `LiteralParameters`?) and quotes around what's meant to be strings.\r\n\r\nI'm not sure what you mean about porting stuff to SDK-based projects and log4net, but I'd recommend making a minimal PR to increase its chances of getting merged.",
        "createdAt": "2018-01-18T18:42:56Z",
        "updatedAt": "2018-01-18T18:43:08Z",
        "author": {
          "login": "AmadeusW"
        }
      },
      {
        "body": "For what it's worth, I don't think introducing support for literals in the WriteCodeFragment task is coherent with the initial design. Let's not forget that the task allows a `Language` attribute which is supposed to establish in which language the code is written. This - and this alone - should know about the appropriate syntax to use when it comes to passing parameter values.\r\n\r\nI do agree though that it would be convenient to use the task to write common boolean attributes such as ComVisible and CLSCompliant.\r\n\r\nAFAIK, MSBuild _does_ recognize boolean expressions as such. Therefore, shouldn't the WriteCodeFragment task already have everything it needs to _at least_ support both string and boolean parameters?\r\n\r\nFixing just this would go a long way already, IMHO.",
        "createdAt": "2018-08-31T01:29:05Z",
        "updatedAt": "2018-08-31T01:29:05Z",
        "author": {
          "login": "Crono1981"
        }
      },
      {
        "body": "One of the problems would be recognising when to use bools, strings or something else. You could define a custom attribute class in custom code and let `WriteCodeFragment` emit some instances.\r\n\r\nFor \"literal arguments\", I'd assume that the literal matches the language used. If you switch between VB and C#, you may need to change the literal arguments to `WriteCodeFragment`.",
        "createdAt": "2018-08-31T05:04:03Z",
        "updatedAt": "2018-08-31T05:04:03Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "Retorting to @AndyGerlicher's \"won't fix\" assessment\r\n\r\n> This would be difficult to implement\r\n\r\n@dasMulli proved this is not at all complex \r\n\r\n> and a fairly easy workaround (use a C# file)\r\n\r\nit's a real messy workaround when your solution has 143 projects and you try to nicely manage them with Directory.Build.targets",
        "createdAt": "2018-08-31T16:34:37Z",
        "updatedAt": "2018-08-31T16:34:37Z",
        "author": {
          "login": "AmadeusW"
        }
      },
      {
        "body": "> it's a real messy workaround when your solution has 143 projects and you try to nicely manage them with Directory.Build.targets\r\n\r\nAgreed. Though it may not be as nice since the proposed change couples the target files to the language used - even just for C# and VB there's a difference between `false` and `False`.\r\nBut still better than having to manage some c# files, esp. if the values shall be autogenerated.\r\n\r\nThe workaround at the moment would be to have some files `build\\NotComVisble.cs` and in the `Directory.Build.targets` adding `$(MSBuildThisFileDirectory)build\\NotComVisible.cs` somewhere.",
        "createdAt": "2018-08-31T17:35:19Z",
        "updatedAt": "2018-08-31T17:35:19Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "@Crono1981 I couldn't disagree more with:\r\n> _... I don't think introducing support for literals in the WriteCodeFragment task is coherent with the initial design_\r\n\r\nIf it's not coherent, then the name of the task is horribly wrong. I'm going out on a limb here, but I think most people would interpret _Write Code Fragment_ as just that. Granted, that doesn't mean the task can write _any_ code, but it certainly doesn't say _Write String Only Fragment_, _Write Attribute_, or something like that.\r\n\r\nThe expectation for the use of literals should be that of the author; otherwise, _caveat emptor_. If multi-targeting languages is something that is required, then obviously that's something the author needs to bake into their targets. As you suggest, using a language discriminator can easily be used to do this:\r\n\r\n```xml\r\n<ItemGroup Condition=\" '$(Language)' == 'C#' \">\r\n  <AssemblyAttribute Include=\"System.CLSCompliantAttribute\" IsLiteral=\"true\" _Parameter1=\"true\" />\r\n  <AssemblyAttribute Include=\"System.ComVisibleAttribute\" IsLiteral=\"true\" _Parameter1=\"true\" />\r\n</ItemGroup>\r\n\r\n<ItemGroup Condition=\" '$(Language)' == 'VB' \">\r\n  <AssemblyAttribute Include=\"System.CLSCompliantAttribute\" IsLiteral=\"true\" _Parameter1=\"True\" />\r\n  <AssemblyAttribute Include=\"System.ComVisibleAttribute\" IsLiteral=\"true\" _Parameter1=\"True\" />\r\n</ItemGroup>\r\n```\r\n\r\nBut even that is probably a non-issue because these items would already be split out into language-specific targets.\r\n\r\n\r\n@dasMulli you're right. There shouldn't be any _interpretation_ of what the literal means. This would add unnecessary complexity. This complexity already exists to some degree because C# and VB have different string escaping rules. You can see this complexity in the task source code. Mistakes in the literal should the onus of the author.\r\n\r\nA possible compromise would be limiting literal values to specific types of primitives, which would be neutral across languages; for example, Boolean and numbers. You _could_ fallback to the least common denominator as necessary. VB is not case-sensitive so `true` and `false` are still perfectly valid. Ultimately, I still think that would be limiting and add unnecessary complexity.\r\n\r\n@dasMulli, @AmadeusW the _messiness_ is real. It can get even messier when you have additional variability. For example, some projects (the main source) are CLS-compliant and others (say tests) are not. You then end up with something in `build\\SharedAssemblyInfo.cs` that looks like:\r\n\r\n```c#\r\n[assembly: ComVisible(false)]\r\n\r\n#if CLS_COMPLIANT\r\n[assembly: CLSCompliant(true)]\r\n#endif\r\n```\r\n\r\nAnd `Directory.Build.targets` that look like:\r\n\r\n```xml\r\n<ItemGroup>\r\n <Compile Include=\"$(MSBuildThisFileDirectory)SharedAssemblyInfo.cs\" Visible=\"false\" />\r\n</ItemGroup>\r\n\r\n<PropertyGroup>\r\n <ClsCompliant Condition=\" '$(ClsCompliant)' == '' \">true</ClsCompliant>\r\n <DefineConstants Condition=\" '$(ClsCompliant)' == 'true' \">$(DefineConstants);CLS_COMPLIANT</DefineConstants>\r\n</PropertyGroup>\r\n```",
        "createdAt": "2018-08-31T18:01:56Z",
        "updatedAt": "2018-08-31T18:01:56Z",
        "author": {
          "login": "commonsensesoftware"
        }
      },
      {
        "body": "Why was this closed exactly? Is there a solution to this now?",
        "createdAt": "2019-04-29T15:01:09Z",
        "updatedAt": "2019-04-29T15:01:09Z",
        "author": {
          "login": "jessekingf"
        }
      },
      {
        "body": "I think this should be reopened since it's still an issue. The only solution ATM would be to write a custom target to generate another Assembly.cs (see last line of this duplicate issue's comment: https://github.com/Microsoft/msbuild/issues/3412#issuecomment-397638805)",
        "createdAt": "2019-05-29T00:58:08Z",
        "updatedAt": "2019-05-29T00:58:08Z",
        "author": {
          "login": "simplexidev"
        }
      },
      {
        "body": "Almost certainly. It's a shame that this capability isn't available just yet, as this was a feature I was looking into implementing to provide custom attributes to the AssemblyInfo.cs\r\n\r\nHopefully this is reconsidered and implemented.",
        "createdAt": "2019-08-15T19:18:41Z",
        "updatedAt": "2019-08-15T19:18:41Z",
        "author": {
          "login": "jamesmcroft"
        }
      },
      {
        "body": "@jamesmcroft:\r\n> Hopefully this is reconsidered and implemented.\r\n\r\nI would at least like to see it put in a backlog, as this is still a requested feature, with no 'good' workarounds, as I would love remove my basic `AssemblyInfo.cs` file and just incorporate it into my MSBuild files.\r\n\r\n@AndyGerlicher @rainersigwald Is there anyway this could be reopened and re-triaged? The issue was closed over 2 years ago, and seems to have picked up more support from when it was opened originally. If not, would it be appropriate to open a new issue?\r\n\r\n**EDIT**: Here is a copy of the comment (from @AndyGerlicher) with the original triage review, and why it was originally closed:\r\n\r\n> Team Triage:\r\n> Closing this as won't fix. This would be difficult to implement (map literal to type) and a fairly easy workaround (use a C# file). If this becomes a more frequent ask we could revisit this in the future.\r\n\r\n",
        "createdAt": "2019-08-15T19:56:59Z",
        "updatedAt": "2019-08-16T06:08:31Z",
        "author": {
          "login": "simplexidev"
        }
      },
      {
        "body": "Reopening to swap with #3412 \r\n\r\nThis is more possible now than before because the non-CodeDOM path could be removed (CodeDOM is now available on Core).\r\n\r\nI still don't prioritize it very highly personally, and I don't understand most of the pushback above on having source files that include the attributes. You could condition adding that `Compile` item on whatever you would have conditioned the attribute on.",
        "createdAt": "2019-08-15T20:08:38Z",
        "updatedAt": "2019-08-15T20:08:38Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> Reopening to swap with #3412\r\n\r\nThank you for that.  \r\n\r\n> I still don't prioritize it very highly personally, and I don't understand most of the pushback above on having source files that include the attributes. You could condition adding that `Compile` item on whatever you would have conditioned the attribute on.\r\n\r\nYes, that is definitely the reasonable approach (as I do [here](https://github.com/tom-corwin/tcdfx/blob/ccef0febd43b345d07500b9cdcbeba07b02dbee0/sources/Directory.Build.targets#L12-L26), minus the conditions).\r\n\r\nI personally think it would be easier to be able to place assembly attributes in a file I already have, rather than have a second one for them. Also, I would be able to use my MSBuild properties as parameters for the attributes.\r\n",
        "createdAt": "2019-08-15T20:42:10Z",
        "updatedAt": "2019-08-15T20:42:10Z",
        "author": {
          "login": "simplexidev"
        }
      },
      {
        "body": "> I still don't prioritize it very highly personally, and I don't understand most of the pushback above on having source files that include the attributes. You could condition adding that Compile item on whatever you would have conditioned the attribute on.\r\n\r\nI imagine that personally you're well versed in msbuild and have no issues understanding .csproj files which are very dense with items and conditions. For the majority of folks, dealing with .csproj, msbuild and other infrastructure is an unnecessary pain. A lot of us will be very happy with simplifications to .csproj. Please prioritize the issue according to everyday users and not expert maintainers like yourself.",
        "createdAt": "2019-08-15T21:32:10Z",
        "updatedAt": "2019-08-15T21:32:10Z",
        "author": {
          "login": "AmadeusW"
        }
      },
      {
        "body": "> Please prioritize the issue according to everyday users and not expert maintainers like yourself.\r\n\r\nMy concern about this feature is that it feels _much_ more complex than using C# code (where the attribute syntax is well established and documented) + simple MSBuild conditions. Look at the examples of how this would have to be implemented in MSBuild in the proposals above. How would you debug a problem arising from lack of, say `_Treat_Parameter1AsLiteral`?\r\n\r\nThe simplest implementation that's possible today (include an `AssemblyInfo.cs` file in your project) is very user-visible, if sometimes more verbose than ideal. Throwing code generation into the mix is not an obvious win from a maintainability/understandability standpoint IMO.",
        "createdAt": "2019-08-16T15:27:29Z",
        "updatedAt": "2019-08-16T15:27:29Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald, I agree that this _could_ easily be over-engineered and made complex, but it doesn't _have_ to be. There a several workable proposals here. Pardon my own bias, but I'm merely suggesting an _All or Nothing_ approach using the single, Boolean metadata item **IsLiteral** per attribute, regardless of how many parameters there. This couldn't be any more straight forward to implement. Either **all** of the parameters are literal, including all of their required escaping, formatting, etc, with the onus on the author or they're not, which is the same behavior as today. Yes - you _could_ have a configuration per each parameter, but that would be clunky and make any sane person's eyes bleed.\r\n\r\nYour assertion that you can simply include or link files into a project is a workable solution and is what I suspect most people are doing today, but it's incongruent with how other build aspects are achieved. Your argument would hold weight if this task didn't exist at all, but it does. I don't think anyone here is asking for full, arbitrary code generation, but why should we have to set some standard assembly attributes purely through MSBuild and others through a hodgepodge of duplicated or linked source files?\r\n\r\nNow that I've worked with .NET SDK style projects for a couple of years, I can say that the **only** time I ever use `AssemblyInfo.cs` is to address this problem; otherwise, my solutions and projects simply do not have it anymore. I can also say that - historically, the `AssemblyInfo.cs` file has been a PIA because a number of input values are variable in a build such as the version number, strong-naming, etc. This has lead to numerous custom build extensions and community build tasks to address the problem. It stands to reason that those same issues are why this built-in task was created in the first place. I think I speak for everyone when I say we're just looking for a consistent, out-of-the-box way to define all assembly-level attributes in one or more projects though MSBuild.\r\n\r\nFor an experienced MSBuild user such as myself, this lack of capability is merely an inconvenience. On the other hand, it's not that hard for me to see that for a less experienced person setting up file linking or shared projects in a solution with more than a few projects could be quite a pain.",
        "createdAt": "2019-08-16T16:16:40Z",
        "updatedAt": "2019-08-16T16:16:40Z",
        "author": {
          "login": "commonsensesoftware"
        }
      },
      {
        "body": "Unlike most of the folks in this thread, I am _not_ an experienced MSBuild user.  I'm trying to update an existing legacy `.csproj` file to the new SDK format, so that my class library can target multiple frameworks.\r\n\r\nWhat is the suggested way to express `[assembly: ComVisible(false)]` and `[assembly: System.CLSCompliant(true)]` in the new VS2017/VS2019 `.csproj` file format, given the fact that there's no support for literal values when using `<AssemblyAttribute>`?  This ticket was originally closed in July 2017 with a suggested workaround (\"_use a C# file_\"), but that does nothing for me.  Nor can I find anything on StackOverflow or docs.microsoft.com that would help me understand where to create this file and what would go in it.",
        "createdAt": "2019-08-21T13:38:38Z",
        "updatedAt": "2019-08-21T13:38:38Z",
        "author": {
          "login": "ghost"
        }
      },
      {
        "body": "@jehrenzweig If you're changing an existing project, I would expect a `Properties\\AssemblyInfo.cs` to already exist. You can place those lines there.\r\n\r\nIf you don't already have such a file, I would recommend creating a new file named `AssemblyInfo.cs` in your project (the name is not important but this matches convention) and adding the attributes there. That is essentially what we do in this repo:\r\n\r\nhttps://github.com/microsoft/msbuild/blob/3885a205f40944174a3e14396547f13db1196b82/src/Build/AssemblyInfo.cs#L42-L43\r\n\r\nThe best documentation on this I could find was [Applying Attributes at the Assembly Level](https://docs.microsoft.com/en-us/dotnet/standard/attributes/applying-attributes#applying-attributes-at-the-assembly-level). I agree that it might be nice to link to that from `ComVisible` and `ClsCompliant` pages, which are commonly applied to the whole assembly. Are you interested in filing a doc bug to that effect?",
        "createdAt": "2019-08-21T14:36:43Z",
        "updatedAt": "2019-08-21T14:36:43Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I thought I left a comment days ago but maybe I forgot to finish writing/sending it or can't find it now..\r\n\r\nI think at some point there was a talk about asking roslyn to implement a compiler feature that would let you specify assembly attributes directly as input to the compiler. This would also fix the need for creating temporary source code files, which esp. for the target framework attribute can be quite a pain.",
        "createdAt": "2019-08-21T14:41:30Z",
        "updatedAt": "2019-08-21T14:41:30Z",
        "author": {
          "login": "dasMulli"
        }
      },
      {
        "body": "@rainersigwald Yep, my legacy projects each contain a `Properties\\AssemblyInfo.cs` file, and they do exactly what you mentioned wrt `[assembly: ComVisible(false)] ` and `[assembly: CLSCompliant(true)]`.  \r\n\r\nHowever, I assumed that as part of modernizing my `.csproj` files, I should transition away from the use of this static file and instead declare equivalent nodes in the new `.csproj` file, then set `<GeneratePackageOnBuild>true</GeneratePackageOnBuild>` to ensure that an equivalent file is generated in the `/obj` folder when the project is built.  What I'm hearing in this thread is leading me to believe I should keep the static `AssemblyInfo.cs` as-is... or am I mistaken?\r\n\r\nI'd be happy to file a doc bug.  However, I've never done that before... how do I get that started?",
        "createdAt": "2019-08-21T16:47:16Z",
        "updatedAt": "2019-08-21T16:47:31Z",
        "author": {
          "login": "ghost"
        }
      },
      {
        "body": "This issue appears to have lost momentum, but it has come up for us recently. Is there a plan for this to move forward?",
        "createdAt": "2020-03-26T14:11:33Z",
        "updatedAt": "2020-03-26T14:11:33Z",
        "author": {
          "login": "TheXenocide"
        }
      },
      {
        "body": "I ran into this concern today as well, wanting to deduplicate declaring AWS's [LambdaSerializerAttribute](https://github.com/aws/aws-lambda-dotnet/blob/master/Libraries/src/Amazon.Lambda.Core/README.md#lambdaserializerattribute)",
        "createdAt": "2020-04-28T18:29:46Z",
        "updatedAt": "2020-04-28T18:29:46Z",
        "author": {
          "login": "hauntingEcho"
        }
      },
      {
        "body": "It would be pretty cool to get this.  otherwise I feel like I'm mixing old and new  patterns",
        "createdAt": "2020-05-15T19:16:16Z",
        "updatedAt": "2020-05-15T19:16:16Z",
        "author": {
          "login": "Frankwayne"
        }
      },
      {
        "body": "Why not `<CLSCompliant>True</CLSCompliant>`?",
        "createdAt": "2020-12-04T09:38:59Z",
        "updatedAt": "2020-12-04T09:38:59Z",
        "author": {
          "login": "JohanLarsson"
        }
      },
      {
        "body": "I would like to see this feature too, to be able to add NUnit attribute to configure tests that can be run in parallell\r\n\r\n`[assembly:NUnit.Framework.Parallelizable(NUnit.Framework.ParallelScope.Fixtures)]`",
        "createdAt": "2020-12-12T04:39:15Z",
        "updatedAt": "2020-12-12T04:39:15Z",
        "author": {
          "login": "Socolin"
        }
      },
      {
        "body": "I will add yet another voice in calling for this work to be done.\r\n\r\nHonestly, the current implementation feels like a poor design and a mistake. Enabling developers to add assembly attributes to the csproj with the current syntax and then _magically_ quoting the values that are generated is... not great. Magical quoting is not good and is an impediment to this syntax doing what it ought to do: replacing the old AssemblyInfo.cs files with a more modern, centralized place to configure your project. Why should I need to have both?\r\n\r\nWhat is the point of having `<AssemblyAttribute>` AT ALL in its current state when it's so limited? Why would you add syntax that allows assembly attributes to be configured in the csproj file, but ONLY make that syntax work for a small subset of attributes because you also added magical quoting to the values? Sorry for the rant, but this is frustrating.\r\n\r\nSo here's another use case I don't see mentioned: the ParallelizeAttribute for unit testing. Its constructor doesn't even take parameters so you have to specify them like this: `Parallelize(Workers = 6, Scope = ExecutionScope.MethodLevel)`\r\n\r\nIt would be really nice to be able to remove the AssemblyInfo files from our test projects and be able to specify this at the csproj level. But without having some functionality where the the `<_Parameter1>` and `<_Parameter2>` are inserted literally and not quoted this is completely impossible.\r\n\r\nDevelopers have been asking for this functionality for 3 years because the current implementation of `<AssemblyAttribute>` is poor. Please prioritize this. It's fine to say that AssemblyInfo.cs is well documented and people know how to use it. That doesn't make it GOOD. That just says to me that you have done a poor job of documenting `<AssemblyAttribute>` and that the tooling ought to be advertising it better. And it ought to actually WORK for all cases.",
        "createdAt": "2020-12-15T16:47:26Z",
        "updatedAt": "2020-12-15T16:49:25Z",
        "author": {
          "login": "hughesappsheet"
        }
      },
      {
        "body": "With the current state of CA1416 emitting incorrect platform warnings if you have any attributes defined in .cs files, this becomes a bigger issue (for us anyway!)",
        "createdAt": "2020-12-17T12:32:44Z",
        "updatedAt": "2020-12-17T12:32:44Z",
        "author": {
          "login": "ekgurney14"
        }
      },
      {
        "body": "It is rather easy to write a target that gets fairly close:\r\n\r\n```xml\r\n\r\n  <PropertyGroup>\r\n    <_LiteralAssemblyFile Condition=\"'$(Language)' == 'C#'\">$(IntermediateOutputPath)LiteralAssemblyAttributes.cs</_LiteralAssemblyFile>\r\n    <CoreCompileDependsOn>\r\n      AddLiteralAssemblyAttributes;\r\n      $(CoreCompileDependsOn);\r\n    </CoreCompileDependsOn>\r\n  </PropertyGroup>\r\n  \r\n  <Target Name=\"AddLiteralAssemblyAttributes\"\r\n          BeforeTargets=\"CoreCompile\"\r\n          Condition=\"'$(Language)' == 'C#'\"\r\n          Inputs=\"$(MSBuildAllProjects)\"\r\n          Outputs=\"$(_LiteralAssemblyFile)\">\r\n\r\n    <ItemGroup>\r\n      <Compile Include=\"$(_LiteralAssemblyFile)\" />\r\n    </ItemGroup>\r\n\r\n    <ItemGroup>\r\n      <_LiteralAssemblyAttrDecls Include=\"// &lt;autogenerated /&gt;\" />\r\n      <_LiteralAssemblyAttrDecls Include=\"extern alias %(LiteralAssemblyAttributeExternAlias.Identity);\"\r\n                                 Condition=\"'%(LiteralAssemblyAttributeExternAlias.Identity)' != ''\" />\r\n      <_LiteralAssemblyAttrDecls Include=\"[assembly: %(LiteralAssemblyAttribute.Identity)(%(LiteralAssemblyAttribute._Parameters))]\"\r\n                                 Condition=\"'%(LiteralAssemblyAttribute.Identity)' != ''\" />\r\n    </ItemGroup>\r\n\r\n    <WriteLinesToFile File=\"$(_LiteralAssemblyFile)\" Encoding=\"UTF-8\" Lines=\"@(_LiteralAssemblyAttrDecls)\" Overwrite=\"true\" />\r\n    \r\n  </Target>\r\n```\r\n\r\nThat implementation allows for any combination of attribute arguments, because it just drops the content of the `_Parameters` metadata into the parenthesis. It also allows you to utilize `extern alias`es.\r\n\r\nFor the specific case of `CLSCompliant`, using that would look like this:\r\n\r\n```xml\r\n  <ItemGroup>\r\n    <LiteralAssemblyAttribute Include=\"global::System.CLSCompliantAttribute\" Condition=\"'$(IsCLSCompliant)' != ''\">\r\n      <_Parameters>$(IsCLSCompliant)</_Parameters>\r\n    </LiteralAssemblyAttribute>\r\n  </ItemGroup>\r\n```\r\n\r\nIf the `IsCLSCompliant` property is set (no matter its value), the property will be applied.\r\n\r\nHaving something just like this, taking the entire parameter list, would be very useful to have in the SDK. Naturally, it would be specialized on language, but I don't think that the content of the parameter list is ever going to be very different between C# and VB, and most users are likely using only one or the other. I think its reasonable to just require users of this variant to specialize on the language currently being compiled.",
        "createdAt": "2020-12-18T13:24:20Z",
        "updatedAt": "2020-12-18T13:24:20Z",
        "author": {
          "login": "nike4613"
        }
      },
      {
        "body": "I got here while trying to address the [`CA1014`](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1014) warning for a brand new project. It's worth noting that another workaround is simply to suppress this warning.\r\n\r\n```xml\r\n<NoWarn>$(NoWarn);CA1014</NoWarn>\r\n```\r\n\r\nI'm not convinced that CA1014 is _obsolete_ (see [discussion](https://github.com/MicrosoftDocs/visualstudio-docs/issues/1417)). I would prefer an easy way to mark my assembly as CLS compliant, but if the cost of is maintaining a legacy `AssemblyInfo.cs` file for new projects, that's not worth it IMO.\r\n",
        "createdAt": "2021-02-21T16:42:40Z",
        "updatedAt": "2021-02-21T16:42:40Z",
        "author": {
          "login": "kmcclellan"
        }
      },
      {
        "body": "I've just created the pull request #6285 that would allow parameter types to be specified. It's similar to what has been mentioned in here, with a couple of improvements:\r\n1. It's mostly language-independent, so it will generate the correct code for C# and VB.NET. Literal values _may_ work across languages, but it depends on the exact syntax that is used (enums will work across both languages).\r\n2. If the attribute comes from `mscorlib`, the parameter types will be inferred, which means you don't need to specify any additional metadata. :tada:\r\n\r\nHere are some examples:\r\n\r\n_The original issue from @AmadeusW:_\r\n\r\n```xml\r\n<ItemGroup>\r\n    <AssemblyAttribute Include=\"System.CLSCompliantAttribute\">\r\n        <_Parameter1>true</_Parameter1>\r\n    </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nGenerates:\r\n```csharp\r\n[assembly: System.CLSCompliantAttribute(true)]\r\n```\r\nor\r\n```vb\r\n<Assembly: System.CLSCompliantAttribute(True)>\r\n```\r\n\r\n\r\n_`OwinStartup` example from @commonsensesoftware:_\r\n\r\n```xml\r\n<ItemGroup>\r\n    <AssemblyAttribute Include=\"Microsoft.Owin.OwinStartup\">\r\n        <_Parameter1>Microsoft.Examples.Startup</_Parameter1>\r\n        <_Parameter1_TypeName>System.Type</_Parameter1_TypeName>\r\n    </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nGenerates:\r\n```csharp\r\n[assembly: Microsoft.Owin.OwinStartup(typeof(Microsoft.Examples.Startup))]\r\n```\r\nor\r\n```vb\r\n<Assembly: Microsoft.Owin.OwinStartup(GetType(Microsoft.Examples.Startup))>\r\n```\r\n\r\n_log4net example from @dasMulli:_\r\n\r\n```xml\r\n<ItemGroup>\r\n    <AssemblyAttribute Include=\"log4net.Config.XmlConfigurator\">\r\n        <ConfigFileExtension>log4net</ConfigFileExtension> <!-- Parameters are still treated as strings by default -->\r\n        <Watch>True</Watch>\r\n        <Watch_TypeName>System.Boolean</Watch_TypeName>\r\n    </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nGenerates:\r\n```csharp\r\n[assembly: log4net.Config.XmlConfigurator(ConfigFileExtension=\"log4net\", Watch=true)]\r\n```\r\nor\r\n```vb\r\n<Assembly: log4net.Config.XmlConfigurator(ConfigFileExtension:=\"log4net\", Watch:=True)>\r\n```\r\n\r\n_nUnit example from @Socolin:_\r\n\r\n```xml\r\n<ItemGroup>\r\n    <AssemblyAttribute Include=\"NUnit.Framework.Parallelizable\">\r\n        <_Parameter1>NUnit.Framework.ParallelScope.Fixtures</_Parameter1>\r\n        <_Parameter1_IsLiteral>true</_Parameter1_IsLiteral>\r\n    </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nGenerates:\r\n```csharp\r\n[assembly: NUnit.Framework.Parallelizable(NUnit.Framework.ParallelScope.Fixtures)]\r\n```\r\nor\r\n```vb\r\n<Assembly: NUnit.Framework.Parallelizable(NUnit.Framework.ParallelScope.Fixtures)>\r\n```",
        "createdAt": "2021-03-20T01:35:20Z",
        "updatedAt": "2021-03-20T01:35:20Z",
        "author": {
          "login": "reduckted"
        }
      },
      {
        "body": "To the person attempting to convert:\r\n\r\n```\r\n[assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)]\r\n```\r\n\r\nThe following would work (granted that you have reference to the PresentationFramework):\r\n\r\n```xml\r\n    <ItemGroup>\r\n      <AssemblyAttribute Include=\"System.Windows.ThemeInfo\">\r\n        <_Parameter1>System.Windows.ResourceDictionaryLocation.None</_Parameter1>\r\n        <_Parameter1_IsLiteral>true</_Parameter1_IsLiteral>\r\n        <_Parameter1_TypeName>System.Windows.ResourceDictionaryLocation</_Parameter1_TypeName>\r\n        <_Parameter2>System.Windows.ResourceDictionaryLocation.SourceAssembly</_Parameter2>\r\n        <_Parameter2_IsLiteral>true</_Parameter2_IsLiteral>\r\n        <_Parameter2_TypeName>System.Windows.ResourceDictionaryLocation</_Parameter2_TypeName>\r\n      </AssemblyAttribute>\r\n    </ItemGroup>\r\n```",
        "createdAt": "2021-08-31T07:25:14Z",
        "updatedAt": "2021-08-31T07:25:14Z",
        "author": {
          "login": "margusmartsepp"
        }
      },
      {
        "body": "> @margusmartsepp  The following would work\r\n\r\nIn fact, you can even leave out the `_TypeName` metadata because the `_IsLiteral` metadata causes the parameter value to be treated as code and the type name metadata is not used.\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"System.Windows.ThemeInfo\">\r\n    <_Parameter1>System.Windows.ResourceDictionaryLocation.None</_Parameter1>\r\n    <_Parameter1_IsLiteral>true</_Parameter1_IsLiteral>\r\n    <_Parameter2>System.Windows.ResourceDictionaryLocation.SourceAssembly</_Parameter2>\r\n    <_Parameter2_IsLiteral>true</_Parameter2_IsLiteral>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```",
        "createdAt": "2021-08-31T12:08:24Z",
        "updatedAt": "2021-08-31T12:08:24Z",
        "author": {
          "login": "reduckted"
        }
      },
      {
        "body": "> @reduckted In fact, you can even leave out the `_TypeName` metadata because the `_IsLiteral` metadata causes the parameter value to be treated as code and the type name metadata is not used.\r\n\r\nYes, thanks for pointing it out.",
        "createdAt": "2021-08-31T13:27:23Z",
        "updatedAt": "2021-08-31T13:27:41Z",
        "author": {
          "login": "margusmartsepp"
        }
      },
      {
        "body": "Using MSBuild variables in parameters, seems to always trigger this warning now. Specifying `System.String` as type does not change that.\r\n\r\n```\r\n  <ItemGroup>\r\n    <AssemblyAttribute Include=\"System.Reflection.AssemblyCommitDateAttribute\">\r\n      <_Parameter1>$(CommitDate)</_Parameter1>\r\n    </AssemblyAttribute>\r\n  </ItemGroup>\r\n```\r\n\r\n```\r\nMicrosoft (R) Build Engine version 16.11.0+0538acc04 for .NET Framework\r\nCoreGenerateAssemblyInfo:\r\n  Could not infer the type of parameter \"#1\" because the attribute type is unknown. The value will be treated as a string.\r\n```\r\n\r\nAnything I'm missing here?\r\n\r\n",
        "createdAt": "2021-09-21T15:35:03Z",
        "updatedAt": "2021-09-21T15:35:03Z",
        "author": {
          "login": "jwfx"
        }
      },
      {
        "body": "To infer the parameter type, MSBuild needs to know about the attribute without having to load any external assemblies. That means parameter inferencing is limited to attributes in the `mscorlib` assembly.",
        "createdAt": "2021-09-21T21:11:28Z",
        "updatedAt": "2021-09-21T21:11:28Z",
        "author": {
          "login": "reduckted"
        }
      },
      {
        "body": "Understood, makes sense.\r\n\r\nIs there a way to supress that warning though, it doesn't seem to have a `MSBxxxxxx` label attached?",
        "createdAt": "2021-09-22T07:02:29Z",
        "updatedAt": "2021-09-22T07:02:29Z",
        "author": {
          "login": "jwfx"
        }
      },
      {
        "body": "It's only logged as a message, so it doesn't affect the build in any way, but if you want to stop it from appearing in the build log, you can specify the parameter type:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <AssemblyAttribute Include=\"System.Reflection.AssemblyCommitDateAttribute\">\r\n        <_Parameter1>$(CommitDate)</_Parameter1>\r\n        <_Parameter1_TypeName>System.String</_Parameter1_TypeName>\r\n    </AssemblyAttribute>\r\n</ItemGroup>\r\n```",
        "createdAt": "2021-09-25T04:22:48Z",
        "updatedAt": "2021-09-25T04:22:48Z",
        "author": {
          "login": "reduckted"
        }
      },
      {
        "body": "I tried that, but the message does not go away.",
        "createdAt": "2021-09-27T08:32:45Z",
        "updatedAt": "2021-09-27T08:32:45Z",
        "author": {
          "login": "jwfx"
        }
      },
      {
        "body": "That's strange. When I add the parameter type the message goes away. I tried it on both v16.11.0.36601 and v17.0.0.45303.",
        "createdAt": "2021-10-02T10:58:37Z",
        "updatedAt": "2021-10-02T10:58:37Z",
        "author": {
          "login": "reduckted"
        }
      },
      {
        "body": "Agree there should be better comprehension available to specify actual types during build. Leaving authors to have to get very creative in how they present their argument lists for sure.",
        "createdAt": "2022-04-04T18:14:28Z",
        "updatedAt": "2022-04-04T18:14:28Z",
        "author": {
          "login": "mwpowellhtx"
        }
      },
      {
        "body": "I think ``WriteCodeFragment`` should be improved further for .NET 6+.\r\n\r\nWhen ``ImplictUsings`` is ``enable`` it should exclude writing ``using`` and exclude fully qualifying the attributes.",
        "createdAt": "2022-07-09T22:13:41Z",
        "updatedAt": "2022-07-09T22:13:41Z",
        "author": {
          "login": "AraHaan"
        }
      },
      {
        "body": "Is there a way to set the module attribute via MSBuild?\r\n```cs\r\n[module: SkipLocalsInit]\r\n```",
        "createdAt": "2022-08-10T13:00:08Z",
        "updatedAt": "2022-08-10T13:00:08Z",
        "author": {
          "login": "HavenDV"
        }
      },
      {
        "body": "@HavenDV, WriteCodeFragment does not support module attributes, and they are out of scope for this issue. Please see <https://github.com/dotnet/sdk/issues/24894> for generating SkipLocalsInitAttribute specifically.",
        "createdAt": "2022-08-10T14:21:56Z",
        "updatedAt": "2022-08-10T14:21:56Z",
        "author": {
          "login": "KalleOlaviNiemitalo"
        }
      }
    ]
  }
}