{
  "number": 3696,
  "title": "Static Graph Design",
  "body": "## Summary\r\n\r\n### Motivations\r\n- Stock projects can build with \"project-level build\" and if clean onboard to MS internal build engines with cache/distribution\r\n- Stock projects will be \"project-level build\" clean.\r\n- Add determinism to MSBuild\r\n- Potential perf gain in graph scheduling\r\n- Increase perf of interaction between MSBuild and higher-order build engines (eg. MS internal build engines) - reuse evaluation and MSBuild nodes\r\n- **Existing functionality must still work. This new behavior is opt-in only.**\r\n\r\n### M1 - MVP\r\n- [ ] Add new project graph discovery\r\n  - [ ] Evaluation and statically follow ProjectReference.\r\n  - [ ] Graph and fully-evaluated instances returned\r\n  - [ ] Nodes in the graph:\r\n    - [ ] List of edges\r\n    - [ ] Instances of evaluated project\r\n\r\n- [ ] BuildSingleProject API: \r\n  - [ ] Build a project/target with /p:BuildProjectReferences=false\r\n  - [ ] Warn on MSBuild invocation in this mode\r\n- [ ] Simple BuildGraph API added\r\n- [ ] Gather data on migration costs and how far off we are from a usable solution\r\n\r\n### M1 non-goals\r\n- Caching\r\n- Distribution\r\n- Input/Output tracking or validation\r\n- Incremental build\r\n- Perf (no multi-core, evaluation re-use, etc)\r\n- Blocking \"bad\" P2P calls\r\n\r\n### M2 - Single Project Enforcement\r\n- [ ] BuildSingleProject\r\n  - [ ] New syntax to allow a project to export state to consuming projects\r\n  - [ ] Modify common targets to, by default, export state for P2P protocol data (probably non-Core first)\r\n  - [ ] Error on MSBuild invocations not exported by target Project\r\n\r\n### M3 - Dependency Tracking\r\n- [ ] BuildSingleProject\r\n  - [ ] Add Tracker to record input/outputs read for each project built\r\n  - [ ] Some sort of content store for this data?\r\n\r\n### M4 - Ready for Caching/Distribution\r\n- [ ] BuildGraph API\r\n  - [ ] Validate project outputs read as inputs are declared by a ProjectReference\r\n  - [ ] Other BuildCop stuff?\r\n- [ ] API to import/export tracker data and exported project state\r\n- [ ] Ability to distribute and cache from QB\r\n\r\n### M5 - Performance\r\n- [ ] Optimized graph scheduling\r\n- [ ] Evaluation re-use\r\n- [ ] Scoped evaluation (parse only what we need)\r\n\r\n-------------------\r\n\r\n## Project Graph\r\n\r\nCalculating the project graph will be very similar to the MS internal build engine's existing Traversal logic. For a given evaluated project, all project references will be identified and recursively evaluated (with deduping). Each project + global props combo can be evaluated in parallel.\r\n\r\nFor cross-targeting projects, the project will be seen just as 1 uber project. Behaviorally this is the same as what happens when building a cross-targeting project directly today; the outer build ends up calling the MSBuild task for every target framework.\r\n\r\nFor example if project A cross targets net471 and netcoreapp2.0, then the graph will have just 1 node: project A + no global properties.\r\n\r\nFor project references to projects which cross-target, it is non-trivial to figure out which target framework to build without running NuGet targets, so as a simplification the dependency will be on the cross-targeting node in the graph (ie. \"all target frameworks\"), rather than the individual target framework which is actually needed. Note that this may lead to over-building.\r\n\r\nFor example if project B had a project reference to the example project A above, then project B would depend on project A (without global properties).\r\n\r\nBecause we are using ProjectReferences to determine the graph, we will need to duplicate the mapping of ProjectReference metadata to global properties given to the MSBuild task. This means that we need to couple the engine to the concept of cross-targeting and how it's done. Which means that whenever we change the cross-targeting MSBuild code we need to update the project graph construction code.\r\n\r\n**OPEN ISSUE:** Are there other \"build dimensions\" similar to cross-targeting? Cross-targeting has a well-known pattern, but there may be others. Like runtime id (e.g. win10, win8, osx, linux14, linux16, etc), which give TFM x RID combinations. We wouldn't want to teach the engine how to handle each type of build dimension. Even if we have to hardcode details about certain build dimensions (to avoid having a ton of sdk writers to change), should we bother designing a way in which sdk writers can declare how new build dimensions affect the graph? To avoid adding more and more coupling to build logic?\r\n\r\n**OPEN ISSUE:** What about MSBuild calls which pass in global properties not on the ProjectReference? Worse, if the global properties are computed at runtime? The sfproj SDK does this with PublishDir, which tells the project where to put its outputs so the parent sfproj can consume them. We may need to work with sfproj folks and other SDK owners, which may not be necessarily a bad thing since already the sfproj SDK requires 2 complete builds of dependencies (ProjectReference + this PublishDir thing) and can be optimized. A possible short term fix: Add nodes to graph to special case these kinds of SDKs.\r\n\r\nNote that we are not taking into account different target lists. Since we're going down the route of export targets (see below), there's no need to track the specific targets which projects need to call in the p2p relationship. This is important to call out though since this means that the project graph feature may not be very usable outside of the export targets feature, meaning the features may be somewhat coupled.\r\n\r\nAlso note that graph cycles are disallowed, even if they're using disconnected targets. This is a breaking change, as today you can have two projects where each project depends on a target from the other project, but that target doesn't depend the default target or anything in its target graph.\r\n\r\n### Building a project graph\r\nThere are conceptually two options when building a project graph: building the entire graph or building a single project in the graph. There is one other scenario, which is building a part of the graph (a project and everything it needs), but that's effectively just rooting the graph at that project and building that whole new graph.\r\n\r\nWhen building a whole graph, we can think of it as just building the root project recursively. So really the two scenarios break down to just building the root project recursively or not, which is actually very similar to how \"msbuild\" vs \"msbuild /p:BuildProjectReferences=false\" works today.\r\n\r\nAdditionally, since building a graph is effectively just building a project recursively, then invoking MSBuild with a target list should behave similarly to how to behaves today. The top-level project will be invoked with those targets, and project references won't be affected by that target list. However, targets like \"Clean\" and \"Rebuild\" will need to be special-cased, as they recursively call those targets on their project references.\r\n\r\nShort-term (M1/MVP), building a graph is the same behaviorally as building the root project (no export target enforcement). The main difference will be in scheduling. Instead of dependency projects being evaluated and executed just in time, MSBuild will schedule dependencies before projects which depend on them. In most cases when building a graph in this order, all MSBuild task executions will come from the MSBuild result cache, which leads fairly cleanly into export targets, which would effectively be the enforcement of that.\r\n\r\n**OPEN ISSUE:** What do we do about properties provided by the SLN? Under the hood, this is effectively different sets of global properties provided to each MSBuild invocation (or ProjectReference?) in the metaproj.\r\n\r\n### Public API ###\r\nThis is a proposal for what the public API may look like:\r\n```c#\r\n\tnamespace Microsoft.Build.Graph\r\n\t{\r\n\t    public class ProjectGraph\r\n\t    {\r\n\t        // Creates a graph starting at the given project file.\r\n\t        public ProjectGraph(string projectFile) { }\r\n\t\r\n\t        // Creates a graph starting at the given project files, for example all projects in a solution.\r\n\t        public ProjectGraph(IEnumerable<string> projectFiles) { }\r\n\t\r\n\t        // All project nodes in the graph.\r\n\t        IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; }\r\n\t    }\r\n\t\r\n\t    public class ProjectGraphNode\r\n\t    {\r\n\t        // No public creation.\r\n\t        internal ProjectGraphNode() { }\r\n\t\r\n\t        // Projects which this project references.\r\n\t        IReadOnlyCollection<ProjectGraphNode> ReferencedProjects { get; }\r\n\t\r\n\t        // Projects which reference this project.\r\n\t        IReadOnlyCollection<ProjectGraphNode> ReferencingProjects { get; }\r\n\t\r\n\t        // The evaluated project\r\n\t        Project Project { get; }\r\n\t    }\r\n\t}\r\n```\r\n## Export Targets\r\n\r\nOne property of the static build graph is that a project is \"built\" only once when the entire project graph is built. This is in conflict with current P2P patterns (project to project) where a project may be built multiple times during a build with different targets and global properties. Thus we need a mechanism through which the project files self describe all the ways they can be built. A public interface of msbuild targets w.r.t. the build graph. We call this interface the exported targets.\r\n\r\nExecuting projects with export targets within the graph means changing the behavior of the MSBuild task to always pull the target results from cache rather than actually evaluating and executing the list targets. This has several benefits such as each project having a concrete lifetime within the build, may reduce re-evaluation cost, and opens up maybe caching and distribution scenarios.\r\n\r\n### Syntax\r\n- Option 1: `<ExportTarget Name=\"GetTargetPath\" />`\r\n  - Pros: Easy to search, very extensible (can export targets which you don't \"own\")\r\n  - Cons: Separated from the target definition, breaking change\r\n- Option 2: `<Target Name=\"GetTargetPath\" Exported=\"true\">`\r\n  - Pros: Near target definition, mostly reuses existing syntax\r\n  - Cons: Not as extensible, breaking change\r\n- Option 3: `<Project DefaultTargets=\"Build\" ExportTargets=\"GetTargetPath\">`\r\n  - Pros: Easy to find (ish. Could be defined in imported props/targets), similar to DefaultTargets and InitialTargets, not a breaking change\r\n  - Cons: Separated from the target definition\r\n- Option 4: Property: `$(MSBuildExportedTargets)`\r\n  - Pros: Easy to use and query, completely non-breaking\r\n  - Cons: Bad actors can override instead of append\r\n\r\n**Option 4** seems like the best choice.\r\n\r\n### Building using export targets\r\nWhen using export targets, the project graph is required to build the projects in the correct order. An individual project will be built using `/p:BuildProjectReferences=false` to avoid recursive builds inside a project\r\n\r\n**OPEN ISSUE:** Can we get away with not setting `/p:BuildProjectReferences=false`? It would mean we'd need to export Build, Rebuild, and Clean, but would eliminate any need for setting extra global properties. Perhaps this is fine, or perhaps the entry point for a project is always considered exported?\r\n\r\nWhen building a project, run the initial targets, default targets, and export targets. Export targets will run last, assuming they're not needed earlier in the build by other targets. Likely the implementation of this will simply be to push the export targets onto the target execution stack in reverse order before the default and initial targets.\r\n\r\nAfter execution, the results of the export targets will be cached and the project can be disposed. Note that this gives project execution a concrete start and end, while previously projects needed to remain active just in case any other project needed to execute a target on it.\r\n\r\nFor projects which depend on other projects, the MSBuild task will look up the target result in the cache. If the target is missing from the cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or via `MSBuild` with a different set of global properties, this will be always allowed (support for cross-targeting).\r\n\r\nThis makes the P2P contract explicit as it requires both projects to declare targets which are part of the contract.\r\n\r\nInitially this result cache will just be in-memory, similar to the existing MSBuild target result cache, but eventually could persist across builds so that an incremental build of a particular project in the project graph would not require re-evaluation or any target execution in that project's dependencies. This may have significant perf improvements for incremental builds.\r\n\r\nNote that because projects have a concrete start and end time, this allows for easy integration with Tracker to observe all inputs and outputs for a project. Note however that export target I/O would be attributed to the dependency (project doing the exporting), not the dependent project (project with the project reference). This differs from today's behavior, but seems like a desirable difference anyway.\r\n\r\n## Distribution\r\nTo support distribution with export targets (eg. for the MS internal build engine), we need a solution for a project and a dependency building on different machines.\r\n- Option 1 (easier): Run export targets only for dependencies, no build.\r\n  - Requires re-evaluation of the dependency, but no big MSBuild support beyond allowing the no-Build mode for dependencies.\r\n- Option 2 (better): Serialize the export target state\r\n  - Best for perf, but requires a serialization protocol and a way to specify how to import the state\r\n  - Possibly same mechanism as the persistent cross-build cache described above.\r\n\r\n## I/O Tracking\r\n**WIP**",
  "state": "CLOSED",
  "createdAt": "2018-09-04T16:15:27Z",
  "updatedAt": "2024-02-21T17:11:25Z",
  "closedAt": "2018-09-04T21:22:58Z",
  "author": {
    "login": "dfederm"
  },
  "labels": [
    "Area: Static Graph",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "Moved to https://github.com/Microsoft/msbuild/blob/master/documentation/specs/static-graph.md for better change-tracking.",
        "createdAt": "2018-09-04T21:22:58Z",
        "updatedAt": "2018-09-04T21:22:58Z",
        "author": {
          "login": "dfederm"
        }
      }
    ]
  }
}