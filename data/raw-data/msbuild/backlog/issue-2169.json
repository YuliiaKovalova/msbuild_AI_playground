{
  "number": 2169,
  "title": "DebugSymbols is ignored if DebugType is set.",
  "body": "The Fody project recently had an issue where debug symbols were not being processed properly in release mode.\r\n\r\nhttps://github.com/Fody/Fody/issues/360\r\n\r\nIt turns out that the value of `DebugSymbols` is completely ignored if `DebugType` is set.\r\n\r\nhttps://github.com/Microsoft/msbuild/blob/master/src/Tasks/Microsoft.Common.CurrentVersion.targets#L145-L151\r\n\r\n    <_DebugSymbolsProduced>false</_DebugSymbolsProduced>\r\n    <_DebugSymbolsProduced Condition=\"'$(DebugSymbols)'=='true'\">true</_DebugSymbolsProduced>\r\n    <_DebugSymbolsProduced Condition=\"'$(DebugType)'=='none'\">false</_DebugSymbolsProduced>\r\n    <_DebugSymbolsProduced Condition=\"'$(DebugType)'=='pdbonly'\">true</_DebugSymbolsProduced>\r\n    <_DebugSymbolsProduced Condition=\"'$(DebugType)'=='full'\">true</_DebugSymbolsProduced>\r\n    <_DebugSymbolsProduced Condition=\"'$(DebugType)'=='portable'\">true</_DebugSymbolsProduced>\r\n    <_DebugSymbolsProduced Condition=\"'$(DebugType)'=='embedded'\">false</_DebugSymbolsProduced>\r\n\r\nBut according to the documentation DebugSymbol should control the output of the symbol file.\r\n\r\nhttps://msdn.microsoft.com/en-us/library/bb629394.aspx\r\n\r\n> **DebugSymbols** A boolean value that indicates whether symbols are generated by the build. Setting /p:DebugSymbols=false on the command line disables generation of program database (.pdb) symbol files.\r\n\r\n> **DebugType** Defines the level of debug information that you want generated. Valid values are \"full,\" \"pdbonly,\" and \"none.\"\r\n\r\nIs this a bug?",
  "state": "OPEN",
  "createdAt": "2017-06-05T00:22:07Z",
  "updatedAt": "2024-05-17T17:26:02Z",
  "closedAt": null,
  "author": {
    "login": "distantcam"
  },
  "labels": [
    "backlog",
    "Area: Documentation",
    "Priority:2",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "related https://github.com/Microsoft/msbuild/issues/2170",
        "createdAt": "2017-06-05T00:29:57Z",
        "updatedAt": "2017-06-05T00:29:57Z",
        "author": {
          "login": "SimonCropp"
        }
      },
      {
        "body": "If you modify \"VS/project properties/Build/Advanced/Debugging information\" then it creates (if necessary) and sets the value of `<DebugType>` in the .csproj file, but does not set or add a `<DebugSymbols>` property.\r\n\r\nSo, if I've understood correctly, it's probably worth noting here that project files generated by Visual Studio rely on the behaviour under discussion.",
        "createdAt": "2020-01-22T13:49:18Z",
        "updatedAt": "2020-01-22T13:49:18Z",
        "author": {
          "login": "mikebeaton"
        }
      },
      {
        "body": "As of Feburary 2024, long after the introduction of `/debug:embedded` and `release-debug-plus` optimization level, the actual behaviour of the `<DebugSymbols>` and `<DebugType>` MSBuild properties does not match the current documentation at all - (while @distantcam linked to [the VS2015 docs](https://learn.microsoft.com/en-gb/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-properties?view=vs-2015&redirectedfrom=MSDN), [the current docs](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-properties?view=vs-2022) for VS2022 has the same incorrect definitions):\r\n\r\n> `<DebugSymbols>`\r\n> A boolean value that indicates whether symbols are generated by the build.\r\n>\r\n> `<DebugType>`\r\n> Defines the level of debug information that you want generated. Valid values are \"full,\" \"pdbonly,\" \"portable\", \"embedded\", and \"none.\"\r\n>\r\n> `<DefineDebug>`\r\n> A boolean value that indicates whether you want the DEBUG constant defined.\r\n\r\n\r\nIn actuality, in the .NET SDK version 7.0 (and also likely 5.0, 6.0, and 8.0, I haven't thoroughly checked those) the actual behavior is:\r\n\r\n* `<DebugSymbols>` \r\n    * The value of `<DebugSymbols>` goes through to `<Csc EmitDebugInformation=\"$(DebugSymbols)\"` (in `Microsoft.CSharp.CurrentVersion.targets`)\r\n      * `EmitDebugInformation=\"false\"` translates to `csc.exe /debug-` which:\r\n          * Disables PDB output entirely if `/debug-` appears after `/debug:DebugType`. **This is an undocumented surprise**.\r\n          * Does not disable PDB output entirely if `/debug-` appears before `/debug:DebugType`.\r\n          * The MSBuild `<Csc>` task is hardcoded to output `/debug+` or `/debug-` immediately before the `/debug:DebugType` option, btw.\r\n      * `EmitDebugInformation=\"true\"` translates to `csc.exe /debug+`\r\n          * Enables PDB output _and_ enables `debugPlus` optimizations.\r\n* `<DebugType>`\r\n    * The value of `<DebugSymbols>` goes through to `<Csc DebugType=\"$(DebugType)\"` (in `Microsoft.CSharp.CurrentVersion.targets`)\r\n    * Special-case: if `DebugType=\"none\"` then this also clears the `<Csc EmitDebugInformation=\"\"` attribute, which affects program optimization.\r\n\r\n* `<DefineDebug>`\r\n    * This only seems to affect VB.NET compilation, and not C# at all, as it only appears in these files:\r\n        * `Microsoft.VisualBasic.CurrentVersion.targets`\r\n        * `Microsoft.NET.Sdk\\targets\\Microsoft.NET.Sdk.VisualBasic.props`\r\n        * `Microsoft.NET.Sdk\\targets\\Microsoft.NET.Sdk.VisualBasic.targets`\r\n    * And, to my surprise, it seems no part of MSBuild or `csc` will define `DEBUG` _at all_, so this now always requires an explicit user MSBuild `<DefineConstants>$(DefineConstants);DEBUG` property, wow.\r\n\r\nSo, if I were writing the documentation, I'd change the text to something like:\r\n\r\n> `<DebugSymbols>`\r\n> * When `true` then:\r\n>     * PDB debugging information will be included in the output (either as a separate `.pdb` file or embedded within the output `.exe`/`.dll`).\r\n>     * Enables `debugPlus` optimization mode in both Release and Debug configurations . This `debugPlus` Disables certain IL-level optimizations, even in Release builds - or  (aka `debugPlus`).\r\n> * When `false` then:\r\n>     * Disables PDB output (including embedded PDB data) - but only when `<DebugType>` is not specified.\r\n>     * Prevents `debugPlus` IL output (thus forcing either `Release` or `Debug` depending on other options).\r\n> * When undefined then:\r\n>    * PDB output is then controlled by `<DebugType>`.\r\n>    * Prevents `debugPlus` IL output (thus forcing either `Release` or `Debug` depending on other options).\r\n>\r\n> `<DebugType>`\r\n> * When `none` then:\r\n>    * Any `<DebugSymbols>` property value becomes undefined (thus `debugPlus`-level optimization will never be applied).\r\n>    * Disables PDB output (whether separate-file or embedded)\r\n> * When `full`, `pdbonly`, or `portable` then:\r\n>    * Enables PDB output as a separate file. The exact file-format of the `.pdb` file depends on your OS platform when using `full` or `pdbonly`.\r\n>    * As of the .NET 7 SDK. provided you are not targeting any legacy platforms then the `full` and `pdbonly` values are both redundant and superfluous, instead use only `portable` or `embedded`.\r\n> * When `embedded` then:\r\n>    * Enables PDB output as extra data embedded directly in the output `.dll`/`.exe` file. The same exact format is used regardless of OS platform.\r\n> * When undefined then:\r\n>    * PDB output will be disabled _unless_ `<DebugSymbols>true` is explicitly set.\r\n>    * PDB exact file format will depend on your OS platform.\r\n>\r\n> `<DefineDebug>`\r\n> * This property is not respected by the C# build system. Instead set an explicit property like so `<DefineConstants>$(DefineConstants);DEBUG;</DefineConstants>`\r\n\r\nSo yes - quite the difference... \r\n\r\nFurthermore, the documentation on Optimization is incorrect, [it says `DebugPlusMode` is ignored when `OptimizationLevel.Release` is set](https://github.com/dotnet/roslyn/blob/main/docs/features/pdb-compilation-options.md#optimization:~:text=and%20DebugPlusMode%20is%20false%20(ignored)), but in reality it's the opposite: `debugPlus == true` _with_ Release mode gives us `ILEmitStyle.DebugFriendlyRelease`, while `debugPlus` has no effect when `CompilationOptions.Optimizationlevel == OptimizationLevel.Debug` (c.f. `Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody`). \r\n\r\nSo currently, my default `Directory.Build.props` looks like this:\r\n\r\n```\r\n\t<PropertyGroup Condition=\"$(Configuration) = 'Debug'\">\r\n\t\t<!-- This combination of properties causes CSC to compile without IL optimizations, and to emit a very debuggable embedded PDB.  -->\r\n\t\t<DebugType>embedded</DebugType>\r\n\t\t<DebugSymbols>true</DebugSymbols>\r\n\t\t<DefineConstants>$(DefineConstants);DEBUG;</DefineConstants>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"$(Configuration) = 'Release'\">\r\n\t\t<!-- This combination of properties causes CSC to compile with \"release-debug-plus\" optimizations. The evidence suggests this has an absolutely negligible performance impact, while significantly improving the debugging experience. -->\r\n\t\t<DebugType>embedded</DebugType>\r\n\t\t<DebugSymbols>true</DebugSymbols>\r\n\t\t<Optimize>true</Optimize>\r\n\t\t<DefineConstants>$(DefineConstants);RELEASE;</DefineConstants>\r\n\t</PropertyGroup>\r\n```\r\n\r\n---------\r\n\r\nIf it helps, I've put together this table:\r\n\r\n| `<DebugType>` | `<DebugSymbols>` | `<Optimize>` |   | Effective csc.exe options          | Effective CompilationOptions                                               | Debugability                                           |\r\n|-------------|----------------|------------|---|------------------------------------|----------------------------------------------------------------------------|--------------------------------------------------------|\r\n| embedded    | false          | false      |   | /debug- /debug:embedded /optimize- | DebugPlusMode=false, Optimization.Debug, emitPdb=true, emitPdbFile=false   | High (Debug mode; DebugPlusMode = false)               |\r\n| embedded    | false          | true       |   | /debug- /debug:embedded /optimize+ | DebugPlusMode=false, Optimization.Release, emitPdb=true, emitPdbFile=false | Low (Release mode, DebugPlusMode = false)              |\r\n| embedded    | true           | false      |   | /debug+ /debug:embedded /optimize- | DebugPlusMode=true, Optimization.Debug, emitPdb=true, emitPdbFile=false    | High (Debug mode; DebugPlusMode = true but is ignored) |\r\n| embedded    | true           | true       |   | /debug+ /debug:embedded /optimize+ | DebugPlusMode=true, Optimization.Release, emitPdb=true, emitPdbFile=false  | Medium (Release mode, DebugPlusMode = true)            |\r\n\r\n",
        "createdAt": "2024-02-17T00:41:03Z",
        "updatedAt": "2024-02-17T02:00:27Z",
        "author": {
          "login": "daiplusplus"
        }
      },
      {
        "body": "@daiplusplus Many thanks for the [deep dive](https://github.com/dotnet/msbuild/issues/2169#issuecomment-1949538420)!\r\n\r\nThese properties have been confusing me lately as well. Out of curiosity, in your \"default `Directory.Build.props`\", why do you still use `embedded` debug symbols in the Release configuration? I suppose it might not be a big deal for a server-side app, but for desktop/mobile apps, doesn't that just make it easier for end users to reverse engineer your assemblies? I always thought `portable` was preferrable in Release.",
        "createdAt": "2024-05-16T02:11:09Z",
        "updatedAt": "2024-05-16T02:11:09Z",
        "author": {
          "login": "Rabadash8820"
        }
      },
      {
        "body": "> @Rabadash8820 but for desktop/mobile apps, doesn't that just make it easier for end users to reverse engineer your assemblies?\r\n\r\n* PDB files only add the names of method-locals, whereas your `.exe`/`.dll` files already contain namespaces, type-names, parameters and _some_ locals (as a by-product of how the compiler generates the type representing closures for `async` methods, etc). So ultimately it doesn't matter because tools like ILSpy have gotten _so good now_ I genuinely can't tell whether or not PDB symbols were available when I've disassembled a .NET program. If a PDB file makes the difference between your program being 0wned or not, then you've probably got an unmaintainable 50,000 line function there.\r\n* Whereas having symbols available when exception stack-traces are generated means you get better stack-traces - otherwise things like the line-numbers tend to be wrong. If `.pdb` symbols weren't embedded then I'd have to find somewhere to stick them all (i.e. a Symbol Server) - and I'd have to retain them indefinitely because many of my projects release nightlies to downstream, and in 7 years time some huge enterprise customer is going to come knocking with a bug report that I won't be able to help them with.\r\n* And speaking for myself, I'm not concerned if anyone uses ILSpy on my binaries, if anything, I'd be flattered that my work was worth anyone's curious attention like that.\r\n   * I know .NET obfuscators exist - they also make troubleshooting memory-dumps a huge pain, even when their obfuscated-stack-trace-translator tools actually work.\r\n   * ...and if you're writing anything where _the suits_ are concerned about binaries being disassembled then you should not be writing in C#/.NET in the first place.\r\n\r\n> I always thought `portable` was preferrable in Release.\r\n\r\nWhatever is \"preferable\" for any given situation is subjective; in my case, it is demonstrably _not_ preferable (c.f.: arguments above), but I appreciate that in yours it might be.\r\n",
        "createdAt": "2024-05-16T02:24:07Z",
        "updatedAt": "2024-05-16T02:30:41Z",
        "author": {
          "login": "daiplusplus"
        }
      },
      {
        "body": "@daiplusplus Thanks for the thoughtful response. I guess the reverse engineering concern is a bit overblown; I too would be flattered if somebody actually cared about my software enough to try that lol, and security through obscurity is not real security anyway, plus most of what I write is open-source anyway. \ud83e\udd37\u200d\u2642\ufe0f\r\n\r\nI guess a bigger concern about `embedded` PDBs in Release is file size. I know assemblies and PDBs are typically not huge (on the order of 10s of MB maybe), but as the number of types and assemblies grows, the savings of not shipping a PDB becomes non-trivial. In particular, do you know if assemblies contain private/protected member/type names as well, or only public ones? If it's only public, then I could see PDBs being quite large by providing all those extra symbols. These files can be hosted elsewhere as you suggested to keep the shipped app smaller. In fact, several SaaS systems for mobile already provide hosting for symbolicating exception call stacks from crashes (Firebase Crashlytics and Unity Cloud Diagnostics do anyway). But for server-side code I guess you're right, there's no big reason against `embedded` symbols.",
        "createdAt": "2024-05-17T17:03:18Z",
        "updatedAt": "2024-05-17T17:03:18Z",
        "author": {
          "login": "Rabadash8820"
        }
      },
      {
        "body": "I don't think that's the right way of thinking about it, regardless of public/private types and methods, the assembly contains all of the definitions. The PDB contains local variable names, info about scopes, and metadata about methods, importantly the IL offsets to source code mapping.\r\n\r\nSo it's generally proportional to how big the assembly is, and that's around 15%.",
        "createdAt": "2024-05-17T17:25:46Z",
        "updatedAt": "2024-05-17T17:26:02Z",
        "author": {
          "login": "slang25"
        }
      }
    ]
  }
}