{
  "number": 9505,
  "title": "[Bug]: ObtainRFC3161Timestamp occasionally fails with a CryptographicException and HRESULT TRUST_E_TIME_STAMP",
  "body": "### Issue Description\r\n\r\nHi, I am using SecurityUtilities.SignFile to sign a ClickOnce manifest files but it occasionally fails with a System.Security.Cryptography.CryptographicException that stems from a call to `ObtainRFC3161Timestamp`.\r\nI am directly calling the API using the Microsoft.Build.Tasks.Core nuget package.\r\n\r\n### Steps to Reproduce\r\n\r\nThis behaviour depends on the result of the random number generator in ObtainRFC3161Timestamp so the issues manifests on average once every couple of hundreds attempts. The following is a minimal example that reproduces the issue using code from [SignedCmiManifest2](https://github.com/dotnet/msbuild/blob/f914c9bfb613d32edb658b803c7fe046f9ee3c37/src/Tasks/ManifestUtil/mansign2.cs#L802).\r\n```\r\nvoid Main()\r\n{\r\n\r\n    for (int i = 1; i <= 1000; i++)\r\n    {\r\n        Console.Write(\". \");\r\n\r\n        try\r\n        {\r\n            ObtainRFC3161Timestamp(\r\n                \"http://timestamp.digicert.com\",\r\n                Convert.ToBase64String(System.Text.Encoding.ASCII.GetBytes(\"I'm a signature\")),\r\n                true);\r\n        }\r\n        catch (CryptographicException ex)\r\n        {\r\n            Console.WriteLine();\r\n            Console.WriteLine($\"i={i}, {ex.Message}, HResult: {ex.HResult:x}\");\r\n        }\r\n    }\r\n\r\n}\r\n\r\nprivate static string ObtainRFC3161Timestamp(string timeStampUrl, string signatureValue, bool useSha256)\r\n{\r\n    byte[] sigValueBytes = Convert.FromBase64String(signatureValue);\r\n    string timestamp = String.Empty;\r\n\r\n    string algId = useSha256 ? Win32.szOID_NIST_sha256 : Win32.szOID_OIWSEC_sha1;\r\n\r\n    unsafe\r\n    {\r\n        IntPtr ppTsContext = IntPtr.Zero;\r\n        IntPtr ppTsSigner = IntPtr.Zero;\r\n        IntPtr phStore = IntPtr.Zero;\r\n\r\n        try\r\n        {\r\n            byte[] nonce = new byte[24];\r\n\r\n            using (RandomNumberGenerator rng = RandomNumberGenerator.Create())\r\n            {\r\n                rng.GetBytes(nonce);\r\n            }\r\n\r\n            Win32.CRYPT_TIMESTAMP_PARA para = new Win32.CRYPT_TIMESTAMP_PARA()\r\n            {\r\n                fRequestCerts = true,\r\n                pszTSAPolicyId = IntPtr.Zero,\r\n            };\r\n\r\n            fixed (byte* pbNonce = nonce)\r\n            {\r\n                para.Nonce.cbData = (uint)nonce.Length;\r\n                para.Nonce.pbData = (IntPtr)pbNonce;\r\n\r\n                if (!Win32.CryptRetrieveTimeStamp(\r\n                        timeStampUrl,\r\n                        0,\r\n                        60 * 1000, // 1 minute timeout\r\n                        algId,\r\n                        ref para,\r\n                        sigValueBytes,\r\n                        sigValueBytes.Length,\r\n                        ref ppTsContext,\r\n                        ref ppTsSigner,\r\n                        ref phStore))\r\n                {\r\n                    throw new CryptographicException(Marshal.GetLastWin32Error());\r\n                }\r\n            }\r\n\r\n            var timestampContext = (Win32.CRYPT_TIMESTAMP_CONTEXT)Marshal.PtrToStructure(ppTsContext, typeof(Win32.CRYPT_TIMESTAMP_CONTEXT));\r\n            byte[] encodedBytes = new byte[(int)timestampContext.cbEncoded];\r\n            Marshal.Copy(timestampContext.pbEncoded, encodedBytes, 0, (int)timestampContext.cbEncoded);\r\n            timestamp = Convert.ToBase64String(encodedBytes);\r\n        }\r\n        finally\r\n        {\r\n            if (ppTsContext != IntPtr.Zero)\r\n                Win32.CryptMemFree(ppTsContext);\r\n\r\n            if (ppTsSigner != IntPtr.Zero)\r\n                Win32.CertFreeCertificateContext(ppTsSigner);\r\n\r\n            if (phStore != IntPtr.Zero)\r\n                Win32.CertCloseStore(phStore, 0);\r\n        }\r\n    }\r\n\r\n    return timestamp;\r\n}\r\n\r\ninternal static class Win32\r\n{\r\n    //\r\n    // PInvoke dll's.\r\n    //\r\n    internal const String CRYPT32 = \"crypt32.dll\";\r\n    internal const String KERNEL32 = \"kernel32.dll\";\r\n\r\n    //\r\n    // Structures.\r\n    //\r\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\r\n    internal struct CRYPT_DATA_BLOB\r\n    {\r\n        internal uint cbData;\r\n        internal IntPtr pbData;\r\n    }\r\n    //\r\n    [DllImport(KERNEL32, CharSet = CharSet.Auto, SetLastError = true)]\r\n    internal extern static\r\n        IntPtr GetProcessHeap();\r\n\r\n    [DllImport(KERNEL32, CharSet = CharSet.Auto, SetLastError = true)]\r\n    [return: MarshalAs(UnmanagedType.Bool)]\r\n    internal extern static\r\n        bool HeapFree(\r\n        [In] IntPtr hHeap,\r\n        [In] uint dwFlags,\r\n        [In] IntPtr lpMem);\r\n\r\n    // hash algorithm OIDs\r\n    internal const string szOID_OIWSEC_sha1 = \"1.3.14.3.2.26\";\r\n    internal const string szOID_NIST_sha256 = \"2.16.840.1.101.3.4.2.1\";\r\n\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    internal struct CRYPT_TIMESTAMP_CONTEXT\r\n    {\r\n        internal uint cbEncoded; // DWORD->unsigned int\r\n        internal IntPtr pbEncoded; // BYTE*\r\n        internal IntPtr pTimeStamp; // PCRYPT_TIMESTAMP_INFO->_CRYPT_TIMESTAMP_INFO*\r\n    }\r\n\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    internal struct CRYPTOAPI_BLOB\r\n    {\r\n        internal uint cbData;\r\n        internal IntPtr pbData;\r\n    }\r\n\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    internal struct CRYPT_TIMESTAMP_PARA\r\n    {\r\n        internal IntPtr pszTSAPolicyId;\r\n        internal bool fRequestCerts;\r\n        internal CRYPTOAPI_BLOB Nonce;\r\n        internal int cExtension;\r\n        internal IntPtr rgExtension;\r\n    }\r\n\r\n    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]\r\n    [DllImport(CRYPT32, CallingConvention = CallingConvention.Winapi, SetLastError = true)]\r\n    [return: MarshalAs(UnmanagedType.Bool)]\r\n    internal extern static\r\n        bool CryptRetrieveTimeStamp(\r\n        [In][MarshalAs(UnmanagedType.LPWStr)] string wszUrl,\r\n        [In] uint dwRetrievalFlags,\r\n        [In] int dwTimeout,\r\n        [In][MarshalAs(UnmanagedType.LPStr)] string pszHashId,\r\n        [In, Out] ref CRYPT_TIMESTAMP_PARA pPara,\r\n        [In] byte[] pbData,\r\n        [In] int cbData,\r\n        [In, Out] ref IntPtr ppTsContext,\r\n        [In, Out] ref IntPtr ppTsSigner,\r\n        [In, Out] ref IntPtr phStore);\r\n\r\n    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]\r\n    [DllImport(CRYPT32, CallingConvention = CallingConvention.Winapi, SetLastError = true)]\r\n    internal static extern bool CertFreeCertificateContext(IntPtr pCertContext);\r\n\r\n    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]\r\n    [DllImport(CRYPT32, CallingConvention = CallingConvention.Winapi, SetLastError = true)]\r\n    internal static extern bool CertCloseStore(IntPtr pCertContext, int dwFlags);\r\n\r\n    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]\r\n    [DllImport(CRYPT32, CallingConvention = CallingConvention.Winapi)]\r\n    internal static extern void CryptMemFree(IntPtr pv);\r\n}\r\n```\r\n\r\n### Expected Behavior\r\n\r\nSigning the ClickOnce manifest file always succeeds.\r\n\r\n### Actual Behavior\r\n\r\nSigning fails occasionally with a `CryptographicException` that has a HResult of `TRUST_E_TIME_STAMP`. \r\n\r\n\r\n### Analysis\r\n\r\nThe problem is that the `Win32.CryptRetrieveTimeStamp()` call within `ObtainRFC3161Timestamp()` sometimes returns a `TRUST_E_TIME_STAMP` result. The reason is because the generated nonce in `ObtainRFC3161Timestamp()` - just a evenly distributed random 192 bit number - is in an unexpected range. \r\nWhen using the default `ObtainRFC3161Timestamp()` implementation of the 1000 calls about two `TRUST_E_TIME_STAMP` errors occur. \r\nTo test this can be made worse by doing `nonce[^1] = 0xFF` in `ObtainRFC3161Timestamp()` which lets 50% of calls fail. \r\n\r\nThe team responsible for nuget signing seems to have encountered a similiar issue and implemented a [fix](https://github.com/NuGet/NuGet.Client/blob/dfe13cc99d13de74f41e9cff35600a2c8958aac1/src/NuGet.Core/NuGet.Packaging/Signing/Timestamp/Rfc3161TimestampProvider.cs#L251-L264). \r\nWhen implementing their fix `nonce[^1] &= 0x7f; nonce[^1] |= 0x01;` 100% of calls succeed.\r\n\r\n### Versions & Configurations\r\n\r\nMSBuild version 17.7.2+d6990bcfa for .NET Framework\r\n17.7.2.37605\r\ndotnet --version\r\n7.0.401",
  "state": "CLOSED",
  "createdAt": "2023-12-07T15:37:30Z",
  "updatedAt": "2024-07-31T10:55:01Z",
  "closedAt": "2024-07-31T10:55:01Z",
  "author": {
    "login": "e455a81e-d3ba-41a2-bc6d-7aafb1d9a5cd"
  },
  "labels": [
    "bug",
    "backlog",
    "triaged"
  ],
  "assignees": {
    "nodes": [
      {
        "login": "sujitnayak"
      }
    ]
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "The issue should be fixed by #9579. Please feel free to re-open the issue otherwise.",
        "createdAt": "2024-07-31T10:55:01Z",
        "updatedAt": "2024-07-31T10:55:01Z",
        "author": {
          "login": "AR-May"
        }
      }
    ]
  }
}