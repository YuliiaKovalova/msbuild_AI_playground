{
  "number": 11801,
  "title": "Support a single-node, multithreaded Task execution mode",
  "body": "Today, MSBuild operates as a multi-process system. Builds are submitted to a central coordinator node that performs evaluation of projects, and then farms out actual Target execution, Task invocation, and more on specific worker nodes. These nodes communicate across processes via a custom Inter-Process Communication channel using custom binary serialization of data.\n\nThis scheme results in a lot of unnecessary re-done work. DLLs must be loaded per-process/node, Project Evaluation data must be sent back and forth across the IPC channel, and caches are built and maintained per-process/node. (There are more examples of this re-work, but these are a few large examples.) In addition, the multi-proc nature of MSBuild makes it hard to debug and analyze build execution.\n\nTherefore, we propose to implement a new single-node, multi-threaded mode of MSBuild execution. In this mode, Tasks would be invoked on Thread-based worker nodes on the same single execution node. Because more of the worker nodes would be within the same process, we would be able to take advantage of structural sharing/shared memory to reuse more of the data that is stateful across a build. We would also be able to save on some of the JITting costs and reduce the cost of communicating across worker nodes due to no longer needing to serialize and transmit data across the IPC channel.\n\n### Task API Contract\n\nNot all Tasks would immediately be able to opt into this mode of execution. Because of the process-isolation execution mode of Tasks today, many Task authors make use of APIs that are not inherently safe in a multi-threaded environment. Such APIs include but are not limited to environment variable access, file I/O, and more. To circumvent these problems, we would need to create a new Task API contract that signals that a Task is intended to operate in a thread-safe execution environment. To help authors obey the rules, we would ship helpers like Banned API Analyzer configuration that prevent authors from using APIs that are known to be in violation of the thread-based execution model. In addition, we would provide a context- or god-object that provides safe versions of anticipated thread-unsafe functionality. The engine would be responsible for preparing this object before Task execution and providing it to the Task. Finally, this new Task API Contract would be able to take advantage of modern .NET expectations for asynchronous operations, like CancellationTokens.\n\n### Engine changes and new Node types\n\nTo take advantage of the new API, the MSBuild engine would need to create a new Node type and potentially a new TaskHost type that is based on a Thread of execution instead of a process. This thread of execution would set up the execution environment similarly to how the execution environment, construct the thread-aware Task and its relevant context- or god-object instance, run the Task, and then handle returning the results of the Task (including cancellation, failure, success) to the worker Node.\n\n### Compatibility\n\n#### out-of-proc execution\n\nThe new Task API doesn't necessarily _require_ multi-threaded execution. As a checkpoint along the implementation journey, when the Task API contract is added we should also extend the current out-of-proc TaskHost implementation with the knowledge of how to spawn these Tasks. This will allow Task authors to target one implementation and run it in either mode, decoupling the distinct units of work of adding multi-threaded Node support to the engine and 'enlightening' Tasks.\n\n#### out-of-proc fallback\n\nAfter the new mode is implemented in the engine, we should provide a flag or trait to allow globally forcing the use of the out of proc or in-proc mechanisms for the new Task API contract. This will act as a safety net in the case of bugs in the newer node implementation - in the worst case users can fallback to out-of-proc execution and get the same behaviors as previous versions of MSBuild.\n\n#### Behavior in the presence of unenlightened Tasks\n\nAfter the engine work is done, there will still be Tasks that use the old API. When the engine encounters these it should use the out-of-proc node and taskhost mechanisms, to ensure that existing builds continue to function.\n\n#### Behavior of Tasks that have both API implementations\n\nA Task author may choose to implement both the old and new Task API contracts, especially if they want to continue to ensure compatibility with older versions of MSBuild. In this case, the consumers of the Task must be very specific in their `UsingTask` declarations to ensure that the Task variant they expect is chosen. We will likely need to surface some knob on `UsingTask` to make it clear what execution mode a Task should operate in.\n\n#### Usage scenarios\n\nThis mode should be usable both from the MSBuild API and from the MSBuild Command Line.\n\n### Risks\n\n#### Loss of Isolation\n\nTasks today exist in a bubble because of their external-process, single-threaded nature. Moving to a multi-threaded model means that it's more possible that state from other threads will pollute the executing Task thread. It's very important that we ensure isolation for the new Task variants.\n\n#### Insufficient performance gains\n\nWe anticipate performance gains for most builds once Tasks that ship in MSBuild and the .NET SDK are enlightened and multi-thread capable. However, those gains may not materialize at the magnitude we expect, or other engine-level costs may still dominate, etc. In this case, this work still represents a benefit - there are a number of ways that we can optimize the multi-threaded node that we simply cannot in multi-proc mode, and analysis of the single node will be much easier. This work also is a prereq for more architectural changes we'd like to make in the future that should also unlock more performance.\n\n",
  "state": "OPEN",
  "createdAt": "2025-05-07T15:30:19Z",
  "updatedAt": "2025-06-02T08:30:39Z",
  "closedAt": null,
  "author": {
    "login": "baronfel"
  },
  "milestone": {
    "title": ".NET 10"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Engine",
    "triaged"
  ],
  "comments": {
    "nodes": [
      {
        "body": "Static graph-based restore would benefit a ton from this.  Currently, it queues all the \"builds\" as part of restore on a single thread since they run in-proc.  I tried it out once with multi-proc but spinning up the nodes and serializing the projects added too much overhead since those builds are very fast.  For static graph-based restore, a build parameter would be enough like `MultiThreaded` where MSBuild would execute the builds in parallel but not set process-wide options like environment variables and current directory.  The caller would have to know that the builds being executed could fail since a lot of builds depend on current directory.  Since NuGet owns the restore targets, we could make this work.",
        "createdAt": "2025-05-07T17:57:34Z",
        "author": {
          "login": "jeffkl"
        }
      }
    ]
  }
}