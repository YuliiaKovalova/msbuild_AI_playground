{
  "number": 10616,
  "title": "[Bug]: BuildManager fails to dispose of cache plugin after exception thrown during BeginBuild",
  "body": "### Issue Description\r\n\r\nBuildManager fails to dispose of the plugin after the exception described in #10615, leading to all future build attempts that use the plugin to fail because the semaphore hasn't been released.\r\n\r\n### Steps to Reproduce\r\n\r\nSee #10615 for repro.\r\n\r\n### Expected Behavior\r\n\r\n*Subsequent* builds fail with this message appearing only *once*:\r\n\r\n> Another instance of MSBuildCache is already running in this build. This is typically due to a misconfiguration of the plugin settings, in particular different plugin settings across projects.\r\n\r\n### Actual Behavior\r\n\r\n*Subsequent* builds fail with an error message appearing *twice*:\r\n\r\n> Another instance of MSBuildCache is already running in this build. This is typically due to a misconfiguration of the plugin settings, in particular different plugin settings across projects.\r\n> Another instance of MSBuildCache is already running in this build. This is typically due to a misconfiguration of the plugin settings, in particular different plugin settings across projects.\r\n\r\n### Analysis\r\n\r\nThe cache plugin is created on this callstack:\r\n\r\n```\r\n>\tMicrosoft.MSBuildCache.Local.dll!Microsoft.MSBuildCache.MSBuildCachePluginBase<Microsoft.MSBuildCache.PluginSettings>.TryAcquireLock(Microsoft.MSBuildCache.PluginSettings settings, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger) Line 853\tC#\r\n \tMicrosoft.MSBuildCache.Local.dll!Microsoft.MSBuildCache.MSBuildCachePluginBase<Microsoft.MSBuildCache.PluginSettings>.BeginBuildInnerAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) Line 229\tC#\r\n \tMicrosoft.MSBuildCache.Local.dll!Microsoft.MSBuildCache.MSBuildCachePluginBase<Microsoft.MSBuildCache.PluginSettings>.TimeAndLogAsync.AnonymousMethod__0() Line 1143\tC#\r\n \tMicrosoft.MSBuildCache.Local.dll!Microsoft.MSBuildCache.MSBuildCachePluginBase<Microsoft.MSBuildCache.PluginSettings>.TimeAndLogAsync<int>(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Func<System.Threading.Tasks.Task<int>> innerAsync, string context, string memberName) Line 1111\tC#\r\n \tMicrosoft.MSBuildCache.Local.dll!Microsoft.MSBuildCache.MSBuildCachePluginBase<Microsoft.MSBuildCache.PluginSettings>.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) Line 215\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.CreateAndInitializePluginAsync(Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor projectCacheDescriptor, Microsoft.Build.Graph.ProjectGraph projectGraph, Microsoft.Build.BackEnd.BuildRequestConfiguration buildRequestConfiguration, System.Collections.Generic.ICollection<string> requestedTargets, System.Threading.CancellationToken cancellationToken) Line 258\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.GetProjectCachePluginAsync.AnonymousMethod__1() Line 168\tC#\r\n \tmscorlib.dll!System.Lazy<System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.ProjectCachePlugin>>.CreateValue()\tUnknown\r\n \tmscorlib.dll!System.Lazy<System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.ProjectCachePlugin>>.LazyInitValue()\tUnknown\r\n \tMicrosoft.Build.dll!Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.GetProjectCachePluginAsync(Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor projectCacheDescriptor, Microsoft.Build.Graph.ProjectGraph projectGraph, Microsoft.Build.BackEnd.BuildRequestConfiguration buildRequestConfiguration, System.Collections.Generic.ICollection<string> requestedTargets, System.Threading.CancellationToken cancellationToken) Line 164\tC#\r\n \tMicrosoft.Build.dll!Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.InitializePluginsForVsScenario.AnonymousMethod__1(Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor projectCacheDescriptor) Line 151\tC#\r\n \tmscorlib.dll!System.Threading.Tasks.Parallel.ForWorker.AnonymousMethod__1()\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.InnerInvokeWithArg(System.Threading.Tasks.Task childTask)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.ExecuteSelfReplicating.AnonymousMethod__0(object <p0>)\tUnknown\r\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\tUnknown\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.InternalRunSynchronously(System.Threading.Tasks.TaskScheduler scheduler, bool waitForCompletion)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Parallel.ForWorker<object>(int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<int> body, System.Action<int, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Func<int, System.Threading.Tasks.ParallelLoopState, object, object> bodyWithLocal, System.Func<object> localInit, System.Action<object> localFinally)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Parallel.ForEachWorker<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor, object>(System.Collections.Generic.IEnumerable<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor> body, System.Action<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Action<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex, System.Func<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor, System.Threading.Tasks.ParallelLoopState, object, object> bodyWithStateAndLocal, System.Func<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor, System.Threading.Tasks.ParallelLoopState, long, object, object> bodyWithEverything, System.Func<object> localInit, System.Action<object> localFinally)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Parallel.ForEach<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor>(System.Collections.Generic.IEnumerable<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor> body)\tUnknown\r\n \tMicrosoft.Build.dll!Microsoft.Build.Experimental.ProjectCache.ProjectCacheService.InitializePluginsForVsScenario.AnonymousMethod__0() Line 145\tC#\r\n \tmscorlib.dll!System.Threading.Tasks.Task.Execute()\tUnknown\r\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\tUnknown\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot)\tUnknown\r\n \tmscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution)\tUnknown\r\n \tmscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch()\tUnknown\r\n```\r\n\r\nI suspect an exception thrown from this isn't caught properly such that the failed plugin will still be disposed of.\r\n\r\n### Versions & Configurations\r\n\r\nDev17.12 (35228.240.main)",
  "state": "OPEN",
  "createdAt": "2024-09-03T22:26:47Z",
  "updatedAt": "2024-10-10T15:56:40Z",
  "closedAt": null,
  "author": {
    "login": "AArnott"
  },
  "labels": [
    "bug",
    "Area: Project Cache",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "@dfederm could you please take a look on this issue?",
        "createdAt": "2024-09-04T15:21:09Z",
        "updatedAt": "2024-09-04T15:21:09Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "Yep, I'll look at some point. I worked with Andrew on this and am just using this issue for tracking so I don't forget.",
        "createdAt": "2024-09-10T15:15:14Z",
        "updatedAt": "2024-09-10T15:15:14Z",
        "author": {
          "login": "dfederm"
        }
      }
    ]
  }
}