{
  "number": 2790,
  "title": "Inferred outputs of task's input/output parameter assume no change during execution",
  "body": "### Steps to reproduce\r\n\r\nI am suspecting this is not a bug, and even it it is, it's already a feature because I reproduce it with MSBuild 2.0. But here's a stunningly simple project that escapes any explanation. The name `test.xxproj` is hardcoded because MSBuild v2.0 did not have `$(MsBuildThisFile)`, apparently. Any existing normal file will work instead.\r\n\r\nSo the target T1, which never runs, calls a task that does not even exist, and the task happily returns the list of outputs it did not even see. If you think that sounded like a Zen koan, I'm entirely with you!\r\n\r\n```xml\r\n<!-- save as test.xxproj -->\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\r\n  <ItemGroup>\r\n    <Files Include=\"test.xxproj\" />\r\n  </ItemGroup>\r\n\r\n  <Target Name=\"Build\" DependsOnTargets=\"T1\" >\r\n    <Message Importance=\"high\" Text=\"Files out of date: '@(OutOfDateFiles)'\" />\r\n  </Target>\r\n\r\n  <!-- Or: Inpust=\"%(Identity)\", same behavior. -->\r\n  <Target Name=\"T1\" Inputs=\"@(Files)\" Outputs=\"@(Files)\">\r\n    <ThisTaskDoesNotExist Foo=\"@(Files)\">\r\n      <Output TaskParameter=\"Foo\" ItemName=\"OutOfDateFiles\" />\r\n    </ThisTaskDoesNotExist>\r\n  </Target>\r\n\r\n</Project>\r\n```\r\nThe `ThisTaskDoesNotExist` task does not exist (hat tip to Dr. Quine), and I'd expect the `T1` never be ran, and `@(OutOfDateFiles)` be empty. The former is true, but as for the latter, all items from `@(Files)` end up in the `@(OutOfDateFiles)` list. The key part is the name `Foo` is both an input and an output property. Change one of them to `Bar`. and then `@(OutOfDateFiles)` will be empty.\r\n\r\nWhat is going on?\r\n\r\n```\r\nC:\\Users\\kkm\\work\\msbuildxx>\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\15.0\\Bin\\MSBuild.exe\"\r\nMicrosoft (R) Build Engine version 15.4.8.50001 for .NET Framework\r\nProject \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" on node 1 (default targets).\r\nT1:\r\nSkipping target \"T1\" because all output files are up-to-date with respect to the input files.\r\nBuild:\r\n  Files out of date: 'test.xxproj'\r\nDone Building Project \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" (default targets).\r\n```\r\nMSBuild 4:\r\n```\r\nC:\\Users\\kkm\\work\\msbuildxx>C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\MSBuild.exe\r\nMicrosoft (R) Build Engine version 4.7.2053.0\r\n[Microsoft .NET Framework, version 4.0.30319.42000]\r\nProject \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" on node 1 (default targets).\r\nT1:\r\nSkipping target \"T1\" because all output files are up-to-date with respect to the input files.\r\nBuild:\r\n  Files out of date: 'test.xxproj'\r\nDone Building Project \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" (default targets).\r\n```\r\nMSBuild 2:\r\n```\r\nC:\\Users\\kkm\\work\\msbuildxx>C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\MSBuild.exe\r\nMicrosoft (R) Build Engine Version 2.0.50727.5483\r\n[Microsoft .NET Framework, Version 2.0.50727.8762]\r\nProject \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" (default targets):\r\nTarget T1:\r\n  Skipping target \"T1\" because all output files are up-to-date with respect to the input files.\r\nTarget Build:\r\n    Files out of date: 'test.xxproj'\r\n```\r\n----\r\nMy real intention was to filter lists with quite complex dependencies (I am automating a compiler that generates multiple outputs, and I do not even know which of them will be generated until it is actually run. Fortunately, it also produces a file with the list of outputs it actually wrote, so I can simply `<Touch>` those it did not generate, for dependency check not to recompile next time. So in the batched compile target, I subtract the (sub-batched) list of actually produced outputs from the sub-batch of expected outputs, and add them to a list to touch later (used also for something else, so I *need* them per-batch with marked metadata, unfortunately, otherwise I'd ran the `<Touch>` in the same target/batch as the compiler, and Bob's your uncle). The 'ThisTaskDoesNotExist' is n\u00e9e 'CreateItem', naturally; first I replaced it with the one of my my own that I could debug, but when I never hit the breakpoints, I realized the task is even irrelevant. But when a particular batch is not run, as in the pared down example above, I incorrectly get all files in this expected but not generated file list.\r\n\r\nI worked around this behavior by creating by own version of CreateItem, with differing input and output property names. But this feels like quite a hack to me. I cannot think of a more idiomatic way of minimizing batched collections using MSBuild dependency up-to-date checks and also collecting some task outputs per batch without hitting this issue though.\r\n\r\n----\r\n\r\nHere's a bit more realistic, less pared down variant that behaves similarly\r\n\r\n```xml\r\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\r\n  <ItemGroup>\r\n    <Files Include=\"test.xxproj; nosuchfile\" />\r\n  </ItemGroup>\r\n\r\n  <Target Name=\"Build\" DependsOnTargets=\"T1\" >\r\n    <Message Importance=\"high\" Text=\"Files out of date: '@(OutOfDateFiles)'\" />\r\n  </Target>\r\n\r\n  <Target Name=\"T1\" Inputs=\"@(Files)\" Outputs=\"%(Identity)\">\r\n    <Message Importance=\"high\" Text=\"Adding '@(Files)' to OutOfDateFiles\" />\r\n    <CreateItem Include=\"@(Files)\">\r\n      <Output TaskParameter=\"Include\" ItemName=\"OutOfDateFiles\" />\r\n    </CreateItem>\r\n  </Target>\r\n\r\n</Project>\r\n```\r\n```\r\nMicrosoft (R) Build Engine version 15.4.8.50001 for .NET Framework\r\nProject \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" on node 1 (default targets).\r\nT1:\r\nSkipping target \"T1\" because all output files are up-to-date with respect to the input files.\r\nT1:\r\n  Adding 'nosuchfile' to OutOfDateFiles\r\nBuild:\r\n  Files out of date: 'test.xxproj;nosuchfile'\r\nDone Building Project \"C:\\Users\\kkm\\work\\msbuildxx\\test.xxproj\" (default targets).\r\n```\r\n\r\n---\r\n### Addendum\r\nAfter some debugger poking [I found this](https://github.com/Microsoft/msbuild/blob/ee6a3f7856a92884b12fe63cea5111509620b14d/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L535-L547), so my best guess this behavior is expected and correct. But oh boy, if it is, does not it deserve a separate chapter in the MsBuild docs, so very not obvious it is!\r\n\r\nAnd it would be amazing to have a way to distinguish inferred items from up-to-date buckets from those actually generated by executed bucket's tasks!",
  "state": "OPEN",
  "createdAt": "2017-12-09T22:28:58Z",
  "updatedAt": "2024-02-21T16:35:15Z",
  "closedAt": null,
  "author": {
    "login": "kkm000"
  },
  "labels": [
    "Breaking Change",
    "triaged"
  ],
  "assignees": {
    "nodes": []
  },
  "milestone": null,
  "comments": {
    "nodes": [
      {
        "body": "Wow, that's an amazing find.\r\n\r\nAs you've already figured out, this is happening because of interaction between [target output inference](https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds#output-inference) and MSBuild's lazy task loading. The task doesn't have to exist, because it is never actually run. But I completely agree that it's **baffling** that the inferrer can extract the passed-through item.\r\n\r\nUnfortunately, I don't think we can change the inferrer at this point without breaking people.\r\n\r\n## Workaround\r\n\r\nThose docs give me an idea that appears to work in the simple case: use `<CreateProperty>` to make a property out of the (real) output item, then use the property to construct the item you want. For your second example:\r\n\r\n```xml\r\n  <Target Name=\"T1\" Inputs=\"@(Files)\" Outputs=\"%(Identity)\">\r\n    <Message Importance=\"high\" Text=\"Adding '@(Files)' to OutOfDateFiles\" />\r\n\r\n    <CreateProperty Value=\"@(Files)\">  \r\n      <Output TaskParameter=\"ValueSetByTask\" PropertyName=\"OutOfDateFilesProperty\" />  \r\n    </CreateProperty>\r\n\r\n    <ItemGroup>\r\n      <OutOfDateFiles Include=\"$(OutOfDateFilesProperty)\" />\r\n    </ItemGroup>\r\n  </Target>\r\n```\r\n\r\n```sh-session\r\n$ dotnet msbuild test.xxproj\r\nMicrosoft (R) Build Engine version 15.5.179.9764 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Adding 'nosuchfile' to OutOfDateFiles\r\n  Files out of date: 'nosuchfile'\r\n```",
        "createdAt": "2018-01-12T16:02:10Z",
        "updatedAt": "2018-01-12T16:02:10Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald: Thank you for looking. I do not why do you consider it breaking--the behavior is strictly same in MsBuild 4.0 that comes with the framework (my latest is 4.6.1 I think), and even in MsBuild 2.0. So there is clearly no regression.\r\n\r\nMy workaround is slightly different, because I am batching the whole target, so the property would not do, but it is close to one you are envisioning. I am creating a specific metadata value using the `CreateItem` task. While all its output items are still added to the collection, only those for which the task has actually ran will have that metadata set. Here's a real-world snippet:\r\n\r\n```xml\r\n  <Target Name=\"_Protobuf_GatherStaleBatched\"\r\n          Inputs=\"@(Protobuf_Compile);%(Source);@(Protobuf_Dependencies);$(MSBuildAllProjects)\"\r\n          Outputs=\"@(Protobuf_ExpectedOutputs)\" >\r\n    <!-- The '_Exec' metadatum is set to distinguish really executed items from those MSBuild\r\n         infers in a bucketed task. For the same reason, cannot use the the intrinsic ItemGroup task here. -->\r\n    <CreateItem Include=\"@(Protobuf_Compile)\" AdditionalMetadata=\"_Exec=true\">\r\n      <Output TaskParameter=\"Include\" ItemName=\"_Protobuf_OutOfDateProto\"/>\r\n    </CreateItem>\r\n  </Target>\r\n```\r\n\r\nBut attempting to use the intrinsic ItemGroup also does not work (the metadata is added to all items), so replacing `CreateItem` above with the following snippet will cause `_Exec`  set an all items, executed or not\r\n\r\n```xml\r\n    <ItemGroup>\r\n      <_Protobuf_OutOfDateProto Include=\"@(Protobuf_Compile)\" _Exec=\"true\" />\r\n    </ItemGroup>\r\n```\r\n\r\nThis is a subtlety I noted in #2800.\r\n\r\nSo in the end I think this is not a bug, but rather a very obscure and, as you aptly put it, baffling feature. I believe a lot of current MsBuild scripting really depends on it.\r\n\r\nBut I really believe it has to be documented very carefully. If you agree that there is nothing to be fixed, I'll mark my to-do list to write a page for docs.microsoft.com on that, but I am swamped at the moment.",
        "createdAt": "2018-01-13T05:32:36Z",
        "updatedAt": "2018-01-13T05:32:36Z",
        "author": {
          "login": "kkm000"
        }
      },
      {
        "body": "@rainersigwald: I have an idea how to make life simpler in the case like mine. What if we add an output property named `Output` to the `CreateItem` task, and, after all processing in task's `Execute()` done, just set it to the same value that the `Include` in/out parameter ends up with? Since inference depends on parameter name, the `Output` property won't be affected by inference. So, for example, with\r\n```xml\r\n    <CreateItem Include=\"@(Source)\">\r\n      <Output TaskParameter=\"Include\" ItemName=\"Both_Inferred_And_Executed\"/>\r\n      <Output TaskParameter=\"Output\" ItemName=\"Executed_Only\"/>\r\n    </CreateItem>\r\n```\r\nthe collection `Both_Inferred_And_Executed` will end up with a copy of `@(Source)`, as it currently does, by way of either task execution or inference, while `Executed_Only` will collect only items from the buckets where the task has actually been executed.\r\n\r\nAm I making sense?",
        "createdAt": "2018-01-13T05:45:09Z",
        "updatedAt": "2018-01-13T05:47:24Z",
        "author": {
          "login": "kkm000"
        }
      }
    ]
  }
}